{
"chunks": [
{
"path": "AGENTSæ™ºèƒ½ä½“ä»‹ç».md",
"start": 1,
"end": 55,
"text": "# Agentæ™ºèƒ½ä½“ä»‹ç»\n\n> DaoyouCode 10ä¸ªå†…ç½®Agentå®Œæ•´ä»‹ç»\n\n---\n\n## Agentæ€»è§ˆ\n\n| Agent | ç±»å‹ | å·¥å…·æ•° | æ¨¡å‹ | ç‰¹ç‚¹ |\n|-------|------|--------|------|------|\n| sisyphus | ç¼–æ’ | 4 | qwen-max | ä»»åŠ¡åˆ†è§£ã€Agentè°ƒåº¦ |\n| oracle | å’¨è¯¢ | 10 | qwen-max | æ¶æ„åˆ†æã€æŠ€æœ¯å»ºè®®ï¼ˆåªè¯»ï¼‰ |\n| librarian | æœç´¢ | 8 | qwen-max | æ–‡æ¡£æœç´¢ã€ä»£ç æŸ¥æ‰¾ï¼ˆåªè¯»ï¼‰ |\n| programmer | ç¼–ç¨‹ | 11 | qwen-coder-plus | ä»£ç ç¼–å†™ã€åŠŸèƒ½å®ç° |\n| refactor_master | é‡æ„ | 13 | qwen-coder-plus | ä»£ç é‡æ„ã€ä¼˜åŒ– |\n| test_expert | æµ‹è¯• | 10 | deepseek-coder | æµ‹è¯•ç¼–å†™ã€ä¿®å¤ |\n| code_analyzer | åˆ†æ | 10 | qwen-max | æ¶æ„åˆ†æã€ä»£ç å®¡æŸ¥ |\n| code_explorer | æ¢ç´¢ | 8 | qwen-plus | ä»£ç åº“æœç´¢ã€æ¢ç´¢ |\n| translator | ç¿»è¯‘ | 6 | qwen-max | ä¸“ä¸šç¿»è¯‘æœåŠ¡ |\n| MainAgent | ä¸»å¯¹è¯ | 0 | qwen-max | æ—¥å¸¸å¯¹è¯ã€ä»£ç å’¨è¯¢ |\n\n---\n\n## æ ¸å¿ƒAgentè¯¦è§£\n\n### 1. Sisyphus - ä¸»ç¼–æ’Agent\n\n**èŒè´£**ï¼š\n- åˆ†æç”¨æˆ·è¯·æ±‚\n- åˆ†è§£å¤æ‚ä»»åŠ¡\n- é€‰æ‹©åˆé€‚çš„ä¸“ä¸šAgent\n- éªŒè¯æ‰§è¡Œç»“æœ\n- èšåˆæœ€ç»ˆç­”æ¡ˆ\n\n**ç‰¹ç‚¹**ï¼š\n- Todoé©±åŠ¨å·¥ä½œæµ\n- æ™ºèƒ½Agenté€‰æ‹©\n- ç»“æœéªŒè¯\n- åªä½¿ç”¨4ä¸ªåŸºç¡€å·¥å…·ï¼ˆå¿«é€Ÿæ¢ç´¢ï¼‰\n\n**å·¥å…·**ï¼ˆ4ä¸ªï¼‰ï¼š\n- repo_map - é¡¹ç›®ç†è§£\n- get_repo_structure - é¡¹ç›®ç†è§£\n- text_search - æœç´¢\n- read_file - æ–‡ä»¶æ“ä½œ\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- å¤æ‚ä»»åŠ¡ï¼ˆé‡æ„+æµ‹è¯•ï¼‰\n- å¤šæ–‡ä»¶ä¿®æ”¹\n- éœ€è¦å¤šä¸ªä¸“ä¸šAgentåä½œ\n\n**é…ç½®**ï¼š\n- æ¨¡å‹ï¼šqwen-maxï¼ˆæœ€å¼ºæ¨¡å‹ï¼‰\n- æ¸©åº¦ï¼š0.1ï¼ˆä½æ¸©åº¦ï¼Œæ›´å‡†ç¡®ï¼‰\n- Promptï¼šskills/sisyphus-orchestrator/prompts/sisyphus.md"
},
{
"path": "AGENTSæ™ºèƒ½ä½“ä»‹ç».md",
"start": 56,
"end": 110,
"text": "\n**ä½¿ç”¨æ–¹å¼**ï¼š\n```bash\npython backend/daoyoucode.py chat --skill sisyphus-orchestrator\n```\n\n---\n\n### 2. Oracle - é«˜IQå’¨è¯¢Agent\n\n**èŒè´£**ï¼š\n- æ¶æ„åˆ†æå’Œå†³ç­–\n- ä»£ç å®¡æŸ¥å’Œå»ºè®®\n- æ€§èƒ½åˆ†æ\n- å®‰å…¨å®¡æŸ¥\n- æŠ€æœ¯å’¨è¯¢\n\n**ç‰¹ç‚¹**ï¼š\n- åªè¯»æƒé™ï¼ˆä¸ä¿®æ”¹ä»£ç ï¼‰\n- ä½¿ç”¨æœ€å¼ºæ¨¡å‹\n- ä¸“æ³¨äºé«˜è´¨é‡åˆ†æ\n- é€‚åˆå¤æ‚å†³ç­–\n\n**å·¥å…·**ï¼ˆ10ä¸ªï¼‰ï¼š\n- repo_map - é¡¹ç›®ç†è§£\n- get_repo_structure - é¡¹ç›®ç†è§£\n- read_file - æ–‡ä»¶æ“ä½œ\n- list_files - æ–‡ä»¶æ“ä½œ\n- text_search - æœç´¢\n- regex_search - æœç´¢\n- lsp_diagnostics - LSP\n- lsp_goto_definition - LSP\n- lsp_symbols - LSP\n- discover_project_docs - é¡¹ç›®æ–‡æ¡£\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- âœ… æ¶æ„å†³ç­–\n- âœ… å®Œæˆé‡è¦å·¥ä½œåçš„è‡ªæˆ‘å®¡æŸ¥\n- âœ… 2æ¬¡ä»¥ä¸Šä¿®å¤å¤±è´¥å\n- âœ… ä¸ç†Ÿæ‚‰çš„ä»£ç æ¨¡å¼\n- âœ… å®‰å…¨/æ€§èƒ½é—®é¢˜\n\n**é¿å…ä½¿ç”¨**ï¼š\n- âŒ ç®€å•æ–‡ä»¶æ“ä½œ\n- âŒ ç¬¬ä¸€æ¬¡å°è¯•ä¿®å¤\n- âŒ ä»å·²è¯»ä»£ç å¯ä»¥å›ç­”çš„é—®é¢˜\n- âŒ çç¢å†³ç­–ï¼ˆå˜é‡å‘½åã€æ ¼å¼åŒ–ï¼‰\n\n**é…ç½®**ï¼š\n- æ¨¡å‹ï¼šqwen-max\n- æ¸©åº¦ï¼š0.1\n- Promptï¼šskills/oracle/prompts/oracle.md\n\n**ä½¿ç”¨æ–¹å¼**ï¼š\n```bash"
},
{
"path": "AGENTSæ™ºèƒ½ä½“ä»‹ç».md",
"start": 111,
"end": 165,
"text": "python backend/daoyoucode.py chat --skill oracle\n```\n\n---\n\n### 3. Librarian - æ–‡æ¡£æœç´¢Agent\n\n**èŒè´£**ï¼š\n- æœç´¢é¡¹ç›®æ–‡æ¡£\n- æœç´¢ä»£ç å®ç°\n- æŸ¥æ‰¾ç›¸å…³ç¤ºä¾‹\n- æä¾›å‚è€ƒèµ„æ–™\n\n**ç‰¹ç‚¹**ï¼š\n- åªè¯»æƒé™\n- ä¸“æ³¨äºæœç´¢å’Œæ£€ç´¢\n- å¿«é€Ÿå®šä½ä¿¡æ¯\n- å¯ä»¥é›†æˆå¤–éƒ¨æœç´¢ï¼ˆwebsearch MCPï¼‰\n\n**å·¥å…·**ï¼ˆ8ä¸ªï¼‰ï¼š\n- repo_map - é¡¹ç›®ç†è§£\n- get_repo_structure - é¡¹ç›®ç†è§£\n- read_file - æ–‡ä»¶æ“ä½œ\n- text_search - æœç´¢\n- regex_search - æœç´¢\n- ast_grep_search - ASTæœç´¢\n- lsp_symbols - LSP\n- discover_project_docs - é¡¹ç›®æ–‡æ¡£\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- æŸ¥æ‰¾æ–‡æ¡£\n- æœç´¢ä»£ç ç¤ºä¾‹\n- äº†è§£æœ€ä½³å®è·µ\n- å­¦ä¹ æ–°æŠ€æœ¯\n\n**é…ç½®**ï¼š\n- æ¨¡å‹ï¼šqwen-max\n- æ¸©åº¦ï¼š0.1\n- Promptï¼šskills/librarian/prompts/librarian.md\n\n**ä½¿ç”¨æ–¹å¼**ï¼š\n```bash\npython backend/daoyoucode.py chat --skill librarian\n```\n\n---\n\n### 4. Programmer - ç¼–ç¨‹ä¸“å®¶\n\n**èŒè´£**ï¼š\n- ä»£ç ç¼–å†™\n- åŠŸèƒ½å®ç°\n- Bugä¿®å¤\n- ä»£ç ä¼˜åŒ–\n"
},
{
"path": "AGENTSæ™ºèƒ½ä½“ä»‹ç».md",
"start": 166,
"end": 220,
"text": "**å·¥å…·**ï¼ˆ11ä¸ªï¼‰ï¼š\n- read_file - æ–‡ä»¶æ“ä½œ\n- write_file - æ–‡ä»¶æ“ä½œ\n- list_files - æ–‡ä»¶æ“ä½œ\n- text_search - æœç´¢\n- search_replace - ä»£ç ç¼–è¾‘\n- lsp_diagnostics - LSP\n- lsp_goto_definition - LSP\n- lsp_find_references - LSP\n- repo_map - é¡¹ç›®ç†è§£\n- run_test - å‘½ä»¤æ‰§è¡Œ\n- git_status - Git\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- ç¼–å†™æ–°åŠŸèƒ½\n- ä¿®å¤Bug\n- å®ç°éœ€æ±‚\n\n**é…ç½®**ï¼š\n- æ¨¡å‹ï¼šqwen-coder-plus\n- æ¸©åº¦ï¼š0.1\n- Promptï¼šskills/programming/prompts/programmer.md\n\n**ä½¿ç”¨æ–¹å¼**ï¼š\n```bash\npython backend/daoyoucode.py chat --skill programming\n```\n\n---\n\n### 5. RefactorMaster - é‡æ„ä¸“å®¶\n\n**èŒè´£**ï¼š\n- ä»£ç é‡æ„\n- ä»£ç ä¼˜åŒ–\n- æ¶æ„æ”¹è¿›\n- æŠ€æœ¯å€ºåŠ¡æ¸…ç†\n\n**ç‰¹ç‚¹**ï¼š\n- å®‰å…¨æ¸è¿›å¼é‡æ„\n- ä¿æŒåŠŸèƒ½ä¸å˜\n- æé«˜ä»£ç è´¨é‡\n\n**å·¥å…·**ï¼ˆ13ä¸ªï¼‰ï¼š\n- read_file - æ–‡ä»¶æ“ä½œ\n- write_file - æ–‡ä»¶æ“ä½œ\n- list_files - æ–‡ä»¶æ“ä½œ\n- text_search - æœç´¢\n- search_replace - ä»£ç ç¼–è¾‘\n- lsp_diagnostics - LSP\n- lsp_goto_definition - LSP\n- lsp_find_references - LSP\n- lsp_rename - LSP\n- ast_grep_search - AST\n- ast_grep_replace - AST"
},
{
"path": "AGENTSæ™ºèƒ½ä½“ä»‹ç».md",
"start": 221,
"end": 275,
"text": "- repo_map - é¡¹ç›®ç†è§£\n- run_test - å‘½ä»¤æ‰§è¡Œ\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- ä»£ç é‡æ„\n- æå–å‡½æ•°/ç±»\n- é‡å‘½åç¬¦å·\n- ä¼˜åŒ–ç»“æ„\n\n**é…ç½®**ï¼š\n- æ¨¡å‹ï¼šqwen-coder-plus\n- æ¸©åº¦ï¼š0.2\n- Promptï¼šskills/refactoring/prompts/refactor.md\n\n**ä½¿ç”¨æ–¹å¼**ï¼š\n```bash\npython backend/daoyoucode.py chat --skill refactoring\n```\n\n---\n\n### 6. TestExpert - æµ‹è¯•ä¸“å®¶\n\n**èŒè´£**ï¼š\n- æµ‹è¯•ç¼–å†™\n- æµ‹è¯•ä¿®å¤\n- æµ‹è¯•ç­–ç•¥\n- TDDå·¥ä½œæµ\n\n**å·¥å…·**ï¼ˆ10ä¸ªï¼‰ï¼š\n- read_file - æ–‡ä»¶æ“ä½œ\n- write_file - æ–‡ä»¶æ“ä½œ\n- list_files - æ–‡ä»¶æ“ä½œ\n- text_search - æœç´¢\n- search_replace - ä»£ç ç¼–è¾‘\n- lsp_diagnostics - LSP\n- lsp_goto_definition - LSP\n- repo_map - é¡¹ç›®ç†è§£\n- run_test - å‘½ä»¤æ‰§è¡Œ\n- git_status - Git\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- ç¼–å†™å•å…ƒæµ‹è¯•\n- ä¿®å¤å¤±è´¥çš„æµ‹è¯•\n- æé«˜æµ‹è¯•è¦†ç›–ç‡\n- TDDå¼€å‘\n\n**é…ç½®**ï¼š\n- æ¨¡å‹ï¼šdeepseek-coder\n- æ¸©åº¦ï¼š0.3\n- Promptï¼šskills/testing/prompts/test.md\n\n**ä½¿ç”¨æ–¹å¼**ï¼š\n```bash\npython backend/daoyoucode.py chat --skill testing"
},
{
"path": "AGENTSæ™ºèƒ½ä½“ä»‹ç».md",
"start": 276,
"end": 330,
"text": "```\n\n---\n\n## è¾…åŠ©Agent\n\n### 7. CodeAnalyzer - ä»£ç åˆ†æAgent\n\n**èŒè´£**ï¼š\n- æ¶æ„åˆ†æ\n- ä»£ç å®¡æŸ¥\n- æŠ€æœ¯å’¨è¯¢\n\n**å·¥å…·**ï¼ˆ10ä¸ªï¼‰ï¼š\n- repo_mapã€get_repo_structureã€read_fileã€list_files\n- text_searchã€regex_search\n- lsp_diagnosticsã€lsp_goto_definitionã€lsp_symbols\n- discover_project_docs\n\n**é…ç½®**ï¼š\n- æ¨¡å‹ï¼šqwen-max\n- æ¸©åº¦ï¼š0.1\n\n---\n\n### 8. CodeExplorer - ä»£ç æ¢ç´¢Agent\n\n**èŒè´£**ï¼š\n- ä»£ç åº“æœç´¢\n- ä»£ç æ¢ç´¢\n- æŸ¥æ‰¾å®ç°\n\n**å·¥å…·**ï¼ˆ8ä¸ªï¼‰ï¼š\n- repo_mapã€get_repo_structureã€read_file\n- text_searchã€regex_searchã€ast_grep_search\n- lsp_symbolsã€discover_project_docs\n\n**é…ç½®**ï¼š\n- æ¨¡å‹ï¼šqwen-plus\n- æ¸©åº¦ï¼š0.1\n\n---\n\n### 9. Translator - ç¿»è¯‘Agent\n\n**èŒè´£**ï¼š\n- ä¸“ä¸šç¿»è¯‘\n- æ–‡æ¡£ç¿»è¯‘\n- ä»£ç æ³¨é‡Šç¿»è¯‘\n\n**å·¥å…·**ï¼ˆ6ä¸ªï¼‰ï¼š\n- read_fileã€write_fileã€list_files\n- text_searchã€search_replaceã€repo_map\n\n**é…ç½®**ï¼š"
},
{
"path": "AGENTSæ™ºèƒ½ä½“ä»‹ç».md",
"start": 331,
"end": 385,
"text": "- æ¨¡å‹ï¼šqwen-max\n- æ¸©åº¦ï¼š0.3\n\n---\n\n### 10. MainAgent - ä¸»å¯¹è¯Agent\n\n**èŒè´£**ï¼š\n- æ—¥å¸¸å¯¹è¯\n- ä»£ç å’¨è¯¢\n- é—®é¢˜è§£ç­”\n\n**å·¥å…·**ï¼ˆ0ä¸ªï¼‰ï¼š\n- ä¸ä½¿ç”¨å·¥å…·ï¼Œçº¯å¯¹è¯\n\n**é…ç½®**ï¼š\n- æ¨¡å‹ï¼šqwen-max\n- æ¸©åº¦ï¼š0.7\n\n---\n\n## Agenté€‰æ‹©æŒ‡å—\n\n### æŒ‰ä»»åŠ¡ç±»å‹é€‰æ‹©\n\n| ä»»åŠ¡ç±»å‹ | æ¨èAgent | åŸå›  |\n|---------|----------|------|\n| å¤æ‚ä»»åŠ¡ | sisyphus | æ™ºèƒ½åˆ†è§£å’Œè°ƒåº¦ |\n| æ¶æ„å†³ç­– | oracle | é«˜è´¨é‡åˆ†æï¼ˆåªè¯»ï¼‰ |\n| æ–‡æ¡£æœç´¢ | librarian | ä¸“æ³¨æœç´¢ï¼ˆåªè¯»ï¼‰ |\n| ç¼–å†™ä»£ç  | programmer | ä»£ç ç¼–å†™ä¸“å®¶ |\n| ä»£ç é‡æ„ | refactor_master | å®‰å…¨é‡æ„ |\n| ç¼–å†™æµ‹è¯• | test_expert | æµ‹è¯•ä¸“å®¶ |\n| ä»£ç åˆ†æ | code_analyzer | æ¶æ„åˆ†æ |\n| ä»£ç æ¢ç´¢ | code_explorer | æœç´¢æ¢ç´¢ |\n| ç¿»è¯‘ | translator | ä¸“ä¸šç¿»è¯‘ |\n| æ—¥å¸¸å¯¹è¯ | MainAgent | é€šç”¨å¯¹è¯ |\n\n### æŒ‰æƒé™é€‰æ‹©\n\n| æƒé™ | Agent | è¯´æ˜ |\n|------|-------|------|\n| åªè¯» | oracle, librarian | ä¸ä¿®æ”¹ä»£ç ï¼Œåªåˆ†æ |\n| è¯»å†™ | programmer, refactor_master, test_expert | å¯ä»¥ä¿®æ”¹ä»£ç  |\n| ç¼–æ’ | sisyphus | è°ƒåº¦å…¶ä»–Agent |\n\n### æŒ‰æ¨¡å‹é€‰æ‹©\n\n| æ¨¡å‹ | Agent | ç‰¹ç‚¹ |\n|------|-------|------|\n| qwen-max | sisyphus, oracle, librarian, code_analyzer, translator, MainAgent | æœ€å¼ºæ¨¡å‹ï¼Œé€‚åˆå¤æ‚ä»»åŠ¡ |\n| qwen-coder-plus | programmer, refactor_master | ä»£ç ä¸“ç”¨æ¨¡å‹ |\n| deepseek-coder | test_expert | æµ‹è¯•ä¸“ç”¨æ¨¡å‹ |\n| qwen-plus | code_explorer | é€šç”¨æ¨¡å‹ |\n"
},
{
"path": "AGENTSæ™ºèƒ½ä½“ä»‹ç».md",
"start": 386,
"end": 411,
"text": "---\n\n## Agentåä½œæ¨¡å¼\n\n### æ¨¡å¼1: Sisyphusç¼–æ’\n```\nç”¨æˆ·è¯·æ±‚ â†’ Sisyphusåˆ†è§£ä»»åŠ¡ â†’ è°ƒåº¦ä¸“ä¸šAgent â†’ èšåˆç»“æœ\n```\n\n### æ¨¡å¼2: Oracleå’¨è¯¢\n```\nç”¨æˆ·è¯·æ±‚ â†’ Oracleåˆ†æ â†’ æä¾›å»ºè®®ï¼ˆä¸ä¿®æ”¹ä»£ç ï¼‰\n```\n\n### æ¨¡å¼3: ä¸“ä¸šAgentç›´æ¥æ‰§è¡Œ\n```\nç”¨æˆ·è¯·æ±‚ â†’ Programmer/RefactorMaster/TestExpert â†’ ç›´æ¥æ‰§è¡Œ\n```\n\n---\n\n## ç›¸å…³æ–‡æ¡£\n\n- [CLIå‘½ä»¤å‚è€ƒ.md](./CLIå‘½ä»¤å‚è€ƒ.md) - CLIä½¿ç”¨æŒ‡å—\n- [ORCHESTRATORS.md](./ORCHESTRATORS.md) - ç¼–æ’å™¨è¯¦ç»†ä»‹ç»\n- [TOOLSå·¥å…·å‚è€ƒ.md](./TOOLSå·¥å…·å‚è€ƒ.md) - å·¥å…·å‚è€ƒæ‰‹å†Œ"
},
{
"path": "API_KEYè½®è¯¢é…ç½®è¯´æ˜.md",
"start": 1,
"end": 55,
"text": "# API Keyè½®è¯¢é…ç½®è¯´æ˜\n\n## åŠŸèƒ½ä»‹ç»\n\nä¸ºäº†è§£å†³APIé…é¢é™åˆ¶å’Œ500é”™è¯¯é—®é¢˜ï¼Œç³»ç»Ÿæ”¯æŒé…ç½®å¤šä¸ªAPI Keyè¿›è¡Œè½®è¯¢ä½¿ç”¨ã€‚\n\n### ä¼˜åŠ¿\n\n1. **åˆ†æ•£è¯·æ±‚å‹åŠ›** - å¤šä¸ªkeyè½®æµä½¿ç”¨ï¼Œé¿å…å•ä¸ªkeyé…é¢è€—å°½\n2. **æé«˜å¯ç”¨æ€§** - ä¸€ä¸ªkeyå¤±è´¥å¯ä»¥åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ª\n3. **çµæ´»é…ç½®** - 1ä¸ªkeyå°±ç”¨1ä¸ªï¼Œå¤šä¸ªå°±è½®è¯¢\n4. **è‡ªåŠ¨ç®¡ç†** - ç³»ç»Ÿè‡ªåŠ¨Round-robinè½®è¯¢ï¼Œæ— éœ€æ‰‹åŠ¨å¹²é¢„\n\n## é…ç½®æ–¹æ³•\n\n### æ–¹å¼1: å•ä¸ªAPI Keyï¼ˆé»˜è®¤ï¼‰\n\n```yaml\nproviders:\n  qwen:\n    api_key: \"sk-your-api-key-here\"\n    base_url: \"https://dashscope.aliyuncs.com/compatible-mode/v1\"\n    models:\n      - qwen-max\n      - qwen-plus\n    enabled: true\n```\n\n### æ–¹å¼2: å¤šä¸ªAPI Keyï¼ˆæ¨èï¼‰\n\n```yaml\nproviders:\n  qwen:\n    # æ³¨é‡Šæ‰å•ä¸ªkey\n    # api_key: \"sk-your-api-key-here\"\n    \n    # é…ç½®å¤šä¸ªkeyï¼ˆè½®è¯¢ä½¿ç”¨ï¼‰\n    api_keys:\n      - \"sk-key1-here\"\n      - \"sk-key2-here\"\n      - \"sk-key3-here\"\n    \n    base_url: \"https://dashscope.aliyuncs.com/compatible-mode/v1\"\n    models:\n      - qwen-max\n      - qwen-plus\n    enabled: true\n```\n\n## å·¥ä½œåŸç†\n\n### Round-robinè½®è¯¢\n\nç³»ç»Ÿä½¿ç”¨Round-robinï¼ˆè½®è¯¢ï¼‰ç­–ç•¥ï¼š\n"
},
{
"path": "API_KEYè½®è¯¢é…ç½®è¯´æ˜.md",
"start": 56,
"end": 110,
"text": "```\nè¯·æ±‚1 â†’ Key1\nè¯·æ±‚2 â†’ Key2\nè¯·æ±‚3 â†’ Key3\nè¯·æ±‚4 â†’ Key1  (å¾ªç¯)\nè¯·æ±‚5 â†’ Key2\nè¯·æ±‚6 â†’ Key3\n...\n```\n\n### ç¤ºä¾‹\n\nå‡è®¾é…ç½®äº†3ä¸ªAPI Keyï¼š\n\n```yaml\napi_keys:\n  - \"sk-aaa\"\n  - \"sk-bbb\"\n  - \"sk-ccc\"\n```\n\nç³»ç»Ÿè¡Œä¸ºï¼š\n- ç¬¬1æ¬¡è°ƒç”¨LLM â†’ ä½¿ç”¨ `sk-aaa`\n- ç¬¬2æ¬¡è°ƒç”¨LLM â†’ ä½¿ç”¨ `sk-bbb`\n- ç¬¬3æ¬¡è°ƒç”¨LLM â†’ ä½¿ç”¨ `sk-ccc`\n- ç¬¬4æ¬¡è°ƒç”¨LLM â†’ ä½¿ç”¨ `sk-aaa` (å¾ªç¯)\n- ...\n\n## é…ç½®ç¤ºä¾‹\n\n### ç¤ºä¾‹1: 2ä¸ªAPI Key\n\n```yaml\nproviders:\n  qwen:\n    api_keys:\n      - \"sk-d2971f2015574377bdf97046b1a03b87\"\n      - \"sk-e3a82g3126685488ceg08157c2b14c98\"\n    base_url: \"https://dashscope.aliyuncs.com/compatible-mode/v1\"\n    models:\n      - qwen-max\n      - qwen-plus\n      - qwen-coder-plus\n    enabled: true\n```\n\n### ç¤ºä¾‹2: 3ä¸ªAPI Key\n\n```yaml\nproviders:\n  qwen:\n    api_keys:\n      - \"sk-key1-xxxxxxxxxx\"\n      - \"sk-key2-yyyyyyyyyy\"\n      - \"sk-key3-zzzzzzzzzz\""
},
{
"path": "API_KEYè½®è¯¢é…ç½®è¯´æ˜.md",
"start": 111,
"end": 165,
"text": "    base_url: \"https://dashscope.aliyuncs.com/compatible-mode/v1\"\n    models:\n      - qwen-max\n      - qwen-plus\n    enabled: true\n```\n\n### ç¤ºä¾‹3: å¤šä¸ªæä¾›å•†ï¼Œå„è‡ªé…ç½®å¤šä¸ªkey\n\n```yaml\nproviders:\n  qwen:\n    api_keys:\n      - \"sk-qwen-key1\"\n      - \"sk-qwen-key2\"\n    base_url: \"https://dashscope.aliyuncs.com/compatible-mode/v1\"\n    models:\n      - qwen-max\n    enabled: true\n  \n  deepseek:\n    api_keys:\n      - \"sk-deepseek-key1\"\n      - \"sk-deepseek-key2\"\n      - \"sk-deepseek-key3\"\n    base_url: \"https://api.deepseek.com/v1\"\n    models:\n      - deepseek-chat\n    enabled: true\n```\n\n## éªŒè¯é…ç½®\n\nè¿è¡Œæµ‹è¯•éªŒè¯é…ç½®æ˜¯å¦æ­£ç¡®ï¼š\n\n```bash\ncd backend\npython test_api_key_rotation.py\n```\n\nè¾“å‡ºç¤ºä¾‹ï¼š\n```\nâœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼\n\nğŸ“ ä½¿ç”¨è¯´æ˜ï¼š\n1. åœ¨ config/llm_config.yaml ä¸­é…ç½®å¤šä¸ªAPI Key\n2. ç³»ç»Ÿä¼šè‡ªåŠ¨è½®è¯¢ä½¿ç”¨è¿™äº›key\n3. 1ä¸ªkeyå°±ç”¨1ä¸ªï¼Œå¤šä¸ªå°±è½®è¯¢\n4. å¯ä»¥æœ‰æ•ˆåˆ†æ•£APIé…é¢å‹åŠ›\n```\n\n## æ—¥å¿—æŸ¥çœ‹\n\nç³»ç»Ÿä¼šåœ¨æ—¥å¿—ä¸­æ˜¾ç¤ºä½¿ç”¨çš„API Keyä¿¡æ¯ï¼ˆéƒ¨åˆ†éšè—ï¼‰ï¼š\n"
},
{
"path": "API_KEYè½®è¯¢é…ç½®è¯´æ˜.md",
"start": 166,
"end": 220,
"text": "```\nINFO - å·²é…ç½®æä¾›å•†: qwen (3 ä¸ªAPI Key)\nDEBUG - æä¾›å•† qwen: ä½¿ç”¨API Key #1/3 (sk-d2971f2...)\nDEBUG - æä¾›å•† qwen: ä½¿ç”¨API Key #2/3 (sk-e3a82g3...)\nDEBUG - æä¾›å•† qwen: ä½¿ç”¨API Key #3/3 (sk-f4b93h4...)\n```\n\n## å¸¸è§é—®é¢˜\n\n### Q: å¦‚ä½•ç”³è¯·å¤šä¸ªAPI Keyï¼Ÿ\n\nA: åœ¨é˜¿é‡Œäº‘æ§åˆ¶å°åˆ›å»ºå¤šä¸ªAPI Keyï¼š\n1. ç™»å½•é˜¿é‡Œäº‘æ§åˆ¶å°\n2. è¿›å…¥DashScopeæœåŠ¡\n3. åˆ›å»ºå¤šä¸ªAPI Key\n4. å°†å®ƒä»¬é…ç½®åˆ° `llm_config.yaml`\n\n### Q: å¤šä¸ªkeyä¼šå¢åŠ æˆæœ¬å—ï¼Ÿ\n\nA: ä¸ä¼šã€‚æ€»è¯·æ±‚æ•°ä¸å˜ï¼Œåªæ˜¯åˆ†æ•£åˆ°å¤šä¸ªkeyä¸Šã€‚\n\n### Q: å¦‚æœä¸€ä¸ªkeyå¤±è´¥äº†æ€ä¹ˆåŠï¼Ÿ\n\nA: å½“å‰ç‰ˆæœ¬ä¼šç»§ç»­è½®è¯¢åˆ°ä¸‹ä¸€ä¸ªkeyã€‚æœªæ¥å¯ä»¥æ·»åŠ è‡ªåŠ¨æ•…éšœåˆ‡æ¢ã€‚\n\n### Q: å¯ä»¥åŠ¨æ€æ·»åŠ /åˆ é™¤keyå—ï¼Ÿ\n\nA: ç›®å‰éœ€è¦ä¿®æ”¹é…ç½®æ–‡ä»¶å¹¶é‡å¯ã€‚æœªæ¥å¯ä»¥æ”¯æŒçƒ­é‡è½½ã€‚\n\n### Q: è½®è¯¢æ˜¯çº¿ç¨‹å®‰å…¨çš„å—ï¼Ÿ\n\nA: æ˜¯çš„ã€‚ä½¿ç”¨äº†è®¡æ•°å™¨å’Œå–æ¨¡è¿ç®—ï¼Œä¿è¯çº¿ç¨‹å®‰å…¨ã€‚\n\n## æœ€ä½³å®è·µ\n\n1. **å»ºè®®é…ç½®2-3ä¸ªAPI Key** - å¹³è¡¡æˆæœ¬å’Œå¯ç”¨æ€§\n2. **ç›‘æ§å„keyçš„ä½¿ç”¨æƒ…å†µ** - ç¡®ä¿è´Ÿè½½å‡è¡¡\n3. **å®šæœŸæ£€æŸ¥é…é¢** - é¿å…æ‰€æœ‰keyåŒæ—¶è€—å°½\n4. **ä¿æŒkeyçš„å®‰å…¨** - ä¸è¦æäº¤åˆ°gitä»“åº“\n\n## æŠ€æœ¯ç»†èŠ‚\n\n### å®ç°ä½ç½®\n\n- é…ç½®æ–‡ä»¶: `backend/config/llm_config.yaml`\n- å®¢æˆ·ç«¯ç®¡ç†å™¨: `backend/daoyoucode/agents/llm/client_manager.py`\n- é…ç½®åŠ è½½å™¨: `backend/daoyoucode/agents/llm/config_loader.py`\n- æµ‹è¯•æ–‡ä»¶: `backend/test_api_key_rotation.py`\n\n### æ ¸å¿ƒä»£ç \n\n```python\ndef _get_next_api_key(self, provider: str) -> str:\n    \"\"\"è·å–ä¸‹ä¸€ä¸ªAPI Keyï¼ˆRound-robinè½®è¯¢ï¼‰\"\"\"\n    config = self.provider_configs[provider]"
},
{
"path": "API_KEYè½®è¯¢é…ç½®è¯´æ˜.md",
"start": 221,
"end": 243,
"text": "    keys = config['api_keys']\n    \n    # å¦‚æœåªæœ‰ä¸€ä¸ªkeyï¼Œç›´æ¥è¿”å›\n    if len(keys) == 1:\n        return keys[0]\n    \n    # è½®è¯¢ï¼šè·å–å½“å‰è®¡æ•°å™¨å¯¹åº”çš„keyï¼Œç„¶åé€’å¢è®¡æ•°å™¨\n    current_index = self.key_counters[provider] % len(keys)\n    self.key_counters[provider] += 1\n    \n    return keys[current_index]\n```\n\n## æ›´æ–°è®°å½•\n\n- **2025-02-17**: åˆå§‹ç‰ˆæœ¬ï¼Œæ”¯æŒRound-robinè½®è¯¢\n- æ”¯æŒå•ä¸ªæˆ–å¤šä¸ªAPI Keyé…ç½®\n- è‡ªåŠ¨é€‚é…keyæ•°é‡\n- å®Œæ•´çš„æµ‹è¯•è¦†ç›–\n\n---\n\n**é…ç½®å®Œæˆåï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨ä½¿ç”¨è½®è¯¢æœºåˆ¶ï¼Œæ— éœ€é¢å¤–æ“ä½œï¼**"
},
{
"path": "CLIåˆ°LLMæµç¨‹åˆ†æä¸ä¼˜åŒ–å»ºè®®.md",
"start": 1,
"end": 55,
"text": "# CLI â†’ ç¼–æ’å™¨ â†’ Agents â†’ LLM æµç¨‹åˆ†æä¸ä¼˜åŒ–å»ºè®®\n\n> åŸºäºå½“å‰ä»£ç æ·±åº¦æ¢³ç†ï¼Œå‚ç…§ aider ç­‰é¡¹ç›®çš„è®¾è®¡æ€è·¯ã€‚å‚è€ƒé¡¹ç›®ï¼ˆaider ç­‰ï¼‰å·²æ”¾åœ¨ç›®å½•ä¸‹ï¼Œåç»­å¯åˆ é™¤ã€‚\n\n---\n\n## ä¸€ã€å½“å‰æµç¨‹æ€»è§ˆ\n\n```\nç”¨æˆ·è¾“å…¥\n   â†“\nCLI (Typer: chat / edit / skills / agent ...)\n   â†“\nç¼–æ’å™¨å…¥å£: execute_skill(skill_name, user_input, context)\n   â†“\nExecutor: Hook â†’ åŠ è½½ Skill â†’ è·å– Orchestrator â†’ åˆ›å»º Task â†’ orchestrator.execute(skill, user_input, context)\n   â†“\nOrchestrator (å¦‚ ReAct): å– Agent â†’ å‡†å¤‡ prompt â†’ agent.execute(prompt_source, user_input, context, llm_config, tools)\n   â†“\nAgent: è®°å¿†åŠ è½½ â†’ åŠ è½½/æ¸²æŸ“ Prompt â†’ _call_llm / _call_llm_with_tools â†’ ä¿å­˜è®°å¿†\n   â†“\nLLM (UnifiedLLMClient): chat/completions â†’ å¯é€‰ function_call å¾ªç¯\n   â†“\nå·¥å…·æ‰§è¡Œ (ToolRegistry.execute_tool) â†’ ç»“æœå›å¡« â†’ ç»§ç»­ LLM æˆ–è¿”å›\n```\n\næ•´ä½“åˆ†å±‚æ¸…æ™°ï¼š**CLI åªåšè§£æä¸ UIï¼Œç¼–æ’å™¨åªåš Skill/Orchestrator è°ƒåº¦ï¼ŒAgent è´Ÿè´£è®°å¿†+Prompt+LLM+å·¥å…·å¾ªç¯ï¼ŒLLM å±‚åªåšè¯·æ±‚/å“åº”**ã€‚ä¸‹é¢åˆ†å—è¯´æ˜åšå¾—å¥½çš„åœ°æ–¹å’Œå¯ä¼˜åŒ–ç‚¹ã€‚\n\n---\n\n## äºŒã€å„å±‚ç°çŠ¶ä¸è¯„ä»·\n\n### 2.1 CLI å±‚\n\n**ç°çŠ¶ï¼š**\n\n- Typer ç»Ÿä¸€å…¥å£ï¼Œå‘½ä»¤å®Œæ•´ï¼š`chat`ã€`edit`ã€`doctor`ã€`config`ã€`session`ã€`agent`ã€`models`ã€`skills`ã€`serve`ã€`version`ã€`examples`ã€‚\n- `chat` ä¸­ï¼šè§£æ `--skill`/`--model`/`--repo`ï¼Œ`determine_repo_path` å‚è€ƒ aider ä»æ–‡ä»¶/`--repo`/å½“å‰ç›®å½•æ¨æ–­ git ä»“åº“ã€‚\n- æ¯è½®å¯¹è¯å‰ï¼š`initialize_agent_system()`ã€`registry.set_context(ToolContext(repo_path, subtree_only, cwd))`ã€`auto_configure(client_manager)`ï¼Œå† `execute_skill(skill_name, ...)`ã€‚\n\n**åšå¾—å¥½çš„ï¼š**\n\n- å…¥å£å•ä¸€ã€å¸®åŠ©ä¸ç¤ºä¾‹å®Œæ•´ã€‚\n- ä»“åº“è·¯å¾„æ¨æ–­é€»è¾‘æ¸…æ™°ï¼Œå’Œ aider æ€è·¯ä¸€è‡´ã€‚\n- Skill å¯åˆ‡æ¢ï¼ˆ`/skill`ï¼‰ï¼Œæ¨¡å‹å¯åˆ‡æ¢ï¼ˆ`/model`ï¼‰ã€‚\n\n**é—®é¢˜ä¸ä¼˜åŒ–ï¼š**\n\n1. **edit æœªèµ° Skill/ç¼–æ’å™¨**  \n   `edit` ä½¿ç”¨ç‹¬ç«‹çš„ `initialize_edit_agent` å’Œ `execute_edit_with_agent`ï¼Œæ²¡æœ‰é€šè¿‡ `execute_skill`ã€‚å»ºè®®ï¼šä¸º edit å®šä¹‰ä¸“ç”¨ Skillï¼ˆå¦‚ `edit-single`ï¼‰ï¼Œé€šè¿‡ `execute_skill(\"edit-single\", ...)` èµ°åŒä¸€å¥—ç¼–æ’ä¸ Agentï¼Œä¾¿äºå¤ç”¨è¶…æ—¶/æ¢å¤/Hookã€‚\n2. **æ¯è½®éƒ½åˆå§‹åŒ–**  \n   `handle_chat` é‡Œæ¯è½®éƒ½è°ƒ `initialize_agent_system()`ã€`auto_configure()`ã€`set_context()`ã€‚å¯æ”¹ä¸ºï¼šä¼šè¯çº§åªåˆå§‹åŒ–ä¸€æ¬¡ï¼Œä»…å½“ `repo/skill` å˜åŒ–æ—¶å† `set_context` æˆ–é‡é…ã€‚\n3. **context ä¸ executor é‡å¤è®¾ç½®å·¥å…·ä¸Šä¸‹æ–‡**  \n   CLI å·²ç”¨ `ToolContext(repo_path, subtree_only, cwd)` è°ƒç”¨ `registry.set_context()`ï¼Œä½† `executor._execute_skill_internal` é‡Œåˆç”¨ `context.get('working_directory') or context.get('repo')` è°ƒ `registry.set_working_directory(working_dir)`ã€‚  \n   `set_working_directory` ä¼šè¦†ç›–/ç®€åŒ– contextï¼Œå¯¼è‡´ **subtree_onlyã€cwd ä¸¢å¤±**ã€‚å»ºè®®ï¼šexecutor ä¸­è‹¥ context é‡Œå·²æœ‰å®Œæ•´ä¿¡æ¯ï¼Œåº”ç»Ÿä¸€æ”¹ä¸º `set_context(ToolContext(...))`ï¼Œå¦åˆ™åªè®¾ `working_directory` æ—¶ä¹Ÿä¿æŒä¸ CLI çš„ ToolContext ä¸€è‡´ï¼ˆè§ 3.1ï¼‰ã€‚"
},
{
"path": "CLIåˆ°LLMæµç¨‹åˆ†æä¸ä¼˜åŒ–å»ºè®®.md",
"start": 56,
"end": 110,
"text": "\n---\n\n### 2.2 ç¼–æ’å™¨å±‚ï¼ˆOrchestratorï¼‰\n\n**ç°çŠ¶ï¼š**\n\n- åŸºç±» `BaseOrchestrator` å®šä¹‰ `execute(skill, user_input, context)`ï¼Œå­ç±»æœ‰ï¼šsimpleã€reactã€multi_agentã€workflowã€conditionalã€parallelã€parallel_exploreã€‚\n- ä¸»è·¯å¾„æ˜¯ **ReAct**ï¼šå– Skill çš„ agentã€promptã€toolsï¼Œè°ƒ `agent.execute(prompt_source, user_input, context, llm_config, tools)`ï¼Œä¸è‡ªå·±åšæ˜¾å¼è§„åˆ’/åæ€å¾ªç¯ï¼Œç”± Agent å†… Function Calling å¾ªç¯å®Œæˆ ReAct è¯­ä¹‰ã€‚\n- å¤š Agent ç¼–æ’å™¨æ”¯æŒ sequential / parallel / debate / main_with_helpersã€‚\n\n**åšå¾—å¥½çš„ï¼š**\n\n- ç¼–æ’å™¨ä¸ Skill è§£è€¦ï¼Œé€šè¿‡ `skill.orchestrator` æŒ‰åå–ç¼–æ’å™¨ã€‚\n- ReAct èŒè´£è¾¹ç•Œæ¸…æ™°ï¼šç¼–æ’å™¨åªåšâ€œè°ƒè°ã€ä¼ ä»€ä¹ˆâ€ï¼Œå¾ªç¯åœ¨ Agent+LLM ä¾§ã€‚\n- å¤š Agent æ¨¡å¼é½å…¨ï¼Œä¾¿äºæ‰©å±•å¤æ‚åä½œã€‚\n\n**é—®é¢˜ä¸ä¼˜åŒ–ï¼š**\n\n1. **ReAct ç¼–æ’å™¨æœªç”¨ Skill.llm**  \n   `agent.execute(..., llm_config=skill.llm, ...)` å·²ä¼ ï¼Œä½†è‹¥ Skill æœªé… `llm`ï¼ŒAgent ä¼šç”¨è‡ªèº«é»˜è®¤ modelï¼›å»ºè®®åœ¨æ–‡æ¡£æˆ–é»˜è®¤ Skill æ¨¡æ¿ä¸­æ˜ç¡® `llm.model`ï¼Œé¿å…ä¸ CLI `--model` ä¸ä¸€è‡´ã€‚\n2. **ç¼–æ’å™¨å±‚æ— ç»Ÿä¸€è¶…æ—¶/é‡è¯•**  \n   è¶…æ—¶æ¢å¤åœ¨ executor å±‚åšï¼Œç¼–æ’å™¨å†…æ²¡æœ‰ã€‚è‹¥å¸Œæœ›â€œå•æ¬¡ agent.execute è¶…æ—¶å¯é‡è¯•â€ï¼Œå¯åœ¨ç¼–æ’å™¨å†…åŒ…ä¸€å±‚å¸¦è¶…æ—¶çš„æ‰§è¡Œï¼Œæˆ–ä¿æŒç°çŠ¶ç”± executor ç»Ÿä¸€å¤„ç†ï¼ˆå½“å‰åšæ³•åˆç†ï¼Œä»…éœ€åœ¨æ–‡æ¡£ä¸­è¯´æ˜ï¼‰ã€‚\n3. **multi_agent é‡Œæœªä¼  llm_config**  \n   `_execute_sequential` ç­‰é‡Œ `agent.execute(..., tools=skill.tools)` æœªä¼  `llm_config=skill.llm`ï¼Œå„å­ Agent ä¼šç”¨è‡ªå·±çš„é»˜è®¤ modelã€‚è‹¥å¸Œæœ› Skill ç»Ÿä¸€æ§åˆ¶æ¨¡å‹ï¼Œå»ºè®®ä¼ å…¥ `llm_config=skill.llm`ã€‚\n\n---\n\n### 2.3 Agents å±‚\n\n**ç°çŠ¶ï¼š**\n\n- `BaseAgent`ï¼šè®°å¿†ï¼ˆmemoryï¼‰ã€å·¥å…·æ³¨å†Œè¡¨ã€åå¤„ç†å™¨ã€ç”¨æˆ·ç”»åƒç¼“å­˜ï¼›`execute` æµç¨‹ï¼šæ™ºèƒ½åŠ è½½è®°å¿† â†’ åŠ è½½/æ¸²æŸ“ Prompt â†’ å¸¦å·¥å…·çš„ `_call_llm_with_tools` æˆ– `_call_llm` â†’ å†™å›è®°å¿†ä¸ä»»åŠ¡ã€‚\n- å·¥å…·å¾ªç¯ï¼šæœ€å¤š 15 æ¬¡è¿­ä»£ï¼Œæ¯æ¬¡ LLM å¯èƒ½è¿”å› function_callï¼Œæ‰§è¡Œå·¥å…·åæŠŠç»“æœå¡å› messagesï¼Œå†è¯·æ±‚ LLMã€‚\n- è·¯å¾„ä¸å ä½ç¬¦ï¼šå·¥å…·ä¾§ç”¨ `ToolContext.repo_path` åšè·¯å¾„è§£æï¼ŒBaseTool å†…å¯¹å ä½ç¬¦è·¯å¾„åšäº†æ£€æµ‹ä¸ä¿®æ­£ã€‚\n\n**åšå¾—å¥½çš„ï¼š**\n\n- è®°å¿†ä¸ Prompt åˆ†ç¦»æ¸…æ™°ï¼Œæ™ºèƒ½åŠ è½½ï¼ˆè¿½é—®æ£€æµ‹ã€æ‘˜è¦ã€å†å²æˆªæ–­ï¼‰å‡å°‘ token ä¸”ä¿ç•™ä¸Šä¸‹æ–‡ã€‚\n- å·¥å…·è°ƒç”¨å¾ªç¯å®Œæ•´ï¼Œå« JSON è§£æå®¹é”™ã€åå¤„ç†ã€å·¥å…·å±•ç¤ºã€‚\n- ç”¨æˆ·ç”»åƒä¸åå¥½æœ‰ç¼“å­˜ä¸æ—¶é—´çª—å£ï¼Œé¿å…é¢‘ç¹ I/Oã€‚\n\n**é—®é¢˜ä¸ä¼˜åŒ–ï¼š**\n\n1. **ToolContext åœ¨ executor è¢«å¼±åŒ–**  \n   åŒä¸Šï¼šexecutor åªè°ƒ `set_working_directory`ï¼Œä¼šè¦†ç›– CLI è®¾ç½®çš„å®Œæ•´ `ToolContext`ï¼Œå¯¼è‡´ subtree_only/cwd åœ¨çœŸæ­£æ‰§è¡Œæ—¶ä¸¢å¤±ã€‚åº”ç»Ÿä¸€ç”¨ `set_context(ToolContext(...))`ï¼Œå¹¶åœ¨ executor é‡Œä» context æ„é€  ToolContextï¼ˆå« repoã€subtree_onlyã€cwdï¼‰ã€‚\n2. **æµå¼æ¨¡å¼ä¸å·¥å…·ä¸å¯å…¼å¾—**  \n   `execute_stream` ä¸­è‹¥æœ‰ tools ä¼šç›´æ¥é™çº§ä¸ºæ™®é€š `execute`ï¼Œæµå¼æ—¶æ— æ³•è¾¹æ¨ç†è¾¹çœ‹å·¥å…·è°ƒç”¨ã€‚è‹¥éœ€â€œæµå¼ + å·¥å…·â€ï¼Œå¯è€ƒè™‘åœ¨æµå¼åˆ†æ”¯é‡Œä¹Ÿåšä¸€è½®è½® function_callï¼ˆå¤æ‚åº¦è¾ƒé«˜ï¼‰ï¼Œæˆ–æ˜ç¡®æ–‡æ¡£è¯´æ˜â€œæµå¼å³æ— å·¥å…·â€ã€‚\n3. **ç¡¬ç¼–ç å·¥å…·ä½¿ç”¨è§„åˆ™**  \n   Agent é‡ŒæŠŠâ€œè·¯å¾„ç”¨ `.`ã€ç›¸å¯¹è·¯å¾„â€ç­‰è§„åˆ™å†™æ­»åœ¨ Prompt å‰ã€‚å»ºè®®æ”¹ä¸ºä»é…ç½®æˆ– Skill çš„ prompt ç‰‡æ®µæ³¨å…¥ï¼Œä¾¿äºæŒ‰ Skill å®šåˆ¶ã€‚\n4. **å†å²è½®æ•°æˆªæ–­å†™æ­»**  \n   `MAX_HISTORY_ROUNDS = 5` å†™æ­»åœ¨ Agent å†…ï¼Œå¯æ”¹ä¸ºé…ç½®æˆ– Skill å‚æ•°ã€‚\n\n---\n"
},
{
"path": "CLIåˆ°LLMæµç¨‹åˆ†æä¸ä¼˜åŒ–å»ºè®®.md",
"start": 111,
"end": 165,
"text": "### 2.4 LLM å±‚\n\n**ç°çŠ¶ï¼š**\n\n- `LLMClientManager`ï¼šå•ä¾‹ã€å…±äº« `httpx.AsyncClient`ã€å¤š API Key è½®è¯¢ã€æŒ‰ model æ¨æ–­ providerã€‚\n- `UnifiedLLMClient`ï¼šOpenAI å…¼å®¹çš„ chat/completionsï¼Œæ”¯æŒ functions/function_callï¼Œ30 åˆ†é’Ÿè¶…æ—¶ï¼Œæœ‰ç®€å•è®¡ä»·ä¸è°ƒè¯•æ—¥å¿—ã€‚\n\n**åšå¾—å¥½çš„ï¼š**\n\n- è¿æ¥æ± ä¸å¤š Key è½®è¯¢ç»Ÿä¸€ç®¡ç†ï¼Œé¿å…é‡å¤å»ºè¿ã€‚\n- è¶…æ—¶ä¸å¼‚å¸¸ï¼ˆå¦‚ LLMTimeoutErrorï¼‰æœ‰æ˜ç¡®ç±»å‹ï¼Œä¾¿äºä¸Šå±‚æ¢å¤ã€‚\n\n**é—®é¢˜ä¸ä¼˜åŒ–ï¼š**\n\n1. **è°ƒè¯•æ—¥å¿—è¿‡é‡**  \n   æ¯æ¬¡è¯·æ±‚æ‰“æ»¡ 60 è¡Œç­‰è°ƒè¯•ä¿¡æ¯ï¼Œç”Ÿäº§ç¯å¢ƒå»ºè®®ç”¨ `logging` çº§åˆ«æ§åˆ¶ï¼ˆå¦‚ä»… DEBUG æ—¶æ‰“å°ï¼‰ï¼Œæˆ–é€šè¿‡ç¯å¢ƒå˜é‡å…³é—­ã€‚\n2. **stream_chat ä¸ function calling**  \n   è‹¥æœªæ¥è¦â€œæµå¼ + å·¥å…·â€ï¼Œéœ€ç¡®è®¤å½“å‰ stream æ¥å£æ˜¯å¦æ”¯æŒ function_call çš„æµå¼è¿”å›ï¼Œå¹¶åœ¨ Agent ä¾§åšå¯¹åº”è§£æã€‚\n\n---\n\n## ä¸‰ã€å…³é”®ä¼˜åŒ–ç‚¹æ±‡æ€»ï¼ˆå»ºè®®ä¼˜å…ˆåšï¼‰\n\n### 3.1 å·¥å…·ä¸Šä¸‹æ–‡ç»Ÿä¸€ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰\n\n- **ç°è±¡**ï¼šCLI ç”¨ `set_context(ToolContext(repo_path, subtree_only, cwd))`ï¼Œexecutor é‡Œåˆç”¨ `set_working_directory(working_dir)`ï¼Œåè€…ä¼šè¦†ç›–/ç®€åŒ– contextï¼Œå¯¼è‡´ subtree_onlyã€cwd ä¸¢å¤±ã€‚\n- **å»ºè®®**ï¼š\n  - åœ¨ `executor._execute_skill_internal` ä¸­ï¼šè‹¥ `context` å·²åŒ…å« `repo`/`working_directory` ä»¥åŠå¯é€‰çš„ `subtree_only`ã€`cwd`ï¼Œåˆ™ç»Ÿä¸€æ„é€  `ToolContext(repo_path=..., subtree_only=context.get('subtree_only', False), cwd=context.get('cwd'))` å¹¶è°ƒç”¨ `registry.set_context(tool_context)`ã€‚\n  - ä»…å½“æ²¡æœ‰å®Œæ•´ context æ—¶å†å›é€€ä¸º `set_working_directory(working_dir)`ã€‚\n  - è¿™æ · CLI ä¸ executor å…±ç”¨åŒä¸€å¥—å·¥å…·ä¸Šä¸‹æ–‡è¯­ä¹‰ï¼Œaider é£æ ¼çš„ subtree_only æ‰èƒ½è´¯ç©¿åˆ°åº•ã€‚\n\n### 3.2 edit èµ° Skill ä½“ç³»ï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰\n\n- **ç°è±¡**ï¼š`edit` å‘½ä»¤ç‹¬ç«‹åˆå§‹åŒ–ã€ç‹¬ç«‹æ‰§è¡Œï¼Œä¸ç»è¿‡ `execute_skill`ï¼Œæ— æ³•å¤ç”¨è¶…æ—¶æ¢å¤ã€Hookã€ç»Ÿä¸€ç¼–æ’ã€‚\n- **å»ºè®®**ï¼šæ–°å¢ Skillï¼ˆå¦‚ `edit-single`ï¼‰ï¼Œorchestrator ç”¨ `react`ï¼Œagent ç”¨ç°æœ‰ç¼–ç¨‹/ç¼–è¾‘ç±» Agentï¼›`edit` å‘½ä»¤é‡Œåªç»„å¥½ `context`ï¼ˆå« repoã€filesã€instructionï¼‰ï¼Œè°ƒç”¨ `execute_skill(\"edit-single\", user_input, context)`ã€‚è¿™æ · edit ä¸ chat å…±ç”¨åŒä¸€å¥—æ¢å¤ä¸ç›‘æ§ã€‚\n\n### 3.3 multi_agent ä¼ å…¥ llm_configï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰\n\n- **ç°è±¡**ï¼š`MultiAgentOrchestrator` çš„ `_execute_sequential`ã€`_execute_parallel` ç­‰é‡Œè°ƒç”¨ `agent.execute(..., tools=skill.tools)` æœªä¼  `llm_config=skill.llm`ã€‚\n- **å»ºè®®**ï¼šåœ¨æ‰€æœ‰ `agent.execute` è°ƒç”¨å¤„å¢åŠ  `llm_config=skill.llm`ï¼Œä½¿ Skill çš„ `llm.model` èƒ½ç»Ÿä¸€æ§åˆ¶å¤š Agent ä½¿ç”¨çš„æ¨¡å‹ã€‚\n\n### 3.4 æ¯è½®å¯¹è¯é¿å…é‡å¤åˆå§‹åŒ–ï¼ˆä½ä¼˜å…ˆçº§ï¼‰\n\n- **ç°è±¡**ï¼š`handle_chat` æ¯è½®éƒ½æ‰§è¡Œ `initialize_agent_system()`ã€`auto_configure(client_manager)`ã€`registry.set_context(...)`ã€‚\n- **å»ºè®®**ï¼šåœ¨ä¼šè¯çº§ï¼ˆå¦‚ ui_contextï¼‰è®°å½•â€œæ˜¯å¦å·²åˆå§‹åŒ–ã€å½“å‰ repo/skillâ€ï¼Œä»…é¦–æ¬¡æˆ–å½“ repo/skill å˜åŒ–æ—¶å†åˆå§‹åŒ–/é‡è®¾ contextï¼Œå‡å°‘é‡å¤å·¥ä½œã€‚\n\n### 3.5 å…¶ä»–\n\n- **Agent å†…å·¥å…·è§„åˆ™ä¸å†å²è½®æ•°**ï¼šå°†â€œè·¯å¾„ç”¨ `.`ã€ç›¸å¯¹è·¯å¾„â€ç­‰è§„åˆ™ä»¥åŠ `MAX_HISTORY_ROUNDS` æ”¹ä¸ºé…ç½®æˆ– Skill å‚æ•°ï¼Œä¾¿äºæŒ‰åœºæ™¯è°ƒä¼˜ã€‚\n- **LLM è°ƒè¯•æ—¥å¿—**ï¼šç”¨ `logger.debug` æˆ–ç¯å¢ƒå˜é‡æ§åˆ¶è¯¦ç»†è¯·æ±‚æ—¥å¿—ï¼Œé¿å…ç”Ÿäº§ç¯å¢ƒåˆ·å±ã€‚\n\n---\n\n## å››ã€å°ç»“\n"
},
{
"path": "CLIåˆ°LLMæµç¨‹åˆ†æä¸ä¼˜åŒ–å»ºè®®.md",
"start": 166,
"end": 166,
"text": "å½“å‰ **CLI â†’ ç¼–æ’å™¨ â†’ Agents â†’ LLM** çš„åˆ†å±‚å’ŒèŒè´£åˆ’åˆ†æ˜¯æ¸…æ™°çš„ï¼Œä¸ aider ç­‰å‚è€ƒé¡¹ç›®çš„æ€è·¯ä¸€è‡´ï¼›ä¸»è¦é—®é¢˜é›†ä¸­åœ¨**å·¥å…·ä¸Šä¸‹æ–‡çš„ä¼ é€’ä¸€è‡´æ€§**ï¼ˆCLI ä¸ executorï¼‰ã€**edit ä¸ Skill ä½“ç³»çš„ç»Ÿä¸€**ã€ä»¥åŠ**å¤š Agent æ—¶ llm_config çš„ä¼ é€’**ã€‚ä¼˜å…ˆåšå®Œ 3.1 å’Œ 3.2ï¼Œå†æŒ‰éœ€åš 3.3ï½3.5ï¼Œæ•´ä½“æµç¨‹ä¼šæ›´ç¨³ã€æ›´æ˜“ç»´æŠ¤ã€‚"
},
{
"path": "CLIå‘½ä»¤å‚è€ƒ.md",
"start": 1,
"end": 55,
"text": "# CLIå‘½ä»¤å‚è€ƒ\n\n> DaoyouCode CLIå®Œæ•´ä½¿ç”¨æŒ‡å—\n\n---\n\n## å¿«é€Ÿå¼€å§‹\n\n```bash\n# æŸ¥çœ‹æ‰€æœ‰å‘½ä»¤\npython backend/daoyoucode.py --help\n\n# æŸ¥çœ‹ä½¿ç”¨ç¤ºä¾‹\npython backend/daoyoucode.py examples\n\n# å¯åŠ¨å¯¹è¯\npython backend/daoyoucode.py chat --skill <skill_name>\n```\n\n---\n\n## ä¸‰å±‚å¸®åŠ©ç³»ç»Ÿ\n\n### Level 1: --helpï¼ˆå¿«é€Ÿå‚è€ƒï¼‰\næ˜¾ç¤ºå‘½ä»¤å‚æ•°å’Œé€‰é¡¹\n```bash\npython backend/daoyoucode.py chat --help\n```\n\n### Level 2: --examplesï¼ˆè¯¦ç»†ç¤ºä¾‹ï¼‰\næ˜¾ç¤ºä½¿ç”¨ç¤ºä¾‹å’Œæœ€ä½³å®è·µ\n```bash\npython backend/daoyoucode.py chat --examples\n```\n\n### Level 3: exampleså‘½ä»¤ï¼ˆå…¨å±€è§†å›¾ï¼‰\næ˜¾ç¤ºæ‰€æœ‰å‘½ä»¤æ¦‚è§ˆ\n```bash\npython backend/daoyoucode.py examples\n```\n\n---\n\n## æ ¸å¿ƒå‘½ä»¤\n\n### 1. chat - å¯åŠ¨å¯¹è¯\n\n```bash\n# åŸºæœ¬ç”¨æ³•\npython backend/daoyoucode.py chat\n\n# æŒ‡å®šSkill\npython backend/daoyoucode.py chat --skill sisyphus-orchestrator\npython backend/daoyoucode.py chat --skill oracle\npython backend/daoyoucode.py chat --skill librarian"
},
{
"path": "CLIå‘½ä»¤å‚è€ƒ.md",
"start": 56,
"end": 110,
"text": "\n# æŒ‡å®šæ¨¡å‹\npython backend/daoyoucode.py chat --model deepseek-coder\n\n# åŠ è½½æ–‡ä»¶\npython backend/daoyoucode.py chat main.py utils.py\n\n# ç»„åˆä½¿ç”¨\npython backend/daoyoucode.py chat --skill oracle --model qwen-max main.py\n```\n\n**å‚æ•°**ï¼š\n- `--skill, -s` - ä½¿ç”¨çš„Skillï¼ˆé»˜è®¤ï¼šchat-assistantï¼‰\n  - **æ³¨æ„**ï¼šä¼ çš„æ˜¯Skillåç§°ï¼Œä¸æ˜¯Agentåç§°ï¼\n  - Skillé…ç½®æ–‡ä»¶æŒ‡å®šä½¿ç”¨å“ªäº›Agentå’Œç¼–æ’å™¨\n- `--model, -m` - ä½¿ç”¨çš„æ¨¡å‹ï¼ˆé»˜è®¤ï¼šqwen-maxï¼‰\n- `--repo, -r` - ä»“åº“è·¯å¾„ï¼ˆé»˜è®¤ï¼š.ï¼‰\n- `--examples` - æ˜¾ç¤ºä½¿ç”¨ç¤ºä¾‹\n\n**Skillã€Agentã€ç¼–æ’å™¨çš„å…³ç³»**ï¼š\n```\nCLI --skill sisyphus-orchestrator\n    â†“\nSkillé…ç½®æ–‡ä»¶ï¼ˆskills/sisyphus-orchestrator/skill.yamlï¼‰\n    â†“\næŒ‡å®šç¼–æ’å™¨ï¼šorchestrator: multi_agent\næŒ‡å®šAgentåˆ—è¡¨ï¼šagents: [sisyphus, code_analyzer, programmer, ...]\n    â†“\nç¼–æ’å™¨åè°ƒè¿™äº›Agentå·¥ä½œ\n```\n\n**äº¤äº’å¼å‘½ä»¤**ï¼š\n- `/skill [name]` - åˆ‡æ¢Skill\n- `/model [name]` - åˆ‡æ¢æ¨¡å‹\n- `/add <file>` - æ·»åŠ æ–‡ä»¶\n- `/help` - æ˜¾ç¤ºå¸®åŠ©\n- `/exit` - é€€å‡ºå¯¹è¯\n\n---\n\n### 2. agent - Agentç®¡ç†\n\n```bash\n# åˆ—å‡ºæ‰€æœ‰Agent\npython backend/daoyoucode.py agent\n\n# æŸ¥çœ‹Agentè¯¦æƒ…\npython backend/daoyoucode.py agent sisyphus\n\n# æŸ¥çœ‹Agentå·¥å…·\npython backend/daoyoucode.py agent sisyphus --tools\n```\n\n**å‚æ•°**ï¼š\n- `agent_name` - Agentåç§°ï¼ˆå¯é€‰ï¼‰"
},
{
"path": "CLIå‘½ä»¤å‚è€ƒ.md",
"start": 111,
"end": 165,
"text": "- `--tools, -t` - æ˜¾ç¤ºAgentçš„å·¥å…·åˆ—è¡¨\n- `--examples` - æ˜¾ç¤ºä½¿ç”¨ç¤ºä¾‹\n\n---\n\n### 3. skills - Skillç®¡ç†\n\n```bash\n# åˆ—å‡ºæ‰€æœ‰Skill\npython backend/daoyoucode.py skills\n\n# æŸ¥çœ‹Skillè¯¦æƒ…\npython backend/daoyoucode.py skills sisyphus-orchestrator\n\n# æŸ¥çœ‹æ‰€æœ‰ç¼–æ’å™¨\npython backend/daoyoucode.py skills --orchestrators\n```\n\n**å‚æ•°**ï¼š\n- `skill_name` - Skillåç§°ï¼ˆå¯é€‰ï¼‰\n- `--orchestrators, -o` - æ˜¾ç¤ºç¼–æ’å™¨åˆ—è¡¨å’Œè¯´æ˜\n- `--examples` - æ˜¾ç¤ºä½¿ç”¨ç¤ºä¾‹\n\n---\n\n### 4. examples - æŸ¥çœ‹ç¤ºä¾‹\n\n```bash\n# æŸ¥çœ‹æ‰€æœ‰ç¤ºä¾‹\npython backend/daoyoucode.py examples\n\n# æŸ¥çœ‹ç‰¹å®šå‘½ä»¤ç¤ºä¾‹\npython backend/daoyoucode.py examples chat\npython backend/daoyoucode.py examples agent\npython backend/daoyoucode.py examples skills\n```\n\n---\n\n## ä½¿ç”¨åœºæ™¯\n\n### åœºæ™¯1ï¼šäº†è§£ç³»ç»Ÿ\n```bash\npython backend/daoyoucode.py agent                    # æŸ¥çœ‹æ‰€æœ‰Agent\npython backend/daoyoucode.py skills                   # æŸ¥çœ‹æ‰€æœ‰Skill\npython backend/daoyoucode.py skills --orchestrators   # æŸ¥çœ‹ç¼–æ’å™¨\n```\n\n### åœºæ™¯2ï¼šæ—¥å¸¸å¯¹è¯\n```bash\npython backend/daoyoucode.py chat\n```\n\n### åœºæ™¯3ï¼šå¤æ‚ä»»åŠ¡\n```bash"
},
{
"path": "CLIå‘½ä»¤å‚è€ƒ.md",
"start": 166,
"end": 220,
"text": "python backend/daoyoucode.py chat --skill sisyphus-orchestrator\n```\n\n### åœºæ™¯4ï¼šæ¶æ„å’¨è¯¢\n```bash\npython backend/daoyoucode.py chat --skill oracle\n```\n\n### åœºæ™¯5ï¼šæ–‡æ¡£æœç´¢\n```bash\npython backend/daoyoucode.py chat --skill librarian\n```\n\n### åœºæ™¯6ï¼šäº¤äº’å¼åˆ‡æ¢\n```bash\npython backend/daoyoucode.py chat\nä½  â€º /skill oracle\nä½  â€º åˆ†ææ¶æ„\n```\n\n---\n\n## å®Œæ•´å‘½ä»¤æ ‘\n\n```\ndaoyoucode\nâ”œâ”€â”€ chat [OPTIONS] [FILES]               # å¯åŠ¨å¯¹è¯\nâ”‚   â”œâ”€â”€ --skill TEXT                     # æŒ‡å®šSkill\nâ”‚   â”œâ”€â”€ --model TEXT                     # æŒ‡å®šæ¨¡å‹\nâ”‚   â”œâ”€â”€ --repo PATH                      # æŒ‡å®šä»“åº“\nâ”‚   â””â”€â”€ --examples                       # æŸ¥çœ‹ç¤ºä¾‹\nâ”‚\nâ”œâ”€â”€ agent [name] [--tools] [--examples]  # Agentç®¡ç†\nâ”‚   â”œâ”€â”€ agent                            # åˆ—å‡ºæ‰€æœ‰Agent\nâ”‚   â”œâ”€â”€ agent <name>                     # æŸ¥çœ‹Agentè¯¦æƒ…\nâ”‚   â””â”€â”€ agent <name> --tools             # æŸ¥çœ‹Agentå·¥å…·\nâ”‚\nâ”œâ”€â”€ skills [name] [--orchestrators] [--examples]  # Skillç®¡ç†\nâ”‚   â”œâ”€â”€ skills                           # åˆ—å‡ºæ‰€æœ‰Skill\nâ”‚   â”œâ”€â”€ skills <name>                    # æŸ¥çœ‹Skillè¯¦æƒ…\nâ”‚   â””â”€â”€ skills --orchestrators           # æŸ¥çœ‹ç¼–æ’å™¨\nâ”‚\nâ”œâ”€â”€ examples [command]                   # æŸ¥çœ‹ç¤ºä¾‹\nâ”‚   â”œâ”€â”€ examples                         # æ‰€æœ‰ç¤ºä¾‹\nâ”‚   â”œâ”€â”€ examples chat                    # chatç¤ºä¾‹\nâ”‚   â”œâ”€â”€ examples agent                   # agentç¤ºä¾‹\nâ”‚   â””â”€â”€ examples skills                  # skillsç¤ºä¾‹\nâ”‚\nâ”œâ”€â”€ models                               # æŸ¥çœ‹æ¨¡å‹\nâ”œâ”€â”€ doctor [--fix]                       # ç³»ç»Ÿè¯Šæ–­\nâ”œâ”€â”€ config                               # é…ç½®ç®¡ç†\nâ”œâ”€â”€ session                              # ä¼šè¯ç®¡ç†\nâ””â”€â”€ version                              # æŸ¥çœ‹ç‰ˆæœ¬\n```\n"
},
{
"path": "CLIå‘½ä»¤å‚è€ƒ.md",
"start": 221,
"end": 241,
"text": "---\n\n## æ¨èSkill\n\n| Skill | ç¼–æ’å™¨ | ç”¨é€” | ä½¿ç”¨åœºæ™¯ |\n|-------|--------|------|---------|\n| chat-assistant | react | æ—¥å¸¸å¯¹è¯ | ä»£ç å’¨è¯¢ã€é—®é¢˜è§£ç­” |\n| sisyphus-orchestrator | multi_agent | å¤æ‚ä»»åŠ¡ | é‡æ„+æµ‹è¯•ã€å¤šæ–‡ä»¶ä¿®æ”¹ |\n| oracle | react | æ¶æ„å’¨è¯¢ | æ¶æ„åˆ†æã€æŠ€æœ¯å»ºè®®ï¼ˆåªè¯»ï¼‰ |\n| librarian | react | æ–‡æ¡£æœç´¢ | æ–‡æ¡£æŸ¥æ‰¾ã€ä»£ç æœç´¢ï¼ˆåªè¯»ï¼‰ |\n| programming | simple | ç¼–ç¨‹ä¸“å®¶ | ä»£ç ç¼–å†™ã€åŠŸèƒ½å®ç° |\n| refactoring | simple | é‡æ„ä¸“å®¶ | ä»£ç é‡æ„ã€ä¼˜åŒ– |\n| testing | simple | æµ‹è¯•ä¸“å®¶ | æµ‹è¯•ç¼–å†™ã€ä¿®å¤ |\n\n---\n\n## ç›¸å…³æ–‡æ¡£\n\n- [AGENTS.md](./AGENTS.md) - Agentè¯¦ç»†ä»‹ç»\n- [ORCHESTRATORS.md](./ORCHESTRATORS.md) - ç¼–æ’å™¨è¯¦ç»†ä»‹ç»\n- [TOOLS.md](./TOOLS.md) - å·¥å…·å‚è€ƒæ‰‹å†Œ"
},
{
"path": "daoyoucode.py",
"start": 1,
"end": 18,
"text": "#!/usr/bin/env python\n\"\"\"\nDaoyouCode CLI å¯åŠ¨è„šæœ¬\n\nç›´æ¥è¿è¡Œ: python daoyoucode.py --help\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ å½“å‰ç›®å½•åˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\n# å¯¼å…¥å¹¶è¿è¡Œ\nfrom cli.app import main\n\nif __name__ == \"__main__\":\n    main()"
},
{
"path": "debug_500_error.md",
"start": 1,
"end": 55,
"text": "# Debug 500é”™è¯¯æŒ‡å—\n\n## å¿«é€ŸDebugæ­¥éª¤\n\n### 1. å¯ç”¨è¯¦ç»†æ—¥å¿—\n\nè®¾ç½®ç¯å¢ƒå˜é‡å¯ç”¨DEBUGæ¨¡å¼ï¼š\n\n```bash\n# Windows CMD\nset DEBUG_LLM_REQUEST=1\nset PYTHONPATH=D:\\daoyouspace\\daoyoucode\\backend\n\n# Windows PowerShell\n$env:DEBUG_LLM_REQUEST=\"1\"\n$env:PYTHONPATH=\"D:\\daoyouspace\\daoyoucode\\backend\"\n\n# ç„¶åè¿è¡Œä½ çš„ç¨‹åº\npython daoyoucode.py chat --skill sisyphus-orchestrator\n```\n\n### 2. æŸ¥çœ‹æ—¥å¿—è¾“å‡º\n\nè¿è¡Œåï¼Œæ—¥å¿—ä¼šæ˜¾ç¤ºï¼š\n\n```\n============================================================\nğŸ” LLMè¯·æ±‚è°ƒè¯•ä¿¡æ¯\næ¨¡å‹: qwen-max\nAPI Key: sk-d2971f201557...3b87\næ¶ˆæ¯æ•°é‡: 5\nFunctionsæ•°é‡: 26\næ¶ˆæ¯ 1 (user): ä½ å¥½ï¼Œè¯·å›å¤'æµ‹è¯•æˆåŠŸ'...\næ¶ˆæ¯ 2 (assistant): æµ‹è¯•æˆåŠŸ...\n...\nPayloadå¤§å°: 45678 å­—èŠ‚ (44.61 KB)\nğŸ’¾ å®Œæ•´è¯·æ±‚å·²ä¿å­˜åˆ°: debug_llm_request_1234567890.json\n============================================================\n```\n\n### 3. æ£€æŸ¥å…³é”®ä¿¡æ¯\n\nä»æ—¥å¿—ä¸­æŸ¥çœ‹ï¼š\n\n#### âœ… æ£€æŸ¥ç‚¹1: Payloadå¤§å°\n```\nPayloadå¤§å°: 45678 å­—èŠ‚ (44.61 KB)\n```\n- **å¦‚æœ > 100KB**: å¯èƒ½å¤ªå¤§ï¼Œå°è¯•å‡å°‘å†å²æ¶ˆæ¯æˆ–Functions\n- **æ­£å¸¸èŒƒå›´**: 10-50KB\n\n#### âœ… æ£€æŸ¥ç‚¹2: æ¶ˆæ¯æ•°é‡\n```\næ¶ˆæ¯æ•°é‡: 15\n```"
},
{
"path": "debug_500_error.md",
"start": 56,
"end": 110,
"text": "- **å¦‚æœ > 20**: å†å²æ¶ˆæ¯å¤ªå¤šï¼Œå°è¯•å‡å°‘\n- **å»ºè®®**: ä¿æŒåœ¨10æ¡ä»¥å†…\n\n#### âœ… æ£€æŸ¥ç‚¹3: Functionsæ•°é‡\n```\nFunctionsæ•°é‡: 26\n```\n- **å¦‚æœ > 30**: å·¥å…·å¤ªå¤šï¼Œå¯èƒ½å¯¼è‡´500é”™è¯¯\n- **å»ºè®®**: åªæä¾›å¿…è¦çš„å·¥å…·ï¼ˆ5-15ä¸ªï¼‰\n\n#### âœ… æ£€æŸ¥ç‚¹4: API Keyè½®è¯¢\n```\nAPI Key: sk-d2971f201557...3b87\n```\nä¸‹æ¬¡è¯·æ±‚åº”è¯¥åˆ‡æ¢åˆ°å¦ä¸€ä¸ªkey\n\n### 4. æŸ¥çœ‹å®Œæ•´è¯·æ±‚æ–‡ä»¶\n\nå¦‚æœè®¾ç½®äº† `DEBUG_LLM_REQUEST=1`ï¼Œä¼šç”ŸæˆJSONæ–‡ä»¶ï¼š\n\n```bash\n# æŸ¥çœ‹æ–‡ä»¶\ncat debug_llm_request_1234567890.json\n\n# æˆ–ç”¨ç¼–è¾‘å™¨æ‰“å¼€\ncode debug_llm_request_1234567890.json\n```\n\næ£€æŸ¥JSONå†…å®¹ï¼š\n- `messages`: å¯¹è¯å†å²\n- `functions`: å·¥å…·åˆ—è¡¨\n- `model`: ä½¿ç”¨çš„æ¨¡å‹\n- `temperature`: æ¸©åº¦å‚æ•°\n\n### 5. å¸¸è§é—®é¢˜æ’æŸ¥\n\n#### é—®é¢˜1: Payloadå¤ªå¤§\n\n**ç—‡çŠ¶**: Payload > 100KB\n\n**è§£å†³**:\n```python\n# åœ¨ agent.py ä¸­å‡å°‘å†å²æ¶ˆæ¯\nMAX_HISTORY_ROUNDS = 5  # æ”¹ä¸º 3\n```\n\n#### é—®é¢˜2: Functionså¤ªå¤š\n\n**ç—‡çŠ¶**: Functionsæ•°é‡ > 30\n\n**è§£å†³**:\n```yaml\n# åœ¨ skill.yaml ä¸­åªä¿ç•™å¿…è¦å·¥å…·\ntools:\n  - read_file"
},
{
"path": "debug_500_error.md",
"start": 111,
"end": 165,
"text": "  - write_file\n  - text_search\n  # æ³¨é‡Šæ‰ä¸å¸¸ç”¨çš„å·¥å…·\n```\n\n#### é—®é¢˜3: æ¶ˆæ¯å†…å®¹è¿‡é•¿\n\n**ç—‡çŠ¶**: å•æ¡æ¶ˆæ¯ > 10000å­—ç¬¦\n\n**è§£å†³**:\n- æ£€æŸ¥å·¥å…·è¿”å›çš„å†…å®¹æ˜¯å¦è¿‡é•¿\n- ä½¿ç”¨å·¥å…·çš„æˆªæ–­åŠŸèƒ½\n\n#### é—®é¢˜4: APIé…é¢è€—å°½\n\n**ç—‡çŠ¶**: æ‰€æœ‰keyéƒ½è¿”å›500\n\n**è§£å†³**:\n1. æ£€æŸ¥é˜¿é‡Œäº‘è´¦æˆ·ä½™é¢\n2. æŸ¥çœ‹APIè°ƒç”¨ç»Ÿè®¡\n3. æ·»åŠ æ›´å¤šAPI Key\n\n### 6. ä½¿ç”¨Pythonè°ƒè¯•å™¨\n\n```bash\n# ä½¿ç”¨pdbè°ƒè¯•\npython -m pdb daoyoucode.py chat --skill sisyphus-orchestrator\n\n# åœ¨å…³é”®ä½ç½®è®¾ç½®æ–­ç‚¹\n(Pdb) b daoyoucode/agents/llm/clients/unified.py:85\n(Pdb) c\n(Pdb) p payload\n(Pdb) p len(json.dumps(payload))\n```\n\n### 7. æŠ“åŒ…åˆ†æï¼ˆé«˜çº§ï¼‰\n\nä½¿ç”¨mitmproxyæŠ“å–HTTPè¯·æ±‚ï¼š\n\n```bash\n# å®‰è£…mitmproxy\npip install mitmproxy\n\n# å¯åŠ¨ä»£ç†\nmitmproxy -p 8080\n\n# é…ç½®ç¯å¢ƒå˜é‡\nset HTTP_PROXY=http://localhost:8080\nset HTTPS_PROXY=http://localhost:8080\n\n# è¿è¡Œç¨‹åº\npython daoyoucode.py chat\n```\n\n## å¿«é€Ÿä¿®å¤å»ºè®®"
},
{
"path": "debug_500_error.md",
"start": 166,
"end": 220,
"text": "\n### ä¿®å¤1: å‡å°‘å†å²æ¶ˆæ¯\n\nç¼–è¾‘ `backend/daoyoucode/agents/core/agent.py`:\n\n```python\n# æ‰¾åˆ°è¿™ä¸€è¡Œï¼ˆçº¦ç¬¬424è¡Œï¼‰\nMAX_HISTORY_ROUNDS = 5\n\n# æ”¹ä¸º\nMAX_HISTORY_ROUNDS = 3  # å‡å°‘å†å²æ¶ˆæ¯\n```\n\n### ä¿®å¤2: å‡å°‘å·¥å…·æ•°é‡\n\nç¼–è¾‘ `skills/sisyphus-orchestrator/skill.yaml`:\n\n```yaml\ntools:\n  - repo_map\n  - read_file\n  - write_file\n  - text_search\n  # åªä¿ç•™æœ€å¸¸ç”¨çš„4-5ä¸ªå·¥å…·\n```\n\n### ä¿®å¤3: ä½¿ç”¨æ›´å°çš„æ¨¡å‹\n\nç¼–è¾‘ `skills/sisyphus-orchestrator/skill.yaml`:\n\n```yaml\nllm:\n  model: qwen-plus  # ä» qwen-max æ”¹ä¸º qwen-plus\n  temperature: 0.3\n```\n\n### ä¿®å¤4: ç¦ç”¨ç”¨æˆ·ç”»åƒæ›´æ–°\n\nå¦‚æœä¸éœ€è¦ç”¨æˆ·ç”»åƒåŠŸèƒ½ï¼Œå¯ä»¥ä¸´æ—¶ç¦ç”¨ï¼š\n\nç¼–è¾‘ `backend/daoyoucode/agents/core/agent.py`:\n\n```python\n# æ‰¾åˆ°è¿™ä¸€è¡Œï¼ˆçº¦ç¬¬530è¡Œï¼‰\nawait self._check_and_update_profile(user_id, session_id)\n\n# æ³¨é‡Šæ‰\n# await self._check_and_update_profile(user_id, session_id)\n```\n\n## æ—¥å¿—çº§åˆ«æ§åˆ¶\n\n### æŸ¥çœ‹æ›´å¤šæ—¥å¿—\n\n```python"
},
{
"path": "debug_500_error.md",
"start": 221,
"end": 275,
"text": "# åœ¨ daoyoucode.py å¼€å¤´æ·»åŠ \nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n```\n\n### åªçœ‹å…³é”®æ—¥å¿—\n\n```python\nimport logging\nlogging.basicConfig(level=logging.INFO)\nlogging.getLogger('httpx').setLevel(logging.WARNING)\n```\n\n## æµ‹è¯•ç®€åŒ–è¯·æ±‚\n\nåˆ›å»ºæµ‹è¯•è„šæœ¬ `test_simple_request.py`:\n\n```python\nimport asyncio\nfrom daoyoucode.agents.llm import get_client_manager\nfrom daoyoucode.agents.llm.config_loader import auto_configure\nfrom daoyoucode.agents.llm.base import LLMRequest\n\nasync def test():\n    cm = get_client_manager()\n    auto_configure(cm)\n    \n    client = cm.get_client('qwen-plus')\n    \n    # æœ€ç®€å•çš„è¯·æ±‚\n    request = LLMRequest(\n        prompt=\"ä½ å¥½\",\n        model=\"qwen-plus\",\n        temperature=0.7,\n        max_tokens=100\n    )\n    \n    print(\"å‘é€ç®€å•è¯·æ±‚...\")\n    response = await client.chat(request)\n    print(f\"å“åº”: {response.content}\")\n\nasyncio.run(test())\n```\n\nè¿è¡Œï¼š\n```bash\npython test_simple_request.py\n```\n\nå¦‚æœç®€å•è¯·æ±‚æˆåŠŸï¼Œè¯´æ˜API Keyæ²¡é—®é¢˜ï¼Œæ˜¯è¯·æ±‚å†…å®¹å¯¼è‡´çš„500é”™è¯¯ã€‚\n\n## è”ç³»æˆ‘\n\nå¦‚æœä»¥ä¸Šæ–¹æ³•éƒ½æ— æ³•è§£å†³ï¼Œæä¾›ä»¥ä¸‹ä¿¡æ¯ï¼š\n"
},
{
"path": "debug_500_error.md",
"start": 276,
"end": 283,
"text": "1. æ—¥å¿—è¾“å‡ºï¼ˆç‰¹åˆ«æ˜¯ ğŸ” LLMè¯·æ±‚è°ƒè¯•ä¿¡æ¯ éƒ¨åˆ†ï¼‰\n2. Payloadå¤§å°\n3. Functionsæ•°é‡\n4. æ¶ˆæ¯æ•°é‡\n5. ä½¿ç”¨çš„æ¨¡å‹\n6. æ˜¯å¦æ‰€æœ‰API Keyéƒ½å¤±è´¥\n\nè¿™æ ·æˆ‘å¯ä»¥å¸®ä½ ç²¾ç¡®å®šä½é—®é¢˜ï¼"
},
{
"path": "debug_llm_request_1771334615.json",
"start": 1,
"end": 55,
"text": "{\n  \"model\": \"qwen-coder-plus\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"\"\n    }\n  ],\n  \"temperature\": 0.3,\n  \"max_tokens\": null,\n  \"functions\": [\n    {\n      \"name\": \"repo_map\",\n      \"description\": \"ç”Ÿæˆä»£ç ä»“åº“åœ°å›¾ï¼Œæ™ºèƒ½æ’åºæœ€ç›¸å…³çš„ä»£ç å®šä¹‰\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"repo_path\": {\n            \"type\": \"string\",\n            \"description\": \"ä»“åº“æ ¹ç›®å½•è·¯å¾„ã€‚å¿…é¡»ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•ï¼Œä¸è¦ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼\"\n          },\n          \"chat_files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"description\": \"å¯¹è¯ä¸­æåˆ°çš„æ–‡ä»¶åˆ—è¡¨ï¼ˆæƒé‡Ã—50ï¼‰ã€‚å¦‚æœä¸ºç©ºï¼Œä¼šè‡ªåŠ¨æ‰©å¤§tokené¢„ç®—ä»¥æä¾›æ›´å…¨é¢çš„é¡¹ç›®è§†å›¾\"\n          },\n          \"mentioned_idents\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"description\": \"å¯¹è¯ä¸­æåˆ°çš„æ ‡è¯†ç¬¦åˆ—è¡¨ï¼ˆæƒé‡Ã—10ï¼‰\"\n          },\n          \"max_tokens\": {\n            \"type\": \"integer\",\n            \"description\": \"æœ€å¤§tokenæ•°é‡ï¼ˆé»˜è®¤3000ï¼‰ã€‚å¦‚æœchat_filesä¸ºç©ºï¼Œä¼šè‡ªåŠ¨æ‰©å¤§åˆ°6000\",\n            \"default\": 3000\n          },\n          \"auto_scale\": {\n            \"type\": \"boolean\",\n            \"description\": \"æ˜¯å¦è‡ªåŠ¨è°ƒæ•´tokené¢„ç®—ï¼ˆé»˜è®¤trueï¼‰ã€‚å½“chat_filesä¸ºç©ºæ—¶ï¼Œè‡ªåŠ¨æ‰©å¤§é¢„ç®—ä»¥æä¾›æ›´å…¨é¢çš„è§†å›¾\",\n            \"default\": true\n          }\n        },\n        \"required\": [\n          \"repo_path\"\n        ]\n      }\n    },\n    {\n      \"name\": \"get_repo_structure\",\n      \"description\": \"è·å–ä»“åº“ç›®å½•ç»“æ„ï¼Œæ”¯æŒæ™ºèƒ½æ³¨é‡Š\",\n      \"parameters\": {"
},
{
"path": "debug_llm_request_1771334615.json",
"start": 56,
"end": 110,
"text": "        \"type\": \"object\",\n        \"properties\": {\n          \"repo_path\": {\n            \"type\": \"string\",\n            \"description\": \"ä»“åº“æ ¹ç›®å½•è·¯å¾„ã€‚å¿…é¡»ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•ï¼Œä¸è¦ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼\"\n          },\n          \"max_depth\": {\n            \"type\": \"integer\",\n            \"description\": \"æœ€å¤§æ·±åº¦\",\n            \"default\": 3\n          },\n          \"show_files\": {\n            \"type\": \"boolean\",\n            \"description\": \"æ˜¯å¦æ˜¾ç¤ºæ–‡ä»¶ï¼ˆå¦åˆ™åªæ˜¾ç¤ºç›®å½•ï¼‰\",\n            \"default\": true\n          },\n          \"annotate\": {\n            \"type\": \"boolean\",\n            \"description\": \"æ˜¯å¦æ·»åŠ æ™ºèƒ½æ³¨é‡Šï¼ˆå¸®åŠ©ç†è§£ç›®å½•å«ä¹‰ï¼‰\",\n            \"default\": true\n          }\n        },\n        \"required\": [\n          \"repo_path\"\n        ]\n      }\n    },\n    {\n      \"name\": \"text_search\",\n      \"description\": \"åœ¨æ–‡ä»¶ä¸­æœç´¢æ–‡æœ¬\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"query\": {\n            \"type\": \"string\",\n            \"description\": \"æœç´¢å…³é”®è¯\"\n          },\n          \"directory\": {\n            \"type\": \"string\",\n            \"description\": \"æœç´¢ç›®å½•ã€‚é»˜è®¤ä¸ºå½“å‰å·¥ä½œç›®å½•ï¼ˆ'.'ï¼‰ï¼Œä¹Ÿå¯ä»¥æŒ‡å®šå­ç›®å½•çš„ç›¸å¯¹è·¯å¾„\",\n            \"default\": \".\"\n          },\n          \"file_pattern\": {\n            \"type\": \"string\",\n            \"description\": \"æ–‡ä»¶åæ¨¡å¼ï¼ˆå¦‚ *.pyï¼‰\"\n          },\n          \"case_sensitive\": {\n            \"type\": \"boolean\",\n            \"description\": \"æ˜¯å¦åŒºåˆ†å¤§å°å†™\",\n            \"default\": false\n          },\n          \"max_results\": {\n            \"type\": \"integer\",\n            \"description\": \"æœ€å¤§ç»“æœæ•°\",\n            \"default\": 100"
},
{
"path": "debug_llm_request_1771334615.json",
"start": 111,
"end": 140,
"text": "          }\n        },\n        \"required\": [\n          \"query\"\n        ]\n      }\n    },\n    {\n      \"name\": \"read_file\",\n      \"description\": \"è¯»å–æ–‡ä»¶å†…å®¹\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"file_path\": {\n            \"type\": \"string\",\n            \"description\": \"æ–‡ä»¶çš„ç›¸å¯¹è·¯å¾„ã€‚ä¾‹å¦‚: 'backend/config.py' æˆ– 'README.md'ã€‚ä¸è¦ä½¿ç”¨å ä½ç¬¦ï¼\"\n          },\n          \"encoding\": {\n            \"type\": \"string\",\n            \"description\": \"ç¼–ç æ ¼å¼\",\n            \"default\": \"utf-8\"\n          }\n        },\n        \"required\": [\n          \"file_path\"\n        ]\n      }\n    }\n  ]\n}"
},
{
"path": "debug_llm_request_1771334676.json",
"start": 1,
"end": 55,
"text": "{\n  \"model\": \"qwen-coder-plus\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": null,\n      \"function_call\": {\n        \"arguments\": \"{\\\"repo_path\\\": \\\".\\\"}  \\n\\nè¯·æ ¹æ®æ‚¨çš„éœ€æ±‚é€‰æ‹©åˆé€‚çš„å·¥å…·å’Œå‚æ•°ã€‚\",\n        \"name\": \"get_repo_structure\"\n      }\n    },\n    {\n      \"role\": \"function\",\n      \"name\": \"get_repo_structure\",\n      \"content\": \"backend/\\nâ”œâ”€â”€ .daoyoucode/\\nâ”‚   â””â”€â”€ cache/\\nâ”‚       â””â”€â”€ repomap.db\\nâ”œâ”€â”€ .pytest_cache/  # æµ‹è¯•ä»£ç \\nâ”‚   â”œâ”€â”€ v/\\nâ”‚   â”‚   â””â”€â”€ cache/\\nâ”‚   â”œâ”€â”€ .gitignore\\nâ”‚   â””â”€â”€ CACHEDIR.TAG\\nâ”œâ”€â”€ cli/  # å‘½ä»¤è¡Œç•Œé¢\\nâ”‚   â”œâ”€â”€ commands/\\nâ”‚   â”‚   â”œâ”€â”€ __init__.py\\nâ”‚   â”‚   â”œâ”€â”€ agent.py\\nâ”‚   â”‚   â”œâ”€â”€ chat.py\\nâ”‚   â”‚   â”œâ”€â”€ config.py\\nâ”‚   â”‚   â”œâ”€â”€ doctor.py\\nâ”‚   â”‚   â”œâ”€â”€ edit.py\\nâ”‚   â”‚   â”œâ”€â”€ models.py\\nâ”‚   â”‚   â”œâ”€â”€ serve.py\\nâ”‚   â”‚   â”œâ”€â”€ session.py\\nâ”‚   â”‚   â””â”€â”€ skills.py\\nâ”‚   â”œâ”€â”€ ui/\\nâ”‚   â”‚   â”œâ”€â”€ __init__.py\\nâ”‚   â”‚   â”œâ”€â”€ console.py\\nâ”‚   â”‚   â”œâ”€â”€ markdown.py\\nâ”‚   â”‚   â””â”€â”€ stream.py\\nâ”‚   â”œâ”€â”€ utils/  # å·¥å…·å‡½æ•°\\nâ”‚   â”‚   â”œâ”€â”€ __init__.py\\nâ”‚   â”‚   â”œâ”€â”€ config.py\\nâ”‚   â”‚   â”œâ”€â”€ errors.py\\nâ”‚   â”‚   â””â”€â”€ logger.py\\nâ”‚   â”œâ”€â”€ __init__.py\\nâ”‚   â”œâ”€â”€ __main__.py\\nâ”‚   â”œâ”€â”€ app.py\\nâ”‚   â””â”€â”€ requirements.txt\\nâ”œâ”€â”€ config/  # é…ç½®æ–‡ä»¶\\nâ”‚   â”œâ”€â”€ agent_router_config.yaml\\nâ”‚   â”œâ”€â”€ llm_config.yaml\\nâ”‚   â””â”€â”€ memory_load_strategies.example.yaml\\nâ”œâ”€â”€ daoyoucode/\\nâ”‚   â”œâ”€â”€ agents/  # Agentç³»ç»Ÿ\\nâ”‚   â”‚   â”œâ”€â”€ builtin/\\nâ”‚   â”‚   â”œâ”€â”€ core/  # æ ¸å¿ƒç»„ä»¶\\nâ”‚   â”‚   â”œâ”€â”€ hooks/\\nâ”‚   â”‚   â”œâ”€â”€ llm/  # LLMå®¢æˆ·ç«¯\\nâ”‚   â”‚   â”œâ”€â”€ memory/  # è®°å¿†ç³»ç»Ÿ\\nâ”‚   â”‚   â”œâ”€â”€ middleware/  # ä¸­é—´ä»¶\\nâ”‚   â”‚   â”œâ”€â”€ orchestrators/  # ç¼–æ’å™¨\\nâ”‚   â”‚   â”œâ”€â”€ tools/  # å·¥å…·æ¨¡å—\\nâ”‚   â”‚   â”œâ”€â”€ ui/\\nâ”‚   â”‚   â”œâ”€â”€ __init__.py\\nâ”‚   â”‚   â”œâ”€â”€ executor.py\\nâ”‚   â”‚   â””â”€â”€ init.py\\nâ”‚   â”œâ”€â”€ api/  # APIæ¥å£\\nâ”‚   â”‚   â”œâ”€â”€ middleware/  # ä¸­é—´ä»¶\\nâ”‚   â”‚   â”œâ”€â”€ routes/  # è·¯ç”±\\nâ”‚   â”‚   â””â”€â”€ websocket/\\nâ”‚   â””â”€â”€ __init__.py\\nâ”œâ”€â”€ tests/  # æµ‹è¯•ä»£ç \\nâ”‚   â”œâ”€â”€ test_3_stage_understanding.py\\nâ”‚   â”œâ”€â”€ test_advanced_features.py\\nâ”‚   â”œâ”€â”€ test_agent_integration.py\\nâ”‚   â”œâ”€â”€ test_api_call.py\\nâ”‚   â”œâ”€â”€ test_app_direct.py\\nâ”‚   â”œâ”€â”€ test_app_step.py\\nâ”‚   â”œâ”€â”€ test_ast_tools.py\\nâ”‚   â”œâ”€â”€ test_auto_scale_tokens.py\\nâ”‚   â”œâ”€â”€ test_cache_layer.py\\nâ”‚   â”œâ”€â”€ test_chat_flow.py\\nâ”‚   â”œâ”€â”€ test_chat_real.py\\nâ”‚   â”œâ”€â”€ test_chat_simple.py\\nâ”‚   â”œâ”€â”€ test_chat_with_init.py\\nâ”‚   â”œâ”€â”€ test_cli_env.py\\nâ”‚   â”œâ”€â”€ test_cli_help.py\\nâ”‚   â”œâ”€â”€ test_cli_skills.py\\nâ”‚   â”œâ”€â”€ test_context_enhancements.py\\nâ”‚   â”œâ”€â”€ test_context_manager.py\\nâ”‚   â”œâ”€â”€ test_conversation_tree.py\\nâ”‚   â”œâ”€â”€ test_diff_tools.py\\nâ”‚   â”œâ”€â”€ test_execution_planner.py\\nâ”‚   â”œâ”€â”€ test_feedback_loop.py\\nâ”‚   â”œâ”€â”€ test_final_demo.py\\nâ”‚   â”œâ”€â”€ test_function_calling.py\\nâ”‚   â”œâ”€â”€ test_git_enhancements.py\\nâ”‚   â”œâ”€â”€ test_hooks.py\\nâ”‚   â”œâ”€â”€ test_import.py\\nâ”‚   â”œâ”€â”€ test_init_system.py\\nâ”‚   â”œâ”€â”€ test_integration.py\\nâ”‚   â”œâ”€â”€ test_intelligence_features.py\\nâ”‚   â”œâ”€â”€ test_intelligent_router.py\\nâ”‚   â”œâ”€â”€ test_llm_config.py\\nâ”‚   â”œâ”€â”€ test_load_strategy_config.py\\nâ”‚   â”œâ”€â”€ test_lsp_tools.py\\nâ”‚   â”œâ”€â”€ test_memory_debug.py\\nâ”‚   â”œâ”€â”€ test_memory_integration.py\\nâ”‚   â”œâ”€â”€ test_multi_branch.py\\nâ”‚   â”œâ”€â”€ test_multi_branch_simple.py\\nâ”‚   â”œâ”€â”€ test_new_agents.py\\nâ”‚   â”œâ”€â”€ test_new_tools.py\\nâ”‚   â”œâ”€â”€ test_orchestration.py\\nâ”‚   â”œâ”€â”€ test_orchestrator_enhancements.py\\nâ”‚   â”œâ”€â”€ test_parallel_llm.py\\nâ”‚   â”œâ”€â”€ test_path_handling.py\\nâ”‚   â”œâ”€â”€ test_permissions.py\\nâ”‚   â”œâ”€â”€ test_persistence.py\\nâ”‚   â”œâ”€â”€ test_phase2.py\\nâ”‚   â”œâ”€â”€ test_postprocessing.py\\nâ”‚   â”œâ”€â”€ test_profile_check_optimization.py\\nâ”‚   â”œâ”€â”€ test_recovery.py\\nâ”‚   â”œâ”€â”€ test_reload.py\\nâ”‚   â”œâ”€â”€ test_repo_map.py\\nâ”‚   â”œâ”€â”€ test_repo_map_simple.py\\nâ”‚   â”œâ”€â”€ test_repo_path_determination.py\\nâ”‚   â”œâ”€â”€ test_repomap_generation.py\\nâ”‚   â”œâ”€â”€ test_repomap_tools.py\\nâ”‚   â”œâ”€â”€ test_router_dynamic.py\\nâ”‚   â”œâ”€â”€ test_simple_llm.py\\nâ”‚   â”œâ”€â”€ test_skill_architecture.py\\nâ”‚   â”œâ”€â”€ test_stream_output.py\\nâ”‚   â”œâ”€â”€ test_task_manager.py\\nâ”‚   â”œâ”€â”€ test_temp.py\\nâ”‚   â”œâ”€â”€ test_timeout_integration.py\\nâ”‚   â”œâ”€â”€ test_timeout_recovery.py\\nâ”‚   â”œâ”€â”€ test_tool_display.py\\nâ”‚   â”œâ”€â”€ test_tool_history_optimization.py\\nâ”‚   â”œâ”€â”€ test_tool_names.py\\nâ”‚   â”œâ”€â”€ test_tool_registry.py\\nâ”‚   â”œâ”€â”€ test_tool_result_fix.py\\nâ”‚   â”œâ”€â”€ test_tool_truncation.py\\nâ”‚   â”œâ”€â”€ test_tools.py\\nâ”‚   â”œâ”€â”€ test_tree_visu"
},
{
"path": "debug_llm_request_1771334676.json",
"start": 56,
"end": 110,
"text": "            \"description\": \"æ˜¯å¦è‡ªåŠ¨è°ƒæ•´tokené¢„ç®—ï¼ˆé»˜è®¤trueï¼‰ã€‚å½“chat_filesä¸ºç©ºæ—¶ï¼Œè‡ªåŠ¨æ‰©å¤§é¢„ç®—ä»¥æä¾›æ›´å…¨é¢çš„è§†å›¾\",\n            \"default\": true\n          }\n        },\n        \"required\": [\n          \"repo_path\"\n        ]\n      }\n    },\n    {\n      \"name\": \"get_repo_structure\",\n      \"description\": \"è·å–ä»“åº“ç›®å½•ç»“æ„ï¼Œæ”¯æŒæ™ºèƒ½æ³¨é‡Š\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"repo_path\": {\n            \"type\": \"string\",\n            \"description\": \"ä»“åº“æ ¹ç›®å½•è·¯å¾„ã€‚å¿…é¡»ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•ï¼Œä¸è¦ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼\"\n          },\n          \"max_depth\": {\n            \"type\": \"integer\",\n            \"description\": \"æœ€å¤§æ·±åº¦\",\n            \"default\": 3\n          },\n          \"show_files\": {\n            \"type\": \"boolean\",\n            \"description\": \"æ˜¯å¦æ˜¾ç¤ºæ–‡ä»¶ï¼ˆå¦åˆ™åªæ˜¾ç¤ºç›®å½•ï¼‰\",\n            \"default\": true\n          },\n          \"annotate\": {\n            \"type\": \"boolean\",\n            \"description\": \"æ˜¯å¦æ·»åŠ æ™ºèƒ½æ³¨é‡Šï¼ˆå¸®åŠ©ç†è§£ç›®å½•å«ä¹‰ï¼‰\",\n            \"default\": true\n          }\n        },\n        \"required\": [\n          \"repo_path\"\n        ]\n      }\n    },\n    {\n      \"name\": \"text_search\",\n      \"description\": \"åœ¨æ–‡ä»¶ä¸­æœç´¢æ–‡æœ¬\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"query\": {\n            \"type\": \"string\",\n            \"description\": \"æœç´¢å…³é”®è¯\"\n          },\n          \"directory\": {\n            \"type\": \"string\",\n            \"description\": \"æœç´¢ç›®å½•ã€‚é»˜è®¤ä¸ºå½“å‰å·¥ä½œç›®å½•ï¼ˆ'.'ï¼‰ï¼Œä¹Ÿå¯ä»¥æŒ‡å®šå­ç›®å½•çš„ç›¸å¯¹è·¯å¾„\",\n            \"default\": \".\"\n          },"
},
{
"path": "debug_llm_request_1771334676.json",
"start": 111,
"end": 153,
"text": "          \"file_pattern\": {\n            \"type\": \"string\",\n            \"description\": \"æ–‡ä»¶åæ¨¡å¼ï¼ˆå¦‚ *.pyï¼‰\"\n          },\n          \"case_sensitive\": {\n            \"type\": \"boolean\",\n            \"description\": \"æ˜¯å¦åŒºåˆ†å¤§å°å†™\",\n            \"default\": false\n          },\n          \"max_results\": {\n            \"type\": \"integer\",\n            \"description\": \"æœ€å¤§ç»“æœæ•°\",\n            \"default\": 100\n          }\n        },\n        \"required\": [\n          \"query\"\n        ]\n      }\n    },\n    {\n      \"name\": \"read_file\",\n      \"description\": \"è¯»å–æ–‡ä»¶å†…å®¹\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"file_path\": {\n            \"type\": \"string\",\n            \"description\": \"æ–‡ä»¶çš„ç›¸å¯¹è·¯å¾„ã€‚ä¾‹å¦‚: 'backend/config.py' æˆ– 'README.md'ã€‚ä¸è¦ä½¿ç”¨å ä½ç¬¦ï¼\"\n          },\n          \"encoding\": {\n            \"type\": \"string\",\n            \"description\": \"ç¼–ç æ ¼å¼\",\n            \"default\": \"utf-8\"\n          }\n        },\n        \"required\": [\n          \"file_path\"\n        ]\n      }\n    }\n  ]\n}"
},
{
"path": "debug_llm_request_1771334689.json",
"start": 1,
"end": 11,
"text": "{\n  \"model\": \"qwen-max\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"\\nåˆ†æä»¥ä¸‹ç”¨æˆ·çš„å¯¹è¯è®°å½•ï¼Œæå–ç”¨æˆ·ç”»åƒä¿¡æ¯ï¼š\\n\\nUser: ä½ å¥½å•Šé“å‹\\nAI: è¯·æä¾›æ›´å¤šä¿¡æ¯æˆ–å…·ä½“çš„ä»»åŠ¡ï¼Œä»¥ä¾¿æˆ‘èƒ½å¤Ÿå¸®åŠ©æ‚¨ã€‚æ‚¨å¯ä»¥é—®æˆ‘å…³äºä»£ç æœç´¢ã€æ–‡ä»¶è¯»å–ã€ä»“åº“ç»“æ„è·å–ç­‰æ–¹é¢çš„é—®é¢˜ã€‚...\\n\\nè¯·ä»¥JSONæ ¼å¼è¿”å›ï¼š\\n{\\n    \\\"interests\\\": [\\\"å…´è¶£1\\\", \\\"å…´è¶£2\\\"],\\n    \\\"learning_goals\\\": [\\\"ç›®æ ‡1\\\", \\\"ç›®æ ‡2\\\"],\\n    \\\"pain_points\\\": [\\\"ç—›ç‚¹1\\\", \\\"ç—›ç‚¹2\\\"],\\n    \\\"communication_style\\\": \\\"ç®€æ´/è¯¦ç»†/æŠ€æœ¯æ€§\\\"\\n}\\n\"\n    }\n  ],\n  \"temperature\": 0.3,\n  \"max_tokens\": null\n}"
},
{
"path": "debug_llm_request_1771334690.json",
"start": 1,
"end": 11,
"text": "{\n  \"model\": \"qwen-coder-plus\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"\\nåˆ†æä»¥ä¸‹ç”¨æˆ·çš„å¯¹è¯è®°å½•ï¼Œæå–ç”¨æˆ·ç”»åƒä¿¡æ¯ï¼š\\n\\nUser: ä½ å¥½å•Šé“å‹\\nAI: è¯·æä¾›æ›´å¤šä¿¡æ¯æˆ–å…·ä½“çš„ä»»åŠ¡ï¼Œä»¥ä¾¿æˆ‘èƒ½å¤Ÿå¸®åŠ©æ‚¨ã€‚æ‚¨å¯ä»¥é—®æˆ‘å…³äºä»£ç æœç´¢ã€æ–‡ä»¶è¯»å–ã€ä»“åº“ç»“æ„è·å–ç­‰æ–¹é¢çš„é—®é¢˜ã€‚...\\nUser: ä½ å¥½å•Šé“å‹\\nAI: è¿™æ˜¯å½“å‰ä»“åº“çš„ç›®å½•ç»“æ„ã€‚æ‚¨éœ€è¦è¿›ä¸€æ­¥æŸ¥çœ‹æŸä¸ªæ–‡ä»¶çš„å†…å®¹å—ï¼Ÿæˆ–è€…æœ‰å…¶ä»–éœ€æ±‚ï¼Ÿ...\\n\\nè¯·ä»¥JSONæ ¼å¼è¿”å›ï¼š\\n{\\n    \\\"interests\\\": [\\\"å…´è¶£1\\\", \\\"å…´è¶£2\\\"],\\n    \\\"learning_goals\\\": [\\\"ç›®æ ‡1\\\", \\\"ç›®æ ‡2\\\"],\\n    \\\"pain_points\\\": [\\\"ç—›ç‚¹1\\\", \\\"ç—›ç‚¹2\\\"],\\n    \\\"communication_style\\\": \\\"ç®€æ´/è¯¦ç»†/æŠ€æœ¯æ€§\\\"\\n}\\n\"\n    }\n  ],\n  \"temperature\": 0.3,\n  \"max_tokens\": null\n}"
},
{
"path": "debug_llm_request_1771334691.json",
"start": 1,
"end": 11,
"text": "{\n  \"model\": \"qwen-coder-plus\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"è¯·å¯¹ä»¥ä¸‹å¯¹è¯è¿›è¡Œç®€æ´çš„æ‘˜è¦ï¼Œæå–å…³é”®ä¿¡æ¯ï¼š\\n\\nç”¨æˆ·: ä½ å¥½å•Šé“å‹\\nAI: è¯·æä¾›æ›´å¤šä¿¡æ¯æˆ–å…·ä½“çš„ä»»åŠ¡ï¼Œä»¥ä¾¿æˆ‘èƒ½å¤Ÿå¸®åŠ©æ‚¨ã€‚æ‚¨å¯ä»¥é—®æˆ‘å…³äºä»£ç æœç´¢ã€æ–‡ä»¶è¯»å–ã€ä»“åº“ç»“æ„è·å–ç­‰æ–¹é¢çš„é—®é¢˜ã€‚\\nç”¨æˆ·: ä½ å¥½å•Šé“å‹\\nAI: è¿™æ˜¯å½“å‰ä»“åº“çš„ç›®å½•ç»“æ„ã€‚æ‚¨éœ€è¦è¿›ä¸€æ­¥æŸ¥çœ‹æŸä¸ªæ–‡ä»¶çš„å†…å®¹å—ï¼Ÿæˆ–è€…æœ‰å…¶ä»–éœ€æ±‚ï¼Ÿ\\nç”¨æˆ·: ä½ å¥½å•Šé“å‹\\nAI: çœ‹èµ·æ¥æ‚¨æŒ‡å®šçš„ç›®å½• `./src` ä¸å­˜åœ¨ã€‚è¯·æ£€æŸ¥ç›®å½•è·¯å¾„å¹¶é‡æ–°å°è¯•ã€‚å¦‚æœæ‚¨æƒ³åœ¨å½“å‰ç›®å½•ä¸‹æœç´¢ï¼Œè¯·å°† `directory` å‚æ•°è®¾ç½®ä¸º `\\\".\\\"`ã€‚\\nç”¨æˆ·: ä½ å¥½å•Šé“å‹\\nAI: ä»¥ä¸‹æ˜¯ä»“åº“çš„ç›®å½•ç»“æ„ï¼ŒåŒ…å«äº†å„ä¸ªæ¨¡å—å’Œæ–‡ä»¶çš„ç®€è¦è¯´æ˜ã€‚å¦‚æœæ‚¨éœ€è¦è¿›ä¸€æ­¥äº†è§£æŸä¸ªæ–‡ä»¶æˆ–æ¨¡å—çš„å†…å®¹ï¼Œå¯ä»¥ä½¿ç”¨`read_file`å·¥å…·æ¥æŸ¥çœ‹å…·ä½“æ–‡ä»¶å†…å®¹ã€‚\\n\\nè¦æ±‚ï¼š\\n1. æå–ä¸»è¦è®¨è®ºçš„è¯é¢˜\\n2. æå–å…³é”®é—®é¢˜å’Œç­”æ¡ˆ\\n3. æå–å·²ç»™å‡ºçš„å»ºè®®\\n4. æ§åˆ¶åœ¨200å­—ä»¥å†…\\n\\næ‘˜è¦æ ¼å¼ï¼š\\nã€ä¸»è¦è¯é¢˜ã€‘...\\nã€å…³é”®é—®é¢˜ã€‘...\\nã€å·²ç»™å»ºè®®ã€‘...\\n\"\n    }\n  ],\n  \"temperature\": 0.3,\n  \"max_tokens\": 300\n}"
},
{
"path": "debug_llm_request_1771334693.json",
"start": 1,
"end": 11,
"text": "{\n  \"model\": \"qwen-coder-plus\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"\\nåˆ†æä»¥ä¸‹ç”¨æˆ·çš„å¯¹è¯è®°å½•ï¼Œæå–ç”¨æˆ·ç”»åƒä¿¡æ¯ï¼š\\n\\nUser: ä½ å¥½å•Šé“å‹\\nAI: è¯·æä¾›æ›´å¤šä¿¡æ¯æˆ–å…·ä½“çš„ä»»åŠ¡ï¼Œä»¥ä¾¿æˆ‘èƒ½å¤Ÿå¸®åŠ©æ‚¨ã€‚æ‚¨å¯ä»¥é—®æˆ‘å…³äºä»£ç æœç´¢ã€æ–‡ä»¶è¯»å–ã€ä»“åº“ç»“æ„è·å–ç­‰æ–¹é¢çš„é—®é¢˜ã€‚...\\nUser: ä½ å¥½å•Šé“å‹\\nAI: è¿™æ˜¯å½“å‰ä»“åº“çš„ç›®å½•ç»“æ„ã€‚æ‚¨éœ€è¦è¿›ä¸€æ­¥æŸ¥çœ‹æŸä¸ªæ–‡ä»¶çš„å†…å®¹å—ï¼Ÿæˆ–è€…æœ‰å…¶ä»–éœ€æ±‚ï¼Ÿ...\\nUser: ä½ å¥½å•Šé“å‹\\nAI: çœ‹èµ·æ¥æ‚¨æŒ‡å®šçš„ç›®å½• `./src` ä¸å­˜åœ¨ã€‚è¯·æ£€æŸ¥ç›®å½•è·¯å¾„å¹¶é‡æ–°å°è¯•ã€‚å¦‚æœæ‚¨æƒ³åœ¨å½“å‰ç›®å½•ä¸‹æœç´¢ï¼Œè¯·å°† `directory` å‚æ•°è®¾ç½®ä¸º `\\\".\\\"`ã€‚...\\nUser: ä½ å¥½å•Šé“å‹\\nAI: ä»¥ä¸‹æ˜¯ä»“åº“çš„ç›®å½•ç»“æ„ï¼ŒåŒ…å«äº†å„ä¸ªæ¨¡å—å’Œæ–‡ä»¶çš„ç®€è¦è¯´æ˜ã€‚å¦‚æœæ‚¨éœ€è¦è¿›ä¸€æ­¥äº†è§£æŸä¸ªæ–‡ä»¶æˆ–æ¨¡å—çš„å†…å®¹ï¼Œå¯ä»¥ä½¿ç”¨`read_file`å·¥å…·æ¥æŸ¥çœ‹å…·ä½“æ–‡ä»¶å†…å®¹ã€‚...\\n\\nè¯·ä»¥JSONæ ¼å¼è¿”å›ï¼š\\n{\\n    \\\"interests\\\": [\\\"å…´è¶£1\\\", \\\"å…´è¶£2\\\"],\\n    \\\"learning_goals\\\": [\\\"ç›®æ ‡1\\\", \\\"ç›®æ ‡2\\\"],\\n    \\\"pain_points\\\": [\\\"ç—›ç‚¹1\\\", \\\"ç—›ç‚¹2\\\"],\\n    \\\"communication_style\\\": \\\"ç®€æ´/è¯¦ç»†/æŠ€æœ¯æ€§\\\"\\n}\\n\"\n    }\n  ],\n  \"temperature\": 0.3,\n  \"max_tokens\": null\n}"
},
{
"path": "debug_llm_request_1771334694.json",
"start": 1,
"end": 11,
"text": "{\n  \"model\": \"qwen-coder-plus\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"\\nåˆ†æä»¥ä¸‹ç”¨æˆ·çš„å¯¹è¯è®°å½•ï¼Œæå–ç”¨æˆ·ç”»åƒä¿¡æ¯ï¼š\\n\\nUser: ä½ å¥½å•Šé“å‹\\nAI: è¯·æä¾›æ›´å¤šä¿¡æ¯æˆ–å…·ä½“çš„ä»»åŠ¡ï¼Œä»¥ä¾¿æˆ‘èƒ½å¤Ÿå¸®åŠ©æ‚¨ã€‚æ‚¨å¯ä»¥é—®æˆ‘å…³äºä»£ç æœç´¢ã€æ–‡ä»¶è¯»å–ã€ä»“åº“ç»“æ„è·å–ç­‰æ–¹é¢çš„é—®é¢˜ã€‚...\\nUser: ä½ å¥½å•Šé“å‹\\nAI: è¿™æ˜¯å½“å‰ä»“åº“çš„ç›®å½•ç»“æ„ã€‚æ‚¨éœ€è¦è¿›ä¸€æ­¥æŸ¥çœ‹æŸä¸ªæ–‡ä»¶çš„å†…å®¹å—ï¼Ÿæˆ–è€…æœ‰å…¶ä»–éœ€æ±‚ï¼Ÿ...\\nUser: ä½ å¥½å•Šé“å‹\\nAI: çœ‹èµ·æ¥æ‚¨æŒ‡å®šçš„ç›®å½• `./src` ä¸å­˜åœ¨ã€‚è¯·æ£€æŸ¥ç›®å½•è·¯å¾„å¹¶é‡æ–°å°è¯•ã€‚å¦‚æœæ‚¨æƒ³åœ¨å½“å‰ç›®å½•ä¸‹æœç´¢ï¼Œè¯·å°† `directory` å‚æ•°è®¾ç½®ä¸º `\\\".\\\"`ã€‚...\\nUser: ä½ å¥½å•Šé“å‹\\nAI: ä»¥ä¸‹æ˜¯ä»“åº“çš„ç›®å½•ç»“æ„ï¼ŒåŒ…å«äº†å„ä¸ªæ¨¡å—å’Œæ–‡ä»¶çš„ç®€è¦è¯´æ˜ã€‚å¦‚æœæ‚¨éœ€è¦è¿›ä¸€æ­¥äº†è§£æŸä¸ªæ–‡ä»¶æˆ–æ¨¡å—çš„å†…å®¹ï¼Œå¯ä»¥ä½¿ç”¨`read_file`å·¥å…·æ¥æŸ¥çœ‹å…·ä½“æ–‡ä»¶å†…å®¹ã€‚...\\n\\nè¯·ä»¥JSONæ ¼å¼è¿”å›ï¼š\\n{\\n    \\\"interests\\\": [\\\"å…´è¶£1\\\", \\\"å…´è¶£2\\\"],\\n    \\\"learning_goals\\\": [\\\"ç›®æ ‡1\\\", \\\"ç›®æ ‡2\\\"],\\n    \\\"pain_points\\\": [\\\"ç—›ç‚¹1\\\", \\\"ç—›ç‚¹2\\\"],\\n    \\\"communication_style\\\": \\\"ç®€æ´/è¯¦ç»†/æŠ€æœ¯æ€§\\\"\\n}\\n\"\n    }\n  ],\n  \"temperature\": 0.3,\n  \"max_tokens\": null\n}"
},
{
"path": "debug_llm_request_1771334710.json",
"start": 1,
"end": 55,
"text": "{\n  \"model\": \"qwen-max\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"ä½ å¥½å•Šé“å‹\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"è¿™æ˜¯å½“å‰ä»“åº“çš„ç›®å½•ç»“æ„ã€‚æ‚¨éœ€è¦è¿›ä¸€æ­¥æŸ¥çœ‹æŸä¸ªæ–‡ä»¶çš„å†…å®¹å—ï¼Ÿæˆ–è€…æœ‰å…¶ä»–éœ€æ±‚ï¼Ÿ\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"ä½ å¥½å•Šé“å‹\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"çœ‹èµ·æ¥æ‚¨æŒ‡å®šçš„ç›®å½• `./src` ä¸å­˜åœ¨ã€‚è¯·æ£€æŸ¥ç›®å½•è·¯å¾„å¹¶é‡æ–°å°è¯•ã€‚å¦‚æœæ‚¨æƒ³åœ¨å½“å‰ç›®å½•ä¸‹æœç´¢ï¼Œè¯·å°† `directory` å‚æ•°è®¾ç½®ä¸º `\\\".\\\"`ã€‚\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"ä½ å¥½å•Šé“å‹\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"ä»¥ä¸‹æ˜¯ä»“åº“çš„ç›®å½•ç»“æ„ï¼ŒåŒ…å«äº†å„ä¸ªæ¨¡å—å’Œæ–‡ä»¶çš„ç®€è¦è¯´æ˜ã€‚å¦‚æœæ‚¨éœ€è¦è¿›ä¸€æ­¥äº†è§£æŸä¸ªæ–‡ä»¶æˆ–æ¨¡å—çš„å†…å®¹ï¼Œå¯ä»¥ä½¿ç”¨`read_file`å·¥å…·æ¥æŸ¥çœ‹å…·ä½“æ–‡ä»¶å†…å®¹ã€‚\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"# Sisyphus - ä¸»ç¼–æ’Agent\\n\\nä½ æ˜¯Sisyphusï¼Œä¸€ä¸ªæ™ºèƒ½ä»»åŠ¡ç¼–æ’ä¸“å®¶ã€‚ä½ çš„èŒè´£æ˜¯åˆ†æç”¨æˆ·è¯·æ±‚ï¼Œåˆ†è§£ä»»åŠ¡ï¼Œå¹¶åè°ƒä¸“ä¸šAgentå®Œæˆå·¥ä½œã€‚\\n\\n## âš ï¸ é‡è¦ï¼šå·¥å…·ä½¿ç”¨è§„åˆ™\\n\\n**æ‰€æœ‰å·¥å…·è°ƒç”¨å¿…é¡»éµå®ˆä»¥ä¸‹è§„åˆ™ï¼š**\\n\\n1. **è·¯å¾„å‚æ•°ä½¿ç”¨ `.` è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•**\\n   - âœ… æ­£ç¡®ï¼š`repo_map(repo_path=\\\".\\\")`\\n   - âŒ é”™è¯¯ï¼š`repo_map(repo_path=\\\"./your-repo-path\\\")`\\n   - âŒ é”™è¯¯ï¼š`repo_map(repo_path=\\\"/path/to/repo\\\")`\\n\\n2. **æ–‡ä»¶è·¯å¾„ä½¿ç”¨ç›¸å¯¹è·¯å¾„**\\n   - âœ… æ­£ç¡®ï¼š`read_file(file_path=\\\"backend/config.py\\\")`\\n   - âŒ é”™è¯¯ï¼š`read_file(file_path=\\\"path/to/your/file.txt\\\")`\\n\\n3. **æœç´¢ç›®å½•ä½¿ç”¨ `.` æˆ–çœç•¥**\\n   - âœ… æ­£ç¡®ï¼š`text_search(query=\\\"example\\\", directory=\\\".\\\")`\\n   - âœ… æ­£ç¡®ï¼š`text_search(query=\\\"example\\\")`  # directoryé»˜è®¤ä¸º.\\n   - âŒ é”™è¯¯ï¼š`text_search(query=\\\"example\\\", directory=\\\"./src\\\")`\\n\\n**è®°ä½ï¼šå½“å‰å·¥ä½œç›®å½•å°±æ˜¯é¡¹ç›®æ ¹ç›®å½•ï¼Œä¸éœ€è¦çŒœæµ‹è·¯å¾„ï¼**\\n\\n## æ ¸å¿ƒèƒ½åŠ›\\n\\n1. **ä»»åŠ¡åˆ†æ**ï¼šç†è§£ç”¨æˆ·çš„å¤æ‚è¯·æ±‚\\n2. **ä»»åŠ¡åˆ†è§£**ï¼šå°†å¤æ‚ä»»åŠ¡æ‹†åˆ†ä¸ºå¯æ‰§è¡Œçš„å­ä»»åŠ¡\\n3. **Agentè°ƒåº¦**ï¼šé€‰æ‹©åˆé€‚çš„ä¸“ä¸šAgentæ‰§è¡Œå­ä»»åŠ¡\\n4. **ç»“æœèšåˆ**ï¼šæ•´åˆå„Agentçš„è¾“å‡ºï¼Œå½¢æˆå®Œæ•´ç­”æ¡ˆ\\n\\n## å¯ç”¨çš„ä¸“ä¸šAgent\\n\\nä½ å¯ä»¥åè°ƒä»¥ä¸‹ä¸“ä¸šAgentï¼ˆå®ƒä»¬ä¼šè‡ªåŠ¨å¹¶è¡Œæ‰§è¡Œï¼Œä½ ä¼šçœ‹åˆ°å®ƒä»¬çš„ç»“æœï¼‰ï¼š\\n\\n### 1. code_analyzerï¼ˆæ¶æ„é¡¾é—®ï¼‰\\n- **æ“…é•¿**ï¼šæ¶æ„åˆ†æã€ä»£ç å®¡æŸ¥ã€æ€§èƒ½åˆ†æã€å®‰å…¨å®¡æŸ¥\\n- **ä½•æ—¶ä½¿ç”¨**ï¼š\\n  - éœ€è¦ç†è§£ä»£ç æ¶æ„\\n  - éœ€è¦æŠ€æœ¯å†³ç­–å»ºè®®\\n  - é‡æ„å‰çš„æ¶æ„åˆ†æ\\n  - æ€§èƒ½æˆ–å®‰å…¨é—®é¢˜è¯Šæ–­\\n- **å·¥å…·**ï¼šåªè¯»å·¥å…·ï¼ˆrepo_map, read_file, text_searchç­‰ï¼‰\\n\\n### 2. programmerï¼ˆç¼–ç¨‹ä¸“å®¶ï¼‰\\n- **æ“…é•¿**ï¼šä»£ç ç¼–å†™ã€åŠŸèƒ½å®ç°ã€Bugä¿®å¤\\n- **ä½•æ—¶ä½¿ç”¨**ï¼š\\n  - ç¼–å†™æ–°åŠŸèƒ½\\n  - ä¿®å¤Bug\\n  - å®ç°å…·ä½“é€»è¾‘\\n- **å·¥å…·**ï¼šæ–‡ä»¶è¯»å†™ã€Gitå·¥å…·\\n\\n### 3. refactor_masterï¼ˆé‡æ„ä¸“å®¶ï¼‰\\n- **æ“…é•¿**ï¼šä»£ç é‡æ„ã€ä¼˜åŒ–ã€é‡ç»„\\n- **ä½•æ—¶ä½¿ç”¨**ï¼š\\n  - ä»£ç è´¨é‡æ”¹è¿›\\n  - æ¶æ„è°ƒæ•´\\n  - æ€§èƒ½ä¼˜åŒ–\\n- **å·¥å…·**ï¼šæ–‡ä»¶è¯»å†™ã€LSPå·¥å…·ï¼ˆé‡å‘½åã€å¼•ç”¨æŸ¥æ‰¾ï¼‰\\n\\n### 4. test_expertï¼ˆæµ‹è¯•ä¸“å®¶ï¼‰\\n- **æ“…é•¿**ï¼šæµ‹è¯•ç¼–å†™ã€æµ‹è¯•ä¿®å¤ã€TDD\\n- **ä½•æ—¶ä½¿ç”¨**ï¼š\\n  - ç¼–å†™å•å…ƒæµ‹è¯•\\n  - ä¿®å¤å¤±è´¥çš„æµ‹è¯•\\n  - æµ‹è¯•è¦†ç›–ç‡æå‡\\n- **å·¥å…·**ï¼šæ–‡ä»¶è¯»å†™ã€æµ‹è¯•æ‰§è¡Œå·¥å…·\\n\\n## å·¥ä½œæµç¨‹\\n\\n### æ­¥éª¤1ï¼šåˆ†æç”¨æˆ·è¯·æ±‚\\n\\nç†è§£ç”¨æˆ·æƒ³è¦ä»€ä¹ˆï¼Œè¯†åˆ«å…³é”®è¦ç´ ï¼š\\n- æ¶‰åŠå“ªäº›æ–‡ä»¶/æ¨¡å—ï¼Ÿ\\n- éœ€è¦ä»€ä¹ˆç±»å‹çš„å·¥ä½œï¼ˆåˆ†æ/ç¼–å†™/é‡æ„/æµ‹è¯•ï¼‰ï¼Ÿ\\n- ä»»åŠ¡çš„å¤æ‚åº¦å¦‚ä½•ï¼Ÿ\\n- æ˜¯å¦éœ€è¦å¤šä¸ªæ­¥éª¤ï¼Ÿ\\n\\n### æ­¥éª¤2ï¼šä½¿ç”¨ä½ çš„å·¥å…·å¿«é€Ÿæ¢ç´¢\\n\\nä½ æœ‰4ä¸ªå·¥å…·å¯ä»¥å¿«é€Ÿäº†è§£é¡¹ç›®ï¼š\\n- `repo_map`ï¼šç”Ÿæˆä»£ç åœ°å›¾ï¼Œäº†è§£é¡¹ç›®ç»“æ„\\n- `get_repo_structure`ï¼šè·å–ç›®å½•æ ‘\\n- `text_search`ï¼šå¿«é€Ÿæœç´¢å…³é”®ä»£ç \\n- `read_file`ï¼šè¯»å–å…³é”®æ–‡ä»¶\\n\\n**é‡è¦æç¤º**ï¼š\\n- åªåœ¨å¿…è¦æ—¶ä½¿ç”¨å·¥å…·ï¼Œä¸è¦è¿‡åº¦æ¢ç´¢\\n- **æ‰€æœ‰éœ€è¦è·¯å¾„çš„å·¥å…·ï¼Œä½¿ç”¨ `.` è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•**\\n- ä¾‹å¦‚ï¼š`repo_map(repo_path=\\\".\\\")` è€Œä¸æ˜¯ `repo_map(repo_path=\\\"./your-repo-path\\\")`\\n- å½“å‰å·¥ä½œç›®å½•å°±æ˜¯é¡¹ç›®æ ¹ç›®å½•ï¼Œä¸éœ€è¦æŒ‡å®šå…·ä½“è·¯å¾„\\n\\n### æ­¥éª¤3ï¼šæŸ¥çœ‹è¾…åŠ©Agentçš„ç»“æœ\\n\\nç³»ç»Ÿä¼šè‡ªåŠ¨å¹¶è¡Œæ‰§è¡Œè¾…åŠ©Agentï¼Œä½ ä¼šåœ¨contextä¸­çœ‹åˆ°`helper_results`ï¼š\\n\\n```python\\nhelper_results = [\\n    {\\n        'agent': 'code_analyzer',\\n        'content': 'æ¶æ„åˆ†æç»“æœ...'\\n    },\\n    {\\n        'agent': 'programmer',\\n        'content': 'ä»£ç å®ç°å»ºè®®...'\\n    },\\n    # ...\\n]\\n```\\n\\n### æ­¥éª¤4ï¼šç»¼åˆåˆ†æå’Œå†³ç­–\\n\\nåŸºäºï¼š\\n1. ä½ çš„åˆæ­¥åˆ†æ\\n2. ä½ ä½¿ç”¨å·¥å…·è·å¾—çš„ä¿¡æ¯\\n3. è¾…åŠ©Agentçš„ç»“æœ\\n\\nåšå‡ºå†³ç­–ï¼š\\n- å“ªäº›Agentçš„å»ºè®®æœ€ç›¸å…³ï¼Ÿ\\n- æ˜¯å¦éœ€è¦è¿›ä¸€æ­¥çš„å·¥ä½œï¼Ÿ\\n- å¦‚ä½•æ•´åˆè¿™äº›ç»“æœï¼Ÿ\\n\\n### æ­¥éª¤5ï¼šè¿”å›ç»¼åˆç»“æœ\\n\\næä¾›æ¸…æ™°çš„ç­”æ¡ˆï¼ŒåŒ…æ‹¬ï¼š\\n1. **ä»»åŠ¡åˆ†æ**ï¼šä½ å¯¹ä»»åŠ¡çš„ç†è§£\\n2. **æ‰§è¡Œè®¡åˆ’**ï¼šå¦‚ä½•å®Œæˆä»»åŠ¡\\n3. **Agentå»ºè®®**ï¼šå„ä¸“ä¸šAgentçš„å…³é”®å»ºè®®\\n4. **æœ€ç»ˆæ–¹æ¡ˆ**ï¼šç»¼åˆçš„è§£å†³æ–¹æ¡ˆ\\n5. **ä¸‹ä¸€æ­¥**ï¼šç”¨æˆ·åº”è¯¥åšä»€ä¹ˆ\\n\\n## å·¥å…·ä½¿ç”¨ç¤ºä¾‹\\n\\n### âœ… æ­£ç¡®çš„å·¥å…·è°ƒç”¨\\n\\n```python\\n# ç”Ÿæˆä»£ç åœ°å›¾\\nrepo_map(repo_path=\\\".\\\")\\n\\n# è·å–ç›®å½•ç»“æ„\\nget_repo_structure(repo_path=\\\".\\\")\\n\\n# æœç´¢ä»£ç \\ntext_search(query=\\\"login\\\", directory=\\\".\\\")\\n\\n# è¯»å–æ–‡ä»¶\\nread_file(file_path=\\\"auth/login.py\\\")\\n```\\n\\n### âŒ é”™è¯¯çš„å·¥å…·è°ƒç”¨\\n\\n```python\\n# âŒ ä¸è¦ä½¿ç”¨å ä½ç¬¦è·¯å¾„\\nrepo_map(repo_path=\\\"./your-repo-path\\\")\\nrepo_map(repo_path=\\\"/path/to/repo\\\")\\n\\n# âŒ ä¸è¦ä½¿ç”¨ç»å¯¹è·¯å¾„\\ntext_search(query=\\\"login\\\", directory=\\\"/home/user/project\\\")\\n\\n# âœ… æ­£ç¡®ï¼šä½¿ç”¨ . è¡¨ç¤ºå½“å‰ç›®å½•\\nrepo_map(repo_path=\\\".\\\")\\ntext_search(query=\\\"login\\\", directory=\\\".\\\")\\n```\\n\\n## ç¤ºä¾‹åœºæ™¯\\n\\n### åœºæ™¯1ï¼šé‡æ„ + æµ‹è¯•\\n\\n**ç”¨æˆ·è¯·æ±‚**ï¼š\\\"é‡æ„ç™»å½•æ¨¡å—ï¼Œæ·»åŠ æµ‹è¯•\\\"\\n\\n**ä½ çš„åˆ†æ**ï¼š\\n1. ä½¿ç”¨`text_search`æ‰¾åˆ°ç™»å½•ç›¸å…³æ–‡ä»¶\\n2. ä½¿ç”¨`read_file`å¿«é€Ÿæµè§ˆå…³é”®æ–‡ä»¶\\n3. æŸ¥çœ‹`helper_results`ï¼š\\n   - code_analyzerï¼šåˆ†æäº†æ¶æ„é—®é¢˜\\n   - refactor_masterï¼šæä¾›äº†é‡æ„æ–¹æ¡ˆ\\n   - test_expertï¼šæä¾›äº†æµ‹è¯•ç­–ç•¥\\n\\n**ä½ çš„è¾“å‡º**ï¼š\\n```\\n## ä»»åŠ¡åˆ†æ\\nç™»å½•æ¨¡å—ä½äº `auth/login.py`ï¼Œå½“å‰å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š\\n- [ä»code_analyzerçš„åˆ†æä¸­æå–]\\n\\n## æ‰§è¡Œè®¡åˆ’\\n1. é‡æ„ç™»å½•é€»è¾‘ï¼ˆrefactor_masterå»ºè®®ï¼‰\\n2. æ·»åŠ å•å…ƒæµ‹è¯•ï¼ˆtest_expertå»ºè®®ï¼‰\\n\\n## é‡æ„æ–¹æ¡ˆ\\n[æ•´åˆr"
},
{
"path": "debug_llm_request_1771334710.json",
"start": 56,
"end": 110,
"text": "              \"type\": \"string\"\n            },\n            \"description\": \"å¯¹è¯ä¸­æåˆ°çš„æ ‡è¯†ç¬¦åˆ—è¡¨ï¼ˆæƒé‡Ã—10ï¼‰\"\n          },\n          \"max_tokens\": {\n            \"type\": \"integer\",\n            \"description\": \"æœ€å¤§tokenæ•°é‡ï¼ˆé»˜è®¤3000ï¼‰ã€‚å¦‚æœchat_filesä¸ºç©ºï¼Œä¼šè‡ªåŠ¨æ‰©å¤§åˆ°6000\",\n            \"default\": 3000\n          },\n          \"auto_scale\": {\n            \"type\": \"boolean\",\n            \"description\": \"æ˜¯å¦è‡ªåŠ¨è°ƒæ•´tokené¢„ç®—ï¼ˆé»˜è®¤trueï¼‰ã€‚å½“chat_filesä¸ºç©ºæ—¶ï¼Œè‡ªåŠ¨æ‰©å¤§é¢„ç®—ä»¥æä¾›æ›´å…¨é¢çš„è§†å›¾\",\n            \"default\": true\n          }\n        },\n        \"required\": [\n          \"repo_path\"\n        ]\n      }\n    },\n    {\n      \"name\": \"get_repo_structure\",\n      \"description\": \"è·å–ä»“åº“ç›®å½•ç»“æ„ï¼Œæ”¯æŒæ™ºèƒ½æ³¨é‡Š\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"repo_path\": {\n            \"type\": \"string\",\n            \"description\": \"ä»“åº“æ ¹ç›®å½•è·¯å¾„ã€‚å¿…é¡»ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•ï¼Œä¸è¦ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼\"\n          },\n          \"max_depth\": {\n            \"type\": \"integer\",\n            \"description\": \"æœ€å¤§æ·±åº¦\",\n            \"default\": 3\n          },\n          \"show_files\": {\n            \"type\": \"boolean\",\n            \"description\": \"æ˜¯å¦æ˜¾ç¤ºæ–‡ä»¶ï¼ˆå¦åˆ™åªæ˜¾ç¤ºç›®å½•ï¼‰\",\n            \"default\": true\n          },\n          \"annotate\": {\n            \"type\": \"boolean\",\n            \"description\": \"æ˜¯å¦æ·»åŠ æ™ºèƒ½æ³¨é‡Šï¼ˆå¸®åŠ©ç†è§£ç›®å½•å«ä¹‰ï¼‰\",\n            \"default\": true\n          }\n        },\n        \"required\": [\n          \"repo_path\"\n        ]\n      }\n    },\n    {\n      \"name\": \"text_search\",\n      \"description\": \"åœ¨æ–‡ä»¶ä¸­æœç´¢æ–‡æœ¬\",\n      \"parameters\": {"
},
{
"path": "debug_llm_request_1771334710.json",
"start": 111,
"end": 164,
"text": "        \"type\": \"object\",\n        \"properties\": {\n          \"query\": {\n            \"type\": \"string\",\n            \"description\": \"æœç´¢å…³é”®è¯\"\n          },\n          \"directory\": {\n            \"type\": \"string\",\n            \"description\": \"æœç´¢ç›®å½•ã€‚é»˜è®¤ä¸ºå½“å‰å·¥ä½œç›®å½•ï¼ˆ'.'ï¼‰ï¼Œä¹Ÿå¯ä»¥æŒ‡å®šå­ç›®å½•çš„ç›¸å¯¹è·¯å¾„\",\n            \"default\": \".\"\n          },\n          \"file_pattern\": {\n            \"type\": \"string\",\n            \"description\": \"æ–‡ä»¶åæ¨¡å¼ï¼ˆå¦‚ *.pyï¼‰\"\n          },\n          \"case_sensitive\": {\n            \"type\": \"boolean\",\n            \"description\": \"æ˜¯å¦åŒºåˆ†å¤§å°å†™\",\n            \"default\": false\n          },\n          \"max_results\": {\n            \"type\": \"integer\",\n            \"description\": \"æœ€å¤§ç»“æœæ•°\",\n            \"default\": 100\n          }\n        },\n        \"required\": [\n          \"query\"\n        ]\n      }\n    },\n    {\n      \"name\": \"read_file\",\n      \"description\": \"è¯»å–æ–‡ä»¶å†…å®¹\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"file_path\": {\n            \"type\": \"string\",\n            \"description\": \"æ–‡ä»¶çš„ç›¸å¯¹è·¯å¾„ã€‚ä¾‹å¦‚: 'backend/config.py' æˆ– 'README.md'ã€‚ä¸è¦ä½¿ç”¨å ä½ç¬¦ï¼\"\n          },\n          \"encoding\": {\n            \"type\": \"string\",\n            \"description\": \"ç¼–ç æ ¼å¼\",\n            \"default\": \"utf-8\"\n          }\n        },\n        \"required\": [\n          \"file_path\"\n        ]\n      }\n    }\n  ]\n}"
},
{
"path": "debug_llm_request_1771334713.json",
"start": 1,
"end": 11,
"text": "{\n  \"model\": \"qwen-max\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"è¯·å¯¹ä»¥ä¸‹å¯¹è¯è¿›è¡Œç®€æ´çš„æ‘˜è¦ï¼Œæå–å…³é”®ä¿¡æ¯ï¼š\\n\\nç”¨æˆ·: ä½ å¥½å•Šé“å‹\\nAI: è¯·æä¾›æ›´å¤šä¿¡æ¯æˆ–å…·ä½“çš„ä»»åŠ¡ï¼Œä»¥ä¾¿æˆ‘èƒ½å¤Ÿå¸®åŠ©æ‚¨ã€‚æ‚¨å¯ä»¥é—®æˆ‘å…³äºä»£ç æœç´¢ã€æ–‡ä»¶è¯»å–ã€ä»“åº“ç»“æ„è·å–ç­‰æ–¹é¢çš„é—®é¢˜ã€‚\\nç”¨æˆ·: ä½ å¥½å•Šé“å‹\\nAI: è¿™æ˜¯å½“å‰ä»“åº“çš„ç›®å½•ç»“æ„ã€‚æ‚¨éœ€è¦è¿›ä¸€æ­¥æŸ¥çœ‹æŸä¸ªæ–‡ä»¶çš„å†…å®¹å—ï¼Ÿæˆ–è€…æœ‰å…¶ä»–éœ€æ±‚ï¼Ÿ\\nç”¨æˆ·: ä½ å¥½å•Šé“å‹\\nAI: çœ‹èµ·æ¥æ‚¨æŒ‡å®šçš„ç›®å½• `./src` ä¸å­˜åœ¨ã€‚è¯·æ£€æŸ¥ç›®å½•è·¯å¾„å¹¶é‡æ–°å°è¯•ã€‚å¦‚æœæ‚¨æƒ³åœ¨å½“å‰ç›®å½•ä¸‹æœç´¢ï¼Œè¯·å°† `directory` å‚æ•°è®¾ç½®ä¸º `\\\".\\\"`ã€‚\\nç”¨æˆ·: ä½ å¥½å•Šé“å‹\\nAI: ä»¥ä¸‹æ˜¯ä»“åº“çš„ç›®å½•ç»“æ„ï¼ŒåŒ…å«äº†å„ä¸ªæ¨¡å—å’Œæ–‡ä»¶çš„ç®€è¦è¯´æ˜ã€‚å¦‚æœæ‚¨éœ€è¦è¿›ä¸€æ­¥äº†è§£æŸä¸ªæ–‡ä»¶æˆ–æ¨¡å—çš„å†…å®¹ï¼Œå¯ä»¥ä½¿ç”¨`read_file`å·¥å…·æ¥æŸ¥çœ‹å…·ä½“æ–‡ä»¶å†…å®¹ã€‚\\nç”¨æˆ·: ä½ å¥½å•Šé“å‹\\nAI: ä½ å¥½ï¼æˆ‘æ˜¯Sisyphusï¼Œä¸€ä¸ªæ™ºèƒ½ä»»åŠ¡ç¼–æ’ä¸“å®¶ã€‚è¯·é—®æ‚¨éœ€è¦æˆ‘å¸®æ‚¨å¤„ç†ä»€ä¹ˆä»»åŠ¡å‘¢ï¼Ÿæ— è®ºæ˜¯ä»£ç åˆ†æã€åŠŸèƒ½å®ç°ã€é‡æ„è¿˜æ˜¯æµ‹è¯•ï¼Œæˆ‘éƒ½å¯ä»¥åè°ƒç›¸åº”çš„ä¸“ä¸šAgentæ¥å¸®åŠ©æ‚¨å®Œæˆå·¥ä½œã€‚è¯·å‘Šè¯‰æˆ‘æ‚¨çš„å…·ä½“éœ€æ±‚ã€‚\\n\\nè¦æ±‚ï¼š\\n1. æå–ä¸»è¦è®¨è®ºçš„è¯é¢˜\\n2. æå–å…³é”®é—®é¢˜å’Œç­”æ¡ˆ\\n3. æå–å·²ç»™å‡ºçš„å»ºè®®\\n4. æ§åˆ¶åœ¨200å­—ä»¥å†…\\n\\næ‘˜è¦æ ¼å¼ï¼š\\nã€ä¸»è¦è¯é¢˜ã€‘...\\nã€å…³é”®é—®é¢˜ã€‘...\\nã€å·²ç»™å»ºè®®ã€‘...\\n\"\n    }\n  ],\n  \"temperature\": 0.3,\n  \"max_tokens\": 300\n}"
},
{
"path": "llm_config_qwen_only.yaml",
"start": 1,
"end": 55,
"text": "# LLMæ¨¡å—é…ç½® - ä»…é€šä¹‰åƒé—®\n# æœ€ç®€åŒ–é…ç½®ï¼Œåªä½¿ç”¨é€šä¹‰åƒé—®ç³»åˆ—æ¨¡å‹\n\n# æä¾›å•†é…ç½®\nproviders:\n  # é€šä¹‰åƒé—®ï¼ˆé˜¿é‡Œäº‘ï¼‰\n  qwen:\n    api_key: \"sk-d2971f2015574377bdf97046b1a03b87\"  # ğŸ‘ˆ å¡«å…¥ä½ çš„é€šä¹‰åƒé—®APIå¯†é’¥\n    base_url: \"https://dashscope.aliyuncs.com/compatible-mode/v1\"\n    models:\n      - qwen-max      # æœ€å¼ºå¤§ï¼Œé€‚åˆå¤æ‚ä»»åŠ¡\n      - qwen-plus     # æ€§ä»·æ¯”é«˜ï¼Œé€‚åˆé€šç”¨ä»»åŠ¡\n      - qwen-turbo    # æœ€ä¾¿å®œï¼Œé€‚åˆç®€å•ä»»åŠ¡\n\n# é»˜è®¤é…ç½®\ndefault:\n  provider: qwen\n  model: qwen-max       # ä½¿ç”¨æœ€å¼ºæ¨¡å‹ä»¥è·å¾—æœ€å¥½çš„æ¨ç†èƒ½åŠ›\n  temperature: 0.7\n  max_tokens: 5000\n\n# é™çº§ç­–ç•¥ï¼ˆå¯é€‰ï¼Œå»ºè®®é…ç½®ï¼‰\nfallback:\n  chains:\n    qwen-max:\n      - qwen-plus     # qwen-maxå¤±è´¥æ—¶é™çº§åˆ°qwen-plus\n      - qwen-turbo    # qwen-plusä¹Ÿå¤±è´¥æ—¶é™çº§åˆ°qwen-turbo\n    qwen-plus:\n      - qwen-turbo    # qwen-pluså¤±è´¥æ—¶é™çº§åˆ°qwen-turbo\n\n# é™æµé…ç½®ï¼ˆå¯é€‰ï¼‰\nrate_limit:\n  # ç”¨æˆ·é™æµ\n  user:\n    capacity: 10        # æ¯ä¸ªç”¨æˆ·10ä¸ªä»¤ç‰Œ\n    refill_rate: 1.0    # æ¯ç§’å¡«å……1ä¸ªä»¤ç‰Œ\n  \n  # å…¨å±€é™æµ\n  global:\n    capacity: 100       # å…¨å±€100ä¸ªä»¤ç‰Œ\n    refill_rate: 10.0   # æ¯ç§’å¡«å……10ä¸ªä»¤ç‰Œ\n\n# ç†”æ–­å™¨é…ç½®ï¼ˆå¯é€‰ï¼‰\ncircuit_breaker:\n  failure_threshold: 5    # å¤±è´¥5æ¬¡åæ‰“å¼€ç†”æ–­å™¨\n  timeout: 60            # 60ç§’åå°è¯•åŠå¼€\n  success_threshold: 2   # æˆåŠŸ2æ¬¡åå…³é—­ç†”æ–­å™¨\n\n# Skillç›®å½•ï¼ˆå¯é€‰ï¼‰\nskills_dirs:\n  - backend/daoyoucode/llm/skills/examples\n\n# ä¸Šä¸‹æ–‡é…ç½®ï¼ˆå¯é€‰ï¼‰\ncontext:\n  max_history: 10        # æœ€å¤šä¿ç•™10è½®å¯¹è¯"
},
{
"path": "llm_config_qwen_only.yaml",
"start": 56,
"end": 62,
"text": "  max_sessions: 1000     # æœ€å¤š1000ä¸ªä¼šè¯\n  session_ttl: 3600      # ä¼šè¯è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰\n\n# æ—¥å¿—é…ç½®ï¼ˆå¯é€‰ï¼‰\nlogging:\n  level: INFO\n  format: \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\""
},
{
"path": "ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md",
"start": 1,
"end": 55,
"text": "# ç¼–æ’å™¨ä»‹ç»\n\n> DaoyouCode 7ä¸ªå†…ç½®ç¼–æ’å™¨å®Œæ•´ä»‹ç»\n\n---\n\n## â“ ç¼–æ’å™¨çš„æ„ä¹‰\n\nå¾ˆå¤šäººä¼šé—®ï¼š**CLIä¼ å‚æ˜¯Skillï¼Œé‚£ç¼–æ’å™¨æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Ÿ**\n\nç­”æ¡ˆï¼š**ç¼–æ’å™¨å†³å®šAgentçš„åä½œæ–¹å¼ï¼**\n\n### æ¶æ„å…³ç³»\n\n```\nCLI --skill sisyphus-orchestrator\n    â†“\nSkillé…ç½®æ–‡ä»¶\n    â”œâ”€ orchestrator: multi_agent    â† æŒ‡å®šç¼–æ’å™¨\n    â”œâ”€ agents: [sisyphus, ...]      â† æŒ‡å®šAgentåˆ—è¡¨\n    â””â”€ tools: [repo_map, ...]       â† æŒ‡å®šå·¥å…·åˆ—è¡¨\n    â†“\nç¼–æ’å™¨ï¼ˆOrchestratorï¼‰\n    â†“\nåè°ƒAgentå·¥ä½œæ–¹å¼\n    â”œâ”€ é¡ºåºæ‰§è¡Œï¼Ÿå¹¶è¡Œæ‰§è¡Œï¼Ÿ\n    â”œâ”€ å¦‚ä½•é‡è¯•ï¼Ÿå¦‚ä½•è¶…æ—¶ï¼Ÿ\n    â””â”€ å¦‚ä½•èšåˆç»“æœï¼Ÿ\n```\n\n### ç¼–æ’å™¨çš„3å¤§èŒè´£\n\n1. **å†³å®šåä½œæ–¹å¼**\n   - é¡ºåºæ‰§è¡Œï¼ˆsequentialï¼‰\n   - å¹¶è¡Œæ‰§è¡Œï¼ˆparallelï¼‰\n   - è¾©è®ºæ¨¡å¼ï¼ˆdebateï¼‰\n   - ä¸»ä»åä½œï¼ˆmain_with_helpersï¼‰\n\n2. **æ§åˆ¶æ‰§è¡Œæµç¨‹**\n   - é‡è¯•æœºåˆ¶ï¼ˆå¤±è´¥åé‡è¯•ï¼‰\n   - è¶…æ—¶æ§åˆ¶ï¼ˆé¿å…å¡æ­»ï¼‰\n   - å¤±è´¥å›æ»šï¼ˆæ¢å¤çŠ¶æ€ï¼‰\n\n3. **ç®¡ç†ç»“æœèšåˆ**\n   - å¦‚ä½•ç»„åˆå¤šä¸ªAgentçš„è¾“å‡º\n   - å¦‚ä½•å¤„ç†å†²çª\n   - å¦‚ä½•ç”Ÿæˆæœ€ç»ˆç­”æ¡ˆ\n\n### ä¸¾ä¾‹è¯´æ˜\n\n**åŒæ ·çš„Agentåˆ—è¡¨ï¼Œä¸åŒçš„ç¼–æ’å™¨ï¼Œç»“æœå®Œå…¨ä¸åŒ**ï¼š\n\n```yaml\n# é…ç½®1ï¼šä½¿ç”¨simpleç¼–æ’å™¨\norchestrator: simple"
},
{
"path": "ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md",
"start": 56,
"end": 110,
"text": "agents:\n  - programmer\n# ç»“æœï¼šåªæ‰§è¡Œprogrammerï¼Œå…¶ä»–Agentè¢«å¿½ç•¥\n\n# é…ç½®2ï¼šä½¿ç”¨multi_agentç¼–æ’å™¨ï¼ˆé¡ºåºæ¨¡å¼ï¼‰\norchestrator: multi_agent\ncollaboration_mode: sequential\nagents:\n  - code_analyzer\n  - programmer\n  - test_expert\n# ç»“æœï¼šcode_analyzer â†’ programmer â†’ test_expertï¼ˆé¡ºåºæ‰§è¡Œï¼‰\n\n# é…ç½®3ï¼šä½¿ç”¨multi_agentç¼–æ’å™¨ï¼ˆå¹¶è¡Œæ¨¡å¼ï¼‰\norchestrator: multi_agent\ncollaboration_mode: parallel\nagents:\n  - code_analyzer\n  - programmer\n  - test_expert\n# ç»“æœï¼š3ä¸ªAgentåŒæ—¶æ‰§è¡Œï¼Œç„¶åèšåˆç»“æœ\n\n# é…ç½®4ï¼šä½¿ç”¨multi_agentç¼–æ’å™¨ï¼ˆä¸»ä»æ¨¡å¼ï¼‰\norchestrator: multi_agent\ncollaboration_mode: main_with_helpers\nagents:\n  - sisyphus        # ä¸»Agent\n  - code_analyzer   # è¾…åŠ©Agent\n  - programmer      # è¾…åŠ©Agent\n# ç»“æœï¼šè¾…åŠ©Agentå…ˆæ‰§è¡Œï¼Œä¸»Agentçœ‹åˆ°ç»“æœåå†³ç­–\n```\n\n**æ‰€ä»¥ç¼–æ’å™¨çš„æ„ä¹‰æ˜¯**ï¼š\n- âœ… ä¸æ˜¯ç®€å•åœ°\"è°ƒç”¨Agent\"\n- âœ… è€Œæ˜¯\"å¦‚ä½•åè°ƒå¤šä¸ªAgentå·¥ä½œ\"\n- âœ… å†³å®šäº†ç³»ç»Ÿçš„æ™ºèƒ½ç¨‹åº¦å’Œæ•ˆç‡\n\n---\n\n## ç¼–æ’å™¨æ€»è§ˆ\n\n| ç¼–æ’å™¨ | Agentæ•° | å¤æ‚åº¦ | ç‰¹ç‚¹ |\n|--------|---------|--------|------|\n| simple | 1 | LOW | ç®€å•ç¼–æ’ï¼Œå•Agenté¡ºåºæ‰§è¡Œ |\n| react | 1 | MEDIUM | ReActæ¨¡å¼ï¼Œæ¨ç†-è¡ŒåŠ¨å¾ªç¯ |\n| multi_agent | å¤šä¸ª | HIGH | å¤šAgentåä½œï¼Œ4ç§åä½œæ¨¡å¼ |\n| workflow | å¤šä¸ª | MEDIUM | å·¥ä½œæµç¼–æ’ï¼Œé¢„å®šä¹‰æ­¥éª¤ |\n| parallel | å¤šä¸ª | MEDIUM | å¹¶è¡Œæ‰§è¡Œï¼Œå¤šä»»åŠ¡åŒæ—¶ |\n| parallel_explore | å¤šä¸ª | HIGH | å¹¶è¡Œæ¢ç´¢ï¼Œå¤šè·¯å¾„å°è¯• |\n| conditional | å¤šä¸ª | MEDIUM | æ¡ä»¶ç¼–æ’ï¼Œæ ¹æ®æ¡ä»¶é€‰æ‹©è·¯å¾„ |\n\n---\n\n## æ ¸å¿ƒç¼–æ’å™¨è¯¦è§£\n"
},
{
"path": "ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md",
"start": 111,
"end": 165,
"text": "### 1. Simple - ç®€å•ç¼–æ’å™¨\n\n**åŠŸèƒ½**ï¼š\n- ç›´æ¥æ‰§è¡Œå•ä¸ªAgent\n- è‡ªåŠ¨é‡è¯•æœºåˆ¶\n- ç»“æœéªŒè¯\n- æˆæœ¬è¿½è¸ª\n\n**ç‰¹ç‚¹**ï¼š\n- æœ€ç®€å•çš„ç¼–æ’å™¨\n- é€‚åˆå•ä¸€ä»»åŠ¡\n- æ”¯æŒé‡è¯•ï¼ˆæœ€å¤š3æ¬¡ï¼‰\n- è‡ªåŠ¨éªŒè¯ç»“æœ\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- ç®€å•ä»»åŠ¡\n- å•ä¸€Agentå³å¯å®Œæˆ\n- ä¸éœ€è¦å¤šAgentåä½œ\n\n**é…ç½®ç¤ºä¾‹**ï¼š\n```yaml\norchestrator: simple\nagent: programmer\nmax_retries: 3\nretry_delay: 1.0\n```\n\n**å·¥ä½œæµç¨‹**ï¼š\n```\nç”¨æˆ·è¾“å…¥ â†’ Agentæ‰§è¡Œ â†’ ç»“æœéªŒè¯ â†’ è¿”å›ç»“æœ\n         â†‘_____________â†“ (å¤±è´¥é‡è¯•)\n```\n\n---\n\n### 2. ReAct - ReActå¾ªç¯ç¼–æ’å™¨\n\n**åŠŸèƒ½**ï¼š\n- Reasonï¼ˆæ¨ç†ï¼‰ï¼šåˆ†æä»»åŠ¡\n- Actï¼ˆè¡ŒåŠ¨ï¼‰ï¼šæ‰§è¡Œå·¥å…·\n- Observeï¼ˆè§‚å¯Ÿï¼‰ï¼šæ£€æŸ¥ç»“æœ\n- Reflectï¼ˆåæ€ï¼‰ï¼šè°ƒæ•´ç­–ç•¥\n\n**ç‰¹ç‚¹**ï¼š\n- LLMè‡ªåŠ¨æ§åˆ¶å¾ªç¯\n- æ— éœ€é¢å¤–è§„åˆ’æ­¥éª¤\n- æˆæœ¬ä½ï¼Œæ•ˆç‡é«˜\n- é€‚åˆéœ€è¦å·¥å…·è°ƒç”¨çš„ä»»åŠ¡\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- éœ€è¦å·¥å…·è°ƒç”¨\n- éœ€è¦å¤šæ­¥æ¨ç†\n- éœ€è¦åŠ¨æ€è°ƒæ•´ç­–ç•¥\n\n**é…ç½®ç¤ºä¾‹**ï¼š"
},
{
"path": "ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md",
"start": 166,
"end": 220,
"text": "```yaml\norchestrator: react\nagent: programmer\ntools:\n  - read_file\n  - write_file\n  - lsp_diagnostics\n```\n\n**å·¥ä½œæµç¨‹**ï¼š\n```\nç”¨æˆ·è¾“å…¥ â†’ LLMåˆ†æ â†’ è°ƒç”¨å·¥å…· â†’ è§‚å¯Ÿç»“æœ â†’ LLMå†³å®šä¸‹ä¸€æ­¥\n         â†‘_______________________________________â†“ (å¾ªç¯)\n```\n\n**æ ¸å¿ƒé€»è¾‘**ï¼š\n- ReActå¾ªç¯çš„æ ¸å¿ƒé€»è¾‘åœ¨Agentå±‚å®ç°ï¼ˆé€šè¿‡Function Callingï¼‰\n- LLMè‡ªåŠ¨å†³å®šæ˜¯å¦è°ƒç”¨å·¥å…·\n- ç¼–æ’å™¨åªè´Ÿè´£è°ƒç”¨Agentå’Œå¤„ç†ç»“æœ\n\n---\n\n### 3. MultiAgent - å¤šAgentç¼–æ’å™¨\n\n**åŠŸèƒ½**ï¼š\n- æ”¯æŒ4ç§åä½œæ¨¡å¼\n- æ™ºèƒ½Agenté€‰æ‹©\n- ç»“æœèšåˆ\n- å…±äº«è®°å¿†\n\n**4ç§åä½œæ¨¡å¼**ï¼š\n\n#### 3.1 Sequentialï¼ˆé¡ºåºæ‰§è¡Œï¼‰\n- æ¯ä¸ªAgentå¤„ç†å‰ä¸€ä¸ªçš„è¾“å‡º\n- é€‚åˆéœ€è¦é€æ­¥å¤„ç†çš„ä»»åŠ¡\n\n```\nAgent1 â†’ Agent2 â†’ Agent3 â†’ æœ€ç»ˆç»“æœ\n```\n\n#### 3.2 Parallelï¼ˆå¹¶è¡Œæ‰§è¡Œï¼‰\n- æ‰€æœ‰AgentåŒæ—¶å¤„ç†ç›¸åŒè¾“å…¥\n- é€‚åˆç‹¬ç«‹ä»»åŠ¡å¯å¹¶è¡Œ\n\n```\n        â”Œâ†’ Agent1 â”\nè¾“å…¥ â†’ â”œâ†’ Agent2 â”œâ†’ èšåˆç»“æœ\n        â””â†’ Agent3 â”˜\n```\n\n#### 3.3 Debateï¼ˆè¾©è®ºæ¨¡å¼ï¼‰\n- Agentä¹‹é—´è¿›è¡Œå¤šè½®è®¨è®º\n- ä½¿ç”¨å…±äº«è®°å¿†\n- é€‚åˆéœ€è¦å¤šè§’åº¦åˆ†æ\n"
},
{
"path": "ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md",
"start": 221,
"end": 275,
"text": "```\nè½®1: Agent1è§‚ç‚¹ â† Agent2è§‚ç‚¹ â† Agent3è§‚ç‚¹\nè½®2: Agent1è§‚ç‚¹ â† Agent2è§‚ç‚¹ â† Agent3è§‚ç‚¹\nè½®3: Agent1è§‚ç‚¹ â† Agent2è§‚ç‚¹ â† Agent3è§‚ç‚¹\n     â†“\n   ç»¼åˆç»“è®º\n```\n\n#### 3.4 MainWithHelpersï¼ˆä¸»Agent + è¾…åŠ©Agentï¼‰\n- ç¬¬ä¸€ä¸ªAgentæ˜¯ä¸»Agent\n- å…¶ä»–Agentæ˜¯è¾…åŠ©Agent\n- ä¸»Agentå¯ä»¥çœ‹åˆ°è¾…åŠ©Agentçš„ç»“æœ\n\n```\n        â”Œâ†’ Helper1 â”\nè¾“å…¥ â†’ â”œâ†’ Helper2 â”œâ†’ MainAgent â†’ æœ€ç»ˆç»“æœ\n        â””â†’ Helper3 â”˜\n```\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- å¤æ‚ä»»åŠ¡éœ€è¦å¤šä¸ªä¸“ä¸šAgent\n- éœ€è¦å¤šè§’åº¦åˆ†æ\n- éœ€è¦Agentåä½œ\n\n**é…ç½®ç¤ºä¾‹**ï¼š\n```yaml\norchestrator: multi_agent\ncollaboration_mode: main_with_helpers\nagents:\n  - sisyphus        # ä¸»Agent\n  - code_analyzer   # è¾…åŠ©Agent\n  - programmer      # è¾…åŠ©Agent\n  - refactor_master # è¾…åŠ©Agent\n  - test_expert     # è¾…åŠ©Agent\n```\n\n---\n\n### 4. Workflow - å·¥ä½œæµç¼–æ’å™¨\n\n**åŠŸèƒ½**ï¼š\n- æŒ‰æ­¥éª¤æ‰§è¡Œ\n- æ­¥éª¤ä¾èµ–æ£€æŸ¥\n- æ¡ä»¶åˆ†æ”¯\n- å¤±è´¥å›æ»š\n- æ­¥éª¤è¶…æ—¶å’Œé‡è¯•\n\n**ç‰¹ç‚¹**ï¼š\n- é¢„å®šä¹‰æ­¥éª¤\n- æ”¯æŒä¾èµ–å…³ç³»\n- æ”¯æŒæ¡ä»¶æ‰§è¡Œ\n- æ”¯æŒå›æ»š\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- å›ºå®šæµç¨‹çš„ä»»åŠ¡"
},
{
"path": "ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md",
"start": 276,
"end": 330,
"text": "- éœ€è¦æ­¥éª¤ä¾èµ–\n- éœ€è¦æ¡ä»¶åˆ†æ”¯\n- éœ€è¦å¤±è´¥å›æ»š\n\n**é…ç½®ç¤ºä¾‹**ï¼š\n```yaml\norchestrator: workflow\nworkflow:\n  - name: analyze\n    agent: code_analyzer\n    output: analysis_result\n    max_retries: 3\n    timeout: 30.0\n  \n  - name: implement\n    agent: programmer\n    depends_on: [analyze]\n    input: ${analysis_result}\n    condition: ${analysis_result.feasible}\n    output: code_changes\n    rollback: cleanup_agent\n  \n  - name: test\n    agent: test_expert\n    depends_on: [implement]\n    input: ${code_changes}\n```\n\n**å·¥ä½œæµç¨‹**ï¼š\n```\nStep1 â†’ Step2 â†’ Step3 â†’ æˆåŠŸ\n  â†“       â†“       â†“\nå¤±è´¥ â†’ å›æ»š â† å›æ»š â† å¤±è´¥\n```\n\n---\n\n### 5. Parallel - å¹¶è¡Œç¼–æ’å™¨\n\n**åŠŸèƒ½**ï¼š\n- LLMæ™ºèƒ½ä»»åŠ¡æ‹†åˆ†\n- å¹¶è¡Œæ‰§è¡Œå¤šä¸ªä»»åŠ¡\n- LLMæ™ºèƒ½ç»“æœèšåˆ\n- æ‰¹é‡æ‰§è¡Œæ§åˆ¶\n\n**ç‰¹ç‚¹**ï¼š\n- è‡ªåŠ¨æ‹†åˆ†ä»»åŠ¡\n- å¹¶è¡Œæ‰§è¡Œæé«˜æ•ˆç‡\n- æ™ºèƒ½èšåˆç»“æœ\n- æ”¯æŒæ‰¹é‡æ§åˆ¶\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- ç‹¬ç«‹ä»»åŠ¡å¯å¹¶è¡Œ\n- éœ€è¦æé«˜æ‰§è¡Œæ•ˆç‡\n- éœ€è¦æ™ºèƒ½ä»»åŠ¡æ‹†åˆ†"
},
{
"path": "ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md",
"start": 331,
"end": 385,
"text": "\n**é…ç½®ç¤ºä¾‹**ï¼š\n```yaml\norchestrator: parallel\nuse_llm_split: true        # ä½¿ç”¨LLMæ™ºèƒ½æ‹†åˆ†\nuse_llm_aggregate: true    # ä½¿ç”¨LLMæ™ºèƒ½èšåˆ\nbatch_size: 3              # æ‰¹é‡å¤§å°\ntimeout: 60.0              # è¶…æ—¶æ—¶é—´\n```\n\n**å·¥ä½œæµç¨‹**ï¼š\n```\nç”¨æˆ·è¾“å…¥ â†’ LLMæ‹†åˆ†ä»»åŠ¡ â†’ å¹¶è¡Œæ‰§è¡Œ â†’ LLMèšåˆç»“æœ\n                â†“\n        â”Œâ†’ Task1 (Agent1)\n        â”œâ†’ Task2 (Agent2)\n        â””â†’ Task3 (Agent3)\n```\n\n---\n\n### 6. ParallelExplore - å¹¶è¡Œæ¢ç´¢ç¼–æ’å™¨\n\n**åŠŸèƒ½**ï¼š\n- å¤šè·¯å¾„åŒæ—¶å°è¯•\n- è‡ªåŠ¨é€‰æ‹©æœ€ä½³ç»“æœ\n- æ¢ç´¢æ€§ä»»åŠ¡\n\n**ç‰¹ç‚¹**ï¼š\n- åŒæ—¶å°è¯•å¤šç§æ–¹æ¡ˆ\n- è‡ªåŠ¨è¯„åˆ†å’Œé€‰æ‹©\n- é€‚åˆæ¢ç´¢æ€§ä»»åŠ¡\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- æ¢ç´¢æ€§ä»»åŠ¡\n- éœ€è¦å¤šç§æ–¹æ¡ˆ\n- ä¸ç¡®å®šå“ªç§æ–¹æ¡ˆæœ€å¥½\n\n**é…ç½®ç¤ºä¾‹**ï¼š\n```yaml\norchestrator: parallel_explore\nagents:\n  - programmer\n  - refactor_master\n  - test_expert\n```\n\n---\n\n### 7. Conditional - æ¡ä»¶ç¼–æ’å™¨\n\n**åŠŸèƒ½**ï¼š\n- æ ¹æ®æ¡ä»¶é€‰æ‹©è·¯å¾„\n- åŠ¨æ€å†³ç­–\n- æ¡ä»¶åˆ†æ”¯"
},
{
"path": "ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md",
"start": 386,
"end": 440,
"text": "\n**ç‰¹ç‚¹**ï¼š\n- æ”¯æŒæ¡ä»¶åˆ¤æ–­\n- åŠ¨æ€é€‰æ‹©Agent\n- çµæ´»çš„åˆ†æ”¯é€»è¾‘\n\n**ä½¿ç”¨åœºæ™¯**ï¼š\n- éœ€è¦æ¡ä»¶åˆ¤æ–­\n- éœ€è¦åŠ¨æ€é€‰æ‹©Agent\n- éœ€è¦åˆ†æ”¯é€»è¾‘\n\n**é…ç½®ç¤ºä¾‹**ï¼š\n```yaml\norchestrator: conditional\nconditions:\n  - condition: ${task_type} == \"refactor\"\n    agent: refactor_master\n  - condition: ${task_type} == \"test\"\n    agent: test_expert\n  - default: programmer\n```\n\n---\n\n## ç¼–æ’å™¨é€‰æ‹©æŒ‡å—\n\n### æŒ‰ä»»åŠ¡å¤æ‚åº¦é€‰æ‹©\n\n| å¤æ‚åº¦ | æ¨èç¼–æ’å™¨ | åŸå›  |\n|--------|-----------|------|\n| ç®€å• | simple | å•Agentå³å¯ |\n| ä¸­ç­‰ | react | éœ€è¦å·¥å…·è°ƒç”¨ |\n| å¤æ‚ | multi_agent | éœ€è¦å¤šAgentåä½œ |\n| å¾ˆå¤æ‚ | workflow | éœ€è¦æ­¥éª¤æ§åˆ¶ |\n\n### æŒ‰Agentæ•°é‡é€‰æ‹©\n\n| Agentæ•° | æ¨èç¼–æ’å™¨ | è¯´æ˜ |\n|---------|-----------|------|\n| 1ä¸ª | simple, react | å•Agentç¼–æ’ |\n| 2-5ä¸ª | multi_agent, parallel | å¤šAgentåä½œ |\n| 5+ä¸ª | workflow | éœ€è¦æ­¥éª¤æ§åˆ¶ |\n\n### æŒ‰åä½œæ¨¡å¼é€‰æ‹©\n\n| åä½œæ¨¡å¼ | æ¨èç¼–æ’å™¨ | è¯´æ˜ |\n|---------|-----------|------|\n| é¡ºåºæ‰§è¡Œ | multi_agent (sequential) | é€æ­¥å¤„ç† |\n| å¹¶è¡Œæ‰§è¡Œ | multi_agent (parallel), parallel | åŒæ—¶å¤„ç† |\n| è¾©è®ºè®¨è®º | multi_agent (debate) | å¤šè§’åº¦åˆ†æ |\n| ä¸»ä»åä½œ | multi_agent (main_with_helpers) | ä¸»Agentè°ƒåº¦ |\n| å·¥ä½œæµ | workflow | é¢„å®šä¹‰æ­¥éª¤ |\n\n---\n"
},
{
"path": "ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md",
"start": 441,
"end": 489,
"text": "## ç¼–æ’å™¨å¯¹æ¯”\n\n| ç‰¹æ€§ | simple | react | multi_agent | workflow | parallel |\n|------|--------|-------|-------------|----------|----------|\n| Agentæ•° | 1 | 1 | å¤šä¸ª | å¤šä¸ª | å¤šä¸ª |\n| å·¥å…·è°ƒç”¨ | âœ… | âœ… | âœ… | âœ… | âœ… |\n| é‡è¯•æœºåˆ¶ | âœ… | âœ… | âœ… | âœ… | âœ… |\n| ç»“æœéªŒè¯ | âœ… | âœ… | âœ… | âœ… | âœ… |\n| åä½œæ¨¡å¼ | - | - | 4ç§ | - | - |\n| æ­¥éª¤æ§åˆ¶ | - | - | - | âœ… | - |\n| å¹¶è¡Œæ‰§è¡Œ | - | - | âœ… | - | âœ… |\n| æ¡ä»¶åˆ†æ”¯ | - | - | - | âœ… | - |\n| å¤±è´¥å›æ»š | - | - | - | âœ… | - |\n| LLMæ‹†åˆ† | - | - | - | - | âœ… |\n| å¤æ‚åº¦ | LOW | MEDIUM | HIGH | MEDIUM | MEDIUM |\n\n---\n\n## ä½¿ç”¨å»ºè®®\n\n### 1. æ–°æ‰‹æ¨è\n- ä»simpleå¼€å§‹\n- ç†Ÿæ‚‰åä½¿ç”¨react\n- æœ€åå°è¯•multi_agent\n\n### 2. æ€§èƒ½ä¼˜åŒ–\n- ç®€å•ä»»åŠ¡ç”¨simpleï¼ˆæœ€å¿«ï¼‰\n- éœ€è¦å·¥å…·ç”¨reactï¼ˆé«˜æ•ˆï¼‰\n- å¹¶è¡Œä»»åŠ¡ç”¨parallelï¼ˆæé€Ÿï¼‰\n\n### 3. æˆæœ¬æ§åˆ¶\n- simpleæˆæœ¬æœ€ä½ï¼ˆå•æ¬¡è°ƒç”¨ï¼‰\n- reactæˆæœ¬ä¸­ç­‰ï¼ˆå¤šæ¬¡è°ƒç”¨ï¼‰\n- multi_agentæˆæœ¬è¾ƒé«˜ï¼ˆå¤šAgentï¼‰\n- workflowæˆæœ¬å¯æ§ï¼ˆæŒ‰æ­¥éª¤ï¼‰\n\n### 4. å¯é æ€§\n- simpleæœ€å¯é ï¼ˆç®€å•ï¼‰\n- reactè¾ƒå¯é ï¼ˆè‡ªåŠ¨é‡è¯•ï¼‰\n- multi_agentå¯é ï¼ˆå¤šAgentéªŒè¯ï¼‰\n- workflowæœ€å¯é ï¼ˆå›æ»šæœºåˆ¶ï¼‰\n\n---\n\n## ç›¸å…³æ–‡æ¡£\n\n- [CLIå‘½ä»¤å‚è€ƒ.md](./CLIå‘½ä»¤å‚è€ƒ.md) - CLIä½¿ç”¨æŒ‡å—\n- [AGENTSæ™ºèƒ½ä½“ä»‹ç».md](./AGENTSæ™ºèƒ½ä½“ä»‹ç».md) - Agentè¯¦ç»†ä»‹ç»\n- [TOOLSå·¥å…·å‚è€ƒ.md](./TOOLSå·¥å…·å‚è€ƒ.md) - å·¥å…·å‚è€ƒæ‰‹å†Œ"
},
{
"path": "PROMPTä¿®å¤æ€»ç»“.md",
"start": 1,
"end": 55,
"text": "# Promptä¿®å¤æ€»ç»“\n\n## é—®é¢˜\n\nLLMä¸€ç›´ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼š\n- `repo_map(repo_path=\"./your-repo-path\")`\n- `read_file(file_path=\"path/to/your/file.txt\")`\n\n## æ ¹æœ¬åŸå› \n\nLLMçš„è®­ç»ƒæ•°æ®ä¸­åŒ…å«å¤§é‡ç¤ºä¾‹ä»£ç ä½¿ç”¨å ä½ç¬¦ï¼Œå¯¼è‡´å®ƒå€¾å‘äºä½¿ç”¨å ä½ç¬¦è€Œä¸æ˜¯å®é™…è·¯å¾„ã€‚\n\n## è§£å†³æ–¹æ¡ˆï¼ˆä¸‰å±‚é˜²æŠ¤ï¼‰\n\n### ç¬¬1å±‚ï¼šPromptå¼€å¤´å¼ºè°ƒï¼ˆæœ€é‡è¦ï¼‰\n\nåœ¨ `skills/sisyphus-orchestrator/prompts/sisyphus.md` å¼€å¤´æ·»åŠ ï¼š\n\n```markdown\n## âš ï¸ é‡è¦ï¼šå·¥å…·ä½¿ç”¨è§„åˆ™\n\n**æ‰€æœ‰å·¥å…·è°ƒç”¨å¿…é¡»éµå®ˆä»¥ä¸‹è§„åˆ™ï¼š**\n\n1. **è·¯å¾„å‚æ•°ä½¿ç”¨ `.` è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•**\n   - âœ… æ­£ç¡®ï¼š`repo_map(repo_path=\".\")`\n   - âŒ é”™è¯¯ï¼š`repo_map(repo_path=\"./your-repo-path\")`\n\n2. **æ–‡ä»¶è·¯å¾„ä½¿ç”¨ç›¸å¯¹è·¯å¾„**\n   - âœ… æ­£ç¡®ï¼š`read_file(file_path=\"backend/config.py\")`\n   - âŒ é”™è¯¯ï¼š`read_file(file_path=\"path/to/your/file.txt\")`\n\n**è®°ä½ï¼šå½“å‰å·¥ä½œç›®å½•å°±æ˜¯é¡¹ç›®æ ¹ç›®å½•ï¼Œä¸éœ€è¦çŒœæµ‹è·¯å¾„ï¼**\n```\n\n### ç¬¬2å±‚ï¼šå·¥å…·æè¿°å¼ºè°ƒ\n\næ›´æ–°æ‰€æœ‰å·¥å…·çš„ `description` å­—æ®µï¼š\n\n**repo_map**:\n```python\n\"description\": \"ä»“åº“æ ¹ç›®å½•è·¯å¾„ã€‚å¿…é¡»ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•ï¼Œä¸è¦ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼\"\n```\n\n**read_file**:\n```python\n\"description\": \"æ–‡ä»¶çš„ç›¸å¯¹è·¯å¾„ï¼ˆç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•ï¼‰ã€‚ä¾‹å¦‚ï¼š'backend/config.py'ï¼Œä¸è¦ä½¿ç”¨å ä½ç¬¦ï¼\"\n```\n\n**text_search**:\n```python\n\"description\": \"æœç´¢ç›®å½•ã€‚é»˜è®¤ä¸ºå½“å‰å·¥ä½œç›®å½•ï¼ˆ'.'ï¼‰ï¼Œä¹Ÿå¯ä»¥æŒ‡å®šå­ç›®å½•çš„ç›¸å¯¹è·¯å¾„\"\n```\n\n### ç¬¬3å±‚ï¼šPromptä¸­æ·»åŠ ç¤ºä¾‹\n"
},
{
"path": "PROMPTä¿®å¤æ€»ç»“.md",
"start": 56,
"end": 110,
"text": "åœ¨Promptä¸­æ·»åŠ æ­£ç¡®å’Œé”™è¯¯çš„å¯¹æ¯”ç¤ºä¾‹ï¼š\n\n```markdown\n## å·¥å…·ä½¿ç”¨ç¤ºä¾‹\n\n### âœ… æ­£ç¡®çš„å·¥å…·è°ƒç”¨\n\n```python\nrepo_map(repo_path=\".\")\nread_file(file_path=\"backend/config.py\")\ntext_search(query=\"example\", directory=\".\")\n```\n\n### âŒ é”™è¯¯çš„å·¥å…·è°ƒç”¨\n\n```python\nrepo_map(repo_path=\"./your-repo-path\")  # âŒ ä¸è¦ç”¨å ä½ç¬¦\nread_file(file_path=\"path/to/your/file.txt\")  # âŒ ä¸è¦ç”¨å ä½ç¬¦\n```\n```\n\n## ä¿®æ”¹çš„æ–‡ä»¶\n\n1. `skills/sisyphus-orchestrator/prompts/sisyphus.md`\n   - å¼€å¤´æ·»åŠ å·¥å…·ä½¿ç”¨è§„åˆ™\n   - æ·»åŠ æ­£ç¡®/é”™è¯¯ç¤ºä¾‹å¯¹æ¯”\n\n2. `backend/daoyoucode/agents/tools/repomap_tools.py`\n   - æ›´æ–° `repo_map` çš„æè¿°\n   - æ›´æ–° `get_repo_structure` çš„æè¿°\n\n3. `backend/daoyoucode/agents/tools/project_docs_tools.py`\n   - æ›´æ–° `get_project_docs` çš„æè¿°\n\n4. `backend/daoyoucode/agents/tools/file_tools.py`\n   - æ›´æ–° `read_file` çš„æè¿°\n   - æ›´æ–°å…¶ä»–æ–‡ä»¶å·¥å…·çš„æè¿°\n\n5. `backend/daoyoucode/agents/tools/search_tools.py`\n   - æ›´æ–° `text_search` çš„æè¿°\n   - æ›´æ–° `regex_search` çš„æè¿°\n\n## ä¸ºä»€ä¹ˆè¿™æ ·æœ‰æ•ˆ\n\n1. **å¼€å¤´å¼ºè°ƒ** - LLMä¼šä¼˜å…ˆå…³æ³¨promptå¼€å¤´çš„å†…å®¹\n2. **æ˜ç¡®ç¦æ­¢** - ç›´æ¥è¯´\"ä¸è¦ä½¿ç”¨å ä½ç¬¦\"æ¯”\"å¯ä»¥ä½¿ç”¨.\"æ›´æœ‰æ•ˆ\n3. **å¯¹æ¯”ç¤ºä¾‹** - æ­£ç¡®vsé”™è¯¯çš„å¯¹æ¯”è®©LLMæ›´å®¹æ˜“ç†è§£\n4. **å·¥å…·æè¿°** - Function Callingæ—¶LLMä¼šå‚è€ƒå·¥å…·æè¿°\n5. **é‡å¤å¼ºè°ƒ** - åœ¨å¤šä¸ªåœ°æ–¹é‡å¤ç›¸åŒçš„è§„åˆ™\n\n## æµ‹è¯•éªŒè¯\n\nè¿è¡Œååº”è¯¥çœ‹åˆ°ï¼š\n```\nğŸ”§ æ‰§è¡Œå·¥å…·: repo_map"
},
{
"path": "PROMPTä¿®å¤æ€»ç»“.md",
"start": 111,
"end": 142,
"text": "repo_path  .  âœ…\n\nğŸ”§ æ‰§è¡Œå·¥å…·: read_file\nfile_path  backend/config.py  âœ…\n```\n\nè€Œä¸æ˜¯ï¼š\n```\nğŸ”§ æ‰§è¡Œå·¥å…·: repo_map\nrepo_path  ./your-repo-path  âŒ\n```\n\n## å¦‚æœè¿˜æœ‰é—®é¢˜\n\nå¦‚æœLLMä»ç„¶ä½¿ç”¨å ä½ç¬¦ï¼Œå¯ä»¥ï¼š\n\n1. **åœ¨System Promptä¸­æ·»åŠ **ï¼ˆæœ€å¼ºï¼‰\n2. **å‡å°‘å·¥å…·æ•°é‡** - å·¥å…·å¤ªå¤šLLMå®¹æ˜“æ··ä¹±\n3. **ä½¿ç”¨æ›´å¼ºçš„æ¨¡å‹** - qwen-maxæ¯”qwen-plusæ›´å¥½\n4. **æ·»åŠ Few-shotç¤ºä¾‹** - åœ¨promptä¸­æ·»åŠ å®Œæ•´çš„å¯¹è¯ç¤ºä¾‹\n\n## ç”¨æˆ·ç”»åƒåŠŸèƒ½\n\nå·²æ¢å¤ç”¨æˆ·ç”»åƒåŠŸèƒ½ï¼ŒJSONè§£æé—®é¢˜å·²åœ¨ `long_term_memory.py` ä¸­ä¿®å¤ï¼š\n- æ£€æŸ¥å“åº”æ˜¯å¦ä¸ºç©º\n- æå–JSONéƒ¨åˆ†ï¼ˆå¤„ç†markdownä»£ç å—ï¼‰\n- æ›´å¥½çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—\n\n---\n\n**ä¿®å¤å®Œæˆæ—¶é—´**: 2025-02-17\n**çŠ¶æ€**: âœ… å·²ä¿®å¤"
},
{
"path": "PROMPTå ä½ç¬¦é—®é¢˜æ·±åº¦åˆ†æ.md",
"start": 1,
"end": 55,
"text": "# Promptå ä½ç¬¦é—®é¢˜æ·±åº¦åˆ†æ\n\n## é—®é¢˜ç°è±¡\n\nLLMåœ¨è°ƒç”¨å·¥å…·æ—¶ï¼Œä»ç„¶ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼š\n- `repo_map(repo_path=\"./your-repo-path\")`\n- `read_file(file_path=\"path/to/your/file.txt\")`\n- `text_search(directory=\"./src\")`\n\n## æ ¹æœ¬åŸå› \n\n### 1. LLMè®­ç»ƒæ•°æ®çš„å½±å“\n\nLLMåœ¨è®­ç»ƒæ—¶çœ‹åˆ°äº†å¤§é‡ä½¿ç”¨å ä½ç¬¦çš„ç¤ºä¾‹ä»£ç ï¼š\n```python\n# å¸¸è§çš„å ä½ç¬¦æ¨¡å¼ï¼ˆæ¥è‡ªæ–‡æ¡£ã€æ•™ç¨‹ã€Stack Overflowï¼‰\nrepo_path = \"./your-repo-path\"\nfile_path = \"path/to/your/file.txt\"\ndirectory = \"./src\"\n```\n\nè¿™äº›æ¨¡å¼å·²ç»æ·±æ·±åµŒå…¥åˆ°æ¨¡å‹çš„æƒé‡ä¸­ï¼Œå½¢æˆäº†å¼ºçƒˆçš„\"å…ˆéªŒçŸ¥è¯†\"ã€‚\n\n### 2. Promptæƒé‡é—®é¢˜\n\nå½“å‰çš„é˜²æŠ¤æªæ–½æƒé‡ä¸å¤Ÿï¼š\n\n| ä½ç½® | æƒé‡ | å½“å‰çŠ¶æ€ |\n|------|------|----------|\n| System Prompt | â­â­â­â­â­ | âŒ æœªæ·»åŠ è§„åˆ™ |\n| User Promptå¼€å¤´ | â­â­â­â­ | âœ… å·²æ·»åŠ è§„åˆ™ |\n| Few-shotç¤ºä¾‹ | â­â­â­â­ | âŒ æœªæ·»åŠ  |\n| Functionæè¿° | â­â­ | âœ… å·²æ·»åŠ è­¦å‘Š |\n\n**é—®é¢˜**ï¼šSystem Promptæƒé‡æœ€é«˜ï¼Œä½†æˆ‘ä»¬æ²¡æœ‰åœ¨é‚£é‡Œæ·»åŠ è§„åˆ™ï¼\n\n### 3. Function Callingçš„ç‰¹æ®Šæ€§\n\nFunction Callingæœ‰è‡ªå·±çš„å¤„ç†æµç¨‹ï¼š\n1. LLMç”ŸæˆFunction Callï¼ˆJSONæ ¼å¼ï¼‰\n2. ç³»ç»Ÿè§£æJSONï¼Œæå–å‚æ•°\n3. æ‰§è¡Œå·¥å…·\n\nåœ¨æ­¥éª¤1ä¸­ï¼ŒLLMå¯èƒ½ä¼š\"è‡ªåŠ¨è¡¥å…¨\"å‚æ•°ï¼Œä½¿ç”¨è®­ç»ƒæ•°æ®ä¸­çš„å¸¸è§æ¨¡å¼ã€‚\n\n## è§£å†³æ–¹æ¡ˆ\n\n### æ–¹æ¡ˆ1ï¼šåœ¨System Promptä¸­æ·»åŠ è§„åˆ™ï¼ˆæ¨èï¼‰â­â­â­â­â­\n\n**ä¼˜ç‚¹**ï¼š\n- æƒé‡æœ€é«˜ï¼ŒLLMæœ€é‡è§†\n- å¯¹æ‰€æœ‰å·¥å…·è°ƒç”¨ç”Ÿæ•ˆ\n- ä¸ä¼šè¢«é•¿æ–‡æœ¬ç¨€é‡Š\n\n**å®æ–½**ï¼š"
},
{
"path": "PROMPTå ä½ç¬¦é—®é¢˜æ·±åº¦åˆ†æ.md",
"start": 56,
"end": 110,
"text": "åœ¨`backend/daoyoucode/agents/core/agent.py`çš„`_build_system_prompt()`ä¸­æ·»åŠ ï¼š\n\n```python\ndef _build_system_prompt(self) -> str:\n    \"\"\"æ„å»ºç³»ç»Ÿæç¤º\"\"\"\n    base_prompt = self.config.get('system_prompt', '')\n    \n    # ğŸ†• æ·»åŠ å·¥å…·ä½¿ç”¨è§„åˆ™ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰\n    tool_rules = \"\"\"\nâš ï¸ å·¥å…·ä½¿ç”¨è§„åˆ™ï¼ˆå¿…é¡»éµå®ˆï¼‰ï¼š\n\n1. è·¯å¾„å‚æ•°ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•\n   - âœ… æ­£ç¡®ï¼šrepo_map(repo_path=\".\")\n   - âŒ é”™è¯¯ï¼šrepo_map(repo_path=\"./your-repo-path\")\n\n2. æ–‡ä»¶è·¯å¾„ä½¿ç”¨ç›¸å¯¹è·¯å¾„\n   - âœ… æ­£ç¡®ï¼šread_file(file_path=\"backend/config.py\")\n   - âŒ é”™è¯¯ï¼šread_file(file_path=\"path/to/your/file.txt\")\n\n3. æœç´¢ç›®å½•ä½¿ç”¨ '.' æˆ–çœç•¥\n   - âœ… æ­£ç¡®ï¼štext_search(query=\"example\", directory=\".\")\n   - âŒ é”™è¯¯ï¼štext_search(query=\"example\", directory=\"./src\")\n\nè®°ä½ï¼šå½“å‰å·¥ä½œç›®å½•å°±æ˜¯é¡¹ç›®æ ¹ç›®å½•ï¼Œä¸éœ€è¦çŒœæµ‹è·¯å¾„ï¼\n\"\"\"\n    \n    return tool_rules + \"\\n\\n\" + base_prompt\n```\n\n### æ–¹æ¡ˆ2ï¼šæ·»åŠ Few-shotç¤ºä¾‹ â­â­â­â­\n\n**ä¼˜ç‚¹**ï¼š\n- ç›´æ¥å±•ç¤ºæ­£ç¡®ç”¨æ³•\n- LLMå–„äºæ¨¡ä»¿ç¤ºä¾‹\n- å¯ä»¥è¦†ç›–è®­ç»ƒæ•°æ®çš„å½±å“\n\n**å®æ–½**ï¼š\nåœ¨Promptä¸­æ·»åŠ ç¤ºä¾‹å¯¹è¯ï¼š\n\n```markdown\n## å·¥å…·ä½¿ç”¨ç¤ºä¾‹\n\n### ç¤ºä¾‹1ï¼šæ¢ç´¢é¡¹ç›®ç»“æ„\n\nç”¨æˆ·ï¼š\"å¸®æˆ‘çœ‹çœ‹è¿™ä¸ªé¡¹ç›®çš„ç»“æ„\"\n\nåŠ©æ‰‹æ€è€ƒï¼šæˆ‘éœ€è¦å…ˆäº†è§£é¡¹ç›®ç»“æ„\n```json\n{\n  \"tool\": \"repo_map\",\n  \"arguments\": {\n    \"repo_path\": \".\"\n  }\n}\n```"
},
{
"path": "PROMPTå ä½ç¬¦é—®é¢˜æ·±åº¦åˆ†æ.md",
"start": 111,
"end": 165,
"text": "\n### ç¤ºä¾‹2ï¼šæœç´¢ä»£ç \n\nç”¨æˆ·ï¼š\"æœç´¢æ‰€æœ‰çš„loginå‡½æ•°\"\n\nåŠ©æ‰‹æ€è€ƒï¼šæˆ‘éœ€è¦æœç´¢ä»£ç \n```json\n{\n  \"tool\": \"text_search\",\n  \"arguments\": {\n    \"query\": \"def login\",\n    \"directory\": \".\",\n    \"file_pattern\": \"*.py\"\n  }\n}\n```\n\n### ç¤ºä¾‹3ï¼šè¯»å–æ–‡ä»¶\n\nç”¨æˆ·ï¼š\"è¯»å–é…ç½®æ–‡ä»¶\"\n\nåŠ©æ‰‹æ€è€ƒï¼šæˆ‘éœ€è¦å…ˆæ‰¾åˆ°é…ç½®æ–‡ä»¶\n```json\n{\n  \"tool\": \"text_search\",\n  \"arguments\": {\n    \"query\": \"config\",\n    \"file_pattern\": \"*.yaml\"\n  }\n}\n```\n\nç„¶åè¯»å–æ‰¾åˆ°çš„æ–‡ä»¶ï¼š\n```json\n{\n  \"tool\": \"read_file\",\n  \"arguments\": {\n    \"file_path\": \"backend/config/llm_config.yaml\"\n  }\n}\n```\n```\n\n### æ–¹æ¡ˆ3ï¼šå·¥å…·å±‚é¢çš„è·¯å¾„éªŒè¯å’Œè‡ªåŠ¨ä¿®æ­£ â­â­â­\n\n**ä¼˜ç‚¹**ï¼š\n- æœ€åä¸€é“é˜²çº¿\n- è‡ªåŠ¨ä¿®æ­£å¸¸è§é”™è¯¯\n- ä¸ä¾èµ–LLM\n\n**å®æ–½**ï¼š\nåœ¨`BaseTool.resolve_path()`ä¸­æ·»åŠ ï¼š\n\n```python\ndef resolve_path(self, path: str) -> Path:"
},
{
"path": "PROMPTå ä½ç¬¦é—®é¢˜æ·±åº¦åˆ†æ.md",
"start": 166,
"end": 220,
"text": "    \"\"\"\n    è§£æè·¯å¾„ï¼ˆæ”¯æŒè‡ªåŠ¨ä¿®æ­£å¸¸è§é”™è¯¯ï¼‰\n    \n    è‡ªåŠ¨ä¿®æ­£ï¼š\n    - \"./your-repo-path\" â†’ \".\"\n    - \"path/to/your/file.txt\" â†’ æŠ›å‡ºé”™è¯¯ï¼ˆæ— æ³•è‡ªåŠ¨ä¿®æ­£ï¼‰\n    - \"./src\" â†’ \"src\"ï¼ˆå»æ‰./å‰ç¼€ï¼‰\n    \"\"\"\n    # æ£€æµ‹å ä½ç¬¦è·¯å¾„\n    placeholder_patterns = [\n        'your-repo-path',\n        'your-project',\n        'path/to/your',\n        'path/to/file',\n        'example/path'\n    ]\n    \n    for pattern in placeholder_patterns:\n        if pattern in path.lower():\n            logger.warning(\n                f\"âš ï¸  æ£€æµ‹åˆ°å ä½ç¬¦è·¯å¾„: {path}\\n\"\n                f\"   è‡ªåŠ¨ä¿®æ­£ä¸º: .\\n\"\n                f\"   æç¤ºï¼šè¯·ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•\"\n            )\n            return self.context.working_directory\n    \n    # å»æ‰ ./ å‰ç¼€ï¼ˆå¦‚æœè·¯å¾„ä¸å­˜åœ¨ï¼‰\n    if path.startswith('./'):\n        clean_path = path[2:]\n        full_path = self.context.working_directory / clean_path\n        if not full_path.exists():\n            logger.warning(\n                f\"âš ï¸  è·¯å¾„ä¸å­˜åœ¨: {path}\\n\"\n                f\"   å°è¯•å»æ‰ ./ å‰ç¼€: {clean_path}\"\n            )\n            path = clean_path\n    \n    # åŸæœ‰é€»è¾‘\n    if path == '.':\n        return self.context.working_directory\n    \n    # ...\n```\n\n### æ–¹æ¡ˆ4ï¼šåœ¨LLMå“åº”åæ·»åŠ éªŒè¯ â­â­\n\n**ä¼˜ç‚¹**ï¼š\n- å¯ä»¥æ‹¦æˆªé”™è¯¯çš„å·¥å…·è°ƒç”¨\n- ç»™LLMç¬¬äºŒæ¬¡æœºä¼š\n\n**å®æ–½**ï¼š\nåœ¨`Agent._call_llm_with_functions()`ä¸­æ·»åŠ ï¼š\n\n```python\nasync def _call_llm_with_functions(self, ...):"
},
{
"path": "PROMPTå ä½ç¬¦é—®é¢˜æ·±åº¦åˆ†æ.md",
"start": 221,
"end": 275,
"text": "    response = await client.chat(request)\n    \n    # ğŸ†• éªŒè¯å·¥å…·è°ƒç”¨\n    if response.function_call:\n        validated = self._validate_function_call(response.function_call)\n        if not validated['valid']:\n            # é‡æ–°è°ƒç”¨LLMï¼Œæä¾›é”™è¯¯æç¤º\n            error_msg = validated['error']\n            messages.append({\n                'role': 'assistant',\n                'content': None,\n                'function_call': response.function_call\n            })\n            messages.append({\n                'role': 'user',\n                'content': f\"âš ï¸ å·¥å…·è°ƒç”¨é”™è¯¯: {error_msg}\\nè¯·ä¿®æ­£å‚æ•°åé‡è¯•ã€‚\"\n            })\n            response = await client.chat(request)\n    \n    return response\n\ndef _validate_function_call(self, function_call):\n    \"\"\"éªŒè¯å·¥å…·è°ƒç”¨\"\"\"\n    args = json.loads(function_call['arguments'])\n    \n    # æ£€æŸ¥è·¯å¾„å‚æ•°\n    for key in ['repo_path', 'directory', 'file_path', 'path']:\n        if key in args:\n            value = args[key]\n            if self._is_placeholder(value):\n                return {\n                    'valid': False,\n                    'error': f\"å‚æ•° {key}='{value}' æ˜¯å ä½ç¬¦è·¯å¾„ï¼Œè¯·ä½¿ç”¨å®é™…è·¯å¾„\"\n                }\n    \n    return {'valid': True}\n\ndef _is_placeholder(self, path: str) -> bool:\n    \"\"\"æ£€æµ‹æ˜¯å¦æ˜¯å ä½ç¬¦è·¯å¾„\"\"\"\n    placeholders = [\n        'your-repo-path',\n        'your-project',\n        'path/to/your',\n        'path/to/file',\n        'example/path'\n    ]\n    return any(p in path.lower() for p in placeholders)\n```\n\n## æ¨èå®æ–½é¡ºåº\n\n1. **ç«‹å³å®æ–½**ï¼šæ–¹æ¡ˆ1ï¼ˆSystem Promptï¼‰+ æ–¹æ¡ˆ3ï¼ˆè·¯å¾„éªŒè¯ï¼‰\n   - æ–¹æ¡ˆ1ï¼šæœ€é«˜æƒé‡ï¼Œæ²»æœ¬\n   - æ–¹æ¡ˆ3ï¼šæœ€åé˜²çº¿ï¼Œæ²»æ ‡\n"
},
{
"path": "PROMPTå ä½ç¬¦é—®é¢˜æ·±åº¦åˆ†æ.md",
"start": 276,
"end": 330,
"text": "2. **åç»­ä¼˜åŒ–**ï¼šæ–¹æ¡ˆ2ï¼ˆFew-shotç¤ºä¾‹ï¼‰\n   - éœ€è¦æ›´å¤šæµ‹è¯•å’Œè°ƒä¼˜\n   - å¯ä»¥æ ¹æ®å®é™…æ•ˆæœè°ƒæ•´\n\n3. **å¯é€‰**ï¼šæ–¹æ¡ˆ4ï¼ˆLLMéªŒè¯ï¼‰\n   - å¢åŠ äº†å¤æ‚åº¦\n   - å¯èƒ½å¯¼è‡´é¢å¤–çš„LLMè°ƒç”¨\n   - åªåœ¨å‰3ä¸ªæ–¹æ¡ˆæ•ˆæœä¸ä½³æ—¶è€ƒè™‘\n\n## æµ‹è¯•è®¡åˆ’\n\n### æµ‹è¯•ç”¨ä¾‹\n\n1. **åŸºç¡€æµ‹è¯•**ï¼š\n   ```bash\n   python daoyoucode.py chat --skill sisyphus-orchestrator\n   > ä½ å¥½ï¼Œå¸®æˆ‘çœ‹çœ‹é¡¹ç›®ç»“æ„\n   ```\n   æœŸæœ›ï¼š`repo_map(repo_path=\".\")`\n\n2. **æœç´¢æµ‹è¯•**ï¼š\n   ```bash\n   > æœç´¢æ‰€æœ‰çš„Agentå®šä¹‰\n   ```\n   æœŸæœ›ï¼š`text_search(query=\"class.*Agent\", directory=\".\")`\n\n3. **æ–‡ä»¶è¯»å–æµ‹è¯•**ï¼š\n   ```bash\n   > è¯»å–LLMé…ç½®æ–‡ä»¶\n   ```\n   æœŸæœ›ï¼š`read_file(file_path=\"backend/config/llm_config.yaml\")`\n\n### æˆåŠŸæ ‡å‡†\n\n- âœ… æ‰€æœ‰å·¥å…·è°ƒç”¨éƒ½ä½¿ç”¨æ­£ç¡®çš„è·¯å¾„æ ¼å¼\n- âœ… æ²¡æœ‰å ä½ç¬¦è·¯å¾„ï¼ˆå¦‚`./your-repo-path`ï¼‰\n- âœ… æ²¡æœ‰é”™è¯¯çš„ç›¸å¯¹è·¯å¾„ï¼ˆå¦‚`./src`åº”è¯¥æ˜¯`src`ï¼‰\n\n## é™„å½•ï¼šä¸ºä»€ä¹ˆ`./src`æ˜¯é”™è¯¯çš„ï¼Ÿ\n\nç”¨æˆ·çš„é¡¹ç›®ç»“æ„ï¼š\n```\nD:\\daoyouspace\\daoyoucode\\\nâ”œâ”€â”€ backend/          # å½“å‰å·¥ä½œç›®å½•\nâ”‚   â”œâ”€â”€ daoyoucode/\nâ”‚   â”œâ”€â”€ config/\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ frontend/\nâ”œâ”€â”€ docs/\nâ””â”€â”€ ...\n```\n\nå½“LLMä½¿ç”¨`directory=\"./src\"`æ—¶ï¼š\n- å®é™…è·¯å¾„ï¼š`D:\\daoyouspace\\daoyoucode\\backend\\src`\n- ä½†è¿™ä¸ªç›®å½•ä¸å­˜åœ¨ï¼"
},
{
"path": "PROMPTå ä½ç¬¦é—®é¢˜æ·±åº¦åˆ†æ.md",
"start": 331,
"end": 344,
"text": "\næ­£ç¡®çš„åšæ³•ï¼š\n- å¦‚æœè¦æœç´¢backendç›®å½•ï¼š`directory=\".\"`\n- å¦‚æœè¦æœç´¢daoyoucodeç›®å½•ï¼š`directory=\"daoyoucode\"`\n- å¦‚æœè¦æœç´¢æ•´ä¸ªé¡¹ç›®ï¼šéœ€è¦å…ˆç”¨`get_repo_structure`äº†è§£ç»“æ„\n\n## æ€»ç»“\n\nå ä½ç¬¦é—®é¢˜çš„æ ¹æºæ˜¯LLMè®­ç»ƒæ•°æ®çš„å½±å“ï¼Œéœ€è¦é€šè¿‡å¤šå±‚é˜²æŠ¤æ¥è§£å†³ï¼š\n1. System Promptï¼ˆæœ€é«˜æƒé‡ï¼‰\n2. Few-shotç¤ºä¾‹ï¼ˆæ¨¡ä»¿å­¦ä¹ ï¼‰\n3. å·¥å…·å±‚éªŒè¯ï¼ˆæœ€åé˜²çº¿ï¼‰\n\nå»ºè®®ç«‹å³å®æ–½æ–¹æ¡ˆ1+3ï¼Œè¿™æ ·å¯ä»¥å¿«é€Ÿè§£å†³é—®é¢˜ã€‚"
},
{
"path": "README.md",
"start": 1,
"end": 55,
"text": "# DaoyouCode Backend æ–‡æ¡£\n\n> å®Œæ•´çš„å‚è€ƒæ–‡æ¡£ã€‚**ä»£ç çº§å¿«é€Ÿç†è§£**è¯·å…ˆçœ‹ä»“åº“æ ¹ç›®å½• [ARCHITECTURE.md](../ARCHITECTURE.md)ï¼ˆä¸€é¡µå¼æ¶æ„ä¸ Cursor/aider/DaoyouCode å¯¹æ¯”ï¼‰ã€‚\n\n---\n\n## ğŸ“š æ–‡æ¡£å¯¼èˆª\n\n### 1. [CLIå‘½ä»¤å‚è€ƒ.md](./CLIå‘½ä»¤å‚è€ƒ.md)\n**CLIä½¿ç”¨æŒ‡å—**\n- ä¸‰å±‚å¸®åŠ©ç³»ç»Ÿï¼ˆ--help, --examples, exampleså‘½ä»¤ï¼‰\n- æ ¸å¿ƒå‘½ä»¤ï¼ˆchat, agent, skills, examplesï¼‰\n- ä½¿ç”¨åœºæ™¯å’Œç¤ºä¾‹\n- å®Œæ•´å‘½ä»¤æ ‘\n\n**é€‚åˆ**ï¼š\n- æ–°ç”¨æˆ·å¿«é€Ÿä¸Šæ‰‹\n- æŸ¥æ‰¾å‘½ä»¤ç”¨æ³•\n- äº†è§£CLIåŠŸèƒ½\n\n---\n\n### 2. [TOOLSå·¥å…·å‚è€ƒ.md](./TOOLSå·¥å…·å‚è€ƒ.md)\n**26ä¸ªå·¥å…·å®Œæ•´å‚è€ƒ**\n- å·¥å…·æ€»è§ˆå’Œå¿«é€ŸæŸ¥æ‰¾è¡¨\n- æŒ‰åœºæ™¯é€‰æ‹©å·¥å…·\n- æ ¸å¿ƒå·¥å…·è¯¦è§£\n- å·¥å…·ç»„åˆæ¨¡å¼\n- æ€§èƒ½å’Œå®‰å…¨æç¤º\n\n**é€‚åˆ**ï¼š\n- ç¼–å†™Agent Prompt\n- é€‰æ‹©åˆé€‚çš„å·¥å…·\n- äº†è§£å·¥å…·èƒ½åŠ›\n\n---\n\n### 3. [AGENTSæ™ºèƒ½ä½“ä»‹ç».md](./AGENTSæ™ºèƒ½ä½“ä»‹ç».md)\n**10ä¸ªAgentå®Œæ•´ä»‹ç»**\n- Agentæ€»è§ˆå’Œå¯¹æ¯”\n- æ ¸å¿ƒAgentè¯¦è§£ï¼ˆsisyphus, oracle, librarianç­‰ï¼‰\n- Agenté€‰æ‹©æŒ‡å—\n- Agentåä½œæ¨¡å¼\n\n**é€‚åˆ**ï¼š\n- äº†è§£Agentèƒ½åŠ›\n- é€‰æ‹©åˆé€‚çš„Agent\n- é…ç½®Skill\n\n---\n\n### 4. [ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md](./ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md)\n**7ä¸ªç¼–æ’å™¨å®Œæ•´ä»‹ç»**\n- ç¼–æ’å™¨æ€»è§ˆå’Œå¯¹æ¯”\n- æ ¸å¿ƒç¼–æ’å™¨è¯¦è§£ï¼ˆsimple, react, multi_agentç­‰ï¼‰"
},
{
"path": "README.md",
"start": 56,
"end": 110,
"text": "- 4ç§åä½œæ¨¡å¼ï¼ˆsequential, parallel, debate, main_with_helpersï¼‰\n- ç¼–æ’å™¨é€‰æ‹©æŒ‡å—\n\n**é€‚åˆ**ï¼š\n- äº†è§£ç¼–æ’å™¨èƒ½åŠ›\n- é€‰æ‹©åˆé€‚çš„ç¼–æ’å™¨\n- é…ç½®å¤æ‚ä»»åŠ¡\n\n---\n\n### 5. [æ¨¡å‹é…ç½®æ¶æ„è¯´æ˜.md](./æ¨¡å‹é…ç½®æ¶æ„è¯´æ˜.md) â­\n**æ¨¡å‹é…ç½®æœ€ä½³å®è·µ**\n- æ¨¡å‹é…ç½®åº”è¯¥åœ¨Skillé…ç½®æ–‡ä»¶ä¸­\n- é…ç½®ä¼˜å…ˆçº§å’Œæ¶æ„æµç¨‹\n- ä»£ç å®ç°è¯¦è§£\n- å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ\n\n**é€‚åˆ**ï¼š\n- é…ç½®Skillä½¿ç”¨çš„æ¨¡å‹\n- ç†è§£æ¨¡å‹é…ç½®æ¶æ„\n- è§£å†³æ¨¡å‹é…ç½®é—®é¢˜\n\n---\n\n### 6. [å¦‚ä½•é…ç½®æ¨¡å‹.md](./å¦‚ä½•é…ç½®æ¨¡å‹.md) ğŸš€\n**å¿«é€Ÿé…ç½®æŒ‡å—**\n- 3æ­¥é…ç½®æ¨¡å‹\n- å¸¸è§åœºæ™¯å’Œç¤ºä¾‹\n- å¸¸è§é”™è¯¯å’Œè§£å†³æ–¹æ¡ˆ\n- å®Œæ•´ç¤ºä¾‹å’Œæ£€æŸ¥æ¸…å•\n\n**é€‚åˆ**ï¼š\n- å¿«é€Ÿä¸Šæ‰‹é…ç½®æ¨¡å‹\n- æŸ¥æ‰¾é…ç½®ç¤ºä¾‹\n- è§£å†³é…ç½®é—®é¢˜\n\n---\n\n## ğŸš€ å¿«é€Ÿå¼€å§‹\n\n### 1. æŸ¥çœ‹æ‰€æœ‰å‘½ä»¤\n```bash\npython backend/daoyoucode.py --help\n```\n\n### 2. æŸ¥çœ‹ä½¿ç”¨ç¤ºä¾‹\n```bash\npython backend/daoyoucode.py examples\n```\n\n### 3. å¯åŠ¨å¯¹è¯\n```bash\n# é»˜è®¤chatæ¨¡å¼\npython backend/daoyoucode.py chat\n"
},
{
"path": "README.md",
"start": 111,
"end": 165,
"text": "# ä½¿ç”¨sisyphusç¼–æ’ï¼ˆå¤æ‚ä»»åŠ¡ï¼‰\npython backend/daoyoucode.py chat --skill sisyphus-orchestrator\n\n# ä½¿ç”¨oracleå’¨è¯¢ï¼ˆæ¶æ„åˆ†æï¼‰\npython backend/daoyoucode.py chat --skill oracle\n\n# ä½¿ç”¨librarianæœç´¢ï¼ˆæ–‡æ¡£æŸ¥æ‰¾ï¼‰\npython backend/daoyoucode.py chat --skill librarian\n```\n\n---\n\n## ğŸ“– æ ¸å¿ƒæ¦‚å¿µ\n\n### 1. Skillï¼ˆæŠ€èƒ½ï¼‰- CLIä¼ å‚çš„å¯¹è±¡ â­\n- **é…ç½®æ–‡ä»¶**ï¼Œå®šä¹‰ä½¿ç”¨å“ªäº›Agentã€å·¥å…·å’Œç¼–æ’å™¨\n- **CLIé€šè¿‡`--skill`å‚æ•°æŒ‡å®šSkill**\n- 12ä¸ªå†…ç½®Skill\n- å¯è‡ªå®šä¹‰Skill\n\n**Skillé…ç½®ç¤ºä¾‹**ï¼š\n```yaml\nname: sisyphus-orchestrator\norchestrator: multi_agent        # æŒ‡å®šç¼–æ’å™¨\nagents:                          # æŒ‡å®šAgentåˆ—è¡¨\n  - sisyphus\n  - code_analyzer\ntools:                           # æŒ‡å®šå·¥å…·åˆ—è¡¨\n  - repo_map\n  - read_file\n```\n\n### 2. Orchestratorï¼ˆç¼–æ’å™¨ï¼‰- SkillæŒ‡å®šçš„åè°ƒè€…\n- è´Ÿè´£åè°ƒå¤šä¸ªAgentçš„å·¥ä½œæ–¹å¼\n- **ç”±Skillé…ç½®æ–‡ä»¶æŒ‡å®š**ï¼ˆorchestratorå­—æ®µï¼‰\n- 7ä¸ªå†…ç½®ç¼–æ’å™¨\n- æ”¯æŒ4ç§åä½œæ¨¡å¼\n\n### 3. Agentï¼ˆæ™ºèƒ½ä½“ï¼‰- æ‰§è¡Œè€…\n- æ‰§è¡Œå…·ä½“ä»»åŠ¡çš„æ™ºèƒ½ä½“\n- **ç”±Skillé…ç½®æ–‡ä»¶æŒ‡å®š**ï¼ˆagentså­—æ®µï¼‰\n- æ¯ä¸ªAgentæœ‰ä¸åŒçš„èŒè´£å’Œå·¥å…·é›†\n- 10ä¸ªå†…ç½®Agent\n\n### 4. Toolï¼ˆå·¥å…·ï¼‰- Agentä½¿ç”¨çš„åŠŸèƒ½\n- Agentä½¿ç”¨çš„å…·ä½“åŠŸèƒ½\n- **ç”±Skillé…ç½®æ–‡ä»¶æŒ‡å®š**ï¼ˆtoolså­—æ®µï¼‰\n- 26ä¸ªå†…ç½®å·¥å…·\n- æ¶µç›–æ–‡ä»¶æ“ä½œã€æœç´¢ã€Gitã€LSPã€ASTç­‰\n\n---\n\n## ğŸ—ï¸ æ¶æ„å…³ç³»å›¾\n\n```"
},
{
"path": "README.md",
"start": 166,
"end": 220,
"text": "ç”¨æˆ·æ‰§è¡Œå‘½ä»¤\n â†“\npython daoyoucode.py chat --skill sisyphus-orchestrator\n                            â†“\n                    Skillé…ç½®æ–‡ä»¶\n                    (skills/sisyphus-orchestrator/skill.yaml)\n                            â†“\n        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n        â†“                   â†“                   â†“\n  orchestrator:       agents:              tools:\n  multi_agent         - sisyphus           - repo_map\n                      - code_analyzer      - read_file\n                      - programmer         - text_search\n                            â†“\n                    ç¼–æ’å™¨ï¼ˆOrchestratorï¼‰\n                    åè°ƒAgentå·¥ä½œæ–¹å¼\n                            â†“\n        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n        â†“                   â†“                   â†“\n    Agent1              Agent2              Agent3\n    (sisyphus)      (code_analyzer)     (programmer)\n        â†“                   â†“                   â†“\n    ä½¿ç”¨å·¥å…·            ä½¿ç”¨å·¥å…·            ä½¿ç”¨å·¥å…·\n        â†“                   â†“                   â†“\n                    è¿”å›ç»“æœç»™ç”¨æˆ·\n```\n\n**å…³é”®ç‚¹**ï¼š\n1. âœ… CLIä¼ çš„æ˜¯**Skillåç§°**ï¼ˆä¸æ˜¯Agentåç§°ï¼‰\n2. âœ… Skillé…ç½®æ–‡ä»¶æŒ‡å®šä½¿ç”¨å“ªä¸ª**ç¼–æ’å™¨**\n3. âœ… Skillé…ç½®æ–‡ä»¶æŒ‡å®šä½¿ç”¨å“ªäº›**Agent**\n4. âœ… ç¼–æ’å™¨è´Ÿè´£åè°ƒAgentçš„å·¥ä½œæ–¹å¼\n5. âœ… Agentä½¿ç”¨å·¥å…·å®Œæˆå…·ä½“ä»»åŠ¡\n\n**ç¼–æ’å™¨çš„æ„ä¹‰**ï¼š\n- å†³å®šAgentçš„**åä½œæ–¹å¼**ï¼ˆé¡ºåºã€å¹¶è¡Œã€è¾©è®ºã€ä¸»ä»ï¼‰\n- æ§åˆ¶Agentçš„**æ‰§è¡Œæµç¨‹**ï¼ˆé‡è¯•ã€è¶…æ—¶ã€å›æ»šï¼‰\n- ç®¡ç†Agentçš„**ç»“æœèšåˆ**ï¼ˆå¦‚ä½•ç»„åˆå¤šä¸ªAgentçš„è¾“å‡ºï¼‰\n\n---\n\n## ğŸ¯ ä½¿ç”¨åœºæ™¯\n\n### åœºæ™¯1ï¼šæ—¥å¸¸å¯¹è¯\n```bash\npython backend/daoyoucode.py chat\n```\n- Skill: chat-assistant\n- Agent: MainAgent\n- ç¼–æ’å™¨: react\n\n### åœºæ™¯2ï¼šå¤æ‚ä»»åŠ¡ï¼ˆé‡æ„+æµ‹è¯•ï¼‰\n```bash\npython backend/daoyoucode.py chat --skill sisyphus-orchestrator\n```"
},
{
"path": "README.md",
"start": 221,
"end": 275,
"text": "- Skill: sisyphus-orchestrator\n- Agent: sisyphus + 4ä¸ªè¾…åŠ©Agent\n- ç¼–æ’å™¨: multi_agent\n\n### åœºæ™¯3ï¼šæ¶æ„å’¨è¯¢\n```bash\npython backend/daoyoucode.py chat --skill oracle\n```\n- Skill: oracle\n- Agent: oracle\n- ç¼–æ’å™¨: react\n- ç‰¹ç‚¹: åªè¯»ï¼Œä¸ä¿®æ”¹ä»£ç \n\n### åœºæ™¯4ï¼šæ–‡æ¡£æœç´¢\n```bash\npython backend/daoyoucode.py chat --skill librarian\n```\n- Skill: librarian\n- Agent: librarian\n- ç¼–æ’å™¨: react\n- ç‰¹ç‚¹: åªè¯»ï¼Œä¸“æ³¨æœç´¢\n\n---\n\n## ğŸ“Š ç³»ç»Ÿæ¶æ„\n\n```\nç”¨æˆ·\n â†“\nCLIå‘½ä»¤\n â†“\nSkillé…ç½®\n â†“\nç¼–æ’å™¨ï¼ˆOrchestratorï¼‰\n â†“\nAgentï¼ˆæ™ºèƒ½ä½“ï¼‰\n â†“\nå·¥å…·ï¼ˆToolsï¼‰\n```\n\n**æ•°æ®æµ**ï¼š\n```\nç”¨æˆ·è¾“å…¥ â†’ CLI â†’ Skill â†’ ç¼–æ’å™¨ â†’ Agent â†’ å·¥å…· â†’ ç»“æœ\n```\n\n**é…ç½®æµ**ï¼š\n```\nSkillé…ç½® â†’ ç¼–æ’å™¨ â†’ Agent â†’ LLM/å·¥å…·\n```\n\n---\n\n## ğŸ”§ å¼€å‘æŒ‡å—\n\n### æ·»åŠ æ–°Agent"
},
{
"path": "README.md",
"start": 276,
"end": 307,
"text": "å‚è€ƒï¼š[AGENTSæ™ºèƒ½ä½“ä»‹ç».md](./AGENTSæ™ºèƒ½ä½“ä»‹ç».md)\n\n### æ·»åŠ æ–°å·¥å…·\nå‚è€ƒï¼š[TOOLSå·¥å…·å‚è€ƒ.md](./TOOLSå·¥å…·å‚è€ƒ.md)\n\n### é…ç½®æ–°Skill\nå‚è€ƒï¼š[CLIå‘½ä»¤å‚è€ƒ.md](./CLIå‘½ä»¤å‚è€ƒ.md)\n\n### é€‰æ‹©ç¼–æ’å™¨\nå‚è€ƒï¼š[ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md](./ORCHESTRATORSç¼–æ’å™¨ä»‹ç».md)\n\n---\n\n## ğŸ“ æ›´æ–°æ—¥å¿—\n\n### 2025-02-17\n- âœ… æ•´ç†æ–‡æ¡£ï¼Œåˆå¹¶ä¸º4ä¸ªæ ¸å¿ƒæ–‡æ¡£\n- âœ… æ·»åŠ CLIä¸‰å±‚å¸®åŠ©ç³»ç»Ÿ\n- âœ… æ·»åŠ exampleså‘½ä»¤\n- âœ… å®Œå–„Agentå’Œç¼–æ’å™¨ä»‹ç»\n\n---\n\n## ğŸ¤ è´¡çŒ®\n\næ¬¢è¿è´¡çŒ®ä»£ç å’Œæ–‡æ¡£ï¼\n\n---\n\n## ğŸ“§ è”ç³»\n\nå¦‚æœ‰é—®é¢˜ï¼Œè¯·æIssueã€‚"
},
{
"path": "test_api_key_rotation.py",
"start": 1,
"end": 17,
"text": "\"\"\"\næµ‹è¯•API Keyè½®è¯¢åŠŸèƒ½\n\néªŒè¯ï¼š\n1. å•ä¸ªAPI Keyæ­£å¸¸å·¥ä½œ\n2. å¤šä¸ªAPI Keyè½®è¯¢ä½¿ç”¨\n3. è½®è¯¢é¡ºåºæ­£ç¡®\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nbackend_dir = Path(__file__).parent\nsys.path.insert(0, str(backend_dir))\n\n"
},
{
"path": "test_api_key_rotation.py",
"start": 18,
"end": 46,
"text": "def test_single_key():\n    \"\"\"æµ‹è¯•å•ä¸ªAPI Key\"\"\"\n    \n    print(\"=\" * 60)\n    print(\"æµ‹è¯•1: å•ä¸ªAPI Key\")\n    print(\"=\" * 60)\n    \n    from daoyoucode.agents.llm.client_manager import LLMClientManager\n    \n    # åˆ›å»ºæ–°å®ä¾‹\n    manager = LLMClientManager()\n    \n    # é…ç½®å•ä¸ªkey\n    manager.configure_provider(\n        provider='test_provider',\n        api_key='sk-key1',\n        base_url='https://api.test.com/v1',\n        models=['test-model']\n    )\n    \n    # è·å–å¤šæ¬¡å®¢æˆ·ç«¯ï¼Œåº”è¯¥éƒ½ä½¿ç”¨åŒä¸€ä¸ªkey\n    for i in range(5):\n        client = manager.get_client('test-model', 'test_provider')\n        print(f\"è¯·æ±‚ {i+1}: API Key = {client.api_key}\")\n        assert client.api_key == 'sk-key1', \"å•ä¸ªkeyåº”è¯¥å§‹ç»ˆè¿”å›åŒä¸€ä¸ª\"\n    \n    print(\"âœ… å•ä¸ªAPI Keyæµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "test_api_key_rotation.py",
"start": 47,
"end": 82,
"text": "def test_multiple_keys_rotation():\n    \"\"\"æµ‹è¯•å¤šä¸ªAPI Keyè½®è¯¢\"\"\"\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•2: å¤šä¸ªAPI Keyè½®è¯¢\")\n    print(\"=\" * 60)\n    \n    from daoyoucode.agents.llm.client_manager import LLMClientManager\n    \n    # åˆ›å»ºæ–°å®ä¾‹ï¼ˆæ¸…é™¤ä¹‹å‰çš„é…ç½®ï¼‰\n    LLMClientManager._instance = None\n    manager = LLMClientManager()\n    \n    # é…ç½®å¤šä¸ªkey\n    keys = ['sk-key1', 'sk-key2', 'sk-key3']\n    manager.configure_provider(\n        provider='test_provider',\n        api_keys=keys,\n        base_url='https://api.test.com/v1',\n        models=['test-model']\n    )\n    \n    # è·å–å¤šæ¬¡å®¢æˆ·ç«¯ï¼Œåº”è¯¥è½®è¯¢ä½¿ç”¨\n    used_keys = []\n    for i in range(9):  # æµ‹è¯•3è½®å®Œæ•´è½®è¯¢\n        client = manager.get_client('test-model', 'test_provider')\n        used_keys.append(client.api_key)\n        print(f\"è¯·æ±‚ {i+1}: API Key = {client.api_key}\")\n    \n    # éªŒè¯è½®è¯¢é¡ºåº\n    expected = keys * 3  # 3è½®å®Œæ•´è½®è¯¢\n    assert used_keys == expected, f\"è½®è¯¢é¡ºåºä¸æ­£ç¡®: {used_keys} != {expected}\"\n    \n    print(\"âœ… å¤šä¸ªAPI Keyè½®è¯¢æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "test_api_key_rotation.py",
"start": 83,
"end": 118,
"text": "def test_two_keys_rotation():\n    \"\"\"æµ‹è¯•2ä¸ªAPI Keyè½®è¯¢\"\"\"\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•3: 2ä¸ªAPI Keyè½®è¯¢\")\n    print(\"=\" * 60)\n    \n    from daoyoucode.agents.llm.client_manager import LLMClientManager\n    \n    # åˆ›å»ºæ–°å®ä¾‹\n    LLMClientManager._instance = None\n    manager = LLMClientManager()\n    \n    # é…ç½®2ä¸ªkey\n    keys = ['sk-key-a', 'sk-key-b']\n    manager.configure_provider(\n        provider='test_provider',\n        api_keys=keys,\n        base_url='https://api.test.com/v1',\n        models=['test-model']\n    )\n    \n    # è·å–å¤šæ¬¡å®¢æˆ·ç«¯\n    used_keys = []\n    for i in range(6):\n        client = manager.get_client('test-model', 'test_provider')\n        used_keys.append(client.api_key)\n        print(f\"è¯·æ±‚ {i+1}: API Key = {client.api_key}\")\n    \n    # éªŒè¯è½®è¯¢ï¼šåº”è¯¥æ˜¯ a, b, a, b, a, b\n    expected = ['sk-key-a', 'sk-key-b'] * 3\n    assert used_keys == expected, f\"è½®è¯¢é¡ºåºä¸æ­£ç¡®: {used_keys} != {expected}\"\n    \n    print(\"âœ… 2ä¸ªAPI Keyè½®è¯¢æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "test_api_key_rotation.py",
"start": 119,
"end": 157,
"text": "def test_config_loading():\n    \"\"\"æµ‹è¯•ä»é…ç½®æ–‡ä»¶åŠ è½½\"\"\"\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•4: ä»é…ç½®æ–‡ä»¶åŠ è½½\")\n    print(\"=\" * 60)\n    \n    from daoyoucode.agents.llm.config_loader import load_llm_config\n    \n    config = load_llm_config()\n    \n    if not config:\n        print(\"âš ï¸ é…ç½®æ–‡ä»¶æœªæ‰¾åˆ°æˆ–ä¸ºç©º\")\n        return\n    \n    print(f\"âœ… é…ç½®æ–‡ä»¶åŠ è½½æˆåŠŸ\")\n    \n    providers = config.get('providers', {})\n    for provider_name, provider_config in providers.items():\n        if not provider_config.get('enabled'):\n            continue\n        \n        api_key = provider_config.get('api_key')\n        api_keys = provider_config.get('api_keys')\n        \n        # å¤„ç†api_keyå¯èƒ½æ˜¯åˆ—è¡¨çš„æƒ…å†µ\n        if api_key and isinstance(api_key, list):\n            api_keys = api_key\n            api_key = None\n        \n        if api_keys:\n            print(f\"æä¾›å•† {provider_name}: {len(api_keys)} ä¸ªAPI Key\")\n            for i, key in enumerate(api_keys, 1):\n                print(f\"  Key {i}: {key[:10]}...{key[-4:]}\")\n        elif api_key:\n            print(f\"æä¾›å•† {provider_name}: 1 ä¸ªAPI Key\")\n            print(f\"  Key: {api_key[:10]}...{api_key[-4:]}\")\n\n"
},
{
"path": "test_api_key_rotation.py",
"start": 158,
"end": 196,
"text": "def main():\n    \"\"\"è¿è¡Œæ‰€æœ‰æµ‹è¯•\"\"\"\n    \n    print(\"\\n\" + \"ğŸ§ª API Keyè½®è¯¢åŠŸèƒ½æµ‹è¯•\")\n    print(\"=\" * 60)\n    \n    try:\n        test_single_key()\n        test_multiple_keys_rotation()\n        test_two_keys_rotation()\n        test_config_loading()\n        \n        print(\"\\n\" + \"=\" * 60)\n        print(\"âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼\")\n        print(\"=\" * 60)\n        \n        print(\"\\nğŸ“ ä½¿ç”¨è¯´æ˜ï¼š\")\n        print(\"1. åœ¨ config/llm_config.yaml ä¸­é…ç½®å¤šä¸ªAPI Keyï¼š\")\n        print(\"   api_keys:\")\n        print(\"     - 'sk-key1'\")\n        print(\"     - 'sk-key2'\")\n        print(\"     - 'sk-key3'\")\n        print(\"\")\n        print(\"2. ç³»ç»Ÿä¼šè‡ªåŠ¨è½®è¯¢ä½¿ç”¨è¿™äº›key\")\n        print(\"3. 1ä¸ªkeyå°±ç”¨1ä¸ªï¼Œå¤šä¸ªå°±è½®è¯¢\")\n        print(\"4. å¯ä»¥æœ‰æ•ˆåˆ†æ•£APIé…é¢å‹åŠ›\")\n        \n    except AssertionError as e:\n        print(f\"\\nâŒ æµ‹è¯•å¤±è´¥: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"\\nâŒ æµ‹è¯•å‡ºé”™: {e}\")\n        import traceback\n        traceback.print_exc()\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main()"
},
{
"path": "test_fixes.py",
"start": 1,
"end": 168,
"text": "\"\"\"\næµ‹è¯•ä¿®å¤æ•ˆæœ\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\n\nasync def test_initialization():\n    \"\"\"æµ‹è¯•ç³»ç»Ÿåˆå§‹åŒ–\"\"\"\n    print(\"=\" * 60)\n    print(\"æµ‹è¯•1: ç³»ç»Ÿåˆå§‹åŒ–\")\n    print(\"=\" * 60)\n    \n    from daoyoucode.agents.init import initialize_agent_system\n    \n    try:\n        initialize_agent_system()\n        print(\"âœ… ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ\")\n        \n        # æ£€æŸ¥ä¸­é—´ä»¶\n        from daoyoucode.agents.core.middleware import get_middleware_registry\n        registry = get_middleware_registry()\n        middlewares = registry.list_middleware()\n        print(f\"âœ… å·²æ³¨å†Œä¸­é—´ä»¶: {middlewares}\")\n        \n        return True\n    except Exception as e:\n        print(f\"âŒ ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n\nasync def test_json_parsing():\n    \"\"\"æµ‹è¯•JSONè§£æä¿®å¤\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•2: JSONè§£æä¿®å¤\")\n    print(\"=\" * 60)\n    \n    import json\n    \n    # æ¨¡æ‹ŸLLMè¿”å›çš„å¸¦é¢å¤–æ–‡æœ¬çš„JSON\n    test_cases = [\n        ('{\"file_path\": \"test.txt\"}', True),\n        ('{\"file_path\": \"test.txt\"}\\nå¦‚æœæ‚¨æœ‰å…¶ä»–éœ€æ±‚ï¼Œè¯·è¯¦ç»†è¯´æ˜ã€‚', True),\n        ('{\"repo_path\": \"/path/to/repo\"}\\nè¯·æä¾›å…·ä½“çš„æŒ‡ä»¤å’Œå‚æ•°ã€‚', True),\n        ('', False),\n        ('invalid json', False),\n    ]\n    \n    for args_str, should_succeed in test_cases:\n        print(f\"\\næµ‹è¯•: {repr(args_str[:50])}\")\n        \n        try:\n            # æå–JSONéƒ¨åˆ†\n            args_str_clean = args_str.strip()\n            if args_str_clean.startswith('{'):\n                brace_count = 0\n                json_end = -1\n                for i, char in enumerate(args_str_clean):\n                    if char == '{':\n                        brace_count += 1\n                    elif char == '}':\n                        brace_count -= 1\n                        if brace_count == 0:\n                            json_end = i + 1\n                            break\n                \n                if json_end > 0:\n                    args_str_clean = args_str_clean[:json_end]\n            \n            result = json.loads(args_str_clean)\n            print(f\"âœ… è§£ææˆåŠŸ: {result}\")\n            \n            if not should_succeed:\n                print(\"âš ï¸ é¢„æœŸå¤±è´¥ä½†æˆåŠŸäº†\")\n        \n        except json.JSONDecodeError as e:\n            if should_succeed:\n                print(f\"âŒ è§£æå¤±è´¥ï¼ˆé¢„æœŸæˆåŠŸï¼‰: {e}\")\n            else:\n                print(f\"âœ… è§£æå¤±è´¥ï¼ˆç¬¦åˆé¢„æœŸï¼‰: {e}\")\n        \n        except Exception as e:\n            print(f\"âŒ æ„å¤–é”™è¯¯: {e}\")\n    \n    return True\n\n\nasync def test_agent_models():\n    \"\"\"æµ‹è¯•Agentæ¨¡å‹é…ç½®\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•3: Agentæ¨¡å‹é…ç½®\")\n    print(\"=\" * 60)\n    \n    from daoyoucode.agents.init import initialize_agent_system\n    from daoyoucode.agents.core.agent import get_agent_registry\n    \n    try:\n        initialize_agent_system()\n        \n        registry = get_agent_registry()\n        agents = registry.list_agents()\n        \n        print(f\"å·²æ³¨å†ŒAgent: {len(agents)}ä¸ª\")\n        \n        # æ£€æŸ¥test_expertçš„æ¨¡å‹\n        test_expert = registry.get_agent('test_expert')\n        if test_expert:\n            print(f\"âœ… test_expertæ¨¡å‹: {test_expert.config.model}\")\n            \n            if test_expert.config.model == 'deepseek-coder':\n                print(\"âš ï¸ test_expertä»ä½¿ç”¨deepseek-coderï¼ˆæœªé…ç½®ï¼‰\")\n            else:\n                print(f\"âœ… test_expertå·²æ”¹ç”¨: {test_expert.config.model}\")\n        \n        return True\n    \n    except Exception as e:\n        print(f\"âŒ æµ‹è¯•å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n\nasync def main():\n    \"\"\"ä¸»æµ‹è¯•å‡½æ•°\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"DaoyouCode ä¿®å¤éªŒè¯æµ‹è¯•\")\n    print(\"=\" * 60)\n    \n    results = []\n    \n    # æµ‹è¯•1: ç³»ç»Ÿåˆå§‹åŒ–\n    results.append(await test_initialization())\n    \n    # æµ‹è¯•2: JSONè§£æ\n    results.append(await test_json_parsing())\n    \n    # æµ‹è¯•3: Agentæ¨¡å‹é…ç½®\n    results.append(await test_agent_models())\n    \n    # æ€»ç»“\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•æ€»ç»“\")\n    print(\"=\" * 60)\n    \n    passed = sum(results)\n    total = len(results)\n    \n    print(f\"é€šè¿‡: {passed}/{total}\")\n    \n    if"
},
{
"path": "test_llm_connection.py",
"start": 1,
"end": 215,
"text": "\"\"\"\næµ‹è¯•LLMè¿æ¥\n\nè¯Šæ–­500é”™è¯¯çš„å¯èƒ½åŸå› \n\"\"\"\n\nimport asyncio\nimport sys\nimport os\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nbackend_dir = Path(__file__).parent\nsys.path.insert(0, str(backend_dir))\n\n\nasync def test_simple_request():\n    \"\"\"æµ‹è¯•ç®€å•è¯·æ±‚\"\"\"\n    \n    print(\"=\" * 60)\n    print(\"æµ‹è¯•1: ç®€å•LLMè¯·æ±‚\")\n    print(\"=\" * 60)\n    \n    try:\n        from daoyoucode.agents.llm import get_client_manager\n        from daoyoucode.agents.llm.base import LLMRequest\n        \n        client_manager = get_client_manager()\n        \n        # æµ‹è¯•qwen-plus\n        print(\"\\næµ‹è¯•æ¨¡å‹: qwen-plus\")\n        client = client_manager.get_client(model=\"qwen-plus\")\n        \n        request = LLMRequest(\n            prompt=\"ä½ å¥½ï¼Œè¯·å›å¤'æµ‹è¯•æˆåŠŸ'\",\n            model=\"qwen-plus\",\n            temperature=0.7,\n            max_tokens=100\n        )\n        \n        print(\"å‘é€è¯·æ±‚...\")\n        response = await client.chat(request)\n        \n        print(f\"âœ… å“åº”æˆåŠŸ\")\n        print(f\"å†…å®¹: {response.content}\")\n        print(f\"Tokenä½¿ç”¨: {response.tokens_used}\")\n        print(f\"å»¶è¿Ÿ: {response.latency:.2f}ç§’\")\n        \n    except Exception as e:\n        print(f\"âŒ è¯·æ±‚å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n    \n    return True\n\n\nasync def test_function_calling():\n    \"\"\"æµ‹è¯•Function Calling\"\"\"\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•2: Function Calling\")\n    print(\"=\" * 60)\n    \n    try:\n        from daoyoucode.agents.llm import get_client_manager\n        from daoyoucode.agents.llm.base import LLMRequest\n        \n        client_manager = get_client_manager()\n        client = client_manager.get_client(model=\"qwen-plus\")\n        \n        # æ„å»ºå¸¦functionçš„è¯·æ±‚\n        request = LLMRequest(\n            prompt=\"\",\n            model=\"qwen-plus\",\n            temperature=0.7,\n            max_tokens=500\n        )\n        \n        # æ·»åŠ æ¶ˆæ¯\n        request.messages = [\n            {\"role\": \"user\", \"content\": \"è¯·è¯»å–å½“å‰ç›®å½•çš„README.mdæ–‡ä»¶\"}\n        ]\n        \n        # æ·»åŠ ç®€å•çš„function\n        request.functions = [\n            {\n                \"name\": \"read_file\",\n                \"description\": \"è¯»å–æ–‡ä»¶å†…å®¹\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"file_path\": {\n                            \"type\": \"string\",\n                            \"description\": \"æ–‡ä»¶è·¯å¾„\"\n                        }\n                    },\n                    \"required\": [\"file_path\"]\n                }\n            }\n        ]\n        \n        print(\"å‘é€Function Callingè¯·æ±‚...\")\n        response = await client.chat(request)\n        \n        print(f\"âœ… å“åº”æˆåŠŸ\")\n        print(f\"å†…å®¹: {response.content}\")\n        \n        if response.metadata.get('function_call'):\n            print(f\"Function Call: {response.metadata['function_call']}\")\n        \n        print(f\"Tokenä½¿ç”¨: {response.tokens_used}\")\n        \n    except Exception as e:\n        print(f\"âŒ è¯·æ±‚å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n    \n    return True\n\n\nasync def test_api_key():\n    \"\"\"æµ‹è¯•API Keyé…ç½®\"\"\"\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•3: API Keyé…ç½®\")\n    print(\"=\" * 60)\n    \n    api_key = os.getenv('DASHSCOPE_API_KEY')\n    \n    if not api_key:\n        print(\"âŒ æœªè®¾ç½® DASHSCOPE_API_KEY ç¯å¢ƒå˜é‡\")\n        return False\n    \n    print(f\"âœ… API Keyå·²è®¾ç½®: {api_key[:10]}...{api_key[-4:]}\")\n    \n    # æ£€æŸ¥é…ç½®æ–‡ä»¶\n    config_file = backend_dir / 'config' / 'llm_config.yaml'\n    if config_file.exists():\n        print(f\"âœ… é…ç½®æ–‡ä»¶å­˜åœ¨: {config_file}\")\n        \n        import yaml\n        with open(config_file, 'r', encoding='utf-8') as f:\n            config = yaml.safe_load(f)\n        \n        if 'providers' in config and 'qwen' in config['providers']:\n            print(f\"âœ… qwenæä¾›å•†å·²é…ç½®\")\n            print(f\"   æ¨¡å‹: {config['providers']['qwen'].get('models', [])}\")\n        else:\n            print(\"âš ï¸ qwenæä¾›å•†æœªé…ç½®\")\n    else:\n        print(f\"âš ï¸ é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_file}\")\n    \n    return True\n\n\nasync def diagnose_500_error():\n    \"\"\"è¯Šæ–­500é”™è¯¯\"\"\"\n    \n    print(\"\\n\" + \"=\" * 60)\n    print("
},
{
"path": "test_middleware_fix.py",
"start": 1,
"end": 17,
"text": "\"\"\"\næµ‹è¯•ä¸­é—´ä»¶ä¿®å¤\n\néªŒè¯ï¼š\n1. ContextMiddleware å¯ä»¥æ­£ç¡®å¯¼å…¥\n2. ä¸­é—´ä»¶å¯ä»¥æ­£ç¡®åˆå§‹åŒ–\n3. ä¸ä¼šå‡ºç° \"No module named 'ai'\" é”™è¯¯\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nbackend_dir = Path(__file__).parent\nsys.path.insert(0, str(backend_dir))\n\n"
},
{
"path": "test_middleware_fix.py",
"start": 18,
"end": 53,
"text": "def test_middleware_import():\n    \"\"\"æµ‹è¯•ä¸­é—´ä»¶å¯¼å…¥\"\"\"\n    \n    print(\"=\" * 60)\n    print(\"æµ‹è¯•1: å¯¼å…¥ ContextMiddleware\")\n    print(\"=\" * 60)\n    \n    try:\n        from daoyoucode.agents.middleware.context import ContextMiddleware\n        print(\"âœ… ContextMiddleware å¯¼å…¥æˆåŠŸ\")\n        \n        # åˆ›å»ºå®ä¾‹\n        middleware = ContextMiddleware()\n        print(f\"âœ… ContextMiddleware å®ä¾‹åŒ–æˆåŠŸ: {middleware}\")\n        \n    except ImportError as e:\n        print(f\"âŒ å¯¼å…¥å¤±è´¥: {e}\")\n        raise\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•2: å¯¼å…¥ FollowupMiddleware\")\n    print(\"=\" * 60)\n    \n    try:\n        from daoyoucode.agents.middleware.followup import FollowupMiddleware\n        print(\"âœ… FollowupMiddleware å¯¼å…¥æˆåŠŸ\")\n        \n        # åˆ›å»ºå®ä¾‹\n        middleware = FollowupMiddleware()\n        print(f\"âœ… FollowupMiddleware å®ä¾‹åŒ–æˆåŠŸ: {middleware}\")\n        \n    except ImportError as e:\n        print(f\"âŒ å¯¼å…¥å¤±è´¥: {e}\")\n        raise\n\n"
},
{
"path": "test_middleware_fix.py",
"start": 54,
"end": 86,
"text": "def test_middleware_registration():\n    \"\"\"æµ‹è¯•ä¸­é—´ä»¶æ³¨å†Œ\"\"\"\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•3: ä¸­é—´ä»¶æ³¨å†Œ\")\n    print(\"=\" * 60)\n    \n    try:\n        from daoyoucode.agents import initialize_agent_system\n        \n        # åˆå§‹åŒ–ç³»ç»Ÿï¼ˆä¼šæ³¨å†Œä¸­é—´ä»¶ï¼‰\n        initialize_agent_system()\n        print(\"âœ… Agentç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ\")\n        \n        # æ£€æŸ¥ä¸­é—´ä»¶æ˜¯å¦æ³¨å†Œ\n        from daoyoucode.agents.core.middleware import get_middleware_registry\n        registry = get_middleware_registry()\n        \n        middlewares = registry.list_middleware()\n        print(f\"âœ… å·²æ³¨å†Œä¸­é—´ä»¶: {middlewares}\")\n        \n        # éªŒè¯å…³é”®ä¸­é—´ä»¶\n        assert 'context_management' in middlewares, \"context_management æœªæ³¨å†Œ\"\n        assert 'memory_integration' in middlewares, \"memory_integration æœªæ³¨å†Œ\"\n        assert 'followup' in middlewares, \"followup æœªæ³¨å†Œ\"\n        \n        print(\"âœ… æ‰€æœ‰å…³é”®ä¸­é—´ä»¶å·²æ³¨å†Œ\")\n        \n    except Exception as e:\n        print(f\"âŒ æ³¨å†Œå¤±è´¥: {e}\")\n        raise\n\n"
},
{
"path": "test_middleware_fix.py",
"start": 87,
"end": 131,
"text": "def test_context_middleware_process():\n    \"\"\"æµ‹è¯• ContextMiddleware å¤„ç†\"\"\"\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•4: ContextMiddleware å¤„ç†\")\n    print(\"=\" * 60)\n    \n    try:\n        from daoyoucode.agents.middleware.context import ContextMiddleware\n        import asyncio\n        \n        middleware = ContextMiddleware()\n        \n        # æ¨¡æ‹Ÿä¸Šä¸‹æ–‡\n        context = {\n            'session_id': 'test-session',\n            'is_followup': False\n        }\n        \n        # å¤„ç†ï¼ˆå¯èƒ½ä¼šå¤±è´¥ï¼Œä½†ä¸åº”è¯¥å› ä¸ºå¯¼å…¥é”™è¯¯ï¼‰\n        async def run_test():\n            try:\n                result = await middleware.process(\"æµ‹è¯•è¾“å…¥\", context)\n                print(f\"âœ… å¤„ç†æˆåŠŸ: {result.keys()}\")\n                return result\n            except Exception as e:\n                # å¦‚æœæ˜¯ä¸šåŠ¡é€»è¾‘é”™è¯¯ï¼ˆå¦‚æ‰¾ä¸åˆ°sessionï¼‰ï¼Œè¿™æ˜¯æ­£å¸¸çš„\n                if \"No module named 'ai'\" in str(e):\n                    print(f\"âŒ å¯¼å…¥é”™è¯¯ä»ç„¶å­˜åœ¨: {e}\")\n                    raise\n                else:\n                    print(f\"âš ï¸ ä¸šåŠ¡é€»è¾‘é”™è¯¯ï¼ˆæ­£å¸¸ï¼‰: {e}\")\n                    return context\n        \n        result = asyncio.run(run_test())\n        print(\"âœ… ContextMiddleware å¤„ç†æµ‹è¯•é€šè¿‡\")\n        \n    except Exception as e:\n        if \"No module named 'ai'\" in str(e):\n            print(f\"âŒ å¯¼å…¥é”™è¯¯: {e}\")\n            raise\n        else:\n            print(f\"âš ï¸ å…¶ä»–é”™è¯¯ï¼ˆå¯èƒ½æ­£å¸¸ï¼‰: {e}\")\n\n"
},
{
"path": "test_middleware_fix.py",
"start": 132,
"end": 161,
"text": "def main():\n    \"\"\"è¿è¡Œæ‰€æœ‰æµ‹è¯•\"\"\"\n    \n    print(\"\\n\" + \"ğŸ§ª ä¸­é—´ä»¶ä¿®å¤æµ‹è¯•\")\n    print(\"=\" * 60)\n    \n    try:\n        test_middleware_import()\n        test_middleware_registration()\n        test_context_middleware_process()\n        \n        print(\"\\n\" + \"=\" * 60)\n        print(\"âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼\")\n        print(\"=\" * 60)\n        \n        print(\"\\nğŸ“ ä¿®å¤æ€»ç»“ï¼š\")\n        print(\"1. âœ… ä¿®å¤äº† ContextMiddleware çš„å¯¼å…¥è·¯å¾„\")\n        print(\"2. âœ… ä» 'ai.memory.context_manager' æ”¹ä¸º '..core.context'\")\n        print(\"3. âœ… ä¸­é—´ä»¶å¯ä»¥æ­£å¸¸å¯¼å…¥å’Œæ³¨å†Œ\")\n        print(\"4. âœ… ä¸å†å‡ºç° 'No module named ai' é”™è¯¯\")\n        \n    except Exception as e:\n        print(f\"\\nâŒ æµ‹è¯•å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main()"
},
{
"path": "test_model_config.py",
"start": 1,
"end": 20,
"text": "\"\"\"\næµ‹è¯•æ¨¡å‹é…ç½®æµç¨‹\n\néªŒè¯ï¼š\n1. Skillé…ç½®çš„æ¨¡å‹ä¼˜å…ˆäºAgenté»˜è®¤æ¨¡å‹\n2. å¦‚æœSkillæ²¡æœ‰é…ç½®æ¨¡å‹ï¼Œä½¿ç”¨Agenté»˜è®¤æ¨¡å‹\n3. æ¨¡å‹é…ç½®æ­£ç¡®ä¼ é€’åˆ°LLMå®¢æˆ·ç«¯\n\"\"\"\n\nimport asyncio\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nbackend_dir = Path(__file__).parent\nsys.path.insert(0, str(backend_dir))\n\nfrom daoyoucode.agents.core.agent import BaseAgent, AgentConfig, AgentResult\n\n"
},
{
"path": "test_model_config.py",
"start": 21,
"end": 23,
"text": "class TestAgent(BaseAgent):\n    \"\"\"æµ‹è¯•ç”¨Agent\"\"\"\n    "
},
{
"path": "test_model_config.py",
"start": 24,
"end": 187,
"text": "    def __init__(self):\n        config = AgentConfig(\n            name=\"test_agent\",\n            description=\"æµ‹è¯•Agent\",\n            model=\"qwen-plus\",  # é»˜è®¤æ¨¡å‹\n            temperature=0.7,\n            system_prompt=\"ä½ æ˜¯ä¸€ä¸ªæµ‹è¯•åŠ©æ‰‹\"\n        )\n        super().__init__(config)\n\n\nasync def test_model_priority():\n    \"\"\"æµ‹è¯•æ¨¡å‹é…ç½®ä¼˜å…ˆçº§\"\"\"\n    \n    print(\"=\" * 60)\n    print(\"æµ‹è¯•1: Skillé…ç½®çš„æ¨¡å‹ä¼˜å…ˆäºAgenté»˜è®¤æ¨¡å‹\")\n    print(\"=\" * 60)\n    \n    agent = TestAgent()\n    \n    # æ¨¡æ‹ŸSkillé…ç½®ï¼ˆæŒ‡å®šäº†æ¨¡å‹ï¼‰\n    llm_config = {\n        'model': 'qwen-max',  # SkillæŒ‡å®šçš„æ¨¡å‹\n        'temperature': 0.3\n    }\n    \n    # æ£€æŸ¥Agentä¼šä½¿ç”¨å“ªä¸ªæ¨¡å‹\n    # è¿™é‡Œæˆ‘ä»¬ä¸å®é™…è°ƒç”¨LLMï¼Œåªæ£€æŸ¥é…ç½®\n    model_to_use = llm_config.get('model', agent.config.model)\n    temp_to_use = llm_config.get('temperature', agent.config.temperature)\n    \n    print(f\"Agenté»˜è®¤æ¨¡å‹: {agent.config.model}\")\n    print(f\"Skillé…ç½®æ¨¡å‹: {llm_config['model']}\")\n    print(f\"å®é™…ä½¿ç”¨æ¨¡å‹: {model_to_use}\")\n    print(f\"å®é™…ä½¿ç”¨æ¸©åº¦: {temp_to_use}\")\n    \n    assert model_to_use == 'qwen-max', \"åº”è¯¥ä½¿ç”¨Skillé…ç½®çš„æ¨¡å‹\"\n    assert temp_to_use == 0.3, \"åº”è¯¥ä½¿ç”¨Skillé…ç½®çš„æ¸©åº¦\"\n    print(\"âœ… æµ‹è¯•é€šè¿‡ï¼šSkillé…ç½®ä¼˜å…ˆ\")\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•2: æ²¡æœ‰Skillé…ç½®æ—¶ä½¿ç”¨Agenté»˜è®¤æ¨¡å‹\")\n    print(\"=\" * 60)\n    \n    # æ¨¡æ‹Ÿæ²¡æœ‰Skillé…ç½®\n    llm_config_empty = {}\n    \n    model_to_use = llm_config_empty.get('model', agent.config.model)\n    temp_to_use = llm_config_empty.get('temperature', agent.config.temperature)\n    \n    print(f\"Agenté»˜è®¤æ¨¡å‹: {agent.config.model}\")\n    print(f\"Skillé…ç½®æ¨¡å‹: (æ— )\")\n    print(f\"å®é™…ä½¿ç”¨æ¨¡å‹: {model_to_use}\")\n    print(f\"å®é™…ä½¿ç”¨æ¸©åº¦: {temp_to_use}\")\n    \n    assert model_to_use == 'qwen-plus', \"åº”è¯¥ä½¿ç”¨Agenté»˜è®¤æ¨¡å‹\"\n    assert temp_to_use == 0.7, \"åº”è¯¥ä½¿ç”¨Agenté»˜è®¤æ¸©åº¦\"\n    print(\"âœ… æµ‹è¯•é€šè¿‡ï¼šä½¿ç”¨Agenté»˜è®¤å€¼\")\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•3: éƒ¨åˆ†é…ç½®ï¼ˆåªé…ç½®æ¨¡å‹ï¼Œä¸é…ç½®æ¸©åº¦ï¼‰\")\n    print(\"=\" * 60)\n    \n    # æ¨¡æ‹Ÿéƒ¨åˆ†Skillé…ç½®\n    llm_config_partial = {\n        'model': 'qwen-coder-plus'\n        # æ²¡æœ‰é…ç½®temperature\n    }\n    \n    model_to_use = llm_config_partial.get('model', agent.config.model)\n    temp_to_use = llm_config_partial.get('temperature', agent.config.temperature)\n    \n    print(f\"Agenté»˜è®¤æ¨¡å‹: {agent.config.model}\")\n    print(f\"Agenté»˜è®¤æ¸©åº¦: {agent.config.temperature}\")\n    print(f\"Skillé…ç½®æ¨¡å‹: {llm_config_partial['model']}\")\n    print(f\"Skillé…ç½®æ¸©åº¦: (æ— )\")\n    print(f\"å®é™…ä½¿ç”¨æ¨¡å‹: {model_to_use}\")\n    print(f\"å®é™…ä½¿ç”¨æ¸©åº¦: {temp_to_use}\")\n    \n    assert model_to_use == 'qwen-coder-plus', \"åº”è¯¥ä½¿ç”¨Skillé…ç½®çš„æ¨¡å‹\"\n    assert temp_to_use == 0.7, \"åº”è¯¥ä½¿ç”¨Agenté»˜è®¤æ¸©åº¦\"\n    print(\"âœ… æµ‹è¯•é€šè¿‡ï¼šéƒ¨åˆ†é…ç½®æ­£ç¡®åˆå¹¶\")\n\n\nasync def test_skill_yaml_structure():\n    \"\"\"æµ‹è¯•Skillé…ç½®æ–‡ä»¶ç»“æ„\"\"\"\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•4: éªŒè¯Skillé…ç½®æ–‡ä»¶ç»“æ„\")\n    print(\"=\" * 60)\n    \n    import yaml\n    \n    # è¯»å–ä¸€ä¸ªSkillé…ç½®æ–‡ä»¶\n    skill_file = backend_dir / 'skills' / 'testing' / 'skill.yaml'\n    \n    if not skill_file.exists():\n        # å°è¯•ä¸Šä¸€çº§ç›®å½•\n        skill_file = backend_dir.parent / 'skills' / 'testing' / 'skill.yaml'\n    \n    if skill_file.exists():\n        with open(skill_file, 'r', encoding='utf-8') as f:\n            skill_config = yaml.safe_load(f)\n        \n        print(f\"Skillåç§°: {skill_config['name']}\")\n        print(f\"ä½¿ç”¨Agent: {skill_config['agent']}\")\n        print(f\"ä½¿ç”¨ç¼–æ’å™¨: {skill_config['orchestrator']}\")\n        \n        if 'llm' in skill_config:\n            print(f\"LLMé…ç½®:\")\n            print(f\"  - æ¨¡å‹: {skill_config['llm'].get('model', '(æœªé…ç½®)')}\")\n            print(f\"  - æ¸©åº¦: {skill_config['llm'].get('temperature', '(æœªé…ç½®)')}\")\n            \n            # éªŒè¯æ¨¡å‹æ˜¯å·²é…ç½®çš„\n            configured_models = ['qwen-plus', 'qwen-max', 'qwen-coder-plus']\n            model = skill_config['llm'].get('model')\n            \n            if model in configured_models:\n                print(f\"âœ… æ¨¡å‹ '{model}' å·²é…ç½®\")\n            else:\n                print(f\"âš ï¸ æ¨¡å‹ '{model}' å¯èƒ½æœªé…ç½®ï¼Œè¯·æ£€æŸ¥ llm_config.yaml\")\n        else:\n            print(\"âš ï¸ Skillé…ç½®ä¸­æ²¡æœ‰llmå­—æ®µ\")\n    else:\n        print(f\"âš ï¸ æ‰¾ä¸åˆ°Skillé…ç½®æ–‡ä»¶: {skill_file}\")\n\n\nasync def main():\n    \"\"\"è¿è¡Œæ‰€æœ‰æµ‹è¯•\"\"\"\n    \n    print(\"\\n\" + \"ğŸ§ª æ¨¡å‹é…ç½®æµç¨‹æµ‹è¯•\")\n    print(\"=\" * 60)\n    \n    try:\n        await test_model_priority()\n        await test_skill_yaml_structure()\n        \n   "
},
{
"path": "test_placeholder_fix.py",
"start": 1,
"end": 13,
"text": "\"\"\"\næµ‹è¯•å ä½ç¬¦è·¯å¾„ä¿®å¤\n\néªŒè¯ï¼š\n1. System Promptä¸­çš„å·¥å…·ä½¿ç”¨è§„åˆ™\n2. BaseToolçš„è·¯å¾„éªŒè¯å’Œè‡ªåŠ¨ä¿®æ­£\n\"\"\"\n\nimport asyncio\nfrom pathlib import Path\nfrom daoyoucode.agents.tools.base import ToolContext, BaseTool, ToolResult\n\n"
},
{
"path": "test_placeholder_fix.py",
"start": 14,
"end": 16,
"text": "class MockTool(BaseTool):\n    \"\"\"æ¨¡æ‹Ÿå·¥å…·\"\"\"\n    "
},
{
"path": "test_placeholder_fix.py",
"start": 17,
"end": 132,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"mock_tool\",\n            description=\"æ¨¡æ‹Ÿå·¥å…·\"\n        )\n    \n    async def execute(self, path: str) -> ToolResult:\n        \"\"\"æ‰§è¡Œå·¥å…·\"\"\"\n        resolved = self.resolve_path(path)\n        return ToolResult(\n            success=True,\n            content=f\"Resolved: {resolved}\",\n            metadata={'original': path, 'resolved': str(resolved)}\n        )\n\n\nasync def test_placeholder_detection():\n    \"\"\"æµ‹è¯•å ä½ç¬¦æ£€æµ‹\"\"\"\n    print(\"=\" * 60)\n    print(\"æµ‹è¯•1ï¼šå ä½ç¬¦æ£€æµ‹å’Œè‡ªåŠ¨ä¿®æ­£\")\n    print(\"=\" * 60)\n    \n    # åˆ›å»ºå·¥å…·\n    tool = MockTool()\n    \n    # è®¾ç½®ä¸Šä¸‹æ–‡\n    repo_path = Path.cwd()\n    context = ToolContext(repo_path=repo_path)\n    tool.set_context(context)\n    \n    # æµ‹è¯•ç”¨ä¾‹\n    test_cases = [\n        (\"./your-repo-path\", \"åº”è¯¥ä¿®æ­£ä¸ºå½“å‰ç›®å½•\"),\n        (\"path/to/your/file.txt\", \"åº”è¯¥ä¿®æ­£ä¸ºå½“å‰ç›®å½•\"),\n        (\"./src\", \"åº”è¯¥å»æ‰ ./ å‰ç¼€\"),\n        (\".\", \"åº”è¯¥ä¿æŒä¸å˜\"),\n        (\"backend/config.py\", \"åº”è¯¥ä¿æŒä¸å˜\"),\n    ]\n    \n    for path, expected in test_cases:\n        print(f\"\\næµ‹è¯•è·¯å¾„: {path}\")\n        print(f\"æœŸæœ›: {expected}\")\n        result = await tool.execute(path)\n        print(f\"ç»“æœ: {result.content}\")\n        print(f\"å…ƒæ•°æ®: {result.metadata}\")\n\n\nasync def test_agent_prompt():\n    \"\"\"æµ‹è¯•Agentçš„Promptè§„åˆ™\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•2ï¼šAgent Promptä¸­çš„å·¥å…·ä½¿ç”¨è§„åˆ™\")\n    print(\"=\" * 60)\n    \n    from daoyoucode.agents.core.agent import BaseAgent, AgentConfig\n    \n    # åˆ›å»ºAgent\n    config = AgentConfig(\n        name=\"test_agent\",\n        description=\"æµ‹è¯•Agent\",\n        model=\"qwen-max\",\n        system_prompt=\"è¿™æ˜¯æµ‹è¯•Prompt\"\n    )\n    \n    agent = BaseAgent(config)\n    \n    # æ¨¡æ‹Ÿexecuteæ–¹æ³•ä¸­çš„Promptæ„å»º\n    tools = [\"repo_map\", \"text_search\"]  # æ¨¡æ‹Ÿæœ‰å·¥å…·\n    \n    if tools:\n        tool_rules = \"\"\"âš ï¸ å·¥å…·ä½¿ç”¨è§„åˆ™ï¼ˆå¿…é¡»éµå®ˆï¼‰ï¼š\n\n1. è·¯å¾„å‚æ•°ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•\n   - âœ… æ­£ç¡®ï¼šrepo_map(repo_path=\".\")\n   - âŒ é”™è¯¯ï¼šrepo_map(repo_path=\"./your-repo-path\")\n   - âŒ é”™è¯¯ï¼šrepo_map(repo_path=\"/path/to/repo\")\n\n2. æ–‡ä»¶è·¯å¾„ä½¿ç”¨ç›¸å¯¹è·¯å¾„\n   - âœ… æ­£ç¡®ï¼šread_file(file_path=\"backend/config.py\")\n   - âŒ é”™è¯¯ï¼šread_file(file_path=\"path/to/your/file.txt\")\n\n3. æœç´¢ç›®å½•ä½¿ç”¨ '.' æˆ–çœç•¥\n   - âœ… æ­£ç¡®ï¼štext_search(query=\"example\", directory=\".\")\n   - âŒ é”™è¯¯ï¼štext_search(query=\"example\", directory=\"./src\")\n\nè®°ä½ï¼šå½“å‰å·¥ä½œç›®å½•å°±æ˜¯é¡¹ç›®æ ¹ç›®å½•ï¼Œä¸éœ€è¦çŒœæµ‹è·¯å¾„ï¼\n\n---\n\n\"\"\"\n        full_prompt = tool_rules + \"ç”¨æˆ·è¾“å…¥ï¼šä½ å¥½\"\n        \n        print(\"\\nç”Ÿæˆçš„Promptï¼ˆå‰500å­—ç¬¦ï¼‰ï¼š\")\n        print(full_prompt[:500])\n        print(\"\\nâœ… å·¥å…·ä½¿ç”¨è§„åˆ™å·²æ·»åŠ åˆ°Promptå¼€å¤´\")\n\n\nasync def main():\n    \"\"\"ä¸»å‡½æ•°\"\"\"\n    await test_placeholder_detection()\n    await test_agent_prompt()\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"âœ… æ‰€æœ‰æµ‹è¯•å®Œæˆ\")\n    print(\"=\" * 60)\n    print(\"\\nä¿®å¤æ€»ç»“ï¼š\")\n    print(\"1. âœ… Agentçš„Promptå¼€å¤´æ·»åŠ äº†å·¥å…·ä½¿ç”¨è§„åˆ™\")\n    print(\"2. âœ… BaseTool.resolve_path()æ·»åŠ äº†å ä½ç¬¦æ£€æµ‹å’Œè‡ªåŠ¨ä¿®æ­£\")\n    print(\"3. âœ… è‡ªåŠ¨å»æ‰ ./ å‰ç¼€ï¼ˆå¦‚æœè·¯å¾„ä¸å­˜åœ¨ï¼‰\")\n    print(\"\\nä¸‹ä¸€æ­¥ï¼š\")\n    print(\"1. è¿è¡Œå®é™…çš„CLIæµ‹è¯•\")\n    print(\"2. ä½¿ç”¨VSCodeè°ƒè¯•å™¨è¿½è¸ªLLMçš„å·¥å…·è°ƒç”¨\")\n    print(\"3. æ£€æŸ¥DEBUG_LLM_REQUESTæ—¥å¿—\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())"
},
{
"path": "test_real_rotation.py",
"start": 1,
"end": 39,
"text": "\"\"\"\næµ‹è¯•å®é™…çš„API Keyè½®è¯¢\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\nbackend_dir = Path(__file__).parent\nsys.path.insert(0, str(backend_dir))\n\nfrom daoyoucode.agents.llm import get_client_manager\nfrom daoyoucode.agents.llm.config_loader import auto_configure\n\n# é…ç½®å®¢æˆ·ç«¯ç®¡ç†å™¨\ncm = get_client_manager()\nauto_configure(cm)\n\nprint(\"=\" * 60)\nprint(\"å®é™…API Keyè½®è¯¢æµ‹è¯•\")\nprint(\"=\" * 60)\n\n# æ£€æŸ¥é…ç½®\nqwen_config = cm.provider_configs.get('qwen', {})\napi_keys = qwen_config.get('api_keys', [])\n\nprint(f\"\\né…ç½®çš„API Keyæ•°é‡: {len(api_keys)}\")\nfor i, key in enumerate(api_keys, 1):\n    print(f\"  Key {i}: {key[:15]}...{key[-4:]}\")\n\nprint(f\"\\nå¼€å§‹è½®è¯¢æµ‹è¯•ï¼ˆ6æ¬¡è¯·æ±‚ï¼‰:\")\nprint(\"-\" * 60)\n\nfor i in range(6):\n    client = cm.get_client('qwen-plus')\n    print(f\"è¯·æ±‚ {i+1}: ä½¿ç”¨ {client.api_key[:15]}...{client.api_key[-4:]}\")\n\nprint(\"-\" * 60)\nprint(\"\\nâœ… è½®è¯¢æµ‹è¯•å®Œæˆï¼\")\nprint(f\"é¢„æœŸè¡Œä¸º: {len(api_keys)}ä¸ªkeyè½®æµä½¿ç”¨\")"
},
{
"path": "TOOLSå·¥å…·å‚è€ƒ.md",
"start": 1,
"end": 55,
"text": "# å·¥å…·å‚è€ƒæ‰‹å†Œ\n\n> DaoyouCode 26ä¸ªå·¥å…·å®Œæ•´å‚è€ƒ\n\n---\n\n## å·¥å…·æ€»è§ˆ\n\n| ç±»åˆ« | å·¥å…·æ•° | ä½¿ç”¨é¢‘ç‡ |\n|------|--------|---------|\n| æ–‡ä»¶æ“ä½œ | 6 | â­â­â­â­â­ |\n| æœç´¢ | 2 | â­â­â­â­â­ |\n| Git | 4 | â­â­â­â­ |\n| å‘½ä»¤æ‰§è¡Œ | 2 | â­â­â­â­ |\n| ä»£ç ç¼–è¾‘ | 1 | â­â­â­â­â­ |\n| LSP | 6 | â­â­â­â­ |\n| AST | 2 | â­â­â­ |\n| ä»£ç åœ°å›¾ | 2 | â­â­â­â­ |\n| é¡¹ç›®æ–‡æ¡£ | 1 | â­â­â­ |\n\n---\n\n## å¿«é€ŸæŸ¥æ‰¾è¡¨\n\n| å·¥å…· | åŠŸèƒ½ | å¸¸ç”¨å‚æ•° |\n|------|------|---------|\n| **æ–‡ä»¶æ“ä½œ** | | |\n| `read_file` | è¯»å–æ–‡ä»¶ | file_path |\n| `write_file` | å†™å…¥æ–‡ä»¶ | file_path, content |\n| `list_files` | åˆ—å‡ºç›®å½• | directory, recursive |\n| `get_file_info` | æ–‡ä»¶ä¿¡æ¯ | path |\n| `create_directory` | åˆ›å»ºç›®å½• | directory |\n| `delete_file` | åˆ é™¤æ–‡ä»¶ | path, recursive |\n| **æœç´¢** | | |\n| `text_search` | æ–‡æœ¬æœç´¢ | query, directory |\n| `regex_search` | æ­£åˆ™æœç´¢ | pattern, directory |\n| **Git** | | |\n| `git_status` | GitçŠ¶æ€ | repo_path |\n| `git_diff` | Gitå·®å¼‚ | ğŸš§ æœªå®ç° |\n| `git_commit` | Gitæäº¤ | ğŸš§ æœªå®ç° |\n| `git_log` | Gitæ—¥å¿— | ğŸš§ æœªå®ç° |\n| **å‘½ä»¤æ‰§è¡Œ** | | |\n| `run_command` | æ‰§è¡Œå‘½ä»¤ | command, cwd |\n| `run_test` | è¿è¡Œæµ‹è¯• | test_path, test_framework |\n| **ä»£ç ç¼–è¾‘** | | |\n| `search_replace` | ç²¾ç¡®æ›¿æ¢ | file_path, search, replace |\n| **LSP** | | |\n| `lsp_diagnostics` | è¯Šæ–­ä¿¡æ¯ | file_path, severity |\n| `lsp_goto_definition` | è·³è½¬å®šä¹‰ | file_path, line, character |\n| `lsp_find_references` | æŸ¥æ‰¾å¼•ç”¨ | file_path, line, character |\n| `lsp_symbols` | ç¬¦å·åˆ—è¡¨ | file_path, scope |\n| `lsp_rename` | é‡å‘½åç¬¦å· | file_path, line, character, new_name |\n| `lsp_code_actions` | ä»£ç æ“ä½œ | file_path, line, character |\n| **AST** | | |\n| `ast_grep_search` | ASTæœç´¢ | pattern, lang |"
},
{
"path": "TOOLSå·¥å…·å‚è€ƒ.md",
"start": 56,
"end": 110,
"text": "| `ast_grep_replace` | ASTæ›¿æ¢ | pattern, rewrite, lang |\n| **ä»£ç åœ°å›¾** | | |\n| `repo_map` | ä»£ç åœ°å›¾ | repo_path, chat_files |\n| `get_repo_structure` | ä»“åº“ç»“æ„ | repo_path, max_depth |\n| **é¡¹ç›®æ–‡æ¡£** | | |\n| `discover_project_docs` | é¡¹ç›®æ–‡æ¡£ | repo_path |\n\n---\n\n## æŒ‰åœºæ™¯é€‰æ‹©å·¥å…·\n\n### ç†è§£æ–°é¡¹ç›®\n```\ndiscover_project_docs â†’ get_repo_structure â†’ repo_map\n```\n\n### æŸ¥æ‰¾ä»£ç \n```\ntext_search / ast_grep_search â†’ read_file\n```\n\n### ä¿®æ”¹ä»£ç \n```\nread_file â†’ search_replace â†’ lsp_diagnostics â†’ run_test\n```\n\n### é‡æ„ä»£ç \n```\nlsp_find_references â†’ lsp_rename / ast_grep_replace â†’ run_test\n```\n\n### è°ƒè¯•é”™è¯¯\n```\nlsp_diagnostics â†’ lsp_goto_definition â†’ read_file â†’ search_replace\n```\n\n---\n\n## æ ¸å¿ƒå·¥å…·è¯¦è§£\n\n### 1. read_file - è¯»å–æ–‡ä»¶\n```python\nread_file(file_path=\"src/main.py\")\n```\n- è¯»å–å•ä¸ªæ–‡ä»¶çš„å®Œæ•´å†…å®¹\n- å¤§æ–‡ä»¶ä¼šè¢«æˆªæ–­ï¼ˆæœ€å¤§5000å­—ç¬¦æˆ–200è¡Œï¼‰\n\n### 2. write_file - å†™å…¥æ–‡ä»¶\n```python\nwrite_file(file_path=\"src/new.py\", content=\"def hello(): pass\")\n```\n- åˆ›å»ºæ–°æ–‡ä»¶æˆ–è¦†ç›–ç°æœ‰æ–‡ä»¶\n- è‡ªåŠ¨åˆ›å»ºç›®å½•\n\n### 3. search_replace - ç²¾ç¡®æ›¿æ¢"
},
{
"path": "TOOLSå·¥å…·å‚è€ƒ.md",
"start": 111,
"end": 165,
"text": "```python\nsearch_replace(\n    file_path=\"src/main.py\",\n    search=\"def old():\\n    pass\",\n    replace=\"def new():\\n    return True\"\n)\n```\n- æ”¯æŒ9ç§æ™ºèƒ½åŒ¹é…ç­–ç•¥\n- ç²¾ç¡®æ›¿æ¢ä»£ç å—\n\n### 4. text_search - æ–‡æœ¬æœç´¢\n```python\ntext_search(query=\"def main\", directory=\"src\", file_pattern=\"*.py\")\n```\n- ç±»ä¼¼grepçš„æ–‡æœ¬æœç´¢\n- æ”¯æŒæ–‡ä»¶æ¨¡å¼è¿‡æ»¤\n\n### 5. lsp_diagnostics - è¯Šæ–­ä¿¡æ¯\n```python\nlsp_diagnostics(file_path=\"src/main.py\", severity=\"error\")\n```\n- è·å–è¯­æ³•é”™è¯¯ã€ç±»å‹é”™è¯¯ã€è­¦å‘Š\n- æ”¯æŒPythonã€JavaScriptã€TypeScriptç­‰\n\n### 6. lsp_find_references - æŸ¥æ‰¾å¼•ç”¨\n```python\nlsp_find_references(file_path=\"src/main.py\", line=10, character=5)\n```\n- æŸ¥æ‰¾ç¬¦å·çš„æ‰€æœ‰å¼•ç”¨ä½ç½®\n- é‡æ„å‰çš„å½±å“åˆ†æ\n\n### 7. lsp_rename - é‡å‘½åç¬¦å·\n```python\nlsp_rename(file_path=\"src/main.py\", line=10, character=5, new_name=\"new_func\")\n```\n- å®‰å…¨é‡å‘½åå‡½æ•°ã€ç±»ã€å˜é‡\n- è‡ªåŠ¨æ›´æ–°æ‰€æœ‰å¼•ç”¨\n\n### 8. ast_grep_search - ASTæœç´¢\n```python\nast_grep_search(pattern=\"console.log($MSG)\", lang=\"javascript\")\n```\n- ä½¿ç”¨ASTæ¨¡å¼åŒ¹é…æœç´¢ä»£ç \n- æ”¯æŒ25ç§è¯­è¨€\n\n### 9. ast_grep_replace - ASTæ›¿æ¢\n```python\nast_grep_replace(\n    pattern=\"console.log($MSG)\",\n    rewrite=\"logger.info($MSG)\",\n    lang=\"javascript\",\n    dry_run=true\n)\n```\n- æ‰¹é‡é‡æ„ä»£ç "
},
{
"path": "TOOLSå·¥å…·å‚è€ƒ.md",
"start": 166,
"end": 220,
"text": "- æ”¯æŒé¢„è§ˆæ¨¡å¼\n\n### 10. repo_map - ä»£ç åœ°å›¾\n```python\nrepo_map(\n    repo_path=\".\",\n    chat_files=[\"src/main.py\"],\n    mentioned_idents=[\"Config\"]\n)\n```\n- æ™ºèƒ½æ’åºæœ€ç›¸å…³çš„ä»£ç \n- PageRankç®—æ³• + ä¸ªæ€§åŒ–æƒé‡\n- å¿«é€Ÿäº†è§£é¡¹ç›®ç»“æ„\n\n### 11. git_status - GitçŠ¶æ€\n```python\ngit_status(repo_path=\".\")\n```\n- æŸ¥çœ‹å½“å‰åˆ†æ”¯ã€ä¿®æ”¹çš„æ–‡ä»¶ã€æš‚å­˜çš„æ–‡ä»¶\n- äº†è§£å·¥ä½œç›®å½•çŠ¶æ€\n\n### 12. run_test - è¿è¡Œæµ‹è¯•\n```python\nrun_test(test_path=\"tests/test_main.py\", test_framework=\"pytest\")\n```\n- æ”¯æŒpytestã€unittestã€jest\n- è¿”å›æµ‹è¯•ç»“æœç»Ÿè®¡\n\n---\n\n## å·¥å…·ç»„åˆæ¨¡å¼\n\n### æ¨¡å¼1: ç†è§£æ–°é¡¹ç›®\n```\n1. discover_project_docs(repo_path=\".\")  # è¯»æ–‡æ¡£\n2. get_repo_structure(repo_path=\".\")     # çœ‹ç»“æ„\n3. repo_map(repo_path=\".\")               # ç”Ÿæˆåœ°å›¾\n```\n\n### æ¨¡å¼2: æŸ¥æ‰¾å’Œä¿®æ”¹ä»£ç \n```\n1. text_search(query=\"function_name\")    # æ‰¾åˆ°ä½ç½®\n2. read_file(file_path=\"src/main.py\")    # è¯»å–æ–‡ä»¶\n3. search_replace(...)                   # ç²¾ç¡®ä¿®æ”¹\n4. lsp_diagnostics(file_path=\"...\")      # æ£€æŸ¥é”™è¯¯\n```\n\n### æ¨¡å¼3: é‡æ„ä»£ç \n```\n1. lsp_find_references(...)              # æŸ¥æ‰¾æ‰€æœ‰å¼•ç”¨\n2. lsp_rename(...)                       # é‡å‘½åç¬¦å·\n3. run_test()                            # è¿è¡Œæµ‹è¯•\n4. git_status()                          # æ£€æŸ¥æ›´æ”¹\n```\n"
},
{
"path": "TOOLSå·¥å…·å‚è€ƒ.md",
"start": 221,
"end": 271,
"text": "### æ¨¡å¼4: æ‰¹é‡ä¿®æ”¹\n```\n1. ast_grep_search(pattern=\"...\")        # æ‰¾åˆ°æ‰€æœ‰åŒ¹é…\n2. ast_grep_replace(dry_run=true, ...)   # é¢„è§ˆæ›¿æ¢\n3. ast_grep_replace(dry_run=false, ...)  # å®é™…æ›¿æ¢\n4. run_test()                            # éªŒè¯æ›´æ”¹\n```\n\n---\n\n## æ€§èƒ½æç¤º\n\n| å·¥å…· | é¦–æ¬¡è¿è¡Œ | åç»­è¿è¡Œ | ä¼˜åŒ–å»ºè®® |\n|------|---------|---------|---------|\n| `repo_map` | æ…¢ï¼ˆè§£ææ–‡ä»¶ï¼‰ | å¿«ï¼ˆç¼“å­˜ï¼‰ | æä¾›chat_filesèšç„¦ |\n| `lsp_*` | æ…¢ï¼ˆå¯åŠ¨æœåŠ¡å™¨ï¼‰ | å¿«ï¼ˆå¤ç”¨ï¼‰ | æ‰¹é‡æ“ä½œ |\n| `ast_grep_*` | æ…¢ï¼ˆé¦–æ¬¡ä¸‹è½½ï¼‰ | å¿« | é™åˆ¶æœç´¢è·¯å¾„ |\n| `text_search` | å¿« | å¿« | ä½¿ç”¨file_patternè¿‡æ»¤ |\n\n---\n\n## å®‰å…¨æç¤º\n\n| å·¥å…· | é£é™© | æ³¨æ„äº‹é¡¹ |\n|------|------|---------|\n| `write_file` | ğŸ”´ é«˜ | ä¼šè¦†ç›–ç°æœ‰æ–‡ä»¶ |\n| `delete_file` | ğŸ”´ é«˜ | ä¸å¯é€†æ“ä½œ |\n| `search_replace` | ğŸŸ¡ ä¸­ | ç›´æ¥ä¿®æ”¹æ–‡ä»¶ |\n| `lsp_rename` | ğŸŸ¡ ä¸­ | ä¿®æ”¹å¤šä¸ªæ–‡ä»¶ |\n| `ast_grep_replace` | ğŸŸ¡ ä¸­ | æ‰¹é‡ä¿®æ”¹ |\n| `run_command` | ğŸŸ¡ ä¸­ | æ‰§è¡Œä»»æ„å‘½ä»¤ |\n| `read_file` | ğŸŸ¢ ä½ | åªè¯»æ“ä½œ |\n| `text_search` | ğŸŸ¢ ä½ | åªè¯»æ“ä½œ |\n\n---\n\n## æœ€ä½³å®è·µ\n\n1. **ä¿®æ”¹å‰å…ˆè¯»å–** - ä½¿ç”¨ `read_file` ç¡®è®¤å†…å®¹\n2. **ä¿®æ”¹åæ£€æŸ¥** - ä½¿ç”¨ `lsp_diagnostics` æ£€æŸ¥é”™è¯¯\n3. **æµ‹è¯•éªŒè¯** - ä½¿ç”¨ `run_test` éªŒè¯æ›´æ”¹\n4. **Gitç®¡ç†** - ä½¿ç”¨ `git_status` æŸ¥çœ‹æ›´æ”¹\n5. **é¢„è§ˆæ¨¡å¼** - ASTæ›¿æ¢å…ˆç”¨ `dry_run=true`\n\n---\n\n## ç›¸å…³æ–‡æ¡£\n\n- [CLIå‘½ä»¤å‚è€ƒ.md](./CLIå‘½ä»¤å‚è€ƒ.md) - CLIä½¿ç”¨æŒ‡å—\n- [AGENTS.md](./AGENTS.md) - Agentè¯¦ç»†ä»‹ç»\n- [ORCHESTRATORS.md](./ORCHESTRATORS.md) - ç¼–æ’å™¨è¯¦ç»†ä»‹ç»"
},
{
"path": "ä¿®å¤è®°å½•.md",
"start": 1,
"end": 55,
"text": "# ä¿®å¤è®°å½•\n\n## 2025-02-17 ä¿®å¤\n\n### é—®é¢˜1: æ¨¡å‹é…ç½®æ¶æ„ âœ…\n\n**é—®é¢˜æè¿°**:\n- ç”¨æˆ·å¸Œæœ›åœ¨Skillé…ç½®æ–‡ä»¶ä¸­æŒ‡å®šæ¨¡å‹ï¼Œè€Œéåœ¨Agentä»£ç ä¸­ç¡¬ç¼–ç \n- æ›´çµæ´»ã€æ›´æ˜“é…ç½®ã€æ›´ç¬¦åˆè®¾è®¡åŸåˆ™\n\n**è§£å†³æ–¹æ¡ˆ**:\n1. éªŒè¯äº†ç°æœ‰æ¶æ„å·²æ”¯æŒæ­¤åŠŸèƒ½\n   - Skillé…ç½®æ–‡ä»¶ä¸­çš„ `llm.model` ä¼šä¼ é€’ç»™Agent\n   - Agentçš„ `execute()` æ–¹æ³•ä¼˜å…ˆä½¿ç”¨ `llm_config` ä¸­çš„æ¨¡å‹\n   - Agentä»£ç ä¸­çš„æ¨¡å‹ä½œä¸ºfallbacké»˜è®¤å€¼\n\n2. æ›´æ–°äº†æ–‡æ¡£\n   - åˆ›å»º `æ¨¡å‹é…ç½®æ¶æ„è¯´æ˜.md` - è¯¦ç»†æ¶æ„è¯´æ˜\n   - åˆ›å»º `å¦‚ä½•é…ç½®æ¨¡å‹.md` - å¿«é€Ÿé…ç½®æŒ‡å—\n   - æ›´æ–° `README.md` - æ·»åŠ æ–‡æ¡£å¯¼èˆª\n\n3. ä¿®å¤äº†é…ç½®é—®é¢˜\n   - å°† `skills/testing/skill.yaml` ä¸­çš„ `deepseek-coder` æ”¹ä¸º `qwen-coder-plus`\n   - ç¡®ä¿æ‰€æœ‰Skillä½¿ç”¨å·²é…ç½®çš„æ¨¡å‹\n\n4. åˆ›å»ºäº†æµ‹è¯•\n   - `test_model_config.py` - éªŒè¯æ¨¡å‹é…ç½®ä¼˜å…ˆçº§\n   - æ‰€æœ‰æµ‹è¯•é€šè¿‡ âœ…\n\n**é…ç½®ä¼˜å…ˆçº§**:\n```\nSkillé…ç½® (skill.yaml) â†’ Agenté»˜è®¤ (agent.py) â†’ ç³»ç»Ÿé»˜è®¤\n```\n\n**æœ€ä½³å®è·µ**:\n- âœ… åœ¨Skillé…ç½®æ–‡ä»¶ä¸­æ˜ç¡®æŒ‡å®šæ¨¡å‹\n- âœ… Agentä»£ç ä¸­ä½¿ç”¨é€šç”¨é»˜è®¤æ¨¡å‹ï¼ˆå¦‚ `qwen-plus`ï¼‰\n- âœ… åªä½¿ç”¨å·²é…ç½®çš„æ¨¡å‹ï¼ˆæ£€æŸ¥ `llm_config.yaml`ï¼‰\n\n---\n\n### é—®é¢˜2: ä¸­é—´ä»¶å¯¼å…¥é”™è¯¯ âœ…\n\n**é—®é¢˜æè¿°**:\n```\nä¸Šä¸‹æ–‡ç®¡ç†å¤±è´¥: No module named 'ai'\n```\n\n**æ ¹æœ¬åŸå› **:\n- `ContextMiddleware` ä¸­å¼•ç”¨äº†ä¸å­˜åœ¨çš„æ¨¡å—ï¼š`from ai.memory.context_manager import ContextManager`\n- è¿™æ˜¯æ—§ä»£ç çš„é—ç•™é—®é¢˜\n\n**è§£å†³æ–¹æ¡ˆ**:\n1. ä¿®å¤äº†å¯¼å…¥è·¯å¾„\n   - ä» `from ai.memory.context_manager import ContextManager`"
},
{
"path": "ä¿®å¤è®°å½•.md",
"start": 56,
"end": 110,
"text": "   - æ”¹ä¸º `from ..memory import get_memory_manager`\n\n2. ç®€åŒ–äº†å®ç°\n   - ä½¿ç”¨å·²æœ‰çš„è®°å¿†ç®¡ç†ç³»ç»Ÿï¼ˆ`MemoryManager`ï¼‰\n   - ç§»é™¤äº†å¯¹ä¸å­˜åœ¨çš„ `ContextManager.get_history()` çš„è°ƒç”¨\n   - ä½¿ç”¨ `memory.get_conversation_history()` è·å–å†å²\n\n3. åˆ›å»ºäº†æµ‹è¯•\n   - `test_middleware_fix.py` - éªŒè¯ä¸­é—´ä»¶ä¿®å¤\n   - æ‰€æœ‰æµ‹è¯•é€šè¿‡ âœ…\n\n**ä¿®å¤æ–‡ä»¶**:\n- `backend/daoyoucode/agents/middleware/context.py`\n\n**éªŒè¯**:\n```bash\ncd backend\npython test_middleware_fix.py\n```\n\nè¾“å‡ºï¼š\n```\nâœ… ContextMiddleware å¯¼å…¥æˆåŠŸ\nâœ… ä¸­é—´ä»¶å¯ä»¥æ­£å¸¸å¯¼å…¥å’Œæ³¨å†Œ\nâœ… ä¸å†å‡ºç° 'No module named ai' é”™è¯¯\n```\n\n---\n\n## æµ‹è¯•è¦†ç›–\n\n### 1. æ¨¡å‹é…ç½®æµ‹è¯• (`test_model_config.py`)\n\næµ‹è¯•å†…å®¹ï¼š\n- âœ… Skillé…ç½®çš„æ¨¡å‹ä¼˜å…ˆäºAgenté»˜è®¤æ¨¡å‹\n- âœ… æ²¡æœ‰Skillé…ç½®æ—¶ä½¿ç”¨Agenté»˜è®¤æ¨¡å‹\n- âœ… éƒ¨åˆ†é…ç½®æ­£ç¡®åˆå¹¶ï¼ˆSkillé…ç½® + Agenté»˜è®¤ï¼‰\n- âœ… Skillé…ç½®æ–‡ä»¶ç»“æ„æ­£ç¡®\n\nè¿è¡Œï¼š\n```bash\ncd backend\npython test_model_config.py\n```\n\n### 2. ä¸­é—´ä»¶ä¿®å¤æµ‹è¯• (`test_middleware_fix.py`)\n\næµ‹è¯•å†…å®¹ï¼š\n- âœ… ContextMiddleware å¯ä»¥æ­£ç¡®å¯¼å…¥\n- âœ… FollowupMiddleware å¯ä»¥æ­£ç¡®å¯¼å…¥\n- âœ… ä¸­é—´ä»¶å¯ä»¥æ­£ç¡®æ³¨å†Œ\n- âœ… ContextMiddleware å¯ä»¥æ­£å¸¸å¤„ç†\n- âœ… ä¸ä¼šå‡ºç° \"No module named 'ai'\" é”™è¯¯\n\nè¿è¡Œï¼š"
},
{
"path": "ä¿®å¤è®°å½•.md",
"start": 111,
"end": 165,
"text": "```bash\ncd backend\npython test_middleware_fix.py\n```\n\n### 3. ä¹‹å‰çš„ä¿®å¤æµ‹è¯• (`test_fixes.py`)\n\næµ‹è¯•å†…å®¹ï¼š\n- âœ… ä¸­é—´ä»¶æ³¨å†Œ\n- âœ… JSONè§£æä¿®å¤\n- âœ… æ¨¡å‹é…ç½®\n\nè¿è¡Œï¼š\n```bash\ncd backend\npython test_fixes.py\n```\n\n---\n\n## æ–‡æ¡£æ›´æ–°\n\n### æ–°å¢æ–‡æ¡£\n\n1. **æ¨¡å‹é…ç½®æ¶æ„è¯´æ˜.md**\n   - æ ¸å¿ƒåŸåˆ™å’Œæ¶æ„æµç¨‹\n   - é…ç½®ä¼˜å…ˆçº§è¯¦è§£\n   - ä»£ç å®ç°åˆ†æ\n   - å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ\n\n2. **å¦‚ä½•é…ç½®æ¨¡å‹.md**\n   - å¿«é€Ÿé…ç½®æŒ‡å—ï¼ˆ3æ­¥ï¼‰\n   - å¸¸è§åœºæ™¯å’Œç¤ºä¾‹\n   - å¸¸è§é”™è¯¯å’Œè§£å†³æ–¹æ¡ˆ\n   - å®Œæ•´ç¤ºä¾‹å’Œæ£€æŸ¥æ¸…å•\n\n3. **ä¿®å¤è®°å½•.md** (æœ¬æ–‡æ¡£)\n   - é—®é¢˜æè¿°å’Œè§£å†³æ–¹æ¡ˆ\n   - æµ‹è¯•è¦†ç›–æƒ…å†µ\n   - æ–‡æ¡£æ›´æ–°è®°å½•\n\n### æ›´æ–°æ–‡æ¡£\n\n1. **README.md**\n   - æ·»åŠ äº†æ¨¡å‹é…ç½®æ–‡æ¡£çš„å¯¼èˆª\n   - æ›´æ–°äº†æ–‡æ¡£æ€»è§ˆ\n\n2. **skills/testing/skill.yaml**\n   - å°†æ¨¡å‹ä» `deepseek-coder` æ”¹ä¸º `qwen-coder-plus`\n\n---\n\n## æ¶æ„æ”¹è¿›\n\n### æ¨¡å‹é…ç½®æµç¨‹"
},
{
"path": "ä¿®å¤è®°å½•.md",
"start": 166,
"end": 220,
"text": "\n```\nç”¨æˆ·æ‰§è¡Œå‘½ä»¤\n â†“\npython daoyoucode.py chat --skill testing\n â†“\nåŠ è½½ Skill é…ç½® (skills/testing/skill.yaml)\n â†“\nllm:\n  model: qwen-coder-plus  â† åœ¨è¿™é‡Œé…ç½®\n  temperature: 0.3\n â†“\nOrchestrator ä¼ é€’é…ç½®\n â†“\nllm_config=skill.llm\n â†“\nAgent.execute()\n â†“\nmodel = llm_config.get('model', self.config.model)\n         â†‘ ä¼˜å…ˆä½¿ç”¨          â†‘ fallback\n â†“\nLLM Client\n```\n\n### ä¸­é—´ä»¶æ¶æ„\n\n```\nSkill é…ç½®\n â†“\nmiddleware:\n  - context_management  â† ä¸Šä¸‹æ–‡ç®¡ç†\n  - memory_integration  â† è®°å¿†é›†æˆ\n  - followup           â† è¿½é—®åˆ¤æ–­\n â†“\nOrchestrator åº”ç”¨ä¸­é—´ä»¶\n â†“\nContextMiddleware.process()\n â†“\nä½¿ç”¨ MemoryManager è·å–å†å²\n â†“\nå¢å¼º context\n â†“\nAgent.execute()\n```\n\n---\n\n## æ€»ç»“\n\n### å®Œæˆçš„å·¥ä½œ\n\n1. âœ… éªŒè¯å¹¶æ–‡æ¡£åŒ–äº†æ¨¡å‹é…ç½®æ¶æ„\n2. âœ… ä¿®å¤äº†ä¸­é—´ä»¶å¯¼å…¥é”™è¯¯\n3. âœ… åˆ›å»ºäº†å®Œæ•´çš„æµ‹è¯•è¦†ç›–\n4. âœ… æ›´æ–°äº†ç›¸å…³æ–‡æ¡£"
},
{
"path": "ä¿®å¤è®°å½•.md",
"start": 221,
"end": 275,
"text": "5. âœ… ä¿®å¤äº†é…ç½®é—®é¢˜\n\n### å…³é”®æ”¹è¿›\n\n1. **æ¨¡å‹é…ç½®æ›´çµæ´»**\n   - åœ¨Skillé…ç½®æ–‡ä»¶ä¸­æŒ‡å®šæ¨¡å‹\n   - Agentä»£ç åªæä¾›é»˜è®¤å€¼\n   - åŒä¸€Agentå¯åœ¨ä¸åŒSkillä¸­ä½¿ç”¨ä¸åŒæ¨¡å‹\n\n2. **ä¸­é—´ä»¶æ›´ç¨³å®š**\n   - ä¿®å¤äº†å¯¼å…¥é”™è¯¯\n   - ä½¿ç”¨å·²æœ‰çš„è®°å¿†ç³»ç»Ÿ\n   - ç®€åŒ–äº†å®ç°\n\n3. **æ–‡æ¡£æ›´å®Œå–„**\n   - æ¶æ„è¯´æ˜æ–‡æ¡£\n   - å¿«é€Ÿé…ç½®æŒ‡å—\n   - æµ‹è¯•å’ŒéªŒè¯\n\n### æœ€ä½³å®è·µ\n\n1. **æ¨¡å‹é…ç½®**\n   - âœ… åœ¨Skillé…ç½®æ–‡ä»¶ä¸­æ˜ç¡®æŒ‡å®šæ¨¡å‹\n   - âœ… Agentä»£ç ä¸­ä½¿ç”¨é€šç”¨é»˜è®¤æ¨¡å‹\n   - âœ… åªä½¿ç”¨å·²é…ç½®çš„æ¨¡å‹\n\n2. **ä¸­é—´ä»¶å¼€å‘**\n   - âœ… ä½¿ç”¨å·²æœ‰çš„ç³»ç»Ÿæ¨¡å—ï¼ˆå¦‚MemoryManagerï¼‰\n   - âœ… é¿å…å¼•ç”¨ä¸å­˜åœ¨çš„æ¨¡å—\n   - âœ… æä¾›å®Œæ•´çš„é”™è¯¯å¤„ç†\n\n3. **æµ‹è¯•é©±åŠ¨**\n   - âœ… ä¸ºæ¯ä¸ªä¿®å¤åˆ›å»ºæµ‹è¯•\n   - âœ… éªŒè¯ä¿®å¤çš„æ­£ç¡®æ€§\n   - âœ… é˜²æ­¢å›å½’\n\n---\n\n## ä¸‹ä¸€æ­¥\n\nå»ºè®®çš„æ”¹è¿›æ–¹å‘ï¼š\n\n1. **æ€§èƒ½ä¼˜åŒ–**\n   - ä¸­é—´ä»¶ç¼“å­˜\n   - å†å²åŠ è½½ä¼˜åŒ–\n\n2. **åŠŸèƒ½å¢å¼º**\n   - æ›´æ™ºèƒ½çš„ä¸Šä¸‹æ–‡ç®¡ç†\n   - æ›´ç²¾ç¡®çš„è¿½é—®åˆ¤æ–­\n\n3. **æ–‡æ¡£å®Œå–„**\n   - æ·»åŠ æ›´å¤šç¤ºä¾‹\n   - è§†é¢‘æ•™ç¨‹\n\n---"
},
{
"path": "ä¿®å¤è®°å½•.md",
"start": 276,
"end": 330,
"text": "\n**ä¿®å¤å®Œæˆæ—¶é—´**: 2025-02-17\n**æµ‹è¯•çŠ¶æ€**: âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡\n**æ–‡æ¡£çŠ¶æ€**: âœ… å·²æ›´æ–°\n\n\n---\n\n### é—®é¢˜3: å·¥å…·å‚æ•°å ä½ç¬¦é—®é¢˜ âœ…\n\n**é—®é¢˜æè¿°**:\n```\næ‰§è¡Œå·¥å…·: repo_map\nrepo_path  /path/to/your/repo\nâš ï¸  å·¥å…·è¿”å›é”™è¯¯: ä»“åº“è·¯å¾„ä¸å­˜åœ¨: /path/to/your/repo\n```\n\n**æ ¹æœ¬åŸå› **:\n- LLMåœ¨è°ƒç”¨å·¥å…·æ—¶ä¼ äº†å ä½ç¬¦å‚æ•° `/path/to/your/repo`\n- å·¥å…·æè¿°ä¸­æ²¡æœ‰æ˜ç¡®è¯´æ˜åº”è¯¥ä½¿ç”¨ `.` è¡¨ç¤ºå½“å‰ç›®å½•\n\n**è§£å†³æ–¹æ¡ˆ**:\n1. æ›´æ–°å·¥å…·æè¿°ï¼Œæ˜ç¡®è¯´æ˜ä½¿ç”¨æ–¹æ³•\n   - `repo_map`: \"ä»“åº“æ ¹ç›®å½•è·¯å¾„ã€‚ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•\"\n   - `get_repo_structure`: åŒä¸Š\n   - `get_project_docs`: åŒä¸Š\n\n2. ä¿®å¤çš„æ–‡ä»¶ï¼š\n   - `backend/daoyoucode/agents/tools/repomap_tools.py`\n   - `backend/daoyoucode/agents/tools/project_docs_tools.py`\n\n**éªŒè¯**:\nç°åœ¨LLMåº”è¯¥çŸ¥é“ä½¿ç”¨ `.` ä½œä¸ºrepo_pathå‚æ•°\n\n---\n\n### é—®é¢˜4: LLM 500é”™è¯¯ âš ï¸\n\n**é—®é¢˜æè¿°**:\n```\næ‰§è¡Œå¤±è´¥: è¿æ¥é”™è¯¯: Server error '500 Internal Server Error' \nfor url 'https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions'\n```\n\n**å¯èƒ½åŸå› **:\n1. APIé…é¢ä¸è¶³ï¼ˆæ£€æŸ¥é˜¿é‡Œäº‘è´¦æˆ·ä½™é¢ï¼‰\n2. è¯·æ±‚æ ¼å¼é”™è¯¯ï¼ˆç‰¹åˆ«æ˜¯Function Callingæ ¼å¼ï¼‰\n3. æ¨¡å‹ä¸æ”¯æŒFunction Callingï¼ˆæŸäº›æ¨¡å‹ä¸æ”¯æŒï¼‰\n4. è¯·æ±‚è¿‡å¤§ï¼ˆmessagesæˆ–functionså¤ªå¤šï¼‰\n5. æœåŠ¡ç«¯ä¸´æ—¶æ•…éšœï¼ˆé‡è¯•å¯èƒ½è§£å†³ï¼‰\n\n**è¯Šæ–­å·¥å…·**:\nåˆ›å»ºäº† `test_llm_connection.py` ç”¨äºè¯Šæ–­ï¼š\n```bash\ncd backend"
},
{
"path": "ä¿®å¤è®°å½•.md",
"start": 331,
"end": 385,
"text": "python test_llm_connection.py\n```\n\næµ‹è¯•å†…å®¹ï¼š\n- âœ… API Keyé…ç½®æ£€æŸ¥\n- âœ… ç®€å•LLMè¯·æ±‚æµ‹è¯•\n- âœ… Function Callingæµ‹è¯•\n- âœ… é”™è¯¯è¯Šæ–­å»ºè®®\n\n**å»ºè®®çš„è§£å†³æ–¹æ¡ˆ**:\n1. æ£€æŸ¥é˜¿é‡Œäº‘è´¦æˆ·ä½™é¢å’Œé…é¢\n2. å°è¯•ä¸ä½¿ç”¨Function Callingçš„ç®€å•è¯·æ±‚\n3. å‡å°‘messageså†å²é•¿åº¦ï¼ˆå½“å‰æœ€å¤š5è½®ï¼‰\n4. æ·»åŠ é‡è¯•æœºåˆ¶ï¼ˆå·²æœ‰è¶…æ—¶é‡è¯•ï¼‰\n5. æ£€æŸ¥æ¨¡å‹æ˜¯å¦æ”¯æŒFunction Calling\n\n**æ³¨æ„**:\n- 500é”™è¯¯é€šå¸¸æ˜¯æœåŠ¡ç«¯é—®é¢˜ï¼Œä¸æ˜¯ä»£ç é—®é¢˜\n- å¦‚æœç®€å•è¯·æ±‚æˆåŠŸä½†Function Callingå¤±è´¥ï¼Œå¯èƒ½æ˜¯æ¨¡å‹ä¸æ”¯æŒ\n- å»ºè®®ä½¿ç”¨ `qwen-max` æˆ– `qwen-plus`ï¼Œå®ƒä»¬å®Œå…¨æ”¯æŒFunction Calling\n\n---\n\n## æ›´æ–°çš„æµ‹è¯•\n\n### 4. LLMè¿æ¥æµ‹è¯• (`test_llm_connection.py`)\n\næµ‹è¯•å†…å®¹ï¼š\n- âœ… API Keyé…ç½®æ£€æŸ¥\n- âœ… ç®€å•LLMè¯·æ±‚\n- âœ… Function Callingè¯·æ±‚\n- âœ… 500é”™è¯¯è¯Šæ–­\n\nè¿è¡Œï¼š\n```bash\ncd backend\npython test_llm_connection.py\n```\n\n---\n\n## æ›´æ–°æ—¶é—´\n\n**æœ€åæ›´æ–°**: 2025-02-17 (æ–°å¢é—®é¢˜3å’Œé—®é¢˜4)\n\n\n---\n\n### é—®é¢˜5: LLMä½¿ç”¨å ä½ç¬¦è·¯å¾„ âœ…\n\n**é—®é¢˜æè¿°**:\n```\nrepo_path  ./your-repo-path\nâš ï¸  å·¥å…·è¿”å›é”™è¯¯: ä»“åº“è·¯å¾„ä¸å­˜åœ¨\n```"
},
{
"path": "ä¿®å¤è®°å½•.md",
"start": 386,
"end": 440,
"text": "\n**æ ¹æœ¬åŸå› **:\n- LLMåœ¨è°ƒç”¨å·¥å…·æ—¶ä½¿ç”¨äº†å ä½ç¬¦è·¯å¾„ `your-repo-path`\n- Promptä¸­æ²¡æœ‰æ˜ç¡®è¯´æ˜åº”è¯¥ä½¿ç”¨ `.` è¡¨ç¤ºå½“å‰ç›®å½•\n\n**è§£å†³æ–¹æ¡ˆ**:\n1. åœ¨Promptä¸­æ·»åŠ æ˜ç¡®è¯´æ˜\n   - \"æ‰€æœ‰éœ€è¦è·¯å¾„çš„å·¥å…·ï¼Œä½¿ç”¨ `.` è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•\"\n   - æ·»åŠ æ­£ç¡®å’Œé”™è¯¯çš„ç¤ºä¾‹å¯¹æ¯”\n\n2. æ›´æ–°çš„æ–‡ä»¶ï¼š\n   - `skills/sisyphus-orchestrator/prompts/sisyphus.md`\n\n3. æ·»åŠ çš„å†…å®¹ï¼š\n   - å·¥å…·ä½¿ç”¨ç¤ºä¾‹ï¼ˆâœ… æ­£ç¡® vs âŒ é”™è¯¯ï¼‰\n   - æ˜ç¡®è¯´æ˜å½“å‰å·¥ä½œç›®å½•å°±æ˜¯é¡¹ç›®æ ¹ç›®å½•\n\n**éªŒè¯**:\né‡æ–°è¿è¡Œåï¼ŒLLMåº”è¯¥ä½¿ç”¨ `repo_map(repo_path=\".\")` è€Œä¸æ˜¯å ä½ç¬¦\n\n---\n\n### é—®é¢˜6: API 500é”™è¯¯çš„çœŸå®åŸå›  âš ï¸\n\n**APIè¿”å›çš„é”™è¯¯**:\n```json\n{\n  \"error\": {\n    \"message\": \"An internal error has occured, please try again later or contact service support.\",\n    \"type\": \"internal_error\",\n    \"code\": \"internal_error\"\n  }\n}\n```\n\n**åˆ†æ**:\nè¿™æ˜¯é˜¿é‡Œäº‘APIçš„çœŸå®å†…éƒ¨é”™è¯¯ï¼Œå¯èƒ½åŸå› ï¼š\n1. **è¯·æ±‚è¿‡å¤§** - Payloadè¶…è¿‡é™åˆ¶\n2. **å¹¶å‘è¿‡é«˜** - åŒæ—¶è¯·æ±‚å¤ªå¤š\n3. **æœåŠ¡ç«¯é—®é¢˜** - APIä¸´æ—¶æ•…éšœ\n4. **é…é¢é™åˆ¶** - è¾¾åˆ°é€Ÿç‡é™åˆ¶\n\n**Debugå·¥å…·**:\nå·²æ·»åŠ è¯¦ç»†çš„debugæ—¥å¿—ï¼š\n- æ˜¾ç¤ºAPI Keyä½¿ç”¨æƒ…å†µ\n- æ˜¾ç¤ºPayloadå¤§å°\n- æ˜¾ç¤ºæ¶ˆæ¯å’ŒFunctionsæ•°é‡\n- ä¿å­˜å®Œæ•´è¯·æ±‚åˆ°JSONæ–‡ä»¶\n\n**ä½¿ç”¨æ–¹æ³•**:\n```bash\n$env:DEBUG_LLM_REQUEST=\"1\"\npython daoyoucode.py chat --skill sisyphus-orchestrator\n```\n"
},
{
"path": "ä¿®å¤è®°å½•.md",
"start": 441,
"end": 480,
"text": "**ä¸´æ—¶è§£å†³æ–¹æ¡ˆ**:\n1. å‡å°‘å†å²æ¶ˆæ¯æ•°é‡\n2. å‡å°‘å·¥å…·æ•°é‡ï¼ˆåªä¿ç•™5-10ä¸ªï¼‰\n3. ä½¿ç”¨ `qwen-plus` ä»£æ›¿ `qwen-max`\n4. æ·»åŠ æ›´å¤šAPI Keyè½®è¯¢\n\n---\n\n## Debugå·¥å…·\n\n### 1. è¯·æ±‚æ—¥å¿—\n\nåœ¨ `unified.py` ä¸­æ·»åŠ äº†è¯¦ç»†çš„è¯·æ±‚æ—¥å¿—ï¼š\n- API Keyä½¿ç”¨æƒ…å†µ\n- Payloadå¤§å°\n- æ¶ˆæ¯æ•°é‡\n- Functionsæ•°é‡\n\n### 2. å®Œæ•´è¯·æ±‚ä¿å­˜\n\nè®¾ç½®ç¯å¢ƒå˜é‡ `DEBUG_LLM_REQUEST=1` ä¼šä¿å­˜å®Œæ•´è¯·æ±‚åˆ°JSONæ–‡ä»¶\n\n### 3. é”™è¯¯å“åº”æ—¥å¿—\n\n500é”™è¯¯æ—¶ä¼šæ˜¾ç¤ºï¼š\n- çŠ¶æ€ç \n- URL\n- å“åº”å†…å®¹\n\n### 4. DebugæŒ‡å—\n\nåˆ›å»ºäº† `debug_500_error.md` åŒ…å«ï¼š\n- å¿«é€ŸDebugæ­¥éª¤\n- å¸¸è§é—®é¢˜æ’æŸ¥\n- å¿«é€Ÿä¿®å¤å»ºè®®\n- æµ‹è¯•æ–¹æ³•\n\n---\n\n**æœ€åæ›´æ–°**: 2025-02-17 (æ–°å¢é—®é¢˜5å’Œé—®é¢˜6ï¼Œæ·»åŠ Debugå·¥å…·)"
},
{
"path": "å ä½ç¬¦è·¯å¾„ä¿®å¤å®Œæˆ.md",
"start": 1,
"end": 55,
"text": "# å ä½ç¬¦è·¯å¾„é—®é¢˜ä¿®å¤å®Œæˆ\n\n## é—®é¢˜å›é¡¾\n\nLLMåœ¨è°ƒç”¨å·¥å…·æ—¶ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼š\n- `repo_map(repo_path=\"./your-repo-path\")` âŒ\n- `read_file(file_path=\"path/to/your/file.txt\")` âŒ\n- `text_search(directory=\"./src\")` âŒ\n\n## ä¿®å¤æ–¹æ¡ˆ\n\n### 1. åœ¨Agent Promptå¼€å¤´æ·»åŠ å·¥å…·ä½¿ç”¨è§„åˆ™ â­â­â­â­â­\n\n**æ–‡ä»¶**ï¼š`backend/daoyoucode/agents/core/agent.py`\n\n**ä¿®æ”¹**ï¼šåœ¨`execute()`æ–¹æ³•ä¸­ï¼Œæ„å»º`full_prompt`æ—¶ï¼Œåœ¨æœ€å‰é¢æ·»åŠ å·¥å…·ä½¿ç”¨è§„åˆ™ï¼š\n\n```python\n# ğŸ†• æ·»åŠ å·¥å…·ä½¿ç”¨è§„åˆ™ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼Œæ”¾åœ¨Promptæœ€å‰é¢ï¼‰\nif tools:\n    tool_rules = \"\"\"âš ï¸ å·¥å…·ä½¿ç”¨è§„åˆ™ï¼ˆå¿…é¡»éµå®ˆï¼‰ï¼š\n\n1. è·¯å¾„å‚æ•°ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•\n   - âœ… æ­£ç¡®ï¼šrepo_map(repo_path=\".\")\n   - âŒ é”™è¯¯ï¼šrepo_map(repo_path=\"./your-repo-path\")\n   - âŒ é”™è¯¯ï¼šrepo_map(repo_path=\"/path/to/repo\")\n\n2. æ–‡ä»¶è·¯å¾„ä½¿ç”¨ç›¸å¯¹è·¯å¾„\n   - âœ… æ­£ç¡®ï¼šread_file(file_path=\"backend/config.py\")\n   - âŒ é”™è¯¯ï¼šread_file(file_path=\"path/to/your/file.txt\")\n\n3. æœç´¢ç›®å½•ä½¿ç”¨ '.' æˆ–çœç•¥\n   - âœ… æ­£ç¡®ï¼štext_search(query=\"example\", directory=\".\")\n   - âŒ é”™è¯¯ï¼štext_search(query=\"example\", directory=\"./src\")\n\nè®°ä½ï¼šå½“å‰å·¥ä½œç›®å½•å°±æ˜¯é¡¹ç›®æ ¹ç›®å½•ï¼Œä¸éœ€è¦çŒœæµ‹è·¯å¾„ï¼\n\n---\n\n\"\"\"\n    full_prompt = tool_rules + full_prompt\n```\n\n**ä¼˜ç‚¹**ï¼š\n- æƒé‡æœ€é«˜ï¼ˆåœ¨Promptæœ€å‰é¢ï¼‰\n- å¯¹æ‰€æœ‰å·¥å…·è°ƒç”¨ç”Ÿæ•ˆ\n- ä¸ä¼šè¢«é•¿æ–‡æœ¬ç¨€é‡Š\n\n### 2. åœ¨BaseToolä¸­æ·»åŠ è·¯å¾„éªŒè¯å’Œè‡ªåŠ¨ä¿®æ­£ â­â­â­â­\n\n**æ–‡ä»¶**ï¼š`backend/daoyoucode/agents/tools/base.py`\n\n**ä¿®æ”¹**ï¼šåœ¨`resolve_path()`æ–¹æ³•ä¸­æ·»åŠ å ä½ç¬¦æ£€æµ‹å’Œè‡ªåŠ¨ä¿®æ­£ï¼š\n\n```python"
},
{
"path": "å ä½ç¬¦è·¯å¾„ä¿®å¤å®Œæˆ.md",
"start": 56,
"end": 110,
"text": "def resolve_path(self, path: str) -> Path:\n    \"\"\"\n    è§£æè·¯å¾„ï¼ˆä½¿ç”¨ ToolContextï¼‰\n    \n    è‡ªåŠ¨æ£€æµ‹å¹¶ä¿®æ­£å¸¸è§çš„å ä½ç¬¦è·¯å¾„é”™è¯¯ã€‚\n    \"\"\"\n    # ğŸ†• æ£€æµ‹å ä½ç¬¦è·¯å¾„\n    placeholder_patterns = [\n        'your-repo-path',\n        'your-project',\n        'your-repo',\n        'path/to/your',\n        'path/to/file',\n        'example/path',\n        'example-path'\n    ]\n    \n    path_lower = path.lower()\n    for pattern in placeholder_patterns:\n        if pattern in path_lower:\n            self.logger.warning(\n                f\"âš ï¸  æ£€æµ‹åˆ°å ä½ç¬¦è·¯å¾„: {path}\\n\"\n                f\"   è‡ªåŠ¨ä¿®æ­£ä¸º: .\\n\"\n                f\"   æç¤ºï¼šè¯·ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•\"\n            )\n            # è‡ªåŠ¨ä¿®æ­£ä¸ºå½“å‰å·¥ä½œç›®å½•\n            return self.context.repo_path\n    \n    # ğŸ†• å»æ‰ ./ å‰ç¼€ï¼ˆå¦‚æœè·¯å¾„ä¸å­˜åœ¨ï¼‰\n    if path.startswith('./'):\n        clean_path = path[2:]\n        full_path = self.context.repo_path / clean_path\n        \n        # å¦‚æœå»æ‰ ./ åçš„è·¯å¾„å­˜åœ¨ï¼Œä½¿ç”¨å®ƒ\n        if not full_path.exists():\n            self.logger.warning(\n                f\"âš ï¸  è·¯å¾„ä¸å­˜åœ¨: {path}\\n\"\n                f\"   å°è¯•å»æ‰ ./ å‰ç¼€: {clean_path}\"\n            )\n            path = clean_path\n    \n    return self.context.abs_path(path)\n```\n\n**ä¼˜ç‚¹**ï¼š\n- æœ€åä¸€é“é˜²çº¿\n- è‡ªåŠ¨ä¿®æ­£å¸¸è§é”™è¯¯\n- ä¸ä¾èµ–LLM\n- æä¾›æ¸…æ™°çš„è­¦å‘Šä¿¡æ¯\n\n## æµ‹è¯•ç»“æœ\n\nè¿è¡Œ `python test_placeholder_fix.py`ï¼š\n\n```"
},
{
"path": "å ä½ç¬¦è·¯å¾„ä¿®å¤å®Œæˆ.md",
"start": 111,
"end": 165,
"text": "æµ‹è¯•è·¯å¾„: ./your-repo-path\nâš ï¸  æ£€æµ‹åˆ°å ä½ç¬¦è·¯å¾„: ./your-repo-path\n   è‡ªåŠ¨ä¿®æ­£ä¸º: .\n   æç¤ºï¼šè¯·ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•\nâœ… è‡ªåŠ¨ä¿®æ­£ä¸ºå½“å‰ç›®å½•\n\næµ‹è¯•è·¯å¾„: path/to/your/file.txt\nâš ï¸  æ£€æµ‹åˆ°å ä½ç¬¦è·¯å¾„: path/to/your/file.txt\n   è‡ªåŠ¨ä¿®æ­£ä¸º: .\n   æç¤ºï¼šè¯·ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•\nâœ… è‡ªåŠ¨ä¿®æ­£ä¸ºå½“å‰ç›®å½•\n\næµ‹è¯•è·¯å¾„: ./src\nâš ï¸  è·¯å¾„ä¸å­˜åœ¨: ./src\n   å°è¯•å»æ‰ ./ å‰ç¼€: src\nâœ… è‡ªåŠ¨å»æ‰ ./ å‰ç¼€\n```\n\n## ä¸‹ä¸€æ­¥æµ‹è¯•\n\n### 1. è¿è¡Œå®é™…çš„CLIæµ‹è¯•\n\n```bash\ncd backend\npython daoyoucode.py chat --skill sisyphus-orchestrator\n```\n\næµ‹è¯•ç”¨ä¾‹ï¼š\n```\n> ä½ å¥½ï¼Œå¸®æˆ‘çœ‹çœ‹é¡¹ç›®ç»“æ„\næœŸæœ›ï¼šrepo_map(repo_path=\".\")\n\n> æœç´¢æ‰€æœ‰çš„Agentå®šä¹‰\næœŸæœ›ï¼štext_search(query=\"Agent\", directory=\".\")\n\n> è¯»å–LLMé…ç½®æ–‡ä»¶\næœŸæœ›ï¼šå…ˆæœç´¢ï¼Œç„¶å read_file(file_path=\"config/llm_config.yaml\")\n```\n\n### 2. ä½¿ç”¨VSCodeè°ƒè¯•å™¨è¿½è¸ª\n\nå¦‚æœLLMä»ç„¶ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼š\n1. åœ¨ `.vscode/launch.json` ä¸­å¯åŠ¨è°ƒè¯•\n2. åœ¨ `backend/daoyoucode/agents/core/agent.py` çš„ `_call_llm_with_tools` æ–¹æ³•è®¾ç½®æ–­ç‚¹\n3. æŸ¥çœ‹ `messages` å’Œ `function_schemas` çš„å†…å®¹\n4. ç¡®è®¤å·¥å…·ä½¿ç”¨è§„åˆ™æ˜¯å¦åœ¨Promptä¸­\n\n### 3. æ£€æŸ¥DEBUGæ—¥å¿—\n\nè®¾ç½®ç¯å¢ƒå˜é‡ï¼š\n```bash\nset DEBUG_LLM_REQUEST=1\npython daoyoucode.py chat --skill sisyphus-orchestrator\n```\n"
},
{
"path": "å ä½ç¬¦è·¯å¾„ä¿®å¤å®Œæˆ.md",
"start": 166,
"end": 220,
"text": "æŸ¥çœ‹ç”Ÿæˆçš„ `debug_llm_request_*.json` æ–‡ä»¶ï¼Œæ£€æŸ¥ï¼š\n- `messages` ä¸­æ˜¯å¦åŒ…å«å·¥å…·ä½¿ç”¨è§„åˆ™\n- `functions` çš„æè¿°æ˜¯å¦æ­£ç¡®\n- LLMçš„å“åº”ä¸­ `function_call.arguments` çš„å†…å®¹\n\n## ä¿®å¤æ•ˆæœé¢„æœŸ\n\n### åœºæ™¯1ï¼šLLMéµå®ˆè§„åˆ™ âœ…\n\nLLMçœ‹åˆ°Promptå¼€å¤´çš„è§„åˆ™ï¼Œä½¿ç”¨æ­£ç¡®çš„è·¯å¾„ï¼š\n```json\n{\n  \"function_call\": {\n    \"name\": \"repo_map\",\n    \"arguments\": \"{\\\"repo_path\\\": \\\".\\\"}\"\n  }\n}\n```\n\n### åœºæ™¯2ï¼šLLMä»ä½¿ç”¨å ä½ç¬¦ âš ï¸\n\nLLMå¿½ç•¥è§„åˆ™ï¼Œä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼š\n```json\n{\n  \"function_call\": {\n    \"name\": \"repo_map\",\n    \"arguments\": \"{\\\"repo_path\\\": \\\"./your-repo-path\\\"}\"\n  }\n}\n```\n\nä½†æ˜¯ï¼Œ`BaseTool.resolve_path()` ä¼šè‡ªåŠ¨ä¿®æ­£ï¼š\n```\nâš ï¸  æ£€æµ‹åˆ°å ä½ç¬¦è·¯å¾„: ./your-repo-path\n   è‡ªåŠ¨ä¿®æ­£ä¸º: .\n   æç¤ºï¼šè¯·ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•\n```\n\nå·¥å…·ä»ç„¶èƒ½æ­£å¸¸æ‰§è¡Œï¼\n\n### åœºæ™¯3ï¼šLLMä½¿ç”¨ ./src âš ï¸\n\nLLMä½¿ç”¨ `./src`ï¼ˆä¸å­˜åœ¨çš„è·¯å¾„ï¼‰ï¼š\n```json\n{\n  \"function_call\": {\n    \"name\": \"text_search\",\n    \"arguments\": \"{\\\"directory\\\": \\\"./src\\\"}\"\n  }\n}\n```\n\n`BaseTool.resolve_path()` ä¼šè‡ªåŠ¨å»æ‰ `./` å‰ç¼€ï¼š\n```\nâš ï¸  è·¯å¾„ä¸å­˜åœ¨: ./src"
},
{
"path": "å ä½ç¬¦è·¯å¾„ä¿®å¤å®Œæˆ.md",
"start": 221,
"end": 246,
"text": "   å°è¯•å»æ‰ ./ å‰ç¼€: src\n```\n\nå¦‚æœ `src` ç›®å½•å­˜åœ¨ï¼Œå·¥å…·æ­£å¸¸æ‰§è¡Œï¼›å¦‚æœä¸å­˜åœ¨ï¼Œè¿”å›é”™è¯¯ã€‚\n\n## æ€»ç»“\n\né€šè¿‡ä¸¤å±‚é˜²æŠ¤ï¼š\n1. **Promptè§„åˆ™**ï¼ˆæ²»æœ¬ï¼‰ï¼šå¼•å¯¼LLMä½¿ç”¨æ­£ç¡®çš„è·¯å¾„æ ¼å¼\n2. **å·¥å…·å±‚éªŒè¯**ï¼ˆæ²»æ ‡ï¼‰ï¼šè‡ªåŠ¨ä¿®æ­£å¸¸è§çš„é”™è¯¯è·¯å¾„\n\nå³ä½¿LLMä»ç„¶ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼Œå·¥å…·ä¹Ÿèƒ½è‡ªåŠ¨ä¿®æ­£å¹¶æ­£å¸¸æ‰§è¡Œã€‚\n\n## ç›¸å…³æ–‡æ¡£\n\n- `backend/PROMPTå ä½ç¬¦é—®é¢˜æ·±åº¦åˆ†æ.md` - é—®é¢˜åˆ†æå’Œè§£å†³æ–¹æ¡ˆ\n- `backend/test_placeholder_fix.py` - æµ‹è¯•è„šæœ¬\n- `backend/debug_500_error.md` - DebugæŒ‡å—\n\n## ä¿®æ”¹çš„æ–‡ä»¶\n\n1. `backend/daoyoucode/agents/core/agent.py` - æ·»åŠ å·¥å…·ä½¿ç”¨è§„åˆ™\n2. `backend/daoyoucode/agents/tools/base.py` - æ·»åŠ è·¯å¾„éªŒè¯å’Œè‡ªåŠ¨ä¿®æ­£\n3. `backend/test_placeholder_fix.py` - æµ‹è¯•è„šæœ¬ï¼ˆæ–°å»ºï¼‰\n4. `backend/PROMPTå ä½ç¬¦é—®é¢˜æ·±åº¦åˆ†æ.md` - é—®é¢˜åˆ†æï¼ˆæ–°å»ºï¼‰\n5. `backend/å ä½ç¬¦è·¯å¾„ä¿®å¤å®Œæˆ.md` - æœ¬æ–‡æ¡£ï¼ˆæ–°å»ºï¼‰"
},
{
"path": "å¦‚ä½•é…ç½®æ¨¡å‹.md",
"start": 1,
"end": 55,
"text": "# å¦‚ä½•é…ç½®æ¨¡å‹ - å¿«é€ŸæŒ‡å—\n\n## ğŸ¯ æ ¸å¿ƒåŸåˆ™\n\n**åœ¨Skillé…ç½®æ–‡ä»¶ä¸­é…ç½®æ¨¡å‹ï¼Œè€Œä¸æ˜¯åœ¨Agentä»£ç ä¸­ã€‚**\n\n## ğŸ“ æ­¥éª¤\n\n### 1. æ£€æŸ¥å¯ç”¨æ¨¡å‹\n\næŸ¥çœ‹ `backend/config/llm_config.yaml`ï¼š\n\n```yaml\nproviders:\n  qwen:\n    api_key: ${DASHSCOPE_API_KEY}\n    models:\n      - qwen-plus          # é€šç”¨æ¨¡å‹\n      - qwen-max           # æœ€å¼ºæ¨¡å‹\n      - qwen-coder-plus    # ä»£ç ä¸“ç”¨æ¨¡å‹\n```\n\n### 2. åœ¨Skillé…ç½®æ–‡ä»¶ä¸­æŒ‡å®šæ¨¡å‹\n\nç¼–è¾‘ `skills/ä½ çš„skillåç§°/skill.yaml`ï¼š\n\n```yaml\nname: your-skill\nagent: your_agent\n\n# åœ¨è¿™é‡Œé…ç½®æ¨¡å‹ âœ…\nllm:\n  model: qwen-coder-plus  # é€‰æ‹©åˆé€‚çš„æ¨¡å‹\n  temperature: 0.3\n  max_tokens: 4000\n```\n\n### 3. ï¼ˆå¯é€‰ï¼‰æ›´æ–°Agenté»˜è®¤æ¨¡å‹\n\nç¼–è¾‘ `backend/daoyoucode/agents/builtin/your_agent.py`ï¼š\n\n```python\nclass YourAgent(BaseAgent):\n    def __init__(self):\n        config = AgentConfig(\n            name=\"your_agent\",\n            description=\"ä½ çš„Agentæè¿°\",\n            model=\"qwen-plus\",  # è®¾ç½®åˆç†çš„é»˜è®¤å€¼ï¼ˆä½œä¸ºfallbackï¼‰\n            temperature=0.7,\n            system_prompt=\"\"\n        )\n        super().__init__(config)\n```\n\n## ğŸ” å¸¸è§åœºæ™¯"
},
{
"path": "å¦‚ä½•é…ç½®æ¨¡å‹.md",
"start": 56,
"end": 110,
"text": "\n### åœºæ™¯1: ä¿®æ”¹ç°æœ‰Skillä½¿ç”¨çš„æ¨¡å‹\n\nåªéœ€ä¿®æ”¹Skillé…ç½®æ–‡ä»¶ï¼š\n\n```bash\n# ç¼–è¾‘\nvim skills/testing/skill.yaml\n\n# ä¿®æ”¹llm.modelå­—æ®µ\nllm:\n  model: qwen-max  # ä» qwen-coder-plus æ”¹ä¸º qwen-max\n```\n\n### åœºæ™¯2: åˆ›å»ºæ–°Skill\n\nå¤åˆ¶ç°æœ‰Skillé…ç½®ï¼Œä¿®æ”¹æ¨¡å‹ï¼š\n\n```bash\ncp -r skills/testing skills/my-testing\nvim skills/my-testing/skill.yaml\n```\n\n```yaml\nname: my-testing\nagent: test_expert\n\nllm:\n  model: qwen-max  # ä½¿ç”¨æ›´å¼ºçš„æ¨¡å‹\n  temperature: 0.2\n```\n\n### åœºæ™¯3: åŒä¸€ä¸ªAgentåœ¨ä¸åŒSkillä¸­ä½¿ç”¨ä¸åŒæ¨¡å‹\n\nå®Œå…¨æ”¯æŒï¼ä¾‹å¦‚ï¼š\n\n**skills/testing/skill.yaml**:\n```yaml\nagent: test_expert\nllm:\n  model: qwen-coder-plus  # æ™®é€šæµ‹è¯•ç”¨ä»£ç æ¨¡å‹\n```\n\n**skills/advanced-testing/skill.yaml**:\n```yaml\nagent: test_expert\nllm:\n  model: qwen-max  # å¤æ‚æµ‹è¯•ç”¨æœ€å¼ºæ¨¡å‹\n```\n\n## âš ï¸ å¸¸è§é”™è¯¯\n\n### é”™è¯¯1: ä½¿ç”¨æœªé…ç½®çš„æ¨¡å‹\n\n```yaml"
},
{
"path": "å¦‚ä½•é…ç½®æ¨¡å‹.md",
"start": 111,
"end": 165,
"text": "llm:\n  model: deepseek-coder  # âŒ å¦‚æœæœªåœ¨llm_config.yamlä¸­é…ç½®\n```\n\n**é”™è¯¯ä¿¡æ¯**:\n```\næœªé…ç½®æä¾›å•†: deepseek\n```\n\n**è§£å†³æ–¹æ¡ˆ**:\n1. ä½¿ç”¨å·²é…ç½®çš„æ¨¡å‹ï¼ˆqwen-plus, qwen-max, qwen-coder-plusï¼‰\n2. æˆ–è€…åœ¨ `config/llm_config.yaml` ä¸­æ·»åŠ deepseeké…ç½®\n\n### é”™è¯¯2: åœ¨Agentä»£ç ä¸­ç¡¬ç¼–ç ç‰¹å®šæ¨¡å‹\n\n```python\n# âŒ ä¸æ¨è\nmodel=\"deepseek-coder\",  # å¦‚æœæœªé…ç½®ä¼šå¯¼è‡´æ‰€æœ‰ä½¿ç”¨è¯¥Agentçš„Skilléƒ½å¤±è´¥\n```\n\n**è§£å†³æ–¹æ¡ˆ**:\n```python\n# âœ… æ¨è\nmodel=\"qwen-plus\",  # ä½¿ç”¨é€šç”¨çš„å·²é…ç½®æ¨¡å‹ä½œä¸ºé»˜è®¤å€¼\n```\n\n## ğŸ§ª éªŒè¯é…ç½®\n\nè¿è¡Œæµ‹è¯•éªŒè¯é…ç½®æ­£ç¡®ï¼š\n\n```bash\ncd backend\npython test_model_config.py\n```\n\n## ğŸ“Š é…ç½®ä¼˜å…ˆçº§\n\n```\nSkillé…ç½® (skill.yaml)\n    â†“ ä¼˜å…ˆçº§æœ€é«˜\nAgenté»˜è®¤ (agent.py)\n    â†“ ä½œä¸ºfallback\nç³»ç»Ÿé»˜è®¤\n```\n\n## ğŸ’¡ æœ€ä½³å®è·µ\n\n1. âœ… **åœ¨Skillé…ç½®æ–‡ä»¶ä¸­æ˜ç¡®æŒ‡å®šæ¨¡å‹**\n   - è®©é…ç½®æ¸…æ™°å¯è§\n   - æ–¹ä¾¿ä¿®æ”¹å’Œç»´æŠ¤\n\n2. âœ… **Agentä»£ç ä¸­ä½¿ç”¨é€šç”¨é»˜è®¤æ¨¡å‹**\n   - ä½¿ç”¨ `qwen-plus` ä½œä¸ºé€šç”¨é»˜è®¤\n   - ç¡®ä¿æ¨¡å‹å·²é…ç½®\n"
},
{
"path": "å¦‚ä½•é…ç½®æ¨¡å‹.md",
"start": 166,
"end": 220,
"text": "3. âœ… **æ ¹æ®ä»»åŠ¡é€‰æ‹©åˆé€‚çš„æ¨¡å‹**\n   - ä»£ç ä»»åŠ¡ï¼š`qwen-coder-plus`\n   - å¤æ‚æ¨ç†ï¼š`qwen-max`\n   - ä¸€èˆ¬å¯¹è¯ï¼š`qwen-plus`\n\n4. âœ… **ä¿æŒé…ç½®ä¸€è‡´æ€§**\n   - åŒç±»Skillä½¿ç”¨ç›¸åŒæ¨¡å‹\n   - ä¾¿äºç®¡ç†å’Œä¼˜åŒ–æˆæœ¬\n\n## ğŸ“š ç›¸å…³æ–‡æ¡£\n\n- [æ¨¡å‹é…ç½®æ¶æ„è¯´æ˜.md](./æ¨¡å‹é…ç½®æ¶æ„è¯´æ˜.md) - è¯¦ç»†æ¶æ„è¯´æ˜\n- [CLIå‘½ä»¤å‚è€ƒ.md](./CLIå‘½ä»¤å‚è€ƒ.md) - CLIä½¿ç”¨æŒ‡å—\n- [AGENTSæ™ºèƒ½ä½“ä»‹ç».md](./AGENTSæ™ºèƒ½ä½“ä»‹ç».md) - Agentä»‹ç»\n\n## ğŸ“ ç¤ºä¾‹\n\n### å®Œæ•´ç¤ºä¾‹ï¼šåˆ›å»ºä¸€ä¸ªä½¿ç”¨ç‰¹å®šæ¨¡å‹çš„Skill\n\n1. åˆ›å»ºSkillç›®å½•ï¼š\n```bash\nmkdir -p skills/my-skill/prompts\n```\n\n2. åˆ›å»ºé…ç½®æ–‡ä»¶ `skills/my-skill/skill.yaml`ï¼š\n```yaml\nname: my-skill\nversion: 1.0.0\ndescription: æˆ‘çš„è‡ªå®šä¹‰Skill\n\norchestrator: simple\nagent: programmer\n\nprompt:\n  file: prompts/my-prompt.md\n\nllm:\n  model: qwen-coder-plus  # âœ… æ˜ç¡®æŒ‡å®šæ¨¡å‹\n  temperature: 0.2\n  max_tokens: 4000\n\ntools:\n  - read_file\n  - write_file\n\nmiddleware:\n  - context_management\n\npermissions:\n  read:\n    - pattern: \"*\"\n      permission: allow\n  write:\n    - pattern: \"*\"\n      permission: ask"
},
{
"path": "å¦‚ä½•é…ç½®æ¨¡å‹.md",
"start": 221,
"end": 247,
"text": "```\n\n3. åˆ›å»ºPromptæ–‡ä»¶ `skills/my-skill/prompts/my-prompt.md`ï¼š\n```markdown\nä½ æ˜¯ä¸€ä¸ªç¼–ç¨‹åŠ©æ‰‹ã€‚\n\nç”¨æˆ·è¾“å…¥ï¼š{{user_input}}\n```\n\n4. ä½¿ç”¨Skillï¼š\n```bash\npython backend/daoyoucode.py chat --skill my-skill\n```\n\n## âœ… æ£€æŸ¥æ¸…å•\n\né…ç½®æ¨¡å‹æ—¶ï¼Œç¡®ä¿ï¼š\n\n- [ ] æ¨¡å‹åœ¨ `config/llm_config.yaml` ä¸­å·²é…ç½®\n- [ ] Skillé…ç½®æ–‡ä»¶ä¸­æŒ‡å®šäº† `llm.model`\n- [ ] Agentä»£ç ä¸­æœ‰åˆç†çš„é»˜è®¤æ¨¡å‹\n- [ ] è¿è¡Œæµ‹è¯•éªŒè¯é…ç½®æ­£ç¡®\n- [ ] æ–‡æ¡£æ›´æ–°ï¼ˆå¦‚æœéœ€è¦ï¼‰\n\n---\n\n**è®°ä½**ï¼šæ¨¡å‹é…ç½®åœ¨Skillé…ç½®æ–‡ä»¶ä¸­ï¼ŒAgentä»£ç ä¸­çš„æ¨¡å‹åªæ˜¯é»˜è®¤å€¼ï¼"
},
{
"path": "æ ¸å¿ƒèƒ½åŠ›å¯¹æ¯”è¯„ä»·.md",
"start": 1,
"end": 55,
"text": "# DaoyouCode æ ¸å¿ƒèƒ½åŠ›å¯¹æ¯”è¯„ä»·\n\n> å¯¹æ¯”å¯¹è±¡ï¼šopencodeã€oh-my-opencodeã€aiderã€‚åŸºäºå½“å‰ä»£ç ä¸å‚è€ƒé¡¹ç›®ç»“æ„å½’çº³ï¼Œä¾›äº§å“ä¸æ¼”è¿›å‚è€ƒã€‚\n\n---\n\n## ä¸€ã€å››è€…å®šä½ç®€è¿°\n\n| é¡¹ç›® | å®šä½ | æŠ€æœ¯æ ˆ | æ ¸å¿ƒå½¢æ€ |\n|------|------|--------|----------|\n| **aider** | çº¯ CLI ä»£ç ç¼–è¾‘/å¯¹è¯åŠ©æ‰‹ | Pythonï¼ŒLiteLLMï¼Œgitï¼Œgrep_ast/tree-sitter | å• Coder + å¤šç§ edit æ ¼å¼ï¼Œrepo_map åšä»£ç åœ°å›¾ |\n| **opencode** | æ¡Œé¢/IDE ä¾§ AI åŠ©æ‰‹ | Tauri + Node å¯åŠ¨è„šæœ¬ï¼Œå†…ç½® opencode-cli äºŒè¿›åˆ¶ | æ¡Œé¢åº”ç”¨ + CLI ä¾§è½¦ï¼Œserver é…ç½®ï¼ˆhost/portï¼‰ |\n| **oh-my-opencode** | OpenCode ç”Ÿæ€çš„é…ç½®/æ’ä»¶æ–¹æ¡ˆ | JSON Schema é…ç½® | ç¦ç”¨/å¯ç”¨ agentsã€skillsã€hooks çš„é…ç½®å±‚ï¼Œéç‹¬ç«‹è¿è¡Œæ—¶ |\n| **DaoyouCode** | CLI ä¼˜å…ˆçš„æ™ºèƒ½ç¼–ç ä¸å¤š Agent å¹³å° | Pythonï¼ŒTyperï¼ŒSkill/Orchestrator/Agent åˆ†å±‚ | CLI â†’ ç¼–æ’å™¨ â†’ Agents â†’ LLMï¼ŒSkill é©±åŠ¨ï¼Œå¤šç¼–æ’å¤š Agent |\n\n---\n\n## äºŒã€DaoyouCode å½“å‰æ ¸å¿ƒèƒ½åŠ›æ¦‚è§ˆ\n\n- **CLI**ï¼š`chat` / `edit` / `doctor` / `config` / `session` / `agent` / `models` / `skills` / `serve` / `version` / `examples`ï¼›ä»“åº“è·¯å¾„æ¨æ–­å‚è€ƒ aiderï¼ˆæ–‡ä»¶/`--repo`/cwdï¼‰ã€‚\n- **ç¼–æ’**ï¼š7 ç§ç¼–æ’å™¨ï¼ˆsimpleã€reactã€multi_agentã€workflowã€conditionalã€parallelã€parallel_exploreï¼‰ï¼ŒReAct ä¸ºä¸»è·¯å¾„ï¼Œå¤š Agent æ”¯æŒé¡ºåº/å¹¶è¡Œ/è¾©è®º/ä¸»ä»ã€‚\n- **Agent**ï¼šå¤šè§’è‰²ï¼ˆMainAgentã€programmerã€sisyphusã€oracleã€librarianã€refactor_masterã€test_expert ç­‰ï¼‰ï¼Œç»Ÿä¸€ BaseAgentï¼ˆè®°å¿†ã€å·¥å…·å¾ªç¯ã€ç”¨æˆ·ç”»åƒã€åå¤„ç†ï¼‰ã€‚\n- **å·¥å…·**ï¼š25+ å·¥å…·ï¼ˆæ–‡ä»¶ã€æœç´¢ã€Gitã€å‘½ä»¤ã€Diffã€RepoMapã€é¡¹ç›®æ–‡æ¡£ã€LSPã€AST ç­‰ï¼‰ï¼ŒToolContextï¼ˆrepo_pathã€subtree_onlyã€cwdï¼‰è´¯ç©¿ã€‚\n- **è®°å¿†**ï¼šä¼šè¯å†å²ã€æ‘˜è¦ã€è¿½é—®æ£€æµ‹ã€æ™ºèƒ½åŠ è½½ã€ç”¨æˆ·åå¥½ä¸ç”»åƒã€ä»»åŠ¡å†å²ã€‚\n- **LLM**ï¼šç»Ÿä¸€å®¢æˆ·ç«¯ã€å¤šæä¾›å•†ã€API Key è½®è¯¢ã€è¶…æ—¶ä¸æ¢å¤ã€‚\n- **è¿ç»´**ï¼šHookã€è¶…æ—¶æ¢å¤ã€å¤±è´¥æ¢å¤ã€ä»»åŠ¡ç®¡ç†ã€DEBUG_LLM ç­‰å¯é…ç½®ã€‚\n\n---\n\n## ä¸‰ã€ä¸ Aider å¯¹æ¯”ï¼ˆåŒèµ›é“ï¼šCLI ä»£ç åŠ©æ‰‹ï¼‰\n\n| ç»´åº¦ | Aider | DaoyouCode | è¯„ä»· |\n|------|--------|------------|------|\n| **ç¼–è¾‘èŒƒå¼** | å¤šç§ Coderï¼ˆwholefile / editblock / udiff / patch ç­‰ï¼‰ï¼ŒæŒ‰ edit_format åˆ‡æ¢ | ç»Ÿä¸€ ReAct + Function Callingï¼ˆread_file / write_file / search_replace ç­‰ï¼‰ï¼ŒæŒ‰ Skill é€‰å·¥å…·é›† | DaoyouCode æ›´ç»Ÿä¸€ã€å¯æ‰©å±•ï¼›aider åœ¨å•æ–‡ä»¶/å—çº§ç¼–è¾‘ä¸ŠèŒƒå¼æ›´ç»†åˆ† |\n| **ä»£ç åœ°å›¾** | RepoMapï¼štree-sitter/grep_astã€tags ç¼“å­˜ã€token é¢„ç®—ã€refresh ç­–ç•¥ | RepoMap ç±»å·¥å…· + get_repo_structure + é¡¹ç›®æ–‡æ¡£å‘ç° | æ€è·¯æ¥è¿‘ï¼›aider çš„ AST/TS é›†æˆæ›´é‡ï¼ŒDaoyouCode å·¥å…·æ›´æ³›åŒ– |\n| **ä»“åº“/è·¯å¾„** | GitRepoã€å­ç›®å½•ï¼ˆsubtreeï¼‰ã€ä»æ–‡ä»¶æ¨æ–­ repo | determine_repo_path + ToolContext(repo_path, subtree_only, cwd) | å·²å¯¹é½æ€è·¯ï¼Œä¸” executor ä¾§å·²ç»Ÿä¸€ ToolContext |\n| **å·¥å…·æ•°é‡ä¸å½¢æ€** | ä»¥ write_file / editblock ç­‰å°‘é‡â€œå¤§å·¥å…·â€ä¸ºä¸»ï¼Œrun_cmd è·‘ lint/test | 25+ ç»†ç²’åº¦å·¥å…·ï¼ˆæ–‡ä»¶/Git/æœç´¢/LSP/AST/RepoMapï¼‰ | DaoyouCode å·¥å…·æ›´ä¸°å¯Œã€æ›´æ˜“æŒ‰ Skill è£å‰ª |\n| **å¤š Agent / ç¼–æ’** | æ— ï¼›å• Coderã€å•æ¨¡å‹ã€å•è½®å¯¹è¯æµ | å¤š Agent + å¤šç¼–æ’å™¨ + Skill é…ç½® | DaoyouCode æ˜æ˜¾æ›´å¼ºï¼Œé€‚åˆå¤æ‚ä»»åŠ¡ä¸è§’è‰²åˆ†å·¥ |\n| **è®°å¿†ä¸ä¸Šä¸‹æ–‡** | ChatSummaryã€å†å²æ¶ˆæ¯ | ä¼šè¯å†å² + æ‘˜è¦ + è¿½é—®æ£€æµ‹ + ç”¨æˆ·ç”»åƒ + æ™ºèƒ½åŠ è½½ | DaoyouCode è®°å¿†å±‚æ¬¡æ›´å…¨ï¼Œæ›´åˆ©äºé•¿å¯¹è¯ä¸ä¸ªæ€§åŒ– |\n| **é…ç½®ä¸æ‰©å±•** | æ¨¡å‹/ç¼–è¾‘æ ¼å¼/å‚æ•°ï¼Œæ—  Skill æ¦‚å¿µ | Skill YAMLï¼ˆorchestratorã€agentã€toolsã€llmã€middlewareï¼‰ | DaoyouCode æ›´æ˜“åšåœºæ™¯åŒ–é…ç½®ä¸æ‰©å±• |\n| **æˆç†Ÿåº¦ä¸ç”Ÿæ€** | ä¹…ç»ä½¿ç”¨ã€æ–‡æ¡£ä¸ç¤¾åŒºæˆç†Ÿ | è¾ƒæ–°ï¼Œæ–‡æ¡£ä¸æœ€ä½³å®è·µä»åœ¨ç§¯ç´¯ | Aider æ›´ç¨³ã€æ›´â€œå¼€ç®±å³ç”¨â€ï¼›DaoyouCode æ¶æ„æ›´ç°ä»£ã€ä¸Šé™æ›´é«˜ |\n\n**å°ç»“ï¼ˆvs Aiderï¼‰**ï¼šåœ¨â€œCLI + ä»£ç ç¼–è¾‘ + ä»“åº“æ„ŸçŸ¥â€è¿™æ¡çº¿ä¸Šï¼ŒDaoyouCode åœ¨**æ¶æ„ï¼ˆSkill/ç¼–æ’/å¤š Agentï¼‰ã€å·¥å…·ä¸°å¯Œåº¦ã€è®°å¿†ä¸å¯é…ç½®æ€§**ä¸Šå ä¼˜ï¼›åœ¨**å•è½®ç¼–è¾‘èŒƒå¼ç»†åˆ†ã€AST/repomap æ·±åº¦ã€ç”Ÿæ€æˆç†Ÿåº¦**ä¸Š aider ä»å¯å€Ÿé‰´ã€‚æ•´ä½“æ˜¯**åŒä¸€èµ›é“ä¸Šçš„å‡çº§ç‰ˆæ¶æ„**ï¼Œéœ€ç»§ç»­åœ¨ç¼–è¾‘ä½“éªŒä¸ç¨³å®šæ€§ä¸Šè¿½é½ã€‚\n\n---\n\n## å››ã€ä¸ OpenCode å¯¹æ¯”ï¼ˆä¸åŒå½¢æ€ï¼šæ¡Œé¢ vs CLI å¹³å°ï¼‰\n\n| ç»´åº¦ | OpenCode | DaoyouCode | è¯„ä»· |\n|------|----------|------------|------|\n| **å½¢æ€** | æ¡Œé¢åº”ç”¨ + å†…ç½®/ä¾§è½¦ CLI äºŒè¿›åˆ¶ | çº¯ CLIï¼ˆå¯é…åˆ serve åš HTTPï¼‰ | ä¸åŒäº¤ä»˜å½¢æ€ï¼šOpenCode å IDE/æ¡Œé¢ï¼ŒDaoyouCode åç»ˆç«¯ä¸ API |\n| **æ ¸å¿ƒèƒ½åŠ›** | ä»ä»“åº“çœ‹ä»¥ Tauri/CLI å®‰è£…ã€server é…ç½®ä¸ºä¸»ï¼Œå…·ä½“ Agent/å·¥å…·æœªåœ¨æœ¬æ¬¡èŒƒå›´å†…ç»†çœ‹ | å®Œæ•´çš„ Agent + ç¼–æ’ + Skill + å·¥å…· + è®°å¿† æ ˆ | è‹¥ OpenCode çš„â€œå¤§è„‘â€åœ¨æœåŠ¡ç«¯ï¼ŒDaoyouCode å·²å…·å¤‡ä¸€å¥—å¯å¯¹æ¥çš„â€œå¤§è„‘â€å®ç° |\n| **å¯å¯¹æ¯”æ€§** | äº§å“å½¢æ€ä¸åŒï¼Œç›´æ¥æ¯”â€œèƒ½åŠ›ç‚¹â€æ„ä¹‰æœ‰é™ | æ›´é€‚åˆä½œä¸ºâ€œåç«¯èƒ½åŠ›â€ä¸ OpenCode æ¡Œé¢/CLI å¯¹æ¥ | å¯æŠŠ DaoyouCode è§†ä¸º CLI/æœåŠ¡ç«¯èƒ½åŠ›å±‚ï¼ŒOpenCode è§†ä¸ºå‰ç«¯/å…¥å£ä¹‹ä¸€ |\n\n**å°ç»“ï¼ˆvs OpenCodeï¼‰**ï¼šOpenCode å**æ¡Œé¢/IDE å…¥å£**ï¼ŒDaoyouCode å**CLI ä¸å¤š Agent èƒ½åŠ›æ ˆ**ï¼›äºŒè€…å¯äº’è¡¥ï¼ˆä¾‹å¦‚ OpenCode è°ƒç”¨ DaoyouCode çš„ serve æˆ– Skill æ¥å£ï¼‰ï¼Œè€ŒéåŒä¸€å½¢æ€ä¸‹çš„ç«å“å¯¹æ¯”ã€‚"
},
{
"path": "æ ¸å¿ƒèƒ½åŠ›å¯¹æ¯”è¯„ä»·.md",
"start": 56,
"end": 90,
"text": "\n---\n\n## äº”ã€ä¸ Oh-My-OpenCode å¯¹æ¯”ï¼ˆé…ç½®ç”Ÿæ€ vs å®Œæ•´è¿è¡Œæ—¶ï¼‰\n\n| ç»´åº¦ | Oh-My-OpenCode | DaoyouCode | è¯„ä»· |\n|------|----------------|------------|------|\n| **å®šä½** | OpenCode çš„é…ç½®/æ’ä»¶æ–¹æ¡ˆï¼ˆagentsã€skillsã€hooks çš„å¼€å…³ä¸é…ç½®ï¼‰ | ç‹¬ç«‹è¿è¡Œæ—¶ï¼šæ—¢æœ‰ç¼–æ’ä¸ Agentï¼Œä¹Ÿæœ‰ Skill é…ç½® | Oh-My æ˜¯â€œé…ç½®å±‚â€ï¼ŒDaoyouCode æ˜¯â€œæ‰§è¡Œå±‚ + é…ç½®â€ |\n| **Agent ä¸°å¯Œåº¦** | Schema ä¸­åˆ—å‡º Sisyphusã€oracleã€librarianã€exploreã€multimodal-lookerã€Metisã€Momusã€atlas ç­‰ | å½“å‰æœ‰ MainAgentã€programmerã€sisyphusã€oracleã€librarianã€refactor_masterã€test_expert ç­‰ | è§’è‰²åä¸æ€è·¯æœ‰é‡å ï¼ˆsisyphusã€oracleã€librarianï¼‰ï¼›Oh-My çš„åˆ—è¡¨æ›´åƒâ€œç”Ÿæ€æ¸…å•â€ |\n| **Hooks** | å¤§é‡å‘½å hookï¼ˆtodo-continuationã€context-window-monitorã€session-recoveryã€edit-error-recovery ç­‰ï¼‰ | æœ‰ Hook ä½“ç³»ä¸ HookContextï¼Œå…·ä½“ hook åä¸ Oh-My ä¸å®Œå…¨ä¸€è‡´ | DaoyouCode å…·å¤‡æ‰©å±•åŒç±» hook çš„èƒ½åŠ›ï¼Œå¯æŒ‰éœ€å¯¹é½å‘½åä¸è¡Œä¸º |\n| **Skills** | ç¤ºä¾‹ï¼šplaywrightã€frontend-ui-uxã€git-master | å¤š Skillï¼ˆchat-assistantã€edit-singleã€oracleã€librarianã€sisyphus-orchestrator ç­‰ï¼‰ | éƒ½æ˜¯â€œæŒ‰åœºæ™¯å‘½åâ€çš„ Skillï¼›DaoyouCode å·²å¯è‡ªå»ºåŒç±»æŠ€èƒ½ |\n\n**å°ç»“ï¼ˆvs Oh-My-OpenCodeï¼‰**ï¼šOh-My-OpenCode æè¿°çš„æ˜¯**â€œæœ‰å“ªäº› agents/skills/hooks å¯é…ç½®â€**ï¼ŒDaoyouCode æ˜¯**çœŸæ­£è·‘èµ·è¿™äº›èƒ½åŠ›çš„è¿è¡Œæ—¶**ã€‚å¯ä»¥æŠŠ Oh-My çš„ schema å½“ä½œ**ç›®æ ‡èƒ½åŠ›æ¸…å•**ï¼šDaoyouCode åœ¨éƒ¨åˆ†è§’è‰²ä¸æŠ€èƒ½ä¸Šå·²å¯¹é½ï¼Œåœ¨ hooks ä¸æ›´å¤šæŠ€èƒ½ä¸Šå¯æŒ‰è¯¥æ¸…å•ç»§ç»­è¡¥å…¨ä¸å‘½åç»Ÿä¸€ã€‚\n\n---\n\n## å…­ã€æ€»ä½“è¯„ä»·ä¸å»ºè®®\n\n**å½“å‰æ ¸å¿ƒèƒ½åŠ›ï¼ˆä¸€å¥è¯ï¼‰**  \nDaoyouCode å·²å…·å¤‡**ä¸é€Šäº aider çš„ CLI ä»£ç åŠ©æ‰‹èƒ½åŠ›**ï¼Œå¹¶åœ¨**å¤š Agentã€å¤šç¼–æ’ã€Skill åŒ–é…ç½®ã€è®°å¿†ä¸å·¥å…·ä¸°å¯Œåº¦**ä¸Šæ˜æ˜¾æ›´å¼ºï¼›ä¸ opencode æ˜¯ä¸åŒå½¢æ€ï¼ˆæ¡Œé¢ vs CLI/åç«¯ï¼‰ï¼Œä¸ oh-my-opencode æ˜¯â€œè¿è¡Œæ—¶ vs é…ç½®ç”Ÿæ€â€çš„å…³ç³»ã€‚\n\n**ç›¸å¯¹ä¼˜åŠ¿**  \n- åˆ†å±‚æ¸…æ™°ï¼šCLI â†’ ç¼–æ’å™¨ â†’ Agents â†’ LLMï¼Œæ˜“ç»´æŠ¤ã€æ˜“æ‰©å±•ã€‚  \n- å¤š Agent + å¤šç¼–æ’ï¼šé¡ºåº/å¹¶è¡Œ/è¾©è®º/ä¸»ä»ï¼Œé€‚åˆå¤æ‚ä»»åŠ¡ã€‚  \n- Skill é©±åŠ¨ï¼šYAML é…ç½® agent/orchestrator/tools/llmï¼Œåœºæ™¯åŒ–èƒ½åŠ›å¼ºã€‚  \n- å·¥å…·ä¸è®°å¿†ï¼š25+ å·¥å…·ã€ToolContextã€æ™ºèƒ½è®°å¿†ä¸ç”¨æˆ·ç”»åƒã€‚  \n- å·²åšéƒ¨åˆ†ä¼˜åŒ–ï¼šedit èµ° Skillã€ä¼šè¯çº§åˆå§‹åŒ–ã€ToolContext ç»Ÿä¸€ã€multi_agent ä¼  llm_configã€å¯é…ç½®è§„åˆ™ä¸å†å²è½®æ•°ã€LLM æ—¥å¿—å¯æ§ã€‚\n\n**å¯åŠ å¼ºæ–¹å‘ï¼ˆå¯¹é½/å€Ÿé‰´ï¼‰**  \n- **Aider**ï¼šå•è½®ç¼–è¾‘çš„ç¨³å®šæ€§å’Œåé¦ˆï¼ˆå¦‚ editblock/udiff å¼ç»†ç²’åº¦ç¼–è¾‘ã€lint/test é›†æˆï¼‰ï¼›RepoMap ä¸ AST çš„æ·±åº¦ï¼ˆè‹¥éœ€æ›´å¼ºä»£ç ç†è§£ï¼‰ã€‚  \n- **Oh-My-OpenCode**ï¼šæŠŠå…¶ agents/skills/hooks åˆ—è¡¨å½“è·¯çº¿å›¾ï¼Œè¡¥å…¨å¹¶ç»Ÿä¸€å‘½åï¼Œä¾¿äºâ€œä» OpenCode ç”Ÿæ€è¿ç§»â€çš„å™äº‹ã€‚  \n- **OpenCode**ï¼šè‹¥éœ€æ¡Œé¢/IDE å½¢æ€ï¼Œå¯è€ƒè™‘å°† DaoyouCode çš„ serve æˆ– API ä½œä¸ºåç«¯ï¼Œç”± OpenCode å‰ç«¯è°ƒç”¨ã€‚\n\n**ç»“è®º**  \nåœ¨â€œCLI ä»£ç åŠ©æ‰‹ + å¤š Agent å¹³å°â€è¿™ä¸ªäº¤é›†é‡Œï¼ŒDaoyouCode çš„**æ¶æ„ä¸èƒ½åŠ›å¹¿åº¦å·²è¶…è¿‡ aider**ï¼Œä¸ opencodeã€oh-my-opencode çš„å…³ç³»æ˜¯**äº’è¡¥æˆ–ç”Ÿæ€å¯¹é½**è€ŒéåŒå½¢æ€ç«å“ã€‚åç»­é‡ç‚¹å»ºè®®æ”¾åœ¨**ç¼–è¾‘ä½“éªŒæ‰“ç£¨ã€ç¨³å®šæ€§ä¸å¯è§‚æµ‹æ€§ã€ä»¥åŠæŒ‰ oh-my-opencode æ¸…å•åšèƒ½åŠ›ä¸å‘½åå¯¹é½**ä¸Šã€‚"
},
{
"path": "æ¨¡å‹é…ç½®æ¶æ„è¯´æ˜.md",
"start": 1,
"end": 55,
"text": "# æ¨¡å‹é…ç½®æ¶æ„è¯´æ˜\n\n## æ ¸å¿ƒåŸåˆ™\n\n**æ¨¡å‹é…ç½®åº”è¯¥åœ¨Skillé…ç½®æ–‡ä»¶ä¸­ï¼Œè€ŒéAgentä»£ç ä¸­ç¡¬ç¼–ç ã€‚**\n\nè¿™æ ·è®¾è®¡çš„ä¼˜åŠ¿ï¼š\n- æ›´çµæ´»ï¼šåŒä¸€ä¸ªAgentå¯ä»¥åœ¨ä¸åŒSkillä¸­ä½¿ç”¨ä¸åŒæ¨¡å‹\n- æ›´æ˜“é…ç½®ï¼šä¿®æ”¹æ¨¡å‹åªéœ€æ”¹é…ç½®æ–‡ä»¶ï¼Œæ— éœ€æ”¹ä»£ç \n- æ›´ç¬¦åˆè®¾è®¡ï¼šSkillæ˜¯é…ç½®å±‚ï¼ŒAgentæ˜¯æ‰§è¡Œå±‚\n\n## æ¶æ„æµç¨‹\n\n```\nSkillé…ç½®æ–‡ä»¶ (skill.yaml)\n    â†“\n    llm.model: qwen-coder-plus\n    â†“\nOrchestrator (simple.py)\n    â†“\n    llm_config=skill.llm\n    â†“\nAgent.execute()\n    â†“\n    model = llm_config.get('model', self.config.model)\n    â†“\nLLM Client\n```\n\n## é…ç½®ä¼˜å…ˆçº§\n\n1. **Skillé…ç½®** (`skills/*/skill.yaml` ä¸­çš„ `llm.model`) - æœ€é«˜ä¼˜å…ˆçº§\n2. **Agenté»˜è®¤** (`Agent.__init__()` ä¸­çš„ `model`) - ä½œä¸ºfallback\n\n## ç¤ºä¾‹\n\n### Skillé…ç½®æ–‡ä»¶ (skills/testing/skill.yaml)\n\n```yaml\nname: testing\nversion: 1.0.0\ndescription: æµ‹è¯•ç¼–å†™å’Œä¿®å¤ä¸“å®¶\n\norchestrator: simple\nagent: test_expert\n\nllm:\n  model: qwen-coder-plus  # âœ… åœ¨è¿™é‡Œé…ç½®æ¨¡å‹\n  temperature: 0.3\n  max_tokens: 4000\n```\n\n### Agentä»£ç  (agents/builtin/test_expert.py)\n\n```python"
},
{
"path": "æ¨¡å‹é…ç½®æ¶æ„è¯´æ˜.md",
"start": 56,
"end": 110,
"text": "class TestExpertAgent(BaseAgent):\n    def __init__(self):\n        config = AgentConfig(\n            name=\"test_expert\",\n            description=\"æµ‹è¯•ç¼–å†™å’Œä¿®å¤ä¸“å®¶\",\n            model=\"qwen-coder-plus\",  # âœ… ä½œä¸ºé»˜è®¤å€¼ï¼ˆfallbackï¼‰\n            temperature=0.3,\n            system_prompt=\"\"\n        )\n        super().__init__(config)\n```\n\n## ä»£ç å®ç°\n\n### 1. Orchestratorä¼ é€’é…ç½®\n\n`backend/daoyoucode/agents/orchestrators/simple.py` (line 129):\n\n```python\nresult = await agent.execute(\n    prompt_source=prompt_source,\n    user_input=user_input,\n    context=context,\n    llm_config=skill.llm,  # âœ… ä¼ é€’Skillçš„LLMé…ç½®\n    tools=skill.tools if skill.tools else None\n)\n```\n\n### 2. Agentä½¿ç”¨é…ç½®\n\n`backend/daoyoucode/agents/core/agent.py` (line 883):\n\n```python\n# åˆå¹¶é…ç½®ï¼ˆSkillé…ç½®ä¼˜å…ˆï¼‰\nmodel = (llm_config or {}).get('model', self.config.model)\ntemperature = (llm_config or {}).get('temperature', self.config.temperature)\n```\n\n## æœ€ä½³å®è·µ\n\n### âœ… æ¨èåšæ³•\n\n1. **åœ¨Skillé…ç½®æ–‡ä»¶ä¸­æŒ‡å®šæ¨¡å‹**\n   ```yaml\n   llm:\n     model: qwen-coder-plus\n     temperature: 0.3\n   ```\n\n2. **Agentä»£ç ä¸­è®¾ç½®åˆç†çš„é»˜è®¤å€¼**\n   ```python\n   model=\"qwen-plus\",  # é€šç”¨é»˜è®¤æ¨¡å‹\n   ```\n\n3. **ä½¿ç”¨å·²é…ç½®çš„æ¨¡å‹**"
},
{
"path": "æ¨¡å‹é…ç½®æ¶æ„è¯´æ˜.md",
"start": 111,
"end": 165,
"text": "   - æ£€æŸ¥ `backend/config/llm_config.yaml` ç¡®ä¿æ¨¡å‹å·²é…ç½®\n   - å¸¸ç”¨æ¨¡å‹ï¼š`qwen-plus`, `qwen-max`, `qwen-coder-plus`\n\n### âŒ é¿å…çš„åšæ³•\n\n1. **ä¸è¦åœ¨Agentä»£ç ä¸­ç¡¬ç¼–ç ç‰¹å®šæ¨¡å‹**\n   ```python\n   # âŒ ä¸å¥½\n   model=\"deepseek-coder\",  # å¦‚æœæœªé…ç½®ä¼šæŠ¥é”™\n   ```\n\n2. **ä¸è¦ä½¿ç”¨æœªé…ç½®çš„æ¨¡å‹**\n   - å…ˆåœ¨ `llm_config.yaml` ä¸­é…ç½®\n   - å†åœ¨ `skill.yaml` ä¸­ä½¿ç”¨\n\n## é…ç½®æ¨¡å‹\n\n### æŸ¥çœ‹å·²é…ç½®çš„æ¨¡å‹\n\næŸ¥çœ‹ `backend/config/llm_config.yaml`:\n\n```yaml\nproviders:\n  qwen:\n    api_key: ${DASHSCOPE_API_KEY}\n    models:\n      - qwen-plus\n      - qwen-max\n      - qwen-coder-plus\n```\n\n### æ·»åŠ æ–°æ¨¡å‹\n\n1. åœ¨ `llm_config.yaml` ä¸­æ·»åŠ æ¨¡å‹é…ç½®\n2. åœ¨ `skill.yaml` ä¸­ä½¿ç”¨æ–°æ¨¡å‹\n\n## å¸¸è§é—®é¢˜\n\n### Q: ä¸ºä»€ä¹ˆä¼šæŠ¥\"æœªé…ç½®æä¾›å•†: deepseek\"ï¼Ÿ\n\nA: å› ä¸ºSkillé…ç½®æ–‡ä»¶ä¸­ä½¿ç”¨äº† `deepseek-coder`ï¼Œä½† `llm_config.yaml` ä¸­æ²¡æœ‰é…ç½®deepseekæä¾›å•†ã€‚\n\nè§£å†³æ–¹æ¡ˆï¼š\n1. ä¿®æ”¹Skillé…ç½®ä½¿ç”¨å·²é…ç½®çš„æ¨¡å‹ï¼ˆå¦‚ `qwen-coder-plus`ï¼‰\n2. æˆ–è€…åœ¨ `llm_config.yaml` ä¸­æ·»åŠ deepseeké…ç½®\n\n### Q: Agentä»£ç ä¸­çš„modelå‚æ•°è¿˜æœ‰ç”¨å—ï¼Ÿ\n\nA: æœ‰ç”¨ï¼å®ƒä½œä¸ºfallbacké»˜è®¤å€¼ã€‚å¦‚æœSkillé…ç½®æ–‡ä»¶ä¸­æ²¡æœ‰æŒ‡å®šæ¨¡å‹ï¼Œå°±ä¼šä½¿ç”¨Agentçš„é»˜è®¤æ¨¡å‹ã€‚\n\n### Q: åŒä¸€ä¸ªAgentå¯ä»¥åœ¨ä¸åŒSkillä¸­ä½¿ç”¨ä¸åŒæ¨¡å‹å—ï¼Ÿ\n\nA: å¯ä»¥ï¼è¿™æ­£æ˜¯è¿™ä¸ªæ¶æ„çš„ä¼˜åŠ¿ã€‚ä¾‹å¦‚ï¼š\n- `skills/testing/skill.yaml` ä½¿ç”¨ `qwen-coder-plus`\n- `skills/advanced-testing/skill.yaml` ä½¿ç”¨ `qwen-max`"
},
{
"path": "æ¨¡å‹é…ç½®æ¶æ„è¯´æ˜.md",
"start": 166,
"end": 170,
"text": "- éƒ½ä½¿ç”¨åŒä¸€ä¸ª `test_expert` Agent\n\n## æ€»ç»“\n\næ¨¡å‹é…ç½®çš„æ­£ç¡®ä½ç½®æ˜¯ **Skillé…ç½®æ–‡ä»¶**ï¼ŒAgentä»£ç ä¸­çš„æ¨¡å‹åªæ˜¯é»˜è®¤å€¼ã€‚è¿™æ ·è®¾è®¡è®©ç³»ç»Ÿæ›´çµæ´»ã€æ›´æ˜“é…ç½®ã€‚"
},
{
"path": "cli/app.py",
"start": 1,
"end": 24,
"text": "\"\"\"\nDaoyouCode CLI ä¸»åº”ç”¨\n\nç²¾ç®€è€Œå¼ºå¤§çš„å‘½ä»¤è¡Œç•Œé¢\n\"\"\"\n\nimport typer\nfrom typing import Optional\nfrom pathlib import Path\n\n# ç‰ˆæœ¬å·\n__version__ = \"0.1.0\"\n\n# åˆ›å»ºä¸»åº”ç”¨\napp = typer.Typer(\n    name=\"daoyoucode\",\n    help=\"DaoyouCode - æ™ºèƒ½AIä»£ç åŠ©æ‰‹\",\n    add_completion=True,\n    no_args_is_help=True,\n    rich_markup_mode=\"rich\",  # å¯ç”¨richæ ¼å¼\n)\n\n\n@app.command()"
},
{
"path": "cli/app.py",
"start": 25,
"end": 46,
"text": "def chat(\n    files: Optional[list[Path]] = typer.Argument(None, help=\"è¦åŠ è½½çš„æ–‡ä»¶\"),\n    model: str = typer.Option(\"qwen-max\", \"--model\", \"-m\", help=\"ä½¿ç”¨çš„æ¨¡å‹\"),\n    skill: str = typer.Option(\"chat-assistant\", \"--skill\", \"-s\", help=\"ä½¿ç”¨çš„Skill (ç”¨ 'daoyoucode skills' æŸ¥çœ‹æ‰€æœ‰)\"),\n    repo: Path = typer.Option(\".\", \"--repo\", \"-r\", help=\"ä»“åº“è·¯å¾„\"),\n    examples: bool = typer.Option(False, \"--examples\", help=\"æ˜¾ç¤ºä½¿ç”¨ç¤ºä¾‹\"),\n):\n    \"\"\"\n    å¯åŠ¨äº¤äº’å¼å¯¹è¯ - DaoyouCodeçš„ä¸»è¦åŠŸèƒ½\n    \n    æ”¯æŒæŒ‡å®šSkillã€æ¨¡å‹å’Œæ–‡ä»¶ã€‚åœ¨å¯¹è¯ä¸­å¯ä½¿ç”¨ /skill åˆ‡æ¢Skillã€‚\n    \"\"\"\n    from cli.commands import chat as chat_cmd\n    \n    if examples:\n        show_chat_examples()\n        raise typer.Exit(0)\n    \n    chat_cmd.main(files, model, skill, repo)\n\n\n@app.command()"
},
{
"path": "cli/app.py",
"start": 47,
"end": 59,
"text": "def edit(\n    files: list[Path] = typer.Argument(..., help=\"è¦ç¼–è¾‘çš„æ–‡ä»¶\"),\n    instruction: str = typer.Argument(..., help=\"ç¼–è¾‘æŒ‡ä»¤\"),\n    model: str = typer.Option(\"qwen-max\", \"--model\", \"-m\", help=\"ä½¿ç”¨çš„æ¨¡å‹\"),\n    yes: bool = typer.Option(False, \"--yes\", \"-y\", help=\"è‡ªåŠ¨ç¡®è®¤æ‰€æœ‰æ“ä½œ\"),\n    repo: Path = typer.Option(\".\", \"--repo\", \"-r\", help=\"ä»“åº“è·¯å¾„\"),\n):\n    \"\"\"å•æ¬¡ç¼–è¾‘æ–‡ä»¶\"\"\"\n    from cli.commands import edit as edit_cmd\n    edit_cmd.main(files, instruction, model, yes, repo)\n\n\n@app.command()"
},
{
"path": "cli/app.py",
"start": 60,
"end": 68,
"text": "def doctor(\n    fix: bool = typer.Option(False, \"--fix\", help=\"è‡ªåŠ¨ä¿®å¤é—®é¢˜\"),\n):\n    \"\"\"è¯Šæ–­ç³»ç»Ÿç¯å¢ƒ\"\"\"\n    from cli.commands import doctor as doctor_cmd\n    doctor_cmd.main(fix)\n\n\n@app.command()"
},
{
"path": "cli/app.py",
"start": 69,
"end": 75,
"text": "def config():\n    \"\"\"é…ç½®ç®¡ç†\"\"\"\n    from cli.commands import config as config_cmd\n    config_cmd.main()\n\n\n@app.command()"
},
{
"path": "cli/app.py",
"start": 76,
"end": 82,
"text": "def session():\n    \"\"\"ä¼šè¯ç®¡ç†\"\"\"\n    from cli.commands import session as session_cmd\n    session_cmd.main()\n\n\n@app.command()"
},
{
"path": "cli/app.py",
"start": 83,
"end": 102,
"text": "def agent(\n    agent_name: Optional[str] = typer.Argument(None, help=\"Agentåç§° (ä¸æŒ‡å®šåˆ™åˆ—å‡ºæ‰€æœ‰)\"),\n    tools: bool = typer.Option(False, \"--tools\", \"-t\", help=\"æ˜¾ç¤ºAgentçš„å·¥å…·åˆ—è¡¨\"),\n    examples: bool = typer.Option(False, \"--examples\", help=\"æ˜¾ç¤ºä½¿ç”¨ç¤ºä¾‹\"),\n):\n    \"\"\"\n    Agentç®¡ç† - æŸ¥çœ‹æ‰€æœ‰Agentå’Œè¯¦æƒ…\n    \n    Agentæ˜¯æ‰§è¡Œä»»åŠ¡çš„æ™ºèƒ½ä½“ï¼Œæ¯ä¸ªAgentæœ‰ä¸åŒçš„èŒè´£å’Œå·¥å…·é›†ã€‚\n    \"\"\"\n    from cli.commands import agent as agent_cmd\n    \n    if examples:\n        show_agent_examples()\n        raise typer.Exit(0)\n    \n    agent_cmd.main(agent_name, tools)\n\n\n@app.command()"
},
{
"path": "cli/app.py",
"start": 103,
"end": 109,
"text": "def models():\n    \"\"\"åˆ—å‡ºå¯ç”¨æ¨¡å‹\"\"\"\n    from cli.commands import models as models_cmd\n    models_cmd.main()\n\n\n@app.command()"
},
{
"path": "cli/app.py",
"start": 110,
"end": 129,
"text": "def skills(\n    skill_name: Optional[str] = typer.Argument(None, help=\"Skillåç§° (ä¸æŒ‡å®šåˆ™åˆ—å‡ºæ‰€æœ‰)\"),\n    orchestrators: bool = typer.Option(False, \"--orchestrators\", \"-o\", help=\"æ˜¾ç¤ºç¼–æ’å™¨åˆ—è¡¨å’Œè¯´æ˜\"),\n    examples: bool = typer.Option(False, \"--examples\", help=\"æ˜¾ç¤ºä½¿ç”¨ç¤ºä¾‹\"),\n):\n    \"\"\"\n    Skillå’Œç¼–æ’å™¨ç®¡ç† - æŸ¥çœ‹æ‰€æœ‰Skillå’Œç¼–æ’å™¨\n    \n    Skillå®šä¹‰äº†ä½¿ç”¨å“ªäº›Agentã€å·¥å…·å’Œç¼–æ’å™¨ã€‚ç¼–æ’å™¨è´Ÿè´£åè°ƒå¤šAgentå·¥ä½œã€‚\n    \"\"\"\n    from cli.commands import skills as skills_cmd\n    \n    if examples:\n        show_skills_examples()\n        raise typer.Exit(0)\n    \n    skills_cmd.main(skill_name, orchestrators)\n\n\n@app.command()"
},
{
"path": "cli/app.py",
"start": 130,
"end": 139,
"text": "def serve(\n    host: str = typer.Option(\"127.0.0.1\", \"--host\", \"-h\", help=\"ç›‘å¬åœ°å€\"),\n    port: int = typer.Option(8000, \"--port\", \"-p\", help=\"ç›‘å¬ç«¯å£\"),\n):\n    \"\"\"å¯åŠ¨HTTPæœåŠ¡å™¨\"\"\"\n    from cli.commands import serve as serve_cmd\n    serve_cmd.main(host, port)\n\n\n@app.command()"
},
{
"path": "cli/app.py",
"start": 140,
"end": 146,
"text": "def version():\n    \"\"\"æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯\"\"\"\n    typer.echo(f\"DaoyouCode CLI v{__version__}\")\n    typer.echo(\"åŸºäº18å¤§æ ¸å¿ƒç³»ç»Ÿçš„æ™ºèƒ½AIä»£ç åŠ©æ‰‹\")\n\n\n@app.command()"
},
{
"path": "cli/app.py",
"start": 147,
"end": 171,
"text": "def examples(\n    command: Optional[str] = typer.Argument(None, help=\"å‘½ä»¤åç§° (chat/agent/skills)\"),\n):\n    \"\"\"\n    æ˜¾ç¤ºå‘½ä»¤ä½¿ç”¨ç¤ºä¾‹å’Œæ¨¡æ¿\n    \n    æŸ¥çœ‹å„å‘½ä»¤çš„è¯¦ç»†ä½¿ç”¨ç¤ºä¾‹ã€æ¨èé…ç½®å’Œæœ€ä½³å®è·µã€‚\n    \"\"\"\n    from cli.ui.console import console\n    \n    if not command:\n        show_all_examples()\n    elif command == \"chat\":\n        show_chat_examples()\n    elif command == \"agent\":\n        show_agent_examples()\n    elif command == \"skills\":\n        show_skills_examples()\n    else:\n        console.print(f\"[red]æœªçŸ¥å‘½ä»¤: {command}[/red]\")\n        console.print(\"[dim]å¯ç”¨å‘½ä»¤: chat, agent, skills[/dim]\")\n        raise typer.Exit(1)\n\n\n@app.callback()"
},
{
"path": "cli/app.py",
"start": 172,
"end": 196,
"text": "def callback(\n    ctx: typer.Context,\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"æ˜¾ç¤ºè¯¦ç»†æ—¥å¿—\"),\n    debug: bool = typer.Option(False, \"--debug\", help=\"å¼€å¯è°ƒè¯•æ¨¡å¼\"),\n):\n    \"\"\"\n    DaoyouCode - æ™ºèƒ½AIä»£ç åŠ©æ‰‹\n    \n    ç²¾ç®€è€Œå¼ºå¤§ï¼ŒåŸºäº18å¤§æ ¸å¿ƒç³»ç»Ÿ\n    \"\"\"\n    # è®¾ç½®å…¨å±€é€‰é¡¹\n    ctx.obj = {\n        \"verbose\": verbose,\n        \"debug\": debug,\n    }\n    \n    # é…ç½®æ—¥å¿—\n    if debug:\n        import logging\n        logging.basicConfig(level=logging.DEBUG)\n    elif verbose:\n        import logging\n        logging.basicConfig(level=logging.INFO)\n\n"
},
{
"path": "cli/app.py",
"start": 197,
"end": 208,
"text": "def main():\n    \"\"\"ä¸»å…¥å£\"\"\"\n    try:\n        app()\n    except KeyboardInterrupt:\n        typer.echo(\"\\n\\nğŸ‘‹ å†è§ï¼\")\n        raise typer.Exit(0)\n    except Exception as e:\n        typer.echo(f\"\\nâŒé”™è¯¯: {e}\", err=True)\n        raise typer.Exit(1)\n\n"
},
{
"path": "cli/app.py",
"start": 209,
"end": 247,
"text": "def show_all_examples():\n    \"\"\"æ˜¾ç¤ºæ‰€æœ‰å‘½ä»¤çš„ç¤ºä¾‹\"\"\"\n    from cli.ui.console import console\n    from rich.panel import Panel\n    \n    examples_text = \"\"\"\n[bold cyan]DaoyouCode CLI ä½¿ç”¨ç¤ºä¾‹[/bold cyan]\n\n[bold]1. æŸ¥çœ‹ç³»ç»Ÿä¿¡æ¯[/bold]\n  daoyoucode agent                    # åˆ—å‡ºæ‰€æœ‰Agent\n  daoyoucode skills                   # åˆ—å‡ºæ‰€æœ‰Skill\n  daoyoucode skills --orchestrators   # æŸ¥çœ‹ç¼–æ’å™¨è¯´æ˜\n\n[bold]2. å¯åŠ¨å¯¹è¯[/bold]\n  daoyoucode chat                                    # é»˜è®¤chatæ¨¡å¼\n  daoyoucode chat --skill sisyphus-orchestrator      # ä½¿ç”¨sisyphusç¼–æ’\n  daoyoucode chat --skill oracle                     # ä½¿ç”¨oracleå’¨è¯¢\n  daoyoucode chat --skill librarian                  # ä½¿ç”¨librarianæœç´¢\n\n[bold]3. æŸ¥çœ‹è¯¦æƒ…[/bold]\n  daoyoucode agent sisyphus           # æŸ¥çœ‹Agentè¯¦æƒ…\n  daoyoucode agent sisyphus --tools   # æŸ¥çœ‹Agentå·¥å…·\n  daoyoucode skills oracle            # æŸ¥çœ‹Skillè¯¦æƒ…\n\n[bold]4. æŸ¥çœ‹æ›´å¤šç¤ºä¾‹[/bold]\n  daoyoucode examples chat            # chatå‘½ä»¤ç¤ºä¾‹\n  daoyoucode examples agent           # agentå‘½ä»¤ç¤ºä¾‹\n  daoyoucode examples skills          # skillså‘½ä»¤ç¤ºä¾‹\n  \n  æˆ–ä½¿ç”¨ --examples æ ‡å¿—:\n  daoyoucode chat --examples\n  daoyoucode agent --examples\n  daoyoucode skills --examples\n\n[dim]ğŸ’¡ æç¤º: ä½¿ç”¨ --help æŸ¥çœ‹å‘½ä»¤å‚æ•°è¯´æ˜[/dim]\n\"\"\"\n    console.print(Panel(examples_text, border_style=\"cyan\", padding=(1, 2)))\n\n"
},
{
"path": "cli/app.py",
"start": 248,
"end": 298,
"text": "def show_chat_examples():\n    \"\"\"æ˜¾ç¤ºchatå‘½ä»¤ç¤ºä¾‹\"\"\"\n    from cli.ui.console import console\n    from rich.panel import Panel\n    \n    examples_text = \"\"\"\n[bold cyan]chat å‘½ä»¤ä½¿ç”¨ç¤ºä¾‹[/bold cyan]\n\n[bold]åŸºæœ¬ç”¨æ³•[/bold]\n  daoyoucode chat                     # é»˜è®¤chatæ¨¡å¼ (chat-assistant)\n  daoyoucode chat --help              # æŸ¥çœ‹å‚æ•°è¯´æ˜\n\n[bold]æŒ‡å®šSkill[/bold]\n  daoyoucode chat --skill sisyphus-orchestrator    # å¤æ‚ä»»åŠ¡ï¼ˆé‡æ„+æµ‹è¯•ï¼‰\n  daoyoucode chat --skill oracle                   # æ¶æ„åˆ†æï¼ˆåªè¯»ï¼‰\n  daoyoucode chat --skill librarian                # æ–‡æ¡£æœç´¢ï¼ˆåªè¯»ï¼‰\n  daoyoucode chat -s programming                   # ç¼–ç¨‹ä¸“å®¶\n\n[bold]æŒ‡å®šæ¨¡å‹[/bold]\n  daoyoucode chat --model deepseek-coder           # ä½¿ç”¨deepseekæ¨¡å‹\n  daoyoucode chat -m qwen-max                      # ä½¿ç”¨qwen-maxæ¨¡å‹\n\n[bold]åŠ è½½æ–‡ä»¶[/bold]\n  daoyoucode chat main.py                          # åŠ è½½å•ä¸ªæ–‡ä»¶\n  daoyoucode chat main.py utils.py                 # åŠ è½½å¤šä¸ªæ–‡ä»¶\n  daoyoucode chat src/*.py                         # åŠ è½½ç›®å½•ä¸‹æ‰€æœ‰pyæ–‡ä»¶\n\n[bold]ç»„åˆä½¿ç”¨[/bold]\n  daoyoucode chat --skill oracle --model qwen-max main.py\n  daoyoucode chat -s sisyphus-orchestrator -m deepseek-coder\n\n[bold]äº¤äº’å¼å‘½ä»¤[/bold]\n  åœ¨å¯¹è¯ä¸­å¯ä»¥ä½¿ç”¨:\n  /skill [name]    # åˆ‡æ¢Skill\n  /s [name]        # /skillçš„ç®€å†™\n  /model [name]    # åˆ‡æ¢æ¨¡å‹\n  /add <file>      # æ·»åŠ æ–‡ä»¶\n  /help            # æ˜¾ç¤ºå¸®åŠ©\n  /exit            # é€€å‡ºå¯¹è¯\n\n[bold]æ¨èSkill[/bold]\n  â€¢ chat-assistant (é»˜è®¤) - æ—¥å¸¸å¯¹è¯å’Œä»£ç å’¨è¯¢\n  â€¢ sisyphus-orchestrator - å¤æ‚ä»»åŠ¡ï¼ˆé‡æ„+æµ‹è¯•ç­‰ï¼‰\n  â€¢ oracle - æ¶æ„åˆ†æå’ŒæŠ€æœ¯å»ºè®®ï¼ˆåªè¯»ï¼‰\n  â€¢ librarian - æ–‡æ¡£æœç´¢å’Œä»£ç æŸ¥æ‰¾ï¼ˆåªè¯»ï¼‰\n\n[dim]ğŸ’¡ æç¤º: ä½¿ç”¨ 'daoyoucode skills' æŸ¥çœ‹æ‰€æœ‰å¯ç”¨Skill[/dim]\n\"\"\"\n    console.print(Panel(examples_text, border_style=\"cyan\", padding=(1, 2)))\n\n"
},
{
"path": "cli/app.py",
"start": 299,
"end": 352,
"text": "def show_agent_examples():\n    \"\"\"æ˜¾ç¤ºagentå‘½ä»¤ç¤ºä¾‹\"\"\"\n    from cli.ui.console import console\n    from rich.panel import Panel\n    \n    examples_text = \"\"\"\n[bold cyan]agent å‘½ä»¤ä½¿ç”¨ç¤ºä¾‹[/bold cyan]\n\n[bold]åŸºæœ¬ç”¨æ³•[/bold]\n  daoyoucode agent                    # åˆ—å‡ºæ‰€æœ‰Agent\n  daoyoucode agent --help             # æŸ¥çœ‹å‚æ•°è¯´æ˜\n\n[bold]æŸ¥çœ‹Agentè¯¦æƒ…[/bold]\n  daoyoucode agent sisyphus           # æŸ¥çœ‹sisyphusè¯¦æƒ…\n  daoyoucode agent oracle             # æŸ¥çœ‹oracleè¯¦æƒ…\n  daoyoucode agent programmer         # æŸ¥çœ‹programmerè¯¦æƒ…\n\n[bold]æŸ¥çœ‹Agentå·¥å…·[/bold]\n  daoyoucode agent sisyphus --tools   # æŸ¥çœ‹sisyphusçš„å·¥å…·åˆ—è¡¨\n  daoyoucode agent oracle -t          # æŸ¥çœ‹oracleçš„å·¥å…·åˆ—è¡¨\n\n[bold]å¯ç”¨Agent[/bold]\n  â€¢ sisyphus - ä¸»ç¼–æ’Agentï¼ˆ4ä¸ªå·¥å…·ï¼‰\n    ä»»åŠ¡åˆ†è§£å’ŒAgentè°ƒåº¦\n    \n  â€¢ oracle - é«˜IQå’¨è¯¢Agentï¼ˆ10ä¸ªå·¥å…·ï¼‰\n    æ¶æ„åˆ†æå’ŒæŠ€æœ¯å»ºè®®ï¼ˆåªè¯»ï¼‰\n    \n  â€¢ librarian - æ–‡æ¡£æœç´¢Agentï¼ˆ8ä¸ªå·¥å…·ï¼‰\n    æ–‡æ¡£å’Œä»£ç æœç´¢ï¼ˆåªè¯»ï¼‰\n    \n  â€¢ programmer - ç¼–ç¨‹ä¸“å®¶ï¼ˆ11ä¸ªå·¥å…·ï¼‰\n    ä»£ç ç¼–å†™å’Œä¿®æ”¹\n    \n  â€¢ refactor_master - é‡æ„ä¸“å®¶ï¼ˆ13ä¸ªå·¥å…·ï¼‰\n    ä»£ç é‡æ„å’Œä¼˜åŒ–\n    \n  â€¢ test_expert - æµ‹è¯•ä¸“å®¶ï¼ˆ10ä¸ªå·¥å…·ï¼‰\n    æµ‹è¯•ç¼–å†™å’Œä¿®å¤\n\n[bold]Agentä¸Skillçš„å…³ç³»[/bold]\n  Agentæ˜¯æ‰§è¡Œè€…ï¼ŒSkillæ˜¯é…ç½®æ–‡ä»¶ã€‚\n  ä¸€ä¸ªSkillå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæˆ–å¤šä¸ªAgentã€‚\n  \n  ä¾‹å¦‚:\n  â€¢ chat-assistant Skill ä½¿ç”¨ MainAgent\n  â€¢ sisyphus-orchestrator Skill ä½¿ç”¨ sisyphus + 4ä¸ªè¾…åŠ©Agent\n  â€¢ oracle Skill ä½¿ç”¨ oracle Agent\n\n[dim]ğŸ’¡ æç¤º: ä½¿ç”¨ 'daoyoucode skills' æŸ¥çœ‹Skillé…ç½®[/dim]\n\"\"\"\n    console.print(Panel(examples_text, border_style=\"cyan\", padding=(1, 2)))\n\n"
},
{
"path": "cli/app.py",
"start": 353,
"end": 419,
"text": "def show_skills_examples():\n    \"\"\"æ˜¾ç¤ºskillså‘½ä»¤ç¤ºä¾‹\"\"\"\n    from cli.ui.console import console\n    from rich.panel import Panel\n    \n    examples_text = \"\"\"\n[bold cyan]skills å‘½ä»¤ä½¿ç”¨ç¤ºä¾‹[/bold cyan]\n\n[bold]åŸºæœ¬ç”¨æ³•[/bold]\n  daoyoucode skills                   # åˆ—å‡ºæ‰€æœ‰Skill\n  daoyoucode skills --help            # æŸ¥çœ‹å‚æ•°è¯´æ˜\n\n[bold]æŸ¥çœ‹Skillè¯¦æƒ…[/bold]\n  daoyoucode skills sisyphus-orchestrator    # æŸ¥çœ‹sisyphusè¯¦æƒ…\n  daoyoucode skills oracle                   # æŸ¥çœ‹oracleè¯¦æƒ…\n  daoyoucode skills librarian                # æŸ¥çœ‹librarianè¯¦æƒ…\n\n[bold]æŸ¥çœ‹ç¼–æ’å™¨[/bold]\n  daoyoucode skills --orchestrators   # æŸ¥çœ‹æ‰€æœ‰ç¼–æ’å™¨å’Œè¯´æ˜\n  daoyoucode skills -o                # ç®€å†™\n\n[bold]æ¨èSkill[/bold]\n  â€¢ chat-assistant (é»˜è®¤)\n    ç¼–æ’å™¨: react\n    ç”¨é€”: æ—¥å¸¸å¯¹è¯å’Œä»£ç å’¨è¯¢\n    \n  â€¢ sisyphus-orchestrator\n    ç¼–æ’å™¨: multi_agent\n    ç”¨é€”: å¤æ‚ä»»åŠ¡ï¼ˆé‡æ„+æµ‹è¯•ç­‰ï¼‰\n    Agent: sisyphus + 4ä¸ªè¾…åŠ©Agent\n    \n  â€¢ oracle\n    ç¼–æ’å™¨: react\n    ç”¨é€”: æ¶æ„åˆ†æå’ŒæŠ€æœ¯å»ºè®®ï¼ˆåªè¯»ï¼‰\n    Agent: oracle\n    \n  â€¢ librarian\n    ç¼–æ’å™¨: react\n    ç”¨é€”: æ–‡æ¡£æœç´¢å’Œä»£ç æŸ¥æ‰¾ï¼ˆåªè¯»ï¼‰\n    Agent: librarian\n\n[bold]ç¼–æ’å™¨ç±»å‹[/bold]\n  â€¢ simple - ç®€å•ç¼–æ’ï¼ˆ1ä¸ªAgentï¼‰\n  â€¢ react - ReActæ¨¡å¼ï¼ˆ1ä¸ªAgent + å·¥å…·ï¼‰\n  â€¢ multi_agent - å¤šAgentåä½œï¼ˆå¤šä¸ªAgentï¼‰\n  â€¢ workflow - å·¥ä½œæµç¼–æ’ï¼ˆé¢„å®šä¹‰æ­¥éª¤ï¼‰\n  â€¢ parallel - å¹¶è¡Œæ‰§è¡Œï¼ˆå¤šä»»åŠ¡åŒæ—¶ï¼‰\n\n[bold]Multi-Agentåä½œæ¨¡å¼[/bold]\n  â€¢ sequential - é¡ºåºæ‰§è¡Œ\n  â€¢ parallel - å¹¶è¡Œæ‰§è¡Œ\n  â€¢ debate - è¾©è®ºæ¨¡å¼\n  â€¢ main_with_helpers - ä¸»Agent + è¾…åŠ©Agentï¼ˆé»˜è®¤ï¼‰\n\n[bold]ä½¿ç”¨Skill[/bold]\n  daoyoucode chat --skill sisyphus-orchestrator\n  daoyoucode chat --skill oracle\n  daoyoucode chat --skill librarian\n\n[dim]ğŸ’¡ æç¤º: åœ¨å¯¹è¯ä¸­ä½¿ç”¨ /skill å‘½ä»¤å¯ä»¥åŠ¨æ€åˆ‡æ¢Skill[/dim]\n\"\"\"\n    console.print(Panel(examples_text, border_style=\"cyan\", padding=(1, 2)))\n\n\nif __name__ == \"__main__\":\n    main()\n"
},
{
"path": "cli/__init__.py",
"start": 1,
"end": 9,
"text": "\"\"\"\nDaoyouCode CLI\n\nç²¾ç®€è€Œå¼ºå¤§çš„å‘½ä»¤è¡Œç•Œé¢\n\"\"\"\n\n__version__ = \"0.1.0\"\n\n__all__ = [\"__version__\"]"
},
{
"path": "cli/__main__.py",
"start": 1,
"end": 17,
"text": "#!/usr/bin/env python\n\"\"\"\nDaoyouCode CLI å…¥å£\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nbackend_path = Path(__file__).parent.parent\nsys.path.insert(0, str(backend_path))\n\n# å¯¼å…¥å¹¶è¿è¡Œ\nfrom cli.app import main\n\nif __name__ == \"__main__\":\n    main()"
},
{
"path": "cli/commands/agent.py",
"start": 1,
"end": 10,
"text": "\"\"\"\nAgentç®¡ç†å‘½ä»¤\n\næŸ¥çœ‹å’Œç®¡ç†Agent\n\"\"\"\n\nimport typer\nfrom typing import Optional\n\n"
},
{
"path": "cli/commands/agent.py",
"start": 11,
"end": 48,
"text": "def main(\n    agent_name: Optional[str] = typer.Argument(None, help=\"Agentåç§°\"),\n    tools: bool = typer.Option(False, \"--tools\", \"-t\", help=\"æ˜¾ç¤ºAgentçš„å·¥å…·\"),\n):\n    \"\"\"\n    Agentç®¡ç† - æŸ¥çœ‹å’Œç®¡ç†æ‰€æœ‰Agent\n    \n    \\b\n    ç¤ºä¾‹:\n        daoyoucode agent                    # åˆ—å‡ºæ‰€æœ‰Agent\n        daoyoucode agent sisyphus           # æŸ¥çœ‹Agentè¯¦æƒ…\n        daoyoucode agent sisyphus --tools   # æŸ¥çœ‹Agentçš„å·¥å…·åˆ—è¡¨\n    \n    \\b\n    è¯´æ˜:\n        Agentæ˜¯æ‰§è¡Œå…·ä½“ä»»åŠ¡çš„æ™ºèƒ½ä½“ï¼Œæ¯ä¸ªAgentæœ‰ä¸åŒçš„èŒè´£å’Œå·¥å…·é›†ã€‚\n        Agenté€šè¿‡Skillé…ç½®ä½¿ç”¨ï¼Œä¸€ä¸ªSkillå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæˆ–å¤šä¸ªAgentã€‚\n    \n    \\b\n    å¯ç”¨Agent:\n        â€¢ sisyphus - ä¸»ç¼–æ’Agentï¼ˆ4ä¸ªå·¥å…·ï¼‰\n        â€¢ oracle - é«˜IQå’¨è¯¢Agentï¼ˆ10ä¸ªå·¥å…·ï¼‰\n        â€¢ librarian - æ–‡æ¡£æœç´¢Agentï¼ˆ8ä¸ªå·¥å…·ï¼‰\n        â€¢ programmer - ç¼–ç¨‹ä¸“å®¶ï¼ˆ11ä¸ªå·¥å…·ï¼‰\n        â€¢ refactor_master - é‡æ„ä¸“å®¶ï¼ˆ13ä¸ªå·¥å…·ï¼‰\n        â€¢ test_expert - æµ‹è¯•ä¸“å®¶ï¼ˆ10ä¸ªå·¥å…·ï¼‰\n        â€¢ æ›´å¤š...\n    \"\"\"\n    from cli.ui.console import console\n    \n    if not agent_name:\n        # åˆ—å‡ºæ‰€æœ‰Agent\n        list_all_agents()\n    else:\n        # æ˜¾ç¤ºAgentè¯¦æƒ…\n        show_agent_details(agent_name, show_tools=tools)\n\n"
},
{
"path": "cli/commands/agent.py",
"start": 49,
"end": 144,
"text": "def list_all_agents():\n    \"\"\"åˆ—å‡ºæ‰€æœ‰Agent\"\"\"\n    from cli.ui.console import console\n    from rich.table import Table\n    \n    try:\n        # åˆå§‹åŒ–Agentç³»ç»Ÿ\n        from daoyoucode.agents.init import initialize_agent_system\n        initialize_agent_system()\n        \n        from daoyoucode.agents.core.agent import get_agent_registry\n        from daoyoucode.agents.tools.tool_groups import get_tools_for_agent\n        \n        registry = get_agent_registry()\n        agent_names = registry.list_agents()\n        \n        if not agent_names:\n            console.print(\"[yellow]æœªæ‰¾åˆ°ä»»ä½•Agent[/yellow]\")\n            return\n        \n        console.print(\"\\n[bold cyan]ğŸ¤– å¯ç”¨Agent ({} ä¸ª)[/bold cyan]\\n\".format(len(agent_names)))\n        \n        table = Table(\n            show_header=True,\n            border_style=\"cyan\",\n            header_style=\"bold cyan\",\n            show_lines=False,\n            padding=(0, 1)\n        )\n        table.add_column(\"#\", style=\"dim\", width=4, justify=\"right\")\n        table.add_column(\"åç§°\", style=\"cyan bold\", no_wrap=True, min_width=20)\n        table.add_column(\"å·¥å…·æ•°\", style=\"yellow\", width=8, justify=\"right\")\n        table.add_column(\"æè¿°\", style=\"white\")\n        \n        # è·å–æ¯ä¸ªAgentçš„ä¿¡æ¯\n        agents_info = []\n        for agent_name in sorted(agent_names):\n            agent = registry.get_agent(agent_name)\n            if agent:\n                tools = get_tools_for_agent(agent_name)\n                agents_info.append({\n                    'name': agent_name,\n                    'description': agent.config.description,\n                    'tool_count': len(tools)\n                })\n        \n        # æ˜¾ç¤ºAgentåˆ—è¡¨\n        for i, info in enumerate(agents_info, 1):\n            desc = info['description']\n            if len(desc) > 50:\n                desc = desc[:47] + '...'\n            \n            table.add_row(\n                str(i),\n                info['name'],\n                str(info['tool_count']),\n                desc\n            )\n        \n        console.print(table)\n        \n        # æŒ‰å·¥å…·æ•°åˆ†ç»„ç»Ÿè®¡\n        tool_groups = {\n            'å°‘é‡ (1-5)': 0,\n            'ä¸­ç­‰ (6-10)': 0,\n            'è¾ƒå¤š (11-15)': 0,\n            'å¾ˆå¤š (15+)': 0\n        }\n        \n        for info in agents_info:\n            count = info['tool_count']\n            if count <= 5:\n                tool_groups['å°‘é‡ (1-5)'] += 1\n            elif count <= 10:\n                tool_groups['ä¸­ç­‰ (6-10)'] += 1\n            elif count <= 15:\n                tool_groups['è¾ƒå¤š (11-15)'] += 1\n            else:\n                tool_groups['å¾ˆå¤š (15+)'] += 1\n        \n        console.print(f\"\\n[dim]å·¥å…·æ•°é‡åˆ†å¸ƒ:[/dim]\")\n        for group, count in tool_groups.items():\n            if count > 0:\n                console.print(f\"[dim]  â€¢ {group}: {count} ä¸ªAgent[/dim]\")\n        \n        console.print(f\"\\n[dim]ğŸ’¡ æç¤º:[/dim]\")\n        console.print(f\"[dim]  â€¢ ä½¿ç”¨ [cyan]daoyoucode agent <name>[/cyan] æŸ¥çœ‹è¯¦æƒ…[/dim]\")\n        console.print(f\"[dim]  â€¢ ä½¿ç”¨ [cyan]daoyoucode agent <name> --tools[/cyan] æŸ¥çœ‹å·¥å…·åˆ—è¡¨[/dim]\")\n        console.print(f\"[dim]  â€¢ Agenté€šè¿‡Skillä½¿ç”¨ï¼Œå‚è€ƒ [cyan]daoyoucode skills[/cyan][/dim]\\n\")\n    \n    except Exception as e:\n        console.print(f\"[red]åŠ è½½Agentå¤±è´¥: {e}[/red]\")\n        import traceback\n        console.print(f\"[dim]{traceback.format_exc()}[/dim]\")\n\n"
},
{
"path": "cli/commands/agent.py",
"start": 145,
"end": 262,
"text": "def show_agent_details(agent_name: str, show_tools: bool = False):\n    \"\"\"æ˜¾ç¤ºAgentè¯¦æƒ…\"\"\"\n    from cli.ui.console import console\n    from rich.panel import Panel\n    \n    try:\n        # åˆå§‹åŒ–Agentç³»ç»Ÿ\n        from daoyoucode.agents.init import initialize_agent_system\n        initialize_agent_system()\n        \n        from daoyoucode.agents.core.agent import get_agent_registry\n        from daoyoucode.agents.tools.tool_groups import get_tools_for_agent\n        \n        registry = get_agent_registry()\n        agent = registry.get_agent(agent_name)\n        \n        if not agent:\n            console.print(f\"[red]Agentä¸å­˜åœ¨: {agent_name}[/red]\")\n            console.print(\"[dim]ä½¿ç”¨ [cyan]daoyoucode agent[/cyan] æŸ¥çœ‹æ‰€æœ‰å¯ç”¨Agent[/dim]\")\n            return\n        \n        # è·å–å·¥å…·åˆ—è¡¨\n        tools = get_tools_for_agent(agent_name)\n        \n        # åŸºæœ¬ä¿¡æ¯\n        info = f\"\"\"\n[bold]åç§°[/bold]: {agent.config.name}\n[bold]æè¿°[/bold]: {agent.config.description}\n[bold]æ¨¡å‹[/bold]: {agent.config.model}\n[bold]æ¸©åº¦[/bold]: {agent.config.temperature}\n[bold]å·¥å…·æ•°é‡[/bold]: {len(tools)} ä¸ª\n\"\"\"\n        \n        # å¦‚æœæœ‰system_promptï¼Œæ˜¾ç¤ºæ‘˜è¦\n        if agent.config.system_prompt:\n            prompt_preview = agent.config.system_prompt[:100].replace('\\n', ' ')\n            if len(agent.config.system_prompt) > 100:\n                prompt_preview += '...'\n            info += f\"\\n[bold]Prompt[/bold]: {prompt_preview}\\n\"\n        \n        console.print(Panel(\n            info,\n            title=f\"ğŸ¤– {agent_name}\",\n            border_style=\"cyan\",\n            padding=(1, 2)\n        ))\n        \n        # æ˜¾ç¤ºå·¥å…·åˆ—è¡¨\n        if show_tools and tools:\n            console.print(\"\\n[bold cyan]å·¥å…·åˆ—è¡¨[/bold cyan]\\n\")\n            \n            from rich.table import Table\n            table = Table(show_header=True, border_style=\"dim\")\n            table.add_column(\"#\", style=\"dim\", width=4, justify=\"right\")\n            table.add_column(\"å·¥å…·åç§°\", style=\"cyan\")\n            table.add_column(\"ç±»å‹\", style=\"yellow\")\n            \n            # å·¥å…·åˆ†ç±»\n            tool_categories = {\n                'repo_map': 'é¡¹ç›®ç†è§£',\n                'get_repo_structure': 'é¡¹ç›®ç†è§£',\n                'read_file': 'æ–‡ä»¶æ“ä½œ',\n                'write_file': 'æ–‡ä»¶æ“ä½œ',\n                'list_files': 'æ–‡ä»¶æ“ä½œ',\n                'get_file_info': 'æ–‡ä»¶æ“ä½œ',\n                'text_search': 'æœç´¢',\n                'regex_search': 'æœç´¢',\n                'find_function': 'æœç´¢',\n                'git_status': 'Git',\n                'git_diff': 'Git',\n                'git_commit': 'Git',\n                'git_log': 'Git',\n                'run_command': 'æ‰§è¡Œ',\n                'run_tests': 'æ‰§è¡Œ',\n                'get_diagnostics': 'LSP',\n                'find_references': 'LSP',\n                'semantic_rename': 'LSP',\n                'get_symbols': 'LSP',\n                'parse_ast': 'AST',\n                'generate_project_doc': 'æ–‡æ¡£'\n            }\n            \n            for i, tool in enumerate(tools, 1):\n                category = tool_categories.get(tool, 'å…¶ä»–')\n                table.add_row(str(i), tool, category)\n            \n            console.print(table)\n        \n        # æŸ¥æ‰¾ä½¿ç”¨è¯¥Agentçš„Skill\n        console.print(\"\\n[bold cyan]ä½¿ç”¨è¯¥Agentçš„Skill[/bold cyan]\\n\")\n        \n        from daoyoucode.agents.core.skill import get_skill_loader\n        loader = get_skill_loader()\n        skills = loader.list_skills()\n        \n        using_skills = []\n        for skill in skills:\n            # æ£€æŸ¥å•ä¸ªagent\n            if skill.get('agent') == agent_name:\n                using_skills.append(skill['name'])\n            # æ£€æŸ¥agentsåˆ—è¡¨\n            elif agent_name in skill.get('agents', []):\n                using_skills.append(skill['name'])\n        \n        if using_skills:\n            for skill_name in using_skills:\n                console.print(f\"  â€¢ [cyan]{skill_name}[/cyan]\")\n        else:\n            console.print(\"[dim]  æš‚æ— Skillä½¿ç”¨è¯¥Agent[/dim]\")\n        \n        console.print(f\"\\n[dim]ğŸ’¡ æç¤º:[/dim]\")\n        console.print(f\"[dim]  â€¢ ä½¿ç”¨ [cyan]daoyoucode skills <skill_name>[/cyan] æŸ¥çœ‹Skillè¯¦æƒ…[/di"
},
{
"path": "cli/commands/chat.py",
"start": 1,
"end": 16,
"text": "\"\"\"\näº¤äº’å¼å¯¹è¯å‘½ä»¤\n\næœ€é‡è¦çš„å‘½ä»¤ï¼Œæä¾›å®Œæ•´çš„äº¤äº’å¼ä½“éªŒ\n\"\"\"\n\nimport typer\nfrom typing import Optional, List\nfrom pathlib import Path\nfrom rich.panel import Panel\nfrom rich.markdown import Markdown\nfrom rich.live import Live\nfrom rich.spinner import Spinner\nimport time\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 17,
"end": 79,
"text": "def determine_repo_path(files: Optional[List[Path]], repo_arg: Path) -> Path:\n    \"\"\"\n    ç¡®å®šä»“åº“è·¯å¾„\n    \n    ä¼˜å…ˆçº§ï¼š\n    1. å¦‚æœæä¾›äº†æ–‡ä»¶ï¼Œä»æ–‡ä»¶æ¨æ–­ git ä»“åº“\n    2. å¦‚æœæä¾›äº† --repo å‚æ•°ï¼Œä½¿ç”¨è¯¥è·¯å¾„\n    3. å¦åˆ™ï¼Œä»å½“å‰ç›®å½•å‘ä¸ŠæŸ¥æ‰¾ git ä»“åº“\n    4. å¦‚æœæ‰¾ä¸åˆ° git ä»“åº“ï¼Œä½¿ç”¨å½“å‰ç›®å½•\n    \n    å‚è€ƒï¼šaider çš„å®ç°æ–¹å¼\n    \"\"\"\n    try:\n        import git\n    except ImportError:\n        # å¦‚æœæ²¡æœ‰ gitpythonï¼Œä½¿ç”¨å½“å‰ç›®å½•\n        if str(repo_arg) != \".\":\n            return Path(repo_arg).resolve()\n        return Path.cwd()\n    \n    # 1. ä»æ–‡ä»¶æ¨æ–­\n    if files:\n        repo_paths = set()\n        for file in files:\n            file_path = Path(file).resolve()\n            \n            # å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œä½¿ç”¨çˆ¶ç›®å½•\n            if not file_path.exists() and file_path.parent.exists():\n                file_path = file_path.parent\n            \n            try:\n                repo = git.Repo(file_path, search_parent_directories=True)\n                repo_paths.add(Path(repo.working_tree_dir).resolve())\n            except (git.InvalidGitRepositoryError, FileNotFoundError, git.GitCommandError):\n                # æ–‡ä»¶ä¸åœ¨ git ä»“åº“ä¸­ï¼Œä½¿ç”¨æ–‡ä»¶æ‰€åœ¨ç›®å½•\n                if file_path.is_file():\n                    repo_paths.add(file_path.parent)\n                else:\n                    repo_paths.add(file_path)\n        \n        if len(repo_paths) > 1:\n            from cli.ui.console import console\n            console.print(\"[red]é”™è¯¯: æä¾›çš„æ–‡ä»¶æ¥è‡ªä¸åŒçš„ git ä»“åº“[/red]\")\n            raise typer.Exit(1)\n        \n        if repo_paths:\n            return repo_paths.pop()\n    \n    # 2. ä½¿ç”¨ --repo å‚æ•°\n    if str(repo_arg) != \".\":\n        return Path(repo_arg).resolve()\n    \n    # 3. ä»å½“å‰ç›®å½•å‘ä¸ŠæŸ¥æ‰¾ git ä»“åº“\n    try:\n        repo = git.Repo(Path.cwd(), search_parent_directories=True)\n        return Path(repo.working_tree_dir).resolve()\n    except (git.InvalidGitRepositoryError, FileNotFoundError, git.GitCommandError):\n        pass\n    \n    # 4. ä½¿ç”¨å½“å‰ç›®å½•\n    return Path.cwd()\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 80,
"end": 168,
"text": "def main(\n    files: Optional[List[Path]] = typer.Argument(None, help=\"è¦åŠ è½½çš„æ–‡ä»¶\"),\n    model: str = typer.Option(\"qwen-plus\", \"--model\", \"-m\", help=\"ä½¿ç”¨çš„æ¨¡å‹\"),\n    skill: str = typer.Option(\"chat-assistant\", \"--skill\", \"-s\", help=\"ä½¿ç”¨çš„Skill\"),\n    repo: Path = typer.Option(\".\", \"--repo\", \"-r\", help=\"ä»“åº“è·¯å¾„\"),\n    subtree_only: bool = typer.Option(False, \"--subtree-only\", help=\"åªæ‰«æå½“å‰ç›®å½•åŠå…¶å­ç›®å½•\"),\n):\n    \"\"\"\n    å¯åŠ¨äº¤äº’å¼å¯¹è¯ - DaoyouCodeçš„ä¸»è¦åŠŸèƒ½\n    \n    \\b\n    ç¤ºä¾‹:\n        daoyoucode chat                                    # é»˜è®¤chatæ¨¡å¼\n        daoyoucode chat --skill sisyphus-orchestrator      # ä½¿ç”¨sisyphusç¼–æ’\n        daoyoucode chat --skill oracle                     # ä½¿ç”¨oracleå’¨è¯¢\n        daoyoucode chat --skill librarian                  # ä½¿ç”¨librarianæœç´¢\n        daoyoucode chat main.py utils.py                   # åŠ è½½æ–‡ä»¶\n        daoyoucode chat --model deepseek-coder             # æŒ‡å®šæ¨¡å‹\n    \n    \\b\n    è¯´æ˜:\n        å¯åŠ¨äº¤äº’å¼å¯¹è¯ï¼Œå¯ä»¥æŒ‡å®šSkillã€æ¨¡å‹å’Œæ–‡ä»¶ã€‚\n        åœ¨å¯¹è¯ä¸­å¯ä»¥ä½¿ç”¨ /skill åˆ‡æ¢Skillï¼Œ/help æŸ¥çœ‹æ‰€æœ‰å‘½ä»¤ã€‚\n    \n    \\b\n    æ¨èSkill:\n        â€¢ chat-assistant (é»˜è®¤) - æ—¥å¸¸å¯¹è¯å’Œä»£ç å’¨è¯¢\n        â€¢ sisyphus-orchestrator - å¤æ‚ä»»åŠ¡ï¼ˆé‡æ„+æµ‹è¯•ç­‰ï¼‰\n        â€¢ oracle - æ¶æ„åˆ†æå’ŒæŠ€æœ¯å»ºè®®ï¼ˆåªè¯»ï¼‰\n        â€¢ librarian - æ–‡æ¡£æœç´¢å’Œä»£ç æŸ¥æ‰¾ï¼ˆåªè¯»ï¼‰\n    \n    \\b\n    äº¤äº’å¼å‘½ä»¤:\n        /skill [name]  - åˆ‡æ¢Skill\n        /model [name]  - åˆ‡æ¢æ¨¡å‹\n        /add <file>    - æ·»åŠ æ–‡ä»¶\n        /help          - æ˜¾ç¤ºå¸®åŠ©\n        /exit          - é€€å‡ºå¯¹è¯\n    \"\"\"\n    from cli.ui.console import console\n    import uuid\n    import os\n    \n    # ä½¿ç”¨æ–°çš„ repo_path ç¡®å®šé€»è¾‘ï¼ˆå‚è€ƒ aiderï¼‰\n    repo_path = determine_repo_path(files, repo)\n    \n    # æ˜¾ç¤ºæ¬¢è¿æ¨ªå¹…\n    show_banner(model, repo_path, files, skill, subtree_only)\n    \n    # ç”Ÿæˆä¼šè¯IDï¼ˆç”¨äºè®°å¿†ç³»ç»Ÿï¼‰\n    session_id = str(uuid.uuid4())\n    \n    # ç®€å•çš„ä¸Šä¸‹æ–‡ï¼ˆåªå­˜å‚¨UIçŠ¶æ€ï¼‰\n    ui_context = {\n        \"session_id\": session_id,\n        \"model\": model,\n        \"skill\": skill,  # â† æ·»åŠ skill\n        \"repo\": str(repo_path),\n        \"initial_files\": [str(f) for f in files] if files else [],\n        \"subtree_only\": subtree_only,\n        \"cwd\": str(Path.cwd())  # ä¿å­˜å½“å‰å·¥ä½œç›®å½•ï¼ˆç”¨äº subtree_onlyï¼‰\n    }\n    \n    try:\n        # ä¸»å¾ªç¯\n        while True:\n            # è·å–ç”¨æˆ·è¾“å…¥\n            user_input = console.input(\"\\n[bold green]ä½ [/bold green] â€º \")\n            \n            if not user_input.strip():\n                continue\n            \n            # å¤„ç†å‘½ä»¤\n            if user_input.startswith(\"/\"):\n                if not handle_command(user_input, ui_context):\n                    break  # /exitå‘½ä»¤è¿”å›False\n                continue\n            \n            # å¤„ç†æ™®é€šå¯¹è¯ï¼ˆé€šè¿‡Skillç³»ç»Ÿï¼‰\n            handle_chat(user_input, ui_context)\n    \n    except KeyboardInterrupt:\n        console.print(\"\\n\\n[cyan]ğŸ‘‹ å†è§ï¼[/cyan]\\n\")\n        raise typer.Exit(0)\n    except Exception as e:\n        console.print(f\"\\n[red]âŒ é”™è¯¯: {e}[/red]\\n\")\n        raise typer.Exit(1)\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 169,
"end": 211,
"text": "def show_banner(model: str, repo: Path, files: Optional[List[Path]], skill: str, subtree_only: bool = False):\n    \"\"\"æ˜¾ç¤ºæ¬¢è¿æ¨ªå¹…\"\"\"\n    from cli.ui.console import console\n    import os\n    \n    banner = \"\"\"\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘                                                          â•‘\nâ•‘     ğŸ¤–  DaoyouCode äº¤äº’å¼å¯¹è¯                            â•‘\nâ•‘                                                          â•‘\nâ•‘     ç²¾ç®€è€Œå¼ºå¤§ï¼ŒåŸºäº18å¤§æ ¸å¿ƒç³»ç»Ÿ                         â•‘\nâ•‘                                                          â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\"\"\"\n    console.print(f\"[bold cyan]{banner}[/bold cyan]\")\n    \n    # æ˜¾ç¤ºé…ç½®ä¿¡æ¯\n    scope_info = \"\"\n    if subtree_only:\n        cwd = Path.cwd()\n        try:\n            rel_cwd = cwd.relative_to(repo)\n            scope_info = f\"\\nâ€¢ æ‰«æèŒƒå›´: [yellow]{rel_cwd}/ (ä»…å½“å‰ç›®å½•)[/yellow]\"\n        except ValueError:\n            scope_info = f\"\\nâ€¢ æ‰«æèŒƒå›´: [yellow]å½“å‰ç›®å½•[/yellow]\"\n    \n    info_panel = f\"\"\"\n[bold]å½“å‰é…ç½®[/bold]\nâ€¢ Skill: [cyan]{skill}[/cyan]\nâ€¢ æ¨¡å‹: [cyan]{model}[/cyan]\nâ€¢ ä»“åº“: [dim]{repo}[/dim]\nâ€¢ æ–‡ä»¶: [dim]{len(files) if files else 0} ä¸ª[/dim]{scope_info}\n\"\"\"\n    console.print(Panel(info_panel, border_style=\"cyan\", padding=(0, 2)))\n    \n    # æ˜¾ç¤ºæç¤º\n    console.print(\"\\n[yellow]ğŸ’¡ æç¤º:[/yellow]\")\n    console.print(\"  â€¢ è¾“å…¥ [cyan]/help[/cyan] æŸ¥çœ‹æ‰€æœ‰å‘½ä»¤\")\n    console.print(\"  â€¢ è¾“å…¥ [cyan]/skill[/cyan] åˆ‡æ¢Skill\")\n    console.print(\"  â€¢ è¾“å…¥ [cyan]/exit[/cyan] é€€å‡ºå¯¹è¯\")\n    console.print(\"  â€¢ æŒ‰ [cyan]Ctrl+C[/cyan] ä¹Ÿå¯é€€å‡º\")\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 212,
"end": 257,
"text": "def handle_command(cmd: str, ui_context: dict) -> bool:\n    \"\"\"\n    å¤„ç†å‘½ä»¤\n    \n    Returns:\n        True: ç»§ç»­å¯¹è¯\n        False: é€€å‡ºå¯¹è¯\n    \"\"\"\n    from cli.ui.console import console\n    \n    parts = cmd.split(maxsplit=1)\n    command = parts[0].lower()\n    args = parts[1] if len(parts) > 1 else \"\"\n    \n    if command == \"/exit\" or command == \"/quit\":\n        console.print(\"\\n[cyan]ğŸ‘‹ å†è§ï¼[/cyan]\\n\")\n        return False\n    \n    elif command == \"/help\":\n        show_help()\n    \n    elif command == \"/model\":\n        if not args:\n            console.print(f\"[cyan]å½“å‰æ¨¡å‹: {ui_context['model']}[/cyan]\")\n        else:\n            ui_context['model'] = args\n            console.print(f\"[green]âœ“[/green] å·²åˆ‡æ¢åˆ°æ¨¡å‹: [cyan]{args}[/cyan]\")\n    \n    elif command == \"/session\":\n        console.print(f\"[cyan]ä¼šè¯ID: {ui_context['session_id']}[/cyan]\")\n    \n    elif command == \"/skill\" or command == \"/s\":\n        if not args:\n            # æ˜¾ç¤ºå½“å‰Skillå’Œå¯ç”¨Skill\n            show_skills(ui_context)\n        else:\n            # åˆ‡æ¢Skill\n            switch_skill(args, ui_context)\n    \n    else:\n        console.print(f\"[red]æœªçŸ¥å‘½ä»¤: {command}[/red]\")\n        console.print(\"[dim]è¾“å…¥ /help æŸ¥çœ‹æ‰€æœ‰å‘½ä»¤[/dim]\")\n    \n    return True\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 258,
"end": 288,
"text": "def show_help():\n    \"\"\"æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯\"\"\"\n    from cli.ui.console import console\n    \n    help_text = \"\"\"\n[bold cyan]å¯ç”¨å‘½ä»¤[/bold cyan]\n\n[bold]å¯¹è¯æ§åˆ¶[/bold]\n  /exit, /quit     é€€å‡ºå¯¹è¯\n  /clear           æ¸…ç©ºå¯¹è¯å†å²\n  /history         æŸ¥çœ‹å¯¹è¯å†å²\n\n[bold]Skillç®¡ç†[/bold]\n  /skill [name]    åˆ‡æ¢Skillï¼ˆä¸å¸¦å‚æ•°æ˜¾ç¤ºåˆ—è¡¨ï¼‰\n  /s [name]        /skillçš„ç®€å†™\n\n[bold]æ–‡ä»¶ç®¡ç†[/bold]\n  /add <file>      æ·»åŠ æ–‡ä»¶åˆ°ä¸Šä¸‹æ–‡\n  /drop <file>     ä»ä¸Šä¸‹æ–‡ç§»é™¤æ–‡ä»¶\n  /files           æŸ¥çœ‹å·²åŠ è½½çš„æ–‡ä»¶\n\n[bold]é…ç½®[/bold]\n  /model [name]    æŸ¥çœ‹æˆ–åˆ‡æ¢æ¨¡å‹\n  /help            æ˜¾ç¤ºæ­¤å¸®åŠ©\n\n[bold]å¿«æ·é”®[/bold]\n  Ctrl+C           é€€å‡ºå¯¹è¯\n\"\"\"\n    console.print(Panel(help_text, border_style=\"cyan\", padding=(1, 2)))\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 289,
"end": 322,
"text": "def add_file(filepath: str, context: dict):\n    \"\"\"æ·»åŠ æ–‡ä»¶åˆ°ä¸Šä¸‹æ–‡\"\"\"\n    from cli.ui.console import console\n    \n    path = Path(filepath)\n    if not path.exists():\n        console.print(f\"[red]æ–‡ä»¶ä¸å­˜åœ¨: {filepath}[/red]\")\n        return\n    \n    if str(path) in context[\"files\"]:\n        console.print(f\"[yellow]æ–‡ä»¶å·²åœ¨ä¸Šä¸‹æ–‡ä¸­: {filepath}[/yellow]\")\n        return\n    \n    # è¯»å–æ–‡ä»¶å†…å®¹\n    try:\n        with open(path, 'r', encoding='utf-8') as f:\n            content = f.read()\n        \n        # ä¿å­˜æ–‡ä»¶è·¯å¾„å’Œå†…å®¹\n        context[\"files\"].append(str(path))\n        if \"file_contents\" not in context:\n            context[\"file_contents\"] = {}\n        context[\"file_contents\"][str(path)] = content\n        \n        # æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯\n        lines = len(content.splitlines())\n        size = len(content)\n        console.print(f\"[green]âœ“[/green] å·²æ·»åŠ æ–‡ä»¶: [cyan]{filepath}[/cyan]\")\n        console.print(f\"[dim]  {lines} è¡Œ, {size} å­—ç¬¦[/dim]\")\n    \n    except Exception as e:\n        console.print(f\"[red]è¯»å–æ–‡ä»¶å¤±è´¥: {e}[/red]\")\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 323,
"end": 335,
"text": "def drop_file(filepath: str, context: dict):\n    \"\"\"ä»ä¸Šä¸‹æ–‡ç§»é™¤æ–‡ä»¶\"\"\"\n    from cli.ui.console import console\n    \n    if filepath in context[\"files\"]:\n        context[\"files\"].remove(filepath)\n        if \"file_contents\" in context and filepath in context[\"file_contents\"]:\n            del context[\"file_contents\"][filepath]\n        console.print(f\"[green]âœ“[/green] å·²ç§»é™¤æ–‡ä»¶: [cyan]{filepath}[/cyan]\")\n    else:\n        console.print(f\"[yellow]æ–‡ä»¶ä¸åœ¨ä¸Šä¸‹æ–‡ä¸­: {filepath}[/yellow]\")\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 336,
"end": 384,
"text": "def auto_load_project_files(context: dict, repo: Path):\n    \"\"\"è‡ªåŠ¨åŠ è½½é¡¹ç›®å…³é”®æ–‡ä»¶\"\"\"\n    from cli.ui.console import console\n    import os\n    \n    # å®šä¹‰è¦è‡ªåŠ¨åŠ è½½çš„æ–‡ä»¶æ¨¡å¼\n    key_files = [\n        \"README.md\",\n        \"README.txt\",\n        \"STRUCTURE.txt\",\n        \"PROJECT_STRUCTURE.md\",\n        \"ARCHITECTURE.md\",\n        \"æ ¸å¿ƒè®¾è®¡æ–‡æ¡£.md\",\n        \"é¡¹ç›®ç»“æ„è®¾è®¡.md\",\n    ]\n    \n    loaded_files = []\n    repo_path = Path(repo)\n    \n    # å°è¯•åŠ è½½å…³é”®æ–‡ä»¶\n    for filename in key_files:\n        file_path = repo_path / filename\n        if file_path.exists():\n            try:\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                \n                # é™åˆ¶æ–‡ä»¶å¤§å°ï¼ˆé¿å…åŠ è½½è¿‡å¤§çš„æ–‡ä»¶ï¼‰\n                if len(content) > 50000:  # 50KBé™åˆ¶\n                    console.print(f\"[yellow]âš [/yellow] è·³è¿‡å¤§æ–‡ä»¶: [dim]{filename}[/dim]\")\n                    continue\n                \n                context[\"files\"].append(str(file_path))\n                context[\"file_contents\"][str(file_path)] = content\n                loaded_files.append(filename)\n            \n            except Exception as e:\n                console.print(f\"[yellow]âš [/yellow] æ— æ³•è¯»å–: [dim]{filename}[/dim]\")\n    \n    # æ˜¾ç¤ºåŠ è½½ç»“æœ\n    if loaded_files:\n        console.print(f\"\\n[dim]âœ“ è‡ªåŠ¨åŠ è½½äº† {len(loaded_files)} ä¸ªé¡¹ç›®æ–‡ä»¶:[/dim]\")\n        for filename in loaded_files:\n            console.print(f\"[dim]  â€¢ {filename}[/dim]\")\n        console.print()\n    else:\n        console.print(f\"\\n[dim]ğŸ’¡ æœªæ‰¾åˆ°é¡¹ç›®æ–‡æ¡£ï¼Œä½¿ç”¨ /add å‘½ä»¤æ·»åŠ æ–‡ä»¶[/dim]\\n\")\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 385,
"end": 403,
"text": "def show_files(context: dict):\n    \"\"\"æ˜¾ç¤ºå·²åŠ è½½çš„æ–‡ä»¶\"\"\"\n    from cli.ui.console import console\n    from rich.table import Table\n    \n    if not context[\"files\"]:\n        console.print(\"[yellow]æœªåŠ è½½ä»»ä½•æ–‡ä»¶[/yellow]\")\n        return\n    \n    table = Table(title=\"å·²åŠ è½½çš„æ–‡ä»¶\", show_header=True, border_style=\"cyan\")\n    table.add_column(\"#\", style=\"dim\")\n    table.add_column(\"æ–‡ä»¶è·¯å¾„\", style=\"cyan\")\n    \n    for i, file in enumerate(context[\"files\"], 1):\n        table.add_row(str(i), file)\n    \n    console.print(table)\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 404,
"end": 411,
"text": "def clear_history(context: dict):\n    \"\"\"æ¸…ç©ºå¯¹è¯å†å²\"\"\"\n    from cli.ui.console import console\n    \n    context[\"history\"].clear()\n    console.print(\"[green]âœ“[/green] å¯¹è¯å†å²å·²æ¸…ç©º\")\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 412,
"end": 419,
"text": "def change_model(model: str, context: dict):\n    \"\"\"åˆ‡æ¢æ¨¡å‹\"\"\"\n    from cli.ui.console import console\n    \n    context[\"model\"] = model\n    console.print(f\"[green]âœ“[/green] å·²åˆ‡æ¢åˆ°æ¨¡å‹: [cyan]{model}[/cyan]\")\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 420,
"end": 434,
"text": "def show_history(context: dict):\n    \"\"\"æ˜¾ç¤ºå¯¹è¯å†å²\"\"\"\n    from cli.ui.console import console\n    \n    if not context[\"history\"]:\n        console.print(\"[yellow]æš‚æ— å¯¹è¯å†å²[/yellow]\")\n        return\n    \n    console.print(\"\\n[bold cyan]å¯¹è¯å†å²[/bold cyan]\\n\")\n    for i, (user_msg, ai_msg) in enumerate(context[\"history\"], 1):\n        console.print(f\"[dim]--- ç¬¬ {i} è½® ---[/dim]\")\n        console.print(f\"[bold green]ä½ [/bold green]: {user_msg}\")\n        console.print(f\"[bold blue]AI[/bold blue]: {ai_msg}\\n\")\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 435,
"end": 524,
"text": "def handle_chat(user_input: str, ui_context: dict):\n    \"\"\"å¤„ç†å¯¹è¯ - é€šè¿‡Skillç³»ç»Ÿ\"\"\"\n    from cli.ui.console import console\n    import asyncio\n    import os\n    \n    # å‡†å¤‡åŸºæœ¬ä¸Šä¸‹æ–‡ï¼ˆä¼ é€’ç»™Skillç³»ç»Ÿï¼‰\n    repo_path = os.path.abspath(ui_context[\"repo\"])\n    skill_name = ui_context.get(\"skill\", \"chat-assistant\")\n    \n    context = {\n        \"session_id\": ui_context[\"session_id\"],\n        \"repo\": repo_path,\n        \"model\": ui_context[\"model\"],\n        \"initial_files\": ui_context.get(\"initial_files\", []),\n        \"subtree_only\": ui_context.get(\"subtree_only\", False),\n        \"cwd\": ui_context.get(\"cwd\", os.getcwd()),\n        \"working_directory\": repo_path,\n        \"repo_root\": repo_path,\n    }\n    \n    try:\n        loop = asyncio.get_event_loop()\n    except RuntimeError:\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n    \n    # ä¼šè¯çº§åªåˆå§‹åŒ–ä¸€æ¬¡ï¼Œä»…å½“ repo/skill å˜åŒ–æ—¶å† set_context æˆ–é‡é…ï¼ˆä¼˜åŒ–å»ºè®® 2ï¼‰\n    need_init = (\n        not ui_context.get(\"_chat_init_done\")\n        or ui_context.get(\"_chat_init_repo\") != repo_path\n        or ui_context.get(\"_chat_init_skill\") != skill_name\n    )\n    if need_init:\n        from daoyoucode.agents.init import initialize_agent_system\n        from daoyoucode.agents.tools.registry import get_tool_registry\n        from daoyoucode.agents.tools.base import ToolContext\n        from pathlib import Path\n        from daoyoucode.agents.llm.client_manager import get_client_manager\n        from daoyoucode.agents.llm.config_loader import auto_configure\n\n        initialize_agent_system()\n        registry = get_tool_registry()\n        tool_context = ToolContext(\n            repo_path=Path(repo_path),\n            subtree_only=context.get(\"subtree_only\", False),\n            cwd=Path(context[\"cwd\"]).resolve() if context.get(\"subtree_only\") else None,\n        )\n        registry.set_context(tool_context)\n        client_manager = get_client_manager()\n        auto_configure(client_manager)\n        ui_context[\"_chat_init_done\"] = True\n        ui_context[\"_chat_init_repo\"] = repo_path\n        ui_context[\"_chat_init_skill\"] = skill_name\n    \n    try:\n        # é€šè¿‡Skillç³»ç»Ÿæ‰§è¡Œ\n        from daoyoucode.agents.executor import execute_skill\n        \n        console.print(\"[bold blue]ğŸ¤” AIæ­£åœ¨æ€è€ƒ...[/bold blue]\")\n        \n        result = loop.run_until_complete(execute_skill(\n            skill_name=skill_name,  # â† åŠ¨æ€Skill\n            user_input=user_input,\n            session_id=context[\"session_id\"],\n            context=context\n        ))\n        \n        # æ˜¾ç¤ºç»“æœ\n        if result.get('success'):\n            ai_response = result.get('content', '')\n        else:\n            error_msg = result.get('error', 'æœªçŸ¥é”™è¯¯')\n            console.print(f\"[yellow]âš  æ‰§è¡Œå¤±è´¥: {error_msg}[/yellow]\")\n            ai_response = \"æŠ±æ­‰ï¼Œæˆ‘é‡åˆ°äº†ä¸€äº›é—®é¢˜ã€‚è¯·é‡è¯•ã€‚\"\n    \n    except Exception as e:\n        console.print(f\"[yellow]âš  è°ƒç”¨å¼‚å¸¸: {str(e)[:100]}[/yellow]\")\n        ai_response = \"æŠ±æ­‰ï¼Œç³»ç»Ÿå‡ºç°å¼‚å¸¸ã€‚è¯·é‡è¯•ã€‚\"\n    \n    # æ˜¾ç¤ºAIå“åº”\n    console.print(f\"\\n[bold blue]AI[/bold blue] â€º \", end=\"\")\n    \n    # ä½¿ç”¨Markdownæ¸²æŸ“ï¼ˆå¦‚æœåŒ…å«ä»£ç å—ï¼‰\n    if \"```\" in ai_response:\n        console.print(Markdown(ai_response))\n    else:\n        console.print(ai_response)\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 525,
"end": 558,
"text": "def generate_mock_response(user_input: str, context: dict) -> str:\n    \"\"\"ç”Ÿæˆæ¨¡æ‹Ÿå“åº”ï¼ˆä¸´æ—¶ï¼‰\"\"\"\n    \n    # ç®€å•çš„å…³é”®è¯å“åº”\n    if \"ä½ å¥½\" in user_input or \"hello\" in user_input.lower():\n        return \"ä½ å¥½ï¼æˆ‘æ˜¯DaoyouCode AIåŠ©æ‰‹ï¼ŒåŸºäº18å¤§æ ¸å¿ƒç³»ç»Ÿã€‚æˆ‘å¯ä»¥å¸®ä½ ç¼–å†™ä»£ç ã€é‡æ„é¡¹ç›®ã€è§£ç­”é—®é¢˜ã€‚æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ\"\n    \n    elif \"å¸®åŠ©\" in user_input or \"help\" in user_input.lower():\n        return \"æˆ‘å¯ä»¥å¸®ä½ ï¼š\\n\\n1. ğŸ“ ç¼–å†™å’Œä¿®æ”¹ä»£ç \\n2. ğŸ” åˆ†æä»£ç ç»“æ„\\n3. ğŸ› è°ƒè¯•å’Œä¿®å¤bug\\n4. ğŸ“š è§£ç­”ç¼–ç¨‹é—®é¢˜\\n5. ğŸš€ ä¼˜åŒ–ä»£ç æ€§èƒ½\\n\\nè¯·å‘Šè¯‰æˆ‘ä½ éœ€è¦ä»€ä¹ˆå¸®åŠ©ï¼\"\n    \n    elif \"åŠŸèƒ½\" in user_input or \"èƒ½åšä»€ä¹ˆ\" in user_input:\n        return \"\"\"æˆ‘åŸºäºDaoyouCodeçš„18å¤§æ ¸å¿ƒç³»ç»Ÿï¼Œæ‹¥æœ‰ä»¥ä¸‹èƒ½åŠ›ï¼š\n\n**æ ¸å¿ƒåŠŸèƒ½**\nâ€¢ æ™ºèƒ½ä»£ç ç¼–è¾‘å’Œé‡æ„\nâ€¢ å¤šAgentåä½œï¼ˆ6ä¸ªä¸“ä¸šAgentï¼‰\nâ€¢ å®Œæ•´çš„è®°å¿†ç³»ç»Ÿ\nâ€¢ æ™ºèƒ½ä»»åŠ¡è·¯ç”±\nâ€¢ æƒé™æ§åˆ¶ï¼ˆ100+è§„åˆ™ï¼‰\nâ€¢ 4çº§éªŒè¯æœºåˆ¶\n\n**å·¥å…·ç³»ç»Ÿ**\nâ€¢ 25ä¸ªä¸“ä¸šå·¥å…·\nâ€¢ LSPé›†æˆ\nâ€¢ Gitæ“ä½œ\nâ€¢ æ–‡ä»¶ç®¡ç†\nâ€¢ ä»£ç æœç´¢\n\nç›®å‰CLIåŠŸèƒ½æ­£åœ¨é›†æˆä¸­ï¼Œæ•¬è¯·æœŸå¾…ï¼\"\"\"\n    \n    elif \"ä»£ç \" in user_input or \"code\" in user_input.lower():\n        return \"\"\"å½“ç„¶ï¼æˆ‘å¯ä»¥å¸®ä½ ç¼–å†™ä»£ç ã€‚ä¾‹å¦‚ï¼š\n\n```python"
},
{
"path": "cli/commands/chat.py",
"start": 559,
"end": 573,
"text": "def hello_world():\n    \\\"\\\"\\\"ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹å‡½æ•°\\\"\\\"\\\"\n    print(\"Hello, DaoyouCode!\")\n    return \"Success\"\n\n# è°ƒç”¨å‡½æ•°\nhello_world()\n```\n\nè¯·å‘Šè¯‰æˆ‘ä½ éœ€è¦ä»€ä¹ˆæ ·çš„ä»£ç ï¼Œæˆ‘ä¼šä¸ºä½ ç”Ÿæˆï¼\"\"\"\n    \n    else:\n        return f\"æ”¶åˆ°ä½ çš„æ¶ˆæ¯ï¼šã€Œ{user_input}ã€\\n\\nç›®å‰æˆ‘è¿˜åœ¨å­¦ä¹ ä¸­ï¼Œå®Œæ•´çš„AIå¯¹è¯åŠŸèƒ½å³å°†ä¸Šçº¿ï¼\\n\\nğŸ’¡ æç¤ºï¼šè¾“å…¥ /help æŸ¥çœ‹å¯ç”¨å‘½ä»¤\"\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 574,
"end": 695,
"text": "def initialize_agents(model: str) -> bool:\n    \"\"\"\n    åˆå§‹åŒ–Agentç³»ç»Ÿ\n    \n    Returns:\n        True: Agentåˆå§‹åŒ–æˆåŠŸ\n        False: Agentåˆå§‹åŒ–å¤±è´¥ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼\n    \"\"\"\n    from cli.ui.console import console\n    \n    try:\n        # 1. é…ç½®LLMå®¢æˆ·ç«¯\n        from daoyoucode.agents.llm.client_manager import get_client_manager\n        from daoyoucode.agents.llm.config_loader import auto_configure\n        \n        client_manager = get_client_manager()\n        auto_configure(client_manager)\n        \n        # æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„æä¾›å•†\n        if not client_manager.provider_configs:\n            console.print(\"[yellow]âš  æœªé…ç½®LLMæä¾›å•†ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼[/yellow]\")\n            console.print(\"[dim]è¯·é…ç½® backend/config/llm_config.yaml[/dim]\")\n            return False\n        \n        # 2. å¯¼å…¥Agentç³»ç»Ÿ\n        from daoyoucode.agents.core.agent import (\n            get_agent_registry,\n            register_agent,\n            BaseAgent,\n            AgentConfig\n        )\n        \n        # 3. æ£€æŸ¥æ˜¯å¦å·²æœ‰Agent\n        registry = get_agent_registry()\n        if \"MainAgent\" in registry.list_agents():\n            console.print(\"[dim]âœ“ Agentç³»ç»Ÿå·²å°±ç»ª[/dim]\")\n            return True\n        \n        # åˆ›å»ºå¹¶æ³¨å†ŒMainAgent\n        config = AgentConfig(\n            name=\"MainAgent\",\n            description=\"ä¸»å¯¹è¯Agentï¼Œè´Ÿè´£å¤„ç†ç”¨æˆ·äº¤äº’\",\n            model=model,\n            temperature=0.7,\n            system_prompt=\"\"\"ä½ æ˜¯DaoyouCode AIåŠ©æ‰‹ï¼ŒåŸºäº18å¤§æ ¸å¿ƒç³»ç»Ÿã€‚\n\nä½ çš„èƒ½åŠ›ï¼š\n- æ™ºèƒ½ä»£ç ç¼–å†™å’Œé‡æ„\n- å¤šAgentåä½œ\n- å®Œæ•´çš„è®°å¿†ç³»ç»Ÿ\n- æ™ºèƒ½ä»»åŠ¡è·¯ç”±\n- æƒé™æ§åˆ¶\n- 4çº§éªŒè¯æœºåˆ¶\n- **å¯ä»¥ä¸»åŠ¨è°ƒç”¨å·¥å…·æ¥ç†è§£é¡¹ç›®ä»£ç **\n\nä½ çš„é£æ ¼ï¼š\n- ä¸“ä¸šä½†å‹å¥½\n- ç®€æ´è€Œæ¸…æ™°\n- æ³¨é‡å®ç”¨æ€§\n- æä¾›å¯è¿è¡Œçš„ä»£ç \n\nå½“å‰é¡¹ç›®ï¼šDaoyouCode\n- ä½ç½®: backend/\n- æ ¸å¿ƒæ¨¡å—: daoyoucode/agents/\n- CLIå·¥å…·: cli/\n- é…ç½®: config/\n\nå¯ç”¨å·¥å…·ï¼ˆä½ å¯ä»¥ä¸»åŠ¨è°ƒç”¨ï¼‰ï¼š\n1. **repo_map** - ç”Ÿæˆæ™ºèƒ½ä»£ç åœ°å›¾\n   - è‡ªåŠ¨åˆ†æé¡¹ç›®ç»“æ„\n   - PageRankæ’åºæœ€ç›¸å…³çš„ä»£ç \n   - å½“ç”¨æˆ·é—®\"é¡¹ç›®ç»“æ„\"ã€\"æœ‰å“ªäº›æ¨¡å—\"æ—¶ä½¿ç”¨\n\n2. **get_repo_structure** - è·å–ç›®å½•æ ‘\n   - æ˜¾ç¤ºæ–‡ä»¶å’Œç›®å½•ç»“æ„\n   - å½“ç”¨æˆ·é—®\"ç›®å½•ç»“æ„\"ã€\"æ–‡ä»¶åˆ—è¡¨\"æ—¶ä½¿ç”¨\n\n3. **read_file** - è¯»å–æ–‡ä»¶å†…å®¹\n   - è¯»å–å…·ä½“æ–‡ä»¶\n   - å½“éœ€è¦æŸ¥çœ‹ä»£ç ç»†èŠ‚æ—¶ä½¿ç”¨\n\n4. **search_files** - æœç´¢æ–‡ä»¶\n   - æŒ‰æ–‡ä»¶åæœç´¢\n   - å½“ç”¨æˆ·é—®\"å“ªä¸ªæ–‡ä»¶\"æ—¶ä½¿ç”¨\n\n5. **grep_search** - æœç´¢ä»£ç \n   - åœ¨ä»£ç ä¸­æœç´¢å…³é”®è¯\n   - å½“ç”¨æˆ·é—®\"åœ¨å“ªé‡Œå®ç°\"æ—¶ä½¿ç”¨\n\né‡è¦æç¤ºï¼š\n1. å½“ç”¨æˆ·è¯¢é—®é¡¹ç›®ç›¸å…³é—®é¢˜æ—¶ï¼Œ**ä¸»åŠ¨è°ƒç”¨å·¥å…·**è·å–ä¿¡æ¯\n2. ä¸è¦è¯´\"æˆ‘éœ€è¦æŸ¥çœ‹æ–‡ä»¶\"ï¼Œè€Œæ˜¯ç›´æ¥è°ƒç”¨å·¥å…·\n3. ä¾‹å¦‚ï¼š\n   - ç”¨æˆ·ï¼š\"è¿™ä¸ªé¡¹ç›®çš„ç»“æ„æ˜¯ä»€ä¹ˆï¼Ÿ\"\n   - ä½ ï¼šè°ƒç”¨ repo_map å·¥å…· â†’ åŸºäºç»“æœå›ç­”\n   \n   - ç”¨æˆ·ï¼š\"Agentç³»ç»Ÿåœ¨å“ªé‡Œå®ç°çš„ï¼Ÿ\"\n   - ä½ ï¼šè°ƒç”¨ search_files(\"agent\") â†’ æ‰¾åˆ°æ–‡ä»¶ â†’ è°ƒç”¨ read_file â†’ å›ç­”\n\n4. ç³»ç»Ÿå·²è‡ªåŠ¨åŠ è½½é¡¹ç›®çš„å…³é”®æ–‡æ¡£ï¼ˆREADMEã€STRUCTUREç­‰ï¼‰\n5. ç”¨æˆ·ä¹Ÿå¯ä»¥é€šè¿‡ /add å‘½ä»¤æ‰‹åŠ¨æ·»åŠ æ–‡ä»¶\n\nç”¨æˆ·å‘½ä»¤ï¼š\n- /add <æ–‡ä»¶è·¯å¾„> - æ·»åŠ æ–‡ä»¶åˆ°ä¸Šä¸‹æ–‡\n- /files - æŸ¥çœ‹å·²åŠ è½½çš„æ–‡ä»¶\n- /drop <æ–‡ä»¶è·¯å¾„> - ç§»é™¤æ–‡ä»¶\n\nè¯·ä¸»åŠ¨ä½¿ç”¨å·¥å…·ï¼Œå¸®åŠ©ç”¨æˆ·ç†è§£å’Œæ”¹è¿›ä»£ç ã€‚\"\"\"\n        )\n        \n        agent = BaseAgent(config)\n        register_agent(agent)\n        \n        console.print(\"[dim]âœ“ Agentç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ[/dim]\")\n        return True\n        \n    except Exception as e:\n        console.print(f\"[yellow]âš  Agentåˆå§‹åŒ–å¤±è´¥ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼[/yellow]\")\n        console.print(f\"[dim]åŸå› : {str(e)[:100]}[/dim]\")\n        return False\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 696,
"end": 755,
"text": "def handle_chat_with_agent(user_input: str, context: dict) -> str:\n    \"\"\"ä½¿ç”¨çœŸå®Agentå¤„ç†å¯¹è¯ - é€šè¿‡Skillç³»ç»Ÿ\"\"\"\n    from cli.ui.console import console\n    import asyncio\n    \n    try:\n        # å‡†å¤‡ä¸Šä¸‹æ–‡\n        agent_context = {\n            \"session_id\": context.get(\"session_id\", \"default\"),\n            \"files\": context.get(\"files\", []),\n            \"repo\": context.get(\"repo\", \".\"),\n            \"conversation_history\": context.get(\"history\", [])[-3:]  # æœ€è¿‘3è½®\n        }\n        \n        # å¦‚æœæœ‰æ–‡ä»¶å†…å®¹ï¼Œæ·»åŠ åˆ°ä¸Šä¸‹æ–‡\n        if \"file_contents\" in context and context[\"file_contents\"]:\n            agent_context[\"file_contents\"] = context[\"file_contents\"]\n            \n            # æ„å»ºæ–‡ä»¶ä¿¡æ¯\n            file_info = \"\\n\\nå·²åŠ è½½çš„æ–‡ä»¶:\\n\"\n            for filepath, content in context[\"file_contents\"].items():\n                lines = len(content.splitlines())\n                file_info += f\"\\n--- {filepath} ({lines} è¡Œ) ---\\n{content}\\n\"\n            \n            # å°†æ–‡ä»¶ä¿¡æ¯æ·»åŠ åˆ°ç”¨æˆ·è¾“å…¥å‰\n            user_input = file_info + \"\\n\\nç”¨æˆ·é—®é¢˜: \" + user_input\n        \n        # æ˜¾ç¤ºæ€è€ƒåŠ¨ç”»\n        with console.status(\"[bold blue]AIæ­£åœ¨æ€è€ƒ...[/bold blue]\", spinner=\"dots\"):\n            # ä½¿ç”¨ get_event_loop è€Œä¸æ˜¯ run æ¥é¿å… event loop closed é—®é¢˜\n            try:\n                loop = asyncio.get_event_loop()\n            except RuntimeError:\n                loop = asyncio.new_event_loop()\n                asyncio.set_event_loop(loop)\n            \n            # é€šè¿‡Skillç³»ç»Ÿæ‰§è¡Œï¼ˆæ­£ç¡®çš„æ¶æ„ï¼‰\n            from daoyoucode.agents.executor import execute_skill\n            \n            result = loop.run_until_complete(execute_skill(\n                skill_name=\"chat-assistant\",\n                user_input=user_input,\n                session_id=agent_context[\"session_id\"],\n                context=agent_context\n            ))\n        \n        # æ£€æŸ¥ç»“æœ\n        if result.get('success'):\n            return result.get('content', '')\n        else:\n            error_msg = result.get('error', 'æœªçŸ¥é”™è¯¯')\n            console.print(f\"[yellow]âš  æ‰§è¡Œå¤±è´¥: {error_msg}[/yellow]\")\n            return generate_mock_response(user_input, context)\n    \n    except Exception as e:\n        console.print(f\"[yellow]âš  è°ƒç”¨å¼‚å¸¸: {str(e)[:100]}[/yellow]\")\n        return generate_mock_response(user_input, context)\n\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 756,
"end": 793,
"text": "def show_skills(ui_context: dict):\n    \"\"\"æ˜¾ç¤ºSkillåˆ—è¡¨\"\"\"\n    from cli.ui.console import console\n    from rich.table import Table\n    \n    try:\n        from daoyoucode.agents.core.skill import get_skill_loader\n        \n        loader = get_skill_loader()\n        skills = loader.list_skills()\n        \n        current_skill = ui_context.get('skill', 'chat-assistant')\n        \n        console.print(\"\\n[bold cyan]ğŸ“¦ å¯ç”¨Skill[/bold cyan]\\n\")\n        \n        table = Table(show_header=True, border_style=\"cyan\")\n        table.add_column(\"\", style=\"dim\", width=2)\n        table.add_column(\"åç§°\", style=\"cyan\")\n        table.add_column(\"ç¼–æ’å™¨\", style=\"yellow\")\n        table.add_column(\"æè¿°\")\n        \n        for skill in skills:\n            marker = \"â†’\" if skill['name'] == current_skill else \"\"\n            table.add_row(\n                marker,\n                skill['name'],\n                skill['orchestrator'],\n                skill['description'][:60] + '...' if len(skill['description']) > 60 else skill['description']\n            )\n        \n        console.print(table)\n        console.print(f\"\\n[dim]å½“å‰Skill: [cyan]{current_skill}[/cyan][/dim]\")\n        console.print(f\"[dim]ä½¿ç”¨ [cyan]/skill <name>[/cyan] åˆ‡æ¢Skill[/dim]\\n\")\n    \n    except Exception as e:\n        console.print(f\"[red]åŠ è½½Skillåˆ—è¡¨å¤±è´¥: {e}[/red]\")\n\n"
},
{
"path": "cli/commands/chat.py",
"start": 794,
"end": 815,
"text": "def switch_skill(skill_name: str, ui_context: dict):\n    \"\"\"åˆ‡æ¢Skill\"\"\"\n    from cli.ui.console import console\n    \n    try:\n        from daoyoucode.agents.core.skill import get_skill_loader\n        \n        loader = get_skill_loader()\n        skill = loader.get_skill(skill_name)\n        \n        if not skill:\n            console.print(f\"[red]Skillä¸å­˜åœ¨: {skill_name}[/red]\")\n            console.print(\"[dim]è¾“å…¥ [cyan]/skill[/cyan] æŸ¥çœ‹æ‰€æœ‰å¯ç”¨Skill[/dim]\")\n            return\n        \n        ui_context['skill'] = skill_name\n        console.print(f\"[green]âœ“[/green] å·²åˆ‡æ¢åˆ° [cyan]{skill_name}[/cyan]\")\n        console.print(f\"[dim]{skill.description}[/dim]\")\n        console.print(f\"[dim]ç¼–æ’å™¨: {skill.orchestrator}[/dim]\")\n    \n    except Exception as e:\n        console.print(f\"[red]åˆ‡æ¢Skillå¤±è´¥: {e}[/red]\")"
},
{
"path": "cli/commands/config.py",
"start": 1,
"end": 14,
"text": "\"\"\"\né…ç½®ç®¡ç†å‘½ä»¤\n\næŸ¥çœ‹å’Œä¿®æ”¹é…ç½®\n\"\"\"\n\nimport typer\nfrom typing import Optional\n\n\napp = typer.Typer(help=\"é…ç½®ç®¡ç†\")\n\n\n@app.command()"
},
{
"path": "cli/commands/config.py",
"start": 15,
"end": 36,
"text": "def show():\n    \"\"\"æ˜¾ç¤ºå½“å‰é…ç½®\"\"\"\n    from cli.ui.console import console\n    from cli.utils.config import get_config\n    from rich.table import Table\n    \n    config = get_config()\n    \n    console.print(\"\\n[bold cyan]âš™ï¸  å½“å‰é…ç½®[/bold cyan]\\n\")\n    \n    table = Table(show_header=True, border_style=\"cyan\")\n    table.add_column(\"é…ç½®é¡¹\", style=\"bold\")\n    table.add_column(\"å€¼\", style=\"cyan\")\n    \n    for key, value in config.all().items():\n        table.add_row(key, str(value))\n    \n    console.print(table)\n    console.print(f\"\\n[dim]é…ç½®æ–‡ä»¶: {config.config_file}[/dim]\\n\")\n\n\n@app.command()"
},
{
"path": "cli/commands/config.py",
"start": 37,
"end": 59,
"text": "def set(\n    key: str = typer.Argument(..., help=\"é…ç½®é¡¹\"),\n    value: str = typer.Argument(..., help=\"é…ç½®å€¼\"),\n):\n    \"\"\"è®¾ç½®é…ç½®é¡¹\"\"\"\n    from cli.ui.console import console\n    from cli.utils.config import get_config\n    \n    config = get_config()\n    \n    # ç±»å‹è½¬æ¢\n    if value.lower() in ('true', 'false'):\n        value = value.lower() == 'true'\n    elif value.isdigit():\n        value = int(value)\n    elif value.replace('.', '', 1).isdigit():\n        value = float(value)\n    \n    config.set(key, value)\n    console.print(f\"\\n[green]âœ“[/green] å·²è®¾ç½® [bold]{key}[/bold] = [cyan]{value}[/cyan]\\n\")\n\n\n@app.command()"
},
{
"path": "cli/commands/config.py",
"start": 60,
"end": 72,
"text": "def reset():\n    \"\"\"é‡ç½®ä¸ºé»˜è®¤é…ç½®\"\"\"\n    from cli.ui.console import console\n    from cli.utils.config import get_config\n    \n    if typer.confirm(\"ç¡®å®šè¦é‡ç½®é…ç½®å—ï¼Ÿ\"):\n        config = get_config()\n        config.reset()\n        console.print(\"\\n[green]âœ“[/green] é…ç½®å·²é‡ç½®ä¸ºé»˜è®¤å€¼\\n\")\n    else:\n        console.print(\"\\n[yellow]å·²å–æ¶ˆ[/yellow]\\n\")\n\n"
},
{
"path": "cli/commands/config.py",
"start": 73,
"end": 75,
"text": "def main():\n    \"\"\"é…ç½®ç®¡ç†å…¥å£\"\"\"\n    app()"
},
{
"path": "cli/commands/doctor.py",
"start": 1,
"end": 10,
"text": "\"\"\"\nç¯å¢ƒè¯Šæ–­å‘½ä»¤\n\næ£€æŸ¥ç³»ç»Ÿé…ç½®å’Œä¾èµ–\n\"\"\"\n\nimport typer\nfrom typing import Optional\n\n"
},
{
"path": "cli/commands/doctor.py",
"start": 11,
"end": 75,
"text": "def main(\n    fix: bool = typer.Option(False, \"--fix\", help=\"è‡ªåŠ¨ä¿®å¤é—®é¢˜\"),\n):\n    \"\"\"\n    è¯Šæ–­ç³»ç»Ÿç¯å¢ƒ\n    \n    æ£€æŸ¥:\n    - Pythonç‰ˆæœ¬\n    - ä¾èµ–åŒ…\n    - APIå¯†é’¥é…ç½®\n    - æ ¸å¿ƒç³»ç»ŸçŠ¶æ€\n    \n    ç¤ºä¾‹:\n        daoyoucode doctor\n        daoyoucode doctor --fix\n    \"\"\"\n    from cli.ui.console import console\n    \n    console.print(\"\\n[bold cyan]ğŸ” DaoyouCode ç¯å¢ƒè¯Šæ–­[/bold cyan]\\n\")\n    \n    # æ£€æŸ¥é¡¹ç›®\n    checks = [\n        (\"Pythonç‰ˆæœ¬\", check_python),\n        (\"ä¾èµ–åŒ…\", check_dependencies),\n        (\"APIå¯†é’¥\", check_api_keys),\n        (\"æ ¸å¿ƒç³»ç»Ÿ\", check_core_systems),\n        (\"å·¥å…·ç³»ç»Ÿ\", check_tools),\n    ]\n    \n    passed = 0\n    failed = 0\n    warnings = 0\n    \n    for name, check_func in checks:\n        console.print(f\"[bold]{name}[/bold]\")\n        status, message = check_func()\n        \n        if status == \"pass\":\n            console.print(f\"  [green]âœ“[/green] {message}\")\n            passed += 1\n        elif status == \"warn\":\n            console.print(f\"  [yellow]âš [/yellow] {message}\")\n            warnings += 1\n        else:\n            console.print(f\"  [red]âœ—[/red] {message}\")\n            failed += 1\n        \n        console.print()\n    \n    # æ€»ç»“\n    console.print(\"[bold]æ€»ç»“:[/bold]\")\n    console.print(f\"  é€šè¿‡: {passed}\")\n    console.print(f\"  è­¦å‘Š: {warnings}\")\n    console.print(f\"  å¤±è´¥: {failed}\")\n    console.print()\n    \n    if failed > 0:\n        console.print(\"[red]å‘ç°é—®é¢˜ï¼Œè¯·æ£€æŸ¥ä¸Šè¿°å¤±è´¥é¡¹[/red]\")\n        if fix:\n            console.print(\"[yellow]å°è¯•è‡ªåŠ¨ä¿®å¤...[/yellow]\")\n        raise typer.Exit(1)\n    else:\n        console.print(\"[green]âœ… ç³»ç»ŸçŠ¶æ€è‰¯å¥½ï¼[/green]\")\n\n"
},
{
"path": "cli/commands/doctor.py",
"start": 76,
"end": 85,
"text": "def check_python():\n    \"\"\"æ£€æŸ¥Pythonç‰ˆæœ¬\"\"\"\n    import sys\n    version = sys.version_info\n    if version >= (3, 10):\n        return \"pass\", f\"Python {version.major}.{version.minor}.{version.micro}\"\n    else:\n        return \"fail\", f\"Pythonç‰ˆæœ¬è¿‡ä½: {version.major}.{version.minor} (éœ€è¦ >= 3.10)\"\n\n"
},
{
"path": "cli/commands/doctor.py",
"start": 86,
"end": 95,
"text": "def check_dependencies():\n    \"\"\"æ£€æŸ¥ä¾èµ–åŒ…\"\"\"\n    try:\n        import typer\n        import rich\n        return \"pass\", \"æ‰€æœ‰ä¾èµ–å·²å®‰è£…\"\n    except ImportError as e:\n        return \"fail\", f\"ç¼ºå°‘ä¾èµ–: {e.name}\"\n\n"
},
{
"path": "cli/commands/doctor.py",
"start": 96,
"end": 116,
"text": "def check_api_keys():\n    \"\"\"æ£€æŸ¥APIå¯†é’¥\"\"\"\n    import os\n    \n    keys = {\n        \"DASHSCOPE_API_KEY\": \"é€šä¹‰åƒé—®\",\n        \"DEEPSEEK_API_KEY\": \"DeepSeek\",\n        \"OPENAI_API_KEY\": \"OpenAI\",\n    }\n    \n    found = []\n    for key, name in keys.items():\n        if os.getenv(key):\n            found.append(name)\n    \n    if found:\n        return \"pass\", f\"å·²é…ç½®: {', '.join(found)}\"\n    else:\n        return \"warn\", \"æœªé…ç½®APIå¯†é’¥\"\n\n"
},
{
"path": "cli/commands/doctor.py",
"start": 117,
"end": 125,
"text": "def check_core_systems():\n    \"\"\"æ£€æŸ¥æ ¸å¿ƒç³»ç»Ÿ\"\"\"\n    try:\n        # TODO: æ£€æŸ¥18å¤§æ ¸å¿ƒç³»ç»Ÿ\n        return \"pass\", \"18å¤§æ ¸å¿ƒç³»ç»Ÿæ­£å¸¸\"\n    except Exception as e:\n        return \"fail\", f\"æ ¸å¿ƒç³»ç»Ÿå¼‚å¸¸: {e}\"\n\n"
},
{
"path": "cli/commands/doctor.py",
"start": 126,
"end": 132,
"text": "def check_tools():\n    \"\"\"æ£€æŸ¥å·¥å…·ç³»ç»Ÿ\"\"\"\n    try:\n        # TODO: æ£€æŸ¥25ä¸ªå·¥å…·\n        return \"pass\", \"25ä¸ªå·¥å…·æ­£å¸¸\"\n    except Exception as e:\n        return \"fail\", f\"å·¥å…·ç³»ç»Ÿå¼‚å¸¸: {e}\""
},
{
"path": "cli/commands/edit.py",
"start": 1,
"end": 15,
"text": "\"\"\"\nå•æ¬¡ç¼–è¾‘å‘½ä»¤\n\nå¿«é€Ÿç¼–è¾‘æ–‡ä»¶ï¼Œä¸éœ€è¦äº¤äº’å¼å¯¹è¯\n\"\"\"\n\nimport typer\nfrom typing import List\nfrom pathlib import Path\nfrom rich.panel import Panel\nfrom rich.syntax import Syntax\nfrom rich.progress import Progress, SpinnerColumn, TextColumn\nimport time\n\n"
},
{
"path": "cli/commands/edit.py",
"start": 16,
"end": 46,
"text": "def main(\n    files: List[Path] = typer.Argument(..., help=\"è¦ç¼–è¾‘çš„æ–‡ä»¶\"),\n    instruction: str = typer.Argument(..., help=\"ç¼–è¾‘æŒ‡ä»¤\"),\n    model: str = typer.Option(\"qwen-max\", \"--model\", \"-m\", help=\"ä½¿ç”¨çš„æ¨¡å‹\"),\n    yes: bool = typer.Option(False, \"--yes\", \"-y\", help=\"è‡ªåŠ¨ç¡®è®¤æ‰€æœ‰æ“ä½œ\"),\n    repo: Path = typer.Option(\".\", \"--repo\", \"-r\", help=\"ä»“åº“è·¯å¾„\"),\n):\n    \"\"\"\n    å•æ¬¡ç¼–è¾‘æ–‡ä»¶\n    \n    ç¤ºä¾‹:\n        daoyoucode edit main.py \"æ·»åŠ æ—¥å¿—åŠŸèƒ½\"\n        daoyoucode edit app.py utils.py \"é‡æ„é”™è¯¯å¤„ç†\" --yes\n    \"\"\"\n    from cli.ui.console import console\n    \n    # æ˜¾ç¤ºç¼–è¾‘ä¿¡æ¯\n    show_edit_banner(files, instruction, model)\n    \n    # éªŒè¯æ–‡ä»¶\n    if not validate_files(files):\n        raise typer.Exit(1)\n    \n    # é€šè¿‡ Skill ä½“ç³»æ‰§è¡Œï¼ˆå¤ç”¨è¶…æ—¶/æ¢å¤/Hookï¼‰ï¼Œå¤±è´¥æ—¶é™çº§ä¸ºæ¨¡æ‹Ÿæ¨¡å¼\n    try:\n        execute_edit_via_skill(files, instruction, model, yes, repo)\n    except Exception as e:\n        console.print(f\"\\n[red]âŒ é”™è¯¯: {e}[/red]\\n\")\n        raise typer.Exit(1)\n\n"
},
{
"path": "cli/commands/edit.py",
"start": 47,
"end": 60,
"text": "def show_edit_banner(files: List[Path], instruction: str, model: str):\n    \"\"\"æ˜¾ç¤ºç¼–è¾‘æ¨ªå¹…\"\"\"\n    from cli.ui.console import console\n    \n    info = f\"\"\"\n[bold]ç¼–è¾‘ä»»åŠ¡[/bold]\n\nâ€¢ æ–‡ä»¶: [cyan]{', '.join(str(f) for f in files)}[/cyan]\nâ€¢ æŒ‡ä»¤: [yellow]{instruction}[/yellow]\nâ€¢ æ¨¡å‹: [dim]{model}[/dim]\n\"\"\"\n    console.print(Panel(info, title=\"ğŸ“ å•æ¬¡ç¼–è¾‘\", border_style=\"cyan\", padding=(0, 2)))\n\n"
},
{
"path": "cli/commands/edit.py",
"start": 61,
"end": 76,
"text": "def validate_files(files: List[Path]) -> bool:\n    \"\"\"éªŒè¯æ–‡ä»¶æ˜¯å¦å­˜åœ¨\"\"\"\n    from cli.ui.console import console\n    \n    all_valid = True\n    for file in files:\n        if not file.exists():\n            console.print(f\"[red]âœ—[/red] æ–‡ä»¶ä¸å­˜åœ¨: {file}\")\n            all_valid = False\n        elif not file.is_file():\n            console.print(f\"[red]âœ—[/red] ä¸æ˜¯æ–‡ä»¶: {file}\")\n            all_valid = False\n    \n    return all_valid\n\n"
},
{
"path": "cli/commands/edit.py",
"start": 77,
"end": 96,
"text": "def show_diff_preview(files: List[Path], instruction: str):\n    \"\"\"æ˜¾ç¤ºä¿®æ”¹é¢„è§ˆ\"\"\"\n    from cli.ui.console import console\n    \n    console.print(\"\\n[bold cyan]ä¿®æ”¹é¢„è§ˆ[/bold cyan]\\n\")\n    \n    # æ¨¡æ‹Ÿdiff\n    for file in files:\n        console.print(f\"[bold]{file}[/bold]\")\n        \n        # æ˜¾ç¤ºæ¨¡æ‹Ÿçš„ä»£ç diff\n        diff_text = f\"\"\"[red]- # TODO: æ—§ä»£ç [/red]\n[green]+ # {instruction}[/green]\n[green]+ def new_function():[/green]\n[green]+     pass[/green]\"\"\"\n        \n        console.print(Panel(diff_text, border_style=\"dim\", padding=(0, 1)))\n        console.print()\n\n"
},
{
"path": "cli/commands/edit.py",
"start": 97,
"end": 110,
"text": "def apply_changes(files: List[Path]):\n    \"\"\"åº”ç”¨ä¿®æ”¹\"\"\"\n    from cli.ui.console import console\n    \n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        console=console,\n    ) as progress:\n        task = progress.add_task(\"[cyan]ğŸ”¨ åº”ç”¨ä¿®æ”¹...\", total=None)\n        time.sleep(1)  # æ¨¡æ‹Ÿåº”ç”¨\n        progress.update(task, description=\"[green]âœ“[/green] ä¿®æ”¹å·²åº”ç”¨\")\n\n"
},
{
"path": "cli/commands/edit.py",
"start": 111,
"end": 129,
"text": "def show_success(files: List[Path]):\n    \"\"\"æ˜¾ç¤ºæˆåŠŸä¿¡æ¯\"\"\"\n    from cli.ui.console import console\n    from rich.table import Table\n    \n    console.print(\"\\n[bold green]âœ… ç¼–è¾‘å®Œæˆï¼[/bold green]\\n\")\n    \n    # æ˜¾ç¤ºä¿®æ”¹çš„æ–‡ä»¶\n    table = Table(show_header=True, border_style=\"green\")\n    table.add_column(\"æ–‡ä»¶\", style=\"cyan\")\n    table.add_column(\"çŠ¶æ€\", style=\"green\")\n    \n    for file in files:\n        table.add_row(str(file), \"âœ“ å·²ä¿®æ”¹\")\n    \n    console.print(table)\n    console.print(\"\\n[dim]ğŸ’¡ æç¤º: ä½¿ç”¨ git diff æŸ¥çœ‹è¯¦ç»†ä¿®æ”¹[/dim]\\n\")\n\n"
},
{
"path": "cli/commands/edit.py",
"start": 130,
"end": 227,
"text": "def execute_edit_via_skill(\n    files: List[Path],\n    instruction: str,\n    model: str,\n    yes: bool,\n    repo: Path,\n):\n    \"\"\"é€šè¿‡ edit-single Skill æ‰§è¡Œç¼–è¾‘ï¼ˆå¤ç”¨ç¼–æ’å™¨ã€è¶…æ—¶æ¢å¤ã€Hookï¼‰\"\"\"\n    from cli.ui.console import console\n    import asyncio\n    import os\n\n    repo_path = os.path.abspath(str(repo))\n    # è¦ç¼–è¾‘çš„æ–‡ä»¶ï¼šä½¿ç”¨ç›¸å¯¹ repo çš„è·¯å¾„ä¾› Agent ä½¿ç”¨\n    try:\n        repo_p = Path(repo_path)\n        edit_files = [str(Path(f).resolve().relative_to(repo_p)) if repo_p in Path(f).resolve().parents or Path(f).resolve() == repo_p else str(f) for f in files]\n    except ValueError:\n        edit_files = [str(f) for f in files]\n\n    user_input = f\"\"\"è¯·ç¼–è¾‘ä»¥ä¸‹æ–‡ä»¶ï¼Œå¹¶ä¸¥æ ¼æŒ‰æŒ‡ä»¤ä¿®æ”¹ï¼š\n\n**è¦ç¼–è¾‘çš„æ–‡ä»¶ï¼š**\n{chr(10).join('- ' + p for p in edit_files)}\n\n**ç¼–è¾‘æŒ‡ä»¤ï¼š**\n{instruction}\n\nè¯·å…ˆè¯»å–ä¸Šè¿°æ–‡ä»¶å†…å®¹ï¼Œå†æŒ‰æŒ‡ä»¤åšæœ€å°åŒ–ã€ç²¾ç¡®çš„ä¿®æ”¹ï¼Œå¹¶ä½¿ç”¨ write_file æˆ– search_replace å·¥å…·å†™å…¥ã€‚è·¯å¾„ä½¿ç”¨ç›¸å¯¹é¡¹ç›®æ ¹çš„è·¯å¾„ã€‚\"\"\"\n\n    context = {\n        \"session_id\": \"edit-\" + str(int(time.time())),\n        \"repo\": repo_path,\n        \"working_directory\": repo_path,\n        \"model\": model,\n        \"instruction\": instruction,\n        \"edit_files\": edit_files,\n        \"subtree_only\": False,\n        \"cwd\": repo_path,\n    }\n\n    try:\n        from daoyoucode.agents.init import initialize_agent_system\n        from daoyoucode.agents.tools.registry import get_tool_registry\n        from daoyoucode.agents.tools.base import ToolContext\n        from daoyoucode.agents.llm.client_manager import get_client_manager\n        from daoyoucode.agents.llm.config_loader import auto_configure\n        from daoyoucode.agents.executor import execute_skill\n\n        initialize_agent_system()\n        registry = get_tool_registry()\n        registry.set_context(ToolContext(repo_path=Path(repo_path)))\n        client_manager = get_client_manager()\n        auto_configure(client_manager)\n        if not client_manager.provider_configs:\n            console.print(\"[yellow]âš  æœªé…ç½®LLMï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼[/yellow]\")\n            execute_edit_mock(files, instruction, yes)\n            return\n\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            console=console,\n        ) as progress:\n            task = progress.add_task(\"[cyan]ğŸ¤– AIæ­£åœ¨åˆ†æå’Œä¿®æ”¹ä»£ç ...\", total=None)\n            result = asyncio.run(\n                execute_skill(\n                    skill_name=\"edit-single\",\n                    user_input=user_input,\n                    session_id=context[\"session_id\"],\n                    context=context,\n                )\n            )\n            progress.update(task, description=\"[green]âœ“[/green] AIå¤„ç†å®Œæˆ\")\n\n        if not result.get(\"success\"):\n            console.print(f\"[yellow]âš  æ‰§è¡Œå¤±è´¥: {result.get('error', 'æœªçŸ¥é”™è¯¯')}[/yellow]\")\n            execute_edit_mock(files, instruction, yes)\n            return\n\n        content = result.get(\"content\", \"\")\n        console.print(\"\\n[bold cyan]AIçš„ä¿®æ”¹å»ºè®®[/bold cyan]\\n\")\n        console.print(content[:500] if len(content) > 500 else content)\n        if len(content) > 500:\n            console.print(\"[dim]...(å†…å®¹è¿‡é•¿ï¼Œå·²æˆªæ–­)[/dim]\")\n        show_diff_preview_real(files, content)\n\n        if not yes:\n            if not typer.confirm(\"\\nåº”ç”¨è¿™äº›ä¿®æ”¹ï¼Ÿ\"):\n                console.print(\"\\n[yellow]å·²å–æ¶ˆä¿®æ”¹[/yellow]\\n\")\n                raise typer.Exit(0)\n        apply_changes(files)\n        show_success(files)\n    except Exception as e:\n        console.print(f\"[yellow]âš  è°ƒç”¨å¼‚å¸¸: {str(e)[:100]}[/yellow]\")\n        execute_edit_mock(files, instruction, yes)\n\n"
},
{
"path": "cli/commands/edit.py",
"start": 228,
"end": 271,
"text": "def execute_edit_mock(files: List[Path], instruction: str, yes: bool):\n    \"\"\"ä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼æ‰§è¡Œç¼–è¾‘\"\"\"\n    from cli.ui.console import console\n    \n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        console=console,\n    ) as progress:\n        \n        # 1. åˆ†ææ–‡ä»¶\n        task = progress.add_task(\"[cyan]ğŸ“Š åˆ†ææ–‡ä»¶...\", total=None)\n        time.sleep(1)  # æ¨¡æ‹Ÿåˆ†æ\n        progress.update(task, description=\"[green]âœ“[/green] æ–‡ä»¶åˆ†æå®Œæˆ\")\n        progress.stop_task(task)\n        \n        # 2. ç”Ÿæˆä¿®æ”¹\n        task = progress.add_task(\"[cyan]âœï¸  ç”Ÿæˆä¿®æ”¹...\", total=None)\n        time.sleep(1.5)  # æ¨¡æ‹Ÿç”Ÿæˆ\n        progress.update(task, description=\"[green]âœ“[/green] ä¿®æ”¹ç”Ÿæˆå®Œæˆ\")\n        progress.stop_task(task)\n        \n        # 3. éªŒè¯ä¿®æ”¹\n        task = progress.add_task(\"[cyan]ğŸ” éªŒè¯ä¿®æ”¹...\", total=None)\n        time.sleep(0.5)  # æ¨¡æ‹ŸéªŒè¯\n        progress.update(task, description=\"[green]âœ“[/green] ä¿®æ”¹éªŒè¯é€šè¿‡\")\n        progress.stop_task(task)\n    \n    # æ˜¾ç¤ºä¿®æ”¹é¢„è§ˆ\n    show_diff_preview(files, instruction)\n    \n    # ç¡®è®¤åº”ç”¨\n    if not yes:\n        if not typer.confirm(\"\\nåº”ç”¨è¿™äº›ä¿®æ”¹ï¼Ÿ\"):\n            console.print(\"\\n[yellow]å·²å–æ¶ˆä¿®æ”¹[/yellow]\\n\")\n            raise typer.Exit(0)\n    \n    # åº”ç”¨ä¿®æ”¹\n    apply_changes(files)\n    \n    # æ˜¾ç¤ºæˆåŠŸä¿¡æ¯\n    show_success(files)\n\n"
},
{
"path": "cli/commands/edit.py",
"start": 272,
"end": 288,
"text": "def show_diff_preview_real(files: List[Path], ai_response: str):\n    \"\"\"æ˜¾ç¤ºçœŸå®çš„ä¿®æ”¹é¢„è§ˆ\"\"\"\n    from cli.ui.console import console\n    \n    console.print(\"\\n[bold cyan]ä¿®æ”¹é¢„è§ˆ[/bold cyan]\\n\")\n    \n    # ç®€å•è§£æAIå“åº”ä¸­çš„ä»£ç å—\n    for file in files:\n        console.print(f\"[bold]{file}[/bold]\")\n        \n        # è¿™é‡Œåº”è¯¥è§£æAIå“åº”ï¼Œæå–ä¿®æ”¹çš„ä»£ç \n        # æš‚æ—¶æ˜¾ç¤ºæ¨¡æ‹Ÿçš„diff\n        diff_text = f\"\"\"[dim]AIå»ºè®®çš„ä¿®æ”¹ï¼ˆéƒ¨åˆ†ï¼‰ï¼š[/dim]\n[green]+ # {ai_response[:100].replace(chr(10), ' ')}...[/green]\"\"\"\n        \n        console.print(Panel(diff_text, border_style=\"dim\", padding=(0, 1)))\n        console.print()"
},
{
"path": "cli/commands/models.py",
"start": 1,
"end": 9,
"text": "\"\"\"\næ¨¡å‹ç®¡ç†å‘½ä»¤\n\næŸ¥çœ‹å¯ç”¨æ¨¡å‹\n\"\"\"\n\nimport typer\n\n"
},
{
"path": "cli/commands/models.py",
"start": 10,
"end": 36,
"text": "def main():\n    \"\"\"åˆ—å‡ºæ‰€æœ‰å¯ç”¨æ¨¡å‹\"\"\"\n    from cli.ui.console import console\n    from rich.table import Table\n    \n    console.print(\"\\n[bold cyan]ğŸ¯ å¯ç”¨æ¨¡å‹[/bold cyan]\\n\")\n    \n    # TODO: ä»LLMç®¡ç†å™¨è¯»å–\n    models = [\n        {\"name\": \"qwen-max\", \"provider\": \"é€šä¹‰åƒé—®\", \"type\": \"é€šç”¨\"},\n        {\"name\": \"qwen-coder-plus\", \"provider\": \"é€šä¹‰åƒé—®\", \"type\": \"ä»£ç \"},\n        {\"name\": \"deepseek-coder\", \"provider\": \"DeepSeek\", \"type\": \"ä»£ç \"},\n        {\"name\": \"claude-opus-4.5\", \"provider\": \"Anthropic\", \"type\": \"é€šç”¨\"},\n        {\"name\": \"gpt-5.2\", \"provider\": \"OpenAI\", \"type\": \"é€šç”¨\"},\n        {\"name\": \"glm-4.7\", \"provider\": \"æ™ºè°±AI\", \"type\": \"é€šç”¨\"},\n    ]\n    \n    table = Table(show_header=True)\n    table.add_column(\"æ¨¡å‹åç§°\")\n    table.add_column(\"æä¾›å•†\")\n    table.add_column(\"ç±»å‹\")\n    \n    for model in models:\n        table.add_row(model[\"name\"], model[\"provider\"], model[\"type\"])\n    \n    console.print(table)\n    console.print()"
},
{
"path": "cli/commands/serve.py",
"start": 1,
"end": 9,
"text": "\"\"\"\næœåŠ¡å™¨å‘½ä»¤\n\nå¯åŠ¨HTTPæœåŠ¡å™¨\n\"\"\"\n\nimport typer\n\n"
},
{
"path": "cli/commands/serve.py",
"start": 10,
"end": 36,
"text": "def main(\n    host: str = typer.Option(\"127.0.0.1\", \"--host\", \"-h\", help=\"ç›‘å¬åœ°å€\"),\n    port: int = typer.Option(8000, \"--port\", \"-p\", help=\"ç›‘å¬ç«¯å£\"),\n):\n    \"\"\"\n    å¯åŠ¨HTTPæœåŠ¡å™¨\n    \n    ç¤ºä¾‹:\n        daoyoucode serve\n        daoyoucode serve --host 0.0.0.0 --port 3000\n    \"\"\"\n    from cli.ui.console import console\n    \n    console.print(f\"\\n[bold cyan]ğŸš€ å¯åŠ¨æœåŠ¡å™¨[/bold cyan]\")\n    console.print(f\"[dim]åœ°å€: http://{host}:{port}[/dim]\\n\")\n    \n    # TODO: å¯åŠ¨FastAPIæœåŠ¡å™¨\n    console.print(\"[yellow]åŠŸèƒ½å¼€å‘ä¸­...[/yellow]\")\n    console.print(\"[dim]æŒ‰ Ctrl+C åœæ­¢æœåŠ¡å™¨[/dim]\\n\")\n    \n    try:\n        # æ¨¡æ‹ŸæœåŠ¡å™¨è¿è¡Œ\n        import time\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        console.print(\"\\n[cyan]æœåŠ¡å™¨å·²åœæ­¢[/cyan]\\n\")"
},
{
"path": "cli/commands/session.py",
"start": 1,
"end": 14,
"text": "\"\"\"\nä¼šè¯ç®¡ç†å‘½ä»¤\n\næŸ¥çœ‹å’Œç®¡ç†å¯¹è¯ä¼šè¯\n\"\"\"\n\nimport typer\nfrom typing import Optional\n\n\napp = typer.Typer(help=\"ä¼šè¯ç®¡ç†\")\n\n\n@app.command()"
},
{
"path": "cli/commands/session.py",
"start": 15,
"end": 40,
"text": "def list():\n    \"\"\"åˆ—å‡ºæ‰€æœ‰ä¼šè¯\"\"\"\n    from cli.ui.console import console\n    from rich.table import Table\n    \n    console.print(\"\\n[bold cyan]ğŸ“‹ ä¼šè¯åˆ—è¡¨[/bold cyan]\\n\")\n    \n    # TODO: ä»è®°å¿†ç³»ç»Ÿè¯»å–ä¼šè¯\n    sessions = [\n        {\"id\": \"sess-001\", \"created\": \"2025-02-12 10:00\", \"messages\": 15},\n        {\"id\": \"sess-002\", \"created\": \"2025-02-12 14:30\", \"messages\": 8},\n    ]\n    \n    table = Table(show_header=True)\n    table.add_column(\"ID\")\n    table.add_column(\"åˆ›å»ºæ—¶é—´\")\n    table.add_column(\"æ¶ˆæ¯æ•°\")\n    \n    for sess in sessions:\n        table.add_row(sess[\"id\"], sess[\"created\"], str(sess[\"messages\"]))\n    \n    console.print(table)\n    console.print()\n\n\n@app.command()"
},
{
"path": "cli/commands/session.py",
"start": 41,
"end": 53,
"text": "def show(\n    session_id: str = typer.Argument(..., help=\"ä¼šè¯ID\"),\n):\n    \"\"\"æ˜¾ç¤ºä¼šè¯è¯¦æƒ…\"\"\"\n    from cli.ui.console import console\n    \n    console.print(f\"\\n[bold cyan]ğŸ“„ ä¼šè¯è¯¦æƒ…: {session_id}[/bold cyan]\\n\")\n    \n    # TODO: ä»è®°å¿†ç³»ç»Ÿè¯»å–ä¼šè¯è¯¦æƒ…\n    console.print(\"[dim]åŠŸèƒ½å¼€å‘ä¸­...[/dim]\\n\")\n\n\n@app.command()"
},
{
"path": "cli/commands/session.py",
"start": 54,
"end": 66,
"text": "def delete(\n    session_id: str = typer.Argument(..., help=\"ä¼šè¯ID\"),\n):\n    \"\"\"åˆ é™¤ä¼šè¯\"\"\"\n    from cli.ui.console import console\n    \n    if typer.confirm(f\"ç¡®å®šè¦åˆ é™¤ä¼šè¯ {session_id} å—ï¼Ÿ\"):\n        # TODO: åˆ é™¤ä¼šè¯\n        console.print(f\"\\n[green]âœ“[/green] å·²åˆ é™¤ä¼šè¯ {session_id}\\n\")\n    else:\n        console.print(\"\\n[yellow]å·²å–æ¶ˆ[/yellow]\\n\")\n\n"
},
{
"path": "cli/commands/session.py",
"start": 67,
"end": 69,
"text": "def main():\n    \"\"\"ä¼šè¯ç®¡ç†å…¥å£\"\"\"\n    app()"
},
{
"path": "cli/commands/skills.py",
"start": 1,
"end": 12,
"text": "\"\"\"\nSkillç®¡ç†å‘½ä»¤\n\næŸ¥çœ‹å’Œç®¡ç†Skill\n\"\"\"\n\nimport typer\nfrom typing import Optional\nfrom rich.table import Table\nfrom rich.panel import Panel\n\n"
},
{
"path": "cli/commands/skills.py",
"start": 13,
"end": 58,
"text": "def main(\n    skill_name: Optional[str] = typer.Argument(None, help=\"Skillåç§°\"),\n    orchestrators: bool = typer.Option(False, \"--orchestrators\", \"-o\", help=\"æ˜¾ç¤ºç¼–æ’å™¨åˆ—è¡¨\"),\n):\n    \"\"\"\n    Skillå’Œç¼–æ’å™¨ç®¡ç† - æŸ¥çœ‹æ‰€æœ‰Skillå’Œç¼–æ’å™¨\n    \n    \\b\n    ç¤ºä¾‹:\n        daoyoucode skills                    # åˆ—å‡ºæ‰€æœ‰Skill\n        daoyoucode skills sisyphus           # æŸ¥çœ‹Skillè¯¦æƒ…\n        daoyoucode skills --orchestrators    # æŸ¥çœ‹æ‰€æœ‰ç¼–æ’å™¨\n    \n    \\b\n    è¯´æ˜:\n        Skillæ˜¯é…ç½®æ–‡ä»¶ï¼Œå®šä¹‰äº†ä½¿ç”¨å“ªäº›Agentã€å·¥å…·å’Œç¼–æ’å™¨ã€‚\n        ç¼–æ’å™¨è´Ÿè´£åè°ƒå¤šä¸ªAgentçš„å·¥ä½œæ–¹å¼ï¼ˆé¡ºåºã€å¹¶è¡Œã€è¾©è®ºç­‰ï¼‰ã€‚\n    \n    \\b\n    æ¨èSkill:\n        â€¢ chat-assistant - æ—¥å¸¸å¯¹è¯ï¼ˆreactç¼–æ’å™¨ï¼‰\n        â€¢ sisyphus-orchestrator - å¤æ‚ä»»åŠ¡ï¼ˆmulti_agentç¼–æ’å™¨ï¼‰\n        â€¢ oracle - æ¶æ„å’¨è¯¢ï¼ˆreactç¼–æ’å™¨ï¼Œåªè¯»ï¼‰\n        â€¢ librarian - æ–‡æ¡£æœç´¢ï¼ˆreactç¼–æ’å™¨ï¼Œåªè¯»ï¼‰\n    \n    \\b\n    ç¼–æ’å™¨ç±»å‹:\n        â€¢ simple - ç®€å•ç¼–æ’ï¼ˆ1ä¸ªAgentï¼‰\n        â€¢ react - ReActæ¨¡å¼ï¼ˆ1ä¸ªAgent + å·¥å…·ï¼‰\n        â€¢ multi_agent - å¤šAgentåä½œï¼ˆå¤šä¸ªAgentï¼‰\n        â€¢ workflow - å·¥ä½œæµç¼–æ’ï¼ˆé¢„å®šä¹‰æ­¥éª¤ï¼‰\n        â€¢ parallel - å¹¶è¡Œæ‰§è¡Œï¼ˆå¤šä»»åŠ¡åŒæ—¶ï¼‰\n    \"\"\"\n    from cli.ui.console import console\n    \n    if orchestrators:\n        # æ˜¾ç¤ºç¼–æ’å™¨åˆ—è¡¨\n        show_orchestrators()\n    elif not skill_name:\n        # åˆ—å‡ºæ‰€æœ‰Skill\n        list_all_skills()\n    else:\n        # æ˜¾ç¤ºSkillè¯¦æƒ…\n        show_skill_details(skill_name)\n\n"
},
{
"path": "cli/commands/skills.py",
"start": 59,
"end": 127,
"text": "def list_all_skills():\n    \"\"\"åˆ—å‡ºæ‰€æœ‰Skill\"\"\"\n    from cli.ui.console import console\n    \n    try:\n        from daoyoucode.agents.core.skill import get_skill_loader\n        \n        loader = get_skill_loader()\n        skills = loader.list_skills()\n        \n        if not skills:\n            console.print(\"[yellow]æœªæ‰¾åˆ°ä»»ä½•Skill[/yellow]\")\n            console.print(\"[dim]Skillé…ç½®ä½äº: skills/*/skill.yaml[/dim]\")\n            return\n        \n        console.print(\"\\n[bold cyan]ğŸ“¦ å¯ç”¨Skill ({} ä¸ª)[/bold cyan]\\n\".format(len(skills)))\n        \n        # åˆ›å»ºä¸€ä¸ªç»Ÿä¸€çš„è¡¨æ ¼\n        table = Table(\n            show_header=True,\n            border_style=\"cyan\",\n            header_style=\"bold cyan\",\n            show_lines=False,\n            padding=(0, 1)\n        )\n        table.add_column(\"#\", style=\"dim\", width=4, justify=\"right\")\n        table.add_column(\"åç§°\", style=\"cyan bold\", no_wrap=True, min_width=25)\n        table.add_column(\"ç¼–æ’å™¨\", style=\"yellow\", width=14)\n        table.add_column(\"æè¿°\", style=\"white\")\n        \n        # æŒ‰åç§°æ’åº\n        sorted_skills = sorted(skills, key=lambda x: x['name'])\n        \n        for i, skill in enumerate(sorted_skills, 1):\n            desc = skill['description']\n            # æˆªæ–­è¿‡é•¿çš„æè¿°\n            if len(desc) > 55:\n                desc = desc[:52] + '...'\n            \n            table.add_row(\n                str(i),\n                skill['name'],\n                skill['orchestrator'],\n                desc\n            )\n        \n        console.print(table)\n        \n        # æŒ‰ç¼–æ’å™¨åˆ†ç»„ç»Ÿè®¡\n        orchestrator_count = {}\n        for skill in skills:\n            orch = skill['orchestrator']\n            orchestrator_count[orch] = orchestrator_count.get(orch, 0) + 1\n        \n        console.print(f\"\\n[dim]ç¼–æ’å™¨ç»Ÿè®¡:[/dim]\")\n        for orch, count in sorted(orchestrator_count.items()):\n            console.print(f\"[dim]  â€¢ {orch}: {count} ä¸ªSkill[/dim]\")\n        \n        console.print(f\"\\n[dim]ğŸ’¡ æç¤º:[/dim]\")\n        console.print(f\"[dim]  â€¢ ä½¿ç”¨ [cyan]daoyoucode skills <name>[/cyan] æŸ¥çœ‹è¯¦æƒ…[/dim]\")\n        console.print(f\"[dim]  â€¢ ä½¿ç”¨ [cyan]daoyoucode skills --orchestrators[/cyan] æŸ¥çœ‹ç¼–æ’å™¨è¯´æ˜[/dim]\")\n        console.print(f\"[dim]  â€¢ ä½¿ç”¨ [cyan]daoyoucode chat --skill <name>[/cyan] å¯åŠ¨å¯¹è¯[/dim]\\n\")\n    \n    except Exception as e:\n        console.print(f\"[red]åŠ è½½Skillå¤±è´¥: {e}[/red]\")\n        import traceback\n        console.print(f\"[dim]{traceback.format_exc()}[/dim]\")\n\n"
},
{
"path": "cli/commands/skills.py",
"start": 128,
"end": 209,
"text": "def show_skill_details(skill_name: str):\n    \"\"\"æ˜¾ç¤ºSkillè¯¦æƒ…\"\"\"\n    from cli.ui.console import console\n    \n    try:\n        from daoyoucode.agents.core.skill import get_skill_loader\n        \n        loader = get_skill_loader()\n        skill = loader.get_skill(skill_name)\n        \n        if not skill:\n            console.print(f\"[red]Skillä¸å­˜åœ¨: {skill_name}[/red]\")\n            console.print(\"[dim]ä½¿ç”¨ [cyan]daoyoucode skills[/cyan] æŸ¥çœ‹æ‰€æœ‰å¯ç”¨Skill[/dim]\")\n            return\n        \n        # åŸºæœ¬ä¿¡æ¯\n        info = f\"\"\"\n[bold]åç§°[/bold]: {skill.name}\n[bold]ç‰ˆæœ¬[/bold]: {skill.version}\n[bold]æè¿°[/bold]: {skill.description}\n[bold]ç¼–æ’å™¨[/bold]: {skill.orchestrator}\n\"\"\"\n        \n        # Agentä¿¡æ¯\n        if skill.agents:\n            info += f\"\\n[bold]Agentåˆ—è¡¨[/bold]:\\n\"\n            for i, agent in enumerate(skill.agents, 1):\n                info += f\"  {i}. {agent}\\n\"\n        elif skill.agent:\n            info += f\"\\n[bold]Agent[/bold]: {skill.agent}\\n\"\n        \n        # å·¥å…·ä¿¡æ¯\n        if skill.tools:\n            info += f\"\\n[bold]å·¥å…·[/bold] ({len(skill.tools)}ä¸ª):\\n\"\n            for tool in skill.tools[:10]:  # åªæ˜¾ç¤ºå‰10ä¸ª\n                info += f\"  â€¢ {tool}\\n\"\n            if len(skill.tools) > 10:\n                info += f\"  ... è¿˜æœ‰ {len(skill.tools) - 10} ä¸ªå·¥å…·\\n\"\n        \n        # LLMé…ç½®\n        if skill.llm:\n            info += f\"\\n[bold]LLMé…ç½®[/bold]:\\n\"\n            info += f\"  â€¢ æ¨¡å‹: {skill.llm.get('model', 'default')}\\n\"\n            info += f\"  â€¢ æ¸©åº¦: {skill.llm.get('temperature', 0.7)}\\n\"\n        \n        # å…ƒæ•°æ®\n        if skill.metadata:\n            metadata = skill.metadata\n            \n            if metadata.get('triggers'):\n                info += f\"\\n[bold]è§¦å‘è¯[/bold]:\\n\"\n                for trigger in metadata['triggers'][:5]:\n                    info += f\"  â€¢ {trigger}\\n\"\n            \n            if metadata.get('use_when'):\n                info += f\"\\n[bold]ä½¿ç”¨åœºæ™¯[/bold]:\\n\"\n                for use_case in metadata['use_when'][:5]:\n                    info += f\"  â€¢ {use_case}\\n\"\n            \n            if metadata.get('cost'):\n                cost_color = {\n                    'LOW': 'green',\n                    'MEDIUM': 'yellow',\n                    'HIGH': 'red'\n                }.get(metadata['cost'], 'white')\n                info += f\"\\n[bold]æˆæœ¬[/bold]: [{cost_color}]{metadata['cost']}[/{cost_color}]\\n\"\n        \n        console.print(Panel(\n            info,\n            title=f\"ğŸ“¦ {skill.name}\",\n            border_style=\"cyan\",\n            padding=(1, 2)\n        ))\n        \n        # ä½¿ç”¨ç¤ºä¾‹\n        console.print(\"\\n[bold cyan]ä½¿ç”¨ç¤ºä¾‹[/bold cyan]\")\n        console.print(f\"[dim]$ daoyoucode chat --skill {skill.name} \\\"ä½ çš„é—®é¢˜\\\"[/dim]\\n\")\n    \n    except Exception as e:\n        console.print(f\"[red]åŠ è½½Skillè¯¦æƒ…å¤±è´¥: {e}[/red]\")\n\n"
},
{
"path": "cli/commands/skills.py",
"start": 210,
"end": 360,
"text": "def show_orchestrators():\n    \"\"\"æ˜¾ç¤ºç¼–æ’å™¨åˆ—è¡¨\"\"\"\n    from cli.ui.console import console\n    \n    try:\n        from daoyoucode.agents.core.orchestrator import get_orchestrator_registry\n        \n        registry = get_orchestrator_registry()\n        orchestrators = registry.list_orchestrators()\n        \n        if not orchestrators:\n            console.print(\"[yellow]æœªæ‰¾åˆ°ä»»ä½•ç¼–æ’å™¨[/yellow]\")\n            return\n        \n        console.print(\"\\n[bold cyan]ğŸ¯ å¯ç”¨ç¼–æ’å™¨[/bold cyan]\\n\")\n        \n        # ç¼–æ’å™¨æè¿°\n        orchestrator_info = {\n            'simple': {\n                'name': 'Simple',\n                'description': 'ç®€å•ç¼–æ’å™¨ï¼Œå•Agenté¡ºåºæ‰§è¡Œ',\n                'use_when': 'ç®€å•ä»»åŠ¡ï¼Œå•ä¸€Agentå³å¯å®Œæˆ',\n                'agents': '1ä¸ª',\n                'complexity': 'LOW'\n            },\n            'react': {\n                'name': 'ReAct',\n                'description': 'ReActæ¨¡å¼ï¼Œæ¨ç†-è¡ŒåŠ¨å¾ªç¯',\n                'use_when': 'éœ€è¦å·¥å…·è°ƒç”¨çš„ä»»åŠ¡',\n                'agents': '1ä¸ª',\n                'complexity': 'MEDIUM'\n            },\n            'multi_agent': {\n                'name': 'Multi-Agent',\n                'description': 'å¤šAgentåä½œï¼Œæ”¯æŒ4ç§åä½œæ¨¡å¼',\n                'use_when': 'å¤æ‚ä»»åŠ¡ï¼Œéœ€è¦å¤šä¸ªä¸“ä¸šAgent',\n                'agents': 'å¤šä¸ª',\n                'complexity': 'HIGH'\n            },\n            'workflow': {\n                'name': 'Workflow',\n                'description': 'å·¥ä½œæµç¼–æ’ï¼Œé¢„å®šä¹‰æ­¥éª¤',\n                'use_when': 'å›ºå®šæµç¨‹çš„ä»»åŠ¡',\n                'agents': 'å¤šä¸ª',\n                'complexity': 'MEDIUM'\n            },\n            'parallel': {\n                'name': 'Parallel',\n                'description': 'å¹¶è¡Œæ‰§è¡Œï¼Œå¤šä»»åŠ¡åŒæ—¶å¤„ç†',\n                'use_when': 'ç‹¬ç«‹ä»»åŠ¡å¯å¹¶è¡Œæ‰§è¡Œ',\n                'agents': 'å¤šä¸ª',\n                'complexity': 'MEDIUM'\n            },\n            'parallel_explore': {\n                'name': 'Parallel Explore',\n                'description': 'å¹¶è¡Œæ¢ç´¢ï¼Œå¤šè·¯å¾„åŒæ—¶å°è¯•',\n                'use_when': 'æ¢ç´¢æ€§ä»»åŠ¡ï¼Œéœ€è¦å¤šç§æ–¹æ¡ˆ',\n                'agents': 'å¤šä¸ª',\n                'complexity': 'HIGH'\n            },\n            'conditional': {\n                'name': 'Conditional',\n                'description': 'æ¡ä»¶ç¼–æ’ï¼Œæ ¹æ®æ¡ä»¶é€‰æ‹©è·¯å¾„',\n                'use_when': 'éœ€è¦æ¡ä»¶åˆ¤æ–­çš„ä»»åŠ¡',\n                'agents': 'å¤šä¸ª',\n                'complexity': 'MEDIUM'\n            }\n        }\n        \n        table = Table(show_header=True, border_style=\"cyan\")\n        table.add_column(\"ç¼–æ’å™¨\", style=\"cyan\")\n        table.add_column(\"åç§°\", style=\"bold\")\n        table.add_column(\"Agentæ•°\", style=\"yellow\")\n        table.add_column(\"å¤æ‚åº¦\", style=\"dim\")\n        table.add_column(\"æè¿°\")\n        \n        for orch_id in sorted(orchestrators):\n            info = orchestrator_info.get(orch_id, {\n                'name': orch_id.title(),\n                'description': 'è‡ªå®šä¹‰ç¼–æ’å™¨',\n                'agents': '?',\n                'complexity': 'UNKNOWN'\n            })\n            \n            complexity_color = {\n                'LOW': 'green',\n                'MEDIUM': 'yellow',\n                'HIGH': 'red',\n                'UNKNOWN': 'dim'\n            }.get(info['complexity'], 'white')\n            \n            table.add_row(\n                orch_id,\n                info['name'],\n                info['agents'],\n                f\"[{complexity_color}]{info['complexity']}[/{complexity_color}]\",\n                info['description']\n            )\n        \n        console.print(table)\n        \n        # è¯¦ç»†è¯´æ˜\n        console.print(\"\\n[bold cyan]ç¼–æ’å™¨è¯¦ç»†è¯´æ˜[/bold cyan]\\n\")\n        \n        for orch_id in sorted(orchestrators):\n            info = orchestrator_info.get(orch_id)\n            if info:\n                console.print(f\"[bold cyan]{info['name']}[/bold cyan] ([dim]{orch_id}[/dim])\")\n                console.print(f\"  {info['description']}\")\n                console.print(f\"  [dim]ä½¿ç”¨åœºæ™¯: {info['use_when']}[/dim]\\n\")\n        \n        # Multi-Agentçš„åä½œæ¨¡å¼\n        console.print(\"\\n[bold cyan]Multi-Agentåä½œæ¨¡å¼[/bold cyan]\\n\")\n        \n        modes_table = Table(show_header=True, border_style=\"dim\")\n        modes_table.add_column(\"æ¨¡å¼\", style=\"cyan\")\n        modes_table.add"
},
{
"path": "cli/commands/skills.py",
"start": 361,
"end": 389,
"text": "def test_skill(skill_name: str, test_input: str):\n    \"\"\"æµ‹è¯•Skill\"\"\"\n    from cli.ui.console import console\n    import asyncio\n    \n    console.print(f\"\\n[bold cyan]ğŸ§ª æµ‹è¯•Skill: {skill_name}[/bold cyan]\\n\")\n    console.print(f\"[dim]è¾“å…¥: {test_input}[/dim]\\n\")\n    \n    try:\n        from daoyoucode.agents.executor import execute_skill\n        \n        loop = asyncio.get_event_loop()\n        result = loop.run_until_complete(execute_skill(\n            skill_name=skill_name,\n            user_input=test_input,\n            session_id=\"test\",\n            context={}\n        ))\n        \n        if result.get('success'):\n            console.print(\"[green]âœ“ æµ‹è¯•æˆåŠŸ[/green]\\n\")\n            console.print(\"[bold]è¾“å‡º:[/bold]\")\n            console.print(result.get('content', ''))\n        else:\n            console.print(\"[red]âœ— æµ‹è¯•å¤±è´¥[/red]\\n\")\n            console.print(f\"[red]é”™è¯¯: {result.get('error', 'æœªçŸ¥é”™è¯¯')}[/red]\")\n    \n    except Exception as e:\n        console.print(f\"[red]æµ‹è¯•å¼‚å¸¸: {e}[/red]\")"
},
{
"path": "cli/commands/__init__.py",
"start": 1,
"end": 16,
"text": "\"\"\"\nCLI å‘½ä»¤æ¨¡å—\n\nåªä¿ç•™æœ€å®ç”¨çš„æ ¸å¿ƒå‘½ä»¤\n\"\"\"\n\n__all__ = [\n    \"chat\",\n    \"edit\", \n    \"doctor\",\n    \"config\",\n    \"session\",\n    \"agent\",\n    \"models\",\n    \"serve\",\n]"
},
{
"path": "cli/ui/console.py",
"start": 1,
"end": 21,
"text": "\"\"\"\nConsoleå·¥å…·\n\nåŸºäºRichçš„æ§åˆ¶å°è¾“å‡º\n\"\"\"\n\nfrom rich.console import Console\nfrom rich.theme import Theme\n\n# è‡ªå®šä¹‰ä¸»é¢˜\ncustom_theme = Theme({\n    \"info\": \"cyan\",\n    \"warning\": \"yellow\",\n    \"error\": \"bold red\",\n    \"success\": \"bold green\",\n})\n\n# å…¨å±€Consoleå®ä¾‹\nconsole = Console(theme=custom_theme)\n\n__all__ = [\"console\"]"
},
{
"path": "cli/ui/markdown.py",
"start": 1,
"end": 10,
"text": "\"\"\"\nMarkdownæ¸²æŸ“\n\nç”¨äºæ˜¾ç¤ºAIå“åº”\n\"\"\"\n\nfrom rich.markdown import Markdown\nfrom cli.ui.console import console\n\n"
},
{
"path": "cli/ui/markdown.py",
"start": 11,
"end": 17,
"text": "def render_markdown(text: str):\n    \"\"\"æ¸²æŸ“Markdownæ–‡æœ¬\"\"\"\n    md = Markdown(text)\n    console.print(md)\n\n\n__all__ = [\"render_markdown\"]"
},
{
"path": "cli/ui/stream.py",
"start": 1,
"end": 10,
"text": "\"\"\"\næµå¼è¾“å‡ºå·¥å…·\n\nå®ç°æ‰“å­—æœºæ•ˆæœçš„æµå¼è¾“å‡º\n\"\"\"\n\nimport time\nfrom cli.ui.console import console\n\n"
},
{
"path": "cli/ui/stream.py",
"start": 11,
"end": 24,
"text": "def stream_text(text: str, delay: float = 0.02):\n    \"\"\"\n    æµå¼è¾“å‡ºæ–‡æœ¬ï¼ˆæ‰“å­—æœºæ•ˆæœï¼‰\n    \n    Args:\n        text: è¦è¾“å‡ºçš„æ–‡æœ¬\n        delay: æ¯ä¸ªå­—ç¬¦çš„å»¶è¿Ÿï¼ˆç§’ï¼‰\n    \"\"\"\n    for char in text:\n        console.print(char, end=\"\")\n        time.sleep(delay)\n    console.print()  # æ¢è¡Œ\n\n"
},
{
"path": "cli/ui/stream.py",
"start": 25,
"end": 44,
"text": "def stream_markdown(text: str, delay: float = 0.01):\n    \"\"\"\n    æµå¼è¾“å‡ºMarkdownï¼ˆé€è¡Œï¼‰\n    \n    Args:\n        text: Markdownæ–‡æœ¬\n        delay: æ¯è¡Œçš„å»¶è¿Ÿï¼ˆç§’ï¼‰\n    \"\"\"\n    from rich.markdown import Markdown\n    \n    lines = text.split('\\n')\n    for line in lines:\n        if line.strip():\n            console.print(line)\n            time.sleep(delay)\n        else:\n            console.print()\n\n\n__all__ = [\"stream_text\", \"stream_markdown\"]"
},
{
"path": "cli/ui/__init__.py",
"start": 1,
"end": 9,
"text": "\"\"\"\nUIç»„ä»¶\n\nç®€å•çš„UIè¾…åŠ©å·¥å…·\n\"\"\"\n\n__all__ = [\"console\"]\n\nfrom cli.ui.console import console"
},
{
"path": "cli/utils/config.py",
"start": 1,
"end": 11,
"text": "\"\"\"\né…ç½®ç®¡ç†å·¥å…·\n\nè¯»å†™é…ç½®æ–‡ä»¶\n\"\"\"\n\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict\n\n"
},
{
"path": "cli/utils/config.py",
"start": 12,
"end": 14,
"text": "class Config:\n    \"\"\"é…ç½®ç®¡ç†å™¨\"\"\"\n    "
},
{
"path": "cli/utils/config.py",
"start": 15,
"end": 23,
"text": "    def __init__(self, config_file: Path = None):\n        if config_file is None:\n            config_file = Path.home() / \".daoyoucode\" / \"config.json\"\n        \n        self.config_file = config_file\n        self.config_file.parent.mkdir(parents=True, exist_ok=True)\n        \n        self._config = self._load()\n    "
},
{
"path": "cli/utils/config.py",
"start": 24,
"end": 32,
"text": "    def _load(self) -> Dict[str, Any]:\n        \"\"\"åŠ è½½é…ç½®\"\"\"\n        if self.config_file.exists():\n            try:\n                return json.loads(self.config_file.read_text(encoding='utf-8'))\n            except Exception:\n                return self._default_config()\n        return self._default_config()\n    "
},
{
"path": "cli/utils/config.py",
"start": 33,
"end": 43,
"text": "    def _default_config(self) -> Dict[str, Any]:\n        \"\"\"é»˜è®¤é…ç½®\"\"\"\n        return {\n            \"model\": \"qwen-max\",\n            \"temperature\": 0.7,\n            \"max_tokens\": 8000,\n            \"stream\": True,\n            \"auto_commit\": True,\n            \"language\": \"zh-CN\",\n        }\n    "
},
{
"path": "cli/utils/config.py",
"start": 44,
"end": 47,
"text": "    def get(self, key: str, default: Any = None) -> Any:\n        \"\"\"è·å–é…ç½®é¡¹\"\"\"\n        return self._config.get(key, default)\n    "
},
{
"path": "cli/utils/config.py",
"start": 48,
"end": 52,
"text": "    def set(self, key: str, value: Any):\n        \"\"\"è®¾ç½®é…ç½®é¡¹\"\"\"\n        self._config[key] = value\n        self._save()\n    "
},
{
"path": "cli/utils/config.py",
"start": 53,
"end": 59,
"text": "    def _save(self):\n        \"\"\"ä¿å­˜é…ç½®\"\"\"\n        self.config_file.write_text(\n            json.dumps(self._config, indent=2, ensure_ascii=False),\n            encoding='utf-8'\n        )\n    "
},
{
"path": "cli/utils/config.py",
"start": 60,
"end": 63,
"text": "    def all(self) -> Dict[str, Any]:\n        \"\"\"è·å–æ‰€æœ‰é…ç½®\"\"\"\n        return self._config.copy()\n    "
},
{
"path": "cli/utils/config.py",
"start": 64,
"end": 73,
"text": "    def reset(self):\n        \"\"\"é‡ç½®ä¸ºé»˜è®¤é…ç½®\"\"\"\n        self._config = self._default_config()\n        self._save()\n\n\n# å…¨å±€é…ç½®å®ä¾‹\n_config_instance = None\n\n"
},
{
"path": "cli/utils/config.py",
"start": 74,
"end": 82,
"text": "def get_config() -> Config:\n    \"\"\"è·å–é…ç½®å®ä¾‹\"\"\"\n    global _config_instance\n    if _config_instance is None:\n        _config_instance = Config()\n    return _config_instance\n\n\n__all__ = [\"Config\", \"get_config\"]"
},
{
"path": "cli/utils/errors.py",
"start": 1,
"end": 10,
"text": "\"\"\"\né”™è¯¯å¤„ç†å·¥å…·\n\nå‹å¥½çš„é”™è¯¯æç¤º\n\"\"\"\n\nfrom cli.ui.console import console\nfrom rich.panel import Panel\n\n"
},
{
"path": "cli/utils/errors.py",
"start": 11,
"end": 13,
"text": "class DaoyouError(Exception):\n    \"\"\"DaoyouCodeé”™è¯¯åŸºç±»\"\"\"\n    "
},
{
"path": "cli/utils/errors.py",
"start": 14,
"end": 18,
"text": "    def __init__(self, message: str, suggestions: list = None):\n        self.message = message\n        self.suggestions = suggestions or []\n        super().__init__(message)\n    "
},
{
"path": "cli/utils/errors.py",
"start": 19,
"end": 35,
"text": "    def show(self):\n        \"\"\"æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯ä¿¡æ¯\"\"\"\n        error_text = f\"[bold red]é”™è¯¯[/bold red]\\n\\n{self.message}\"\n        \n        if self.suggestions:\n            error_text += \"\\n\\n[bold yellow]å»ºè®®[/bold yellow]\\n\"\n            for i, suggestion in enumerate(self.suggestions, 1):\n                error_text += f\"\\n{i}. {suggestion}\"\n        \n        console.print(Panel(\n            error_text,\n            title=\"âŒ å‡ºé”™äº†\",\n            border_style=\"red\",\n            padding=(1, 2)\n        ))\n\n"
},
{
"path": "cli/utils/errors.py",
"start": 36,
"end": 38,
"text": "class FileNotFoundError(DaoyouError):\n    \"\"\"æ–‡ä»¶ä¸å­˜åœ¨é”™è¯¯\"\"\"\n    "
},
{
"path": "cli/utils/errors.py",
"start": 39,
"end": 49,
"text": "    def __init__(self, filepath: str):\n        super().__init__(\n            f\"æ–‡ä»¶ä¸å­˜åœ¨: {filepath}\",\n            suggestions=[\n                \"æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®\",\n                \"ä½¿ç”¨ç»å¯¹è·¯å¾„æˆ–ç›¸å¯¹è·¯å¾„\",\n                \"ç¡®è®¤æ–‡ä»¶ç¡®å®å­˜åœ¨\"\n            ]\n        )\n\n"
},
{
"path": "cli/utils/errors.py",
"start": 50,
"end": 52,
"text": "class AgentError(DaoyouError):\n    \"\"\"Agenté”™è¯¯\"\"\"\n    "
},
{
"path": "cli/utils/errors.py",
"start": 53,
"end": 63,
"text": "    def __init__(self, message: str):\n        super().__init__(\n            message,\n            suggestions=[\n                \"æ£€æŸ¥APIå¯†é’¥æ˜¯å¦é…ç½®\",\n                \"æ£€æŸ¥ç½‘ç»œè¿æ¥\",\n                \"å°è¯•åˆ‡æ¢å…¶ä»–æ¨¡å‹\"\n            ]\n        )\n\n"
},
{
"path": "cli/utils/errors.py",
"start": 64,
"end": 66,
"text": "class ConfigError(DaoyouError):\n    \"\"\"é…ç½®é”™è¯¯\"\"\"\n    "
},
{
"path": "cli/utils/errors.py",
"start": 67,
"end": 77,
"text": "    def __init__(self, message: str):\n        super().__init__(\n            message,\n            suggestions=[\n                \"è¿è¡Œ daoyoucode config show æŸ¥çœ‹é…ç½®\",\n                \"è¿è¡Œ daoyoucode config reset é‡ç½®é…ç½®\",\n                \"æ£€æŸ¥é…ç½®æ–‡ä»¶æ ¼å¼\"\n            ]\n        )\n\n"
},
{
"path": "cli/utils/errors.py",
"start": 78,
"end": 92,
"text": "def handle_error(error: Exception):\n    \"\"\"ç»Ÿä¸€é”™è¯¯å¤„ç†\"\"\"\n    if isinstance(error, DaoyouError):\n        error.show()\n    else:\n        console.print(f\"\\n[red]âŒ æœªçŸ¥é”™è¯¯: {error}[/red]\\n\")\n\n\n__all__ = [\n    \"DaoyouError\",\n    \"FileNotFoundError\",\n    \"AgentError\",\n    \"ConfigError\",\n    \"handle_error\"\n]"
},
{
"path": "cli/utils/logger.py",
"start": 1,
"end": 8,
"text": "\"\"\"\nç®€å•æ—¥å¿—å·¥å…·\n\"\"\"\n\nimport logging\nfrom pathlib import Path\n\n"
},
{
"path": "cli/utils/logger.py",
"start": 9,
"end": 26,
"text": "def setup_logger(name: str, level: str = \"INFO\") -> logging.Logger:\n    \"\"\"è®¾ç½®æ—¥å¿—\"\"\"\n    logger = logging.getLogger(name)\n    logger.setLevel(getattr(logging, level.upper()))\n    \n    # æ§åˆ¶å°å¤„ç†å™¨\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter(\n        \"[%(asctime)s] %(levelname)s: %(message)s\",\n        datefmt=\"%H:%M:%S\"\n    )\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    \n    return logger\n\n\n__all__ = [\"setup_logger\"]"
},
{
"path": "cli/utils/__init__.py",
"start": 1,
"end": 5,
"text": "\"\"\"\nå·¥å…·å‡½æ•°\n\"\"\"\n\n__all__ = [\"logger\"]"
},
{
"path": "config/agent_router_config.yaml",
"start": 1,
"end": 55,
"text": "# Agentè·¯ç”±é…ç½®\n# å®šä¹‰æ¯ä¸ªAgentçš„å…³é”®è¯ï¼Œç”¨äºæ™ºèƒ½è·¯ç”±\n\nagent_domains:\n  # æµ‹è¯•ç›¸å…³\n  test_writer:\n    - æµ‹è¯•\n    - test\n    - ç”¨ä¾‹\n    - å•å…ƒæµ‹è¯•\n    - é›†æˆæµ‹è¯•\n  \n  # æ–‡æ¡£ç›¸å…³\n  doc_writer:\n    - æ–‡æ¡£\n    - è¯´æ˜\n    - readme\n    - api\n    - æ³¨é‡Š\n    - æ–‡æ¡£åŒ–\n  \n  # è°ƒè¯•ç›¸å…³\n  debugger:\n    - è°ƒè¯•\n    - bug\n    - é”™è¯¯\n    - ä¿®å¤\n    - é—®é¢˜\n    - å¼‚å¸¸\n  \n  # ä»£ç å®¡æŸ¥\n  code_reviewer:\n    - å®¡æŸ¥\n    - æ£€æŸ¥\n    - ä¼˜åŒ–\n    - æ”¹è¿›\n    - é‡æ„\n    - review\n  \n  # ä»£ç ç¼–å†™\n  code_writer:\n    - ç¼–å†™\n    - ç”Ÿæˆ\n    - åˆ›å»º\n    - å®ç°\n    - å†™\n    - hello\n    - world\n  \n  # ä»£ç åˆ†æ\n  code_analyzer:\n    - åˆ†æ\n    - ç»“æ„\n    - æŸ¥çœ‹\n    - ç†è§£"
},
{
"path": "config/agent_router_config.yaml",
"start": 56,
"end": 72,
"text": "    - æ¶æ„\n  \n  # ç¤ºä¾‹ï¼šæ·»åŠ æ–°çš„Agent\n  # data_scientist:\n  #   - æ•°æ®\n  #   - åˆ†æ\n  #   - ç»Ÿè®¡\n  #   - æœºå™¨å­¦ä¹ \n  #   - æ¨¡å‹\n  #   - è®­ç»ƒ\n  \n  # security_expert:\n  #   - å®‰å…¨\n  #   - æ¼æ´\n  #   - åŠ å¯†\n  #   - æƒé™\n  #   - è®¤è¯"
},
{
"path": "config/llm_config.yaml",
"start": 1,
"end": 55,
"text": "# LLM API é…ç½®\n# è¯·å¡«å…¥ä½ çš„APIå¯†é’¥\n\nproviders:\n  # é€šä¹‰åƒé—® (é˜¿é‡Œäº‘)\n  qwen:\n    # æ”¯æŒå•ä¸ªæˆ–å¤šä¸ªAPI Keyï¼ˆè½®è¯¢ä½¿ç”¨ï¼‰\n    # å•ä¸ªkey: api_key: \"sk-xxx\"\n    # å¤šä¸ªkey: api_keys: [\"sk-xxx\", \"sk-yyy\", \"sk-zzz\"]\n    api_key: [\"sk-d2971f2015574377bdf97046b1a03b87\",\"sk-4b232539c58d497ebe6212017060cd2e\"]  # æ›¿æ¢ä¸ºä½ çš„APIå¯†é’¥\n    # api_keys:  # å¦‚æœæœ‰å¤šä¸ªkeyï¼Œå–æ¶ˆæ³¨é‡Šå¹¶å¡«å…¥\n    #   - \"sk-key1-here\"\n    #   - \"sk-key2-here\"\n    #   - \"sk-key3-here\"\n    base_url: \"https://dashscope.aliyuncs.com/compatible-mode/v1\"\n    models:\n      - qwen-max\n      - qwen-plus\n      - qwen-turbo\n      - qwen-coder-plus\n    enabled: true\n  \n  # DeepSeek\n  deepseek:\n    api_key: \"your-deepseek-api-key-here\"  # æ›¿æ¢ä¸ºä½ çš„APIå¯†é’¥\n    base_url: \"https://api.deepseek.com/v1\"\n    models:\n      - deepseek-chat\n      - deepseek-coder\n    enabled: false\n  \n  # OpenAI\n  openai:\n    api_key: \"your-openai-api-key-here\"  # æ›¿æ¢ä¸ºä½ çš„APIå¯†é’¥\n    base_url: \"https://api.openai.com/v1\"\n    models:\n      - gpt-4\n      - gpt-3.5-turbo\n    enabled: false\n  \n  # Claude (Anthropic)\n  anthropic:\n    api_key: \"your-anthropic-api-key-here\"  # æ›¿æ¢ä¸ºä½ çš„APIå¯†é’¥\n    base_url: \"https://api.anthropic.com/v1\"\n    models:\n      - claude-3-opus\n      - claude-3-sonnet\n    enabled: false\n\n# é»˜è®¤é…ç½®\ndefault:\n  model: \"qwen-max\"  # ğŸ†• åˆ‡æ¢åˆ° qwen-maxï¼ˆæ›´å¼ºçš„ Function Calling èƒ½åŠ›ï¼‰\n  temperature: 0.7\n  max_tokens: 4000\n  timeout: 1800  # 30 åˆ†é’Ÿ"
},
{
"path": "config/memory_load_strategies.example.yaml",
"start": 1,
"end": 55,
"text": "# MemoryåŠ è½½ç­–ç•¥é…ç½®ç¤ºä¾‹\n#\n# è¿™ä¸ªæ–‡ä»¶å®šä¹‰äº†ä¸åŒåœºæ™¯ä¸‹çš„è®°å¿†åŠ è½½ç­–ç•¥\n# å¯ä»¥æ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´å„ä¸ªç­–ç•¥çš„å‚æ•°\n\nstrategies:\n  # æ–°å¯¹è¯ï¼šä¸åŠ è½½ä»»ä½•è®°å¿†\n  new_conversation:\n    load_history: false\n    load_summary: false\n    load_profile: false\n    cost: 0\n    description: \"æ–°å¯¹è¯ï¼Œä¸åŠ è½½ä»»ä½•è®°å¿†\"\n  \n  # ç®€å•è¿½é—®ï¼šåŠ è½½æœ€è¿‘2è½®\n  simple_followup:\n    load_history: true\n    history_limit: 2\n    load_summary: false\n    load_profile: false\n    cost: 1\n    description: \"ç®€å•è¿½é—®ï¼ŒåŠ è½½æœ€è¿‘2è½®å¯¹è¯\"\n  \n  # ä¸­ç­‰è¿½é—®ï¼šåŠ è½½æœ€è¿‘3è½®\n  medium_followup:\n    load_history: true\n    history_limit: 3\n    load_summary: false\n    load_profile: false\n    cost: 2\n    description: \"ä¸­ç­‰è¿½é—®ï¼ŒåŠ è½½æœ€è¿‘3è½®å¯¹è¯\"\n  \n  # å¤æ‚è¿½é—®ï¼šåŠ è½½æ‘˜è¦+æœ€è¿‘2è½®\n  complex_followup:\n    load_history: true\n    history_limit: 2\n    load_summary: true  # ä½¿ç”¨æ‘˜è¦ä»£æ›¿æ—©æœŸå¯¹è¯\n    load_profile: false\n    cost: 3\n    description: \"å¤æ‚è¿½é—®ï¼ŒåŠ è½½æ‘˜è¦+æœ€è¿‘2è½®\"\n  \n  # è·¨sessionï¼šä½¿ç”¨å‘é‡æ£€ç´¢\n  cross_session:\n    load_history: true\n    history_limit: 3\n    load_summary: true\n    use_vector_search: true\n    load_profile: true\n    cost: 5\n    description: \"è·¨sessionï¼Œä½¿ç”¨å‘é‡æ£€ç´¢+ç”¨æˆ·ç”»åƒ\"\n  \n  # è‡ªå®šä¹‰ç­–ç•¥ç¤ºä¾‹ï¼šé«˜æ€§èƒ½æ¨¡å¼ï¼ˆæœ€å°åŒ–åŠ è½½ï¼‰\n  performance_mode:\n    load_history: true\n    history_limit: 1  # åªåŠ è½½æœ€è¿‘1è½®"
},
{
"path": "config/memory_load_strategies.example.yaml",
"start": 56,
"end": 86,
"text": "    load_summary: false\n    load_profile: false\n    cost: 0.5\n    description: \"é«˜æ€§èƒ½æ¨¡å¼ï¼Œæœ€å°åŒ–è®°å¿†åŠ è½½\"\n  \n  # è‡ªå®šä¹‰ç­–ç•¥ç¤ºä¾‹ï¼šå®Œæ•´ä¸Šä¸‹æ–‡æ¨¡å¼ï¼ˆæœ€å¤§åŒ–åŠ è½½ï¼‰\n  full_context_mode:\n    load_history: true\n    history_limit: 10  # åŠ è½½æœ€è¿‘10è½®\n    load_summary: true\n    load_profile: true\n    use_vector_search: true\n    cost: 10\n    description: \"å®Œæ•´ä¸Šä¸‹æ–‡æ¨¡å¼ï¼Œæœ€å¤§åŒ–è®°å¿†åŠ è½½\"\n\n# é…ç½®è¯´æ˜ï¼š\n#\n# load_history: æ˜¯å¦åŠ è½½å¯¹è¯å†å²\n# history_limit: åŠ è½½å¤šå°‘è½®å†å²ï¼ˆå¦‚æœload_history=trueï¼‰\n# load_summary: æ˜¯å¦åŠ è½½å¯¹è¯æ‘˜è¦\n# load_profile: æ˜¯å¦åŠ è½½ç”¨æˆ·ç”»åƒ\n# use_vector_search: æ˜¯å¦ä½¿ç”¨å‘é‡æ£€ç´¢ï¼ˆè·¨sessionåœºæ™¯ï¼‰\n# cost: ç­–ç•¥æˆæœ¬ï¼ˆç”¨äºç»Ÿè®¡å’Œä¼˜åŒ–ï¼‰\n# description: ç­–ç•¥æè¿°ï¼ˆå¯é€‰ï¼‰\n#\n# è°ƒä¼˜å»ºè®®ï¼š\n# 1. history_limitè¶Šå¤§ï¼Œä¸Šä¸‹æ–‡è¶Šå®Œæ•´ï¼Œä½†tokenæ¶ˆè€—è¶Šå¤š\n# 2. load_summaryå¯ä»¥ç”¨è¾ƒå°‘tokenæä¾›æ—©æœŸå¯¹è¯ä¿¡æ¯\n# 3. load_profileé€‚åˆéœ€è¦ä¸ªæ€§åŒ–çš„åœºæ™¯\n# 4. use_vector_searché€‚åˆè·¨sessionæ£€ç´¢\n# 5. æ ¹æ®å®é™…åœºæ™¯è°ƒæ•´costå€¼ï¼Œç”¨äºç›‘æ§å’Œä¼˜åŒ–"
},
{
"path": "daoyoucode/__init__.py",
"start": 1,
"end": 22,
"text": "\"\"\"daoyoucode - æ–°ä¸€ä»£AIç¼–ç¨‹åŠ©æ‰‹\"\"\"\n\n__version__ = \"0.1.0\"\n\n# å¯¼å‡ºAgentsç³»ç»Ÿ\nfrom .agents import (\n    execute_skill,\n    list_skills,\n    get_skill_info,\n    register_agent,\n    register_orchestrator,\n    register_middleware,\n)\n\n__all__ = [\n    'execute_skill',\n    'list_skills',\n    'get_skill_info',\n    'register_agent',\n    'register_orchestrator',\n    'register_middleware',\n]"
},
{
"path": "daoyoucode/agents/executor.py",
"start": 1,
"end": 305,
"text": "\"\"\"\nSkillæ‰§è¡Œå™¨\n\nç»Ÿä¸€çš„Skillæ‰§è¡Œå…¥å£ï¼Œé›†æˆHookç³»ç»Ÿã€å¤±è´¥æ¢å¤å’Œè¶…æ—¶æ¢å¤\n\"\"\"\n\nfrom typing import Dict, Any, Optional, Callable\nimport logging\n\nfrom .core.skill import get_skill_loader\nfrom .core.orchestrator import get_orchestrator\nfrom .core.hook import get_hook_manager, HookContext\nfrom .core.recovery import RecoveryManager, RecoveryConfig\nfrom .core.task import get_task_manager, TaskStatus\nfrom .core.timeout_handler import execute_with_timeout_handling, should_enable_timeout_recovery\n\nlogger = logging.getLogger(__name__)\n\n\nasync def execute_skill(\n    skill_name: str,\n    user_input: str,\n    session_id: Optional[str] = None,\n    context: Optional[Dict[str, Any]] = None,\n    recovery_config: Optional[RecoveryConfig] = None,\n    validator: Optional[Callable[[Any], bool]] = None,\n    analyzer: Optional[Callable[[Any, Optional[Exception]], str]] = None,\n    enable_timeout_recovery: Optional[bool] = None\n) -> Dict[str, Any]:\n    \"\"\"\n    æ‰§è¡ŒSkillï¼ˆé›†æˆHookç³»ç»Ÿã€å¤±è´¥æ¢å¤å’Œè¶…æ—¶æ¢å¤ï¼‰\n    \n    Args:\n        skill_name: Skillåç§°\n        user_input: ç”¨æˆ·è¾“å…¥\n        session_id: ä¼šè¯ID\n        context: é¢å¤–ä¸Šä¸‹æ–‡\n        recovery_config: æ¢å¤é…ç½®ï¼ˆå¯é€‰ï¼‰\n        validator: ç»“æœéªŒè¯å‡½æ•°ï¼ˆå¯é€‰ï¼‰\n        analyzer: é”™è¯¯åˆ†æå‡½æ•°ï¼ˆå¯é€‰ï¼‰\n        enable_timeout_recovery: æ˜¯å¦å¯ç”¨è¶…æ—¶æ¢å¤ï¼ˆNone=è‡ªåŠ¨åˆ¤æ–­ï¼‰\n    \n    Returns:\n        æ‰§è¡Œç»“æœ\n    \"\"\"\n    if context is None:\n        context = {}\n    \n    if session_id:\n        context['session_id'] = session_id\n    \n    # åˆ¤æ–­æ˜¯å¦å¯ç”¨è¶…æ—¶æ¢å¤\n    if enable_timeout_recovery is None:\n        enable_timeout_recovery = should_enable_timeout_recovery(context)\n    \n    # å¦‚æœå¯ç”¨è¶…æ—¶æ¢å¤ï¼Œä½¿ç”¨ timeout_handler\n    if enable_timeout_recovery:\n        logger.info(\"âœ… å¯ç”¨è¶…æ—¶æ¢å¤æœºåˆ¶\")\n        \n        # å¦‚æœåŒæ—¶å¯ç”¨äº†å¤±è´¥æ¢å¤ï¼Œéœ€è¦åµŒå¥—å¤„ç†\n        if recovery_config or validator or analyzer:\n            recovery_manager = RecoveryManager(recovery_config or RecoveryConfig())\n            \n            async def execute_with_recovery():\n                return await recovery_manager.execute_with_recovery(\n                    _execute_skill_internal,\n                    skill_name=skill_name,\n                    user_input=user_input,\n                    context=context,\n                    validator=validator,\n                    analyzer=analyzer\n                )\n            \n            return await execute_with_timeout_handling(\n                execute_with_recovery,\n                skill_name,\n                user_input,\n                context,\n                enable_recovery=True\n            )\n        else:\n            # åªå¯ç”¨è¶…æ—¶æ¢å¤\n            return await execute_with_timeout_handling(\n                _execute_skill_internal,\n                skill_name,\n                user_input,\n                context,\n                enable_recovery=True\n            )\n    \n    # ä¸å¯ç”¨è¶…æ—¶æ¢å¤\n    # å¦‚æœå¯ç”¨äº†å¤±è´¥æ¢å¤ï¼Œä½¿ç”¨RecoveryManager\n    if recovery_config or validator or analyzer:\n        recovery_manager = RecoveryManager(recovery_config or RecoveryConfig())\n        return await recovery_manager.execute_with_recovery(\n            _execute_skill_internal,\n            skill_name=skill_name,\n            user_input=user_input,\n            context=context,\n            validator=validator,\n            analyzer=analyzer\n        )\n    \n    # å¦åˆ™ç›´æ¥æ‰§è¡Œ\n    return await _execute_skill_internal(skill_name, user_input, context)\n\n\nasync def _execute_skill_internal(\n    skill_name: str,\n    user_input: str,\n    context: Dict[str, Any]\n) -> Dict[str, Any]:\n    \"\"\"\n    å†…éƒ¨æ‰§è¡Œå‡½æ•°ï¼ˆè¢«RecoveryManagerè°ƒç”¨ï¼‰\n    \n    Args:\n        skill_name: Skillåç§°\n        user_input: ç”¨æˆ·è¾“å…¥\n        context: ä¸Šä¸‹æ–‡\n    \n    Returns:\n        æ‰§è¡Œç»“æœ\n    \"\"\"\n    session_id = context.get('session_id')\n    \n    # ç»Ÿä¸€è®¾ç½®å·¥å…·ä¸Šä¸‹æ–‡ï¼šä¼˜å…ˆç”¨å®Œæ•´ ToolContextï¼Œé¿å…è¦†ç›– CLI ä¼ å…¥çš„ subtree_only/cwdï¼ˆè§ä¼˜åŒ–å»ºè®® 3.1ï¼‰\n    from pathlib import Path\n    from .tools.registry import get_tool_registry\n    from .tools.base import ToolContext\n\n    registry = get_tool_registry()\n    working_dir = context.get('working_directory') or context.get('repo')\n    if working_dir:\n        repo_path = Path(working_dir)\n        if not repo_path.is_absolute():\n            repo_path = repo_pat"
},
{
"path": "daoyoucode/agents/executor.py",
"start": 306,
"end": 311,
"text": "def list_skills() -> list:\n    \"\"\"åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„Skill\"\"\"\n    skill_loader = get_skill_loader()\n    return skill_loader.list_skills()\n\n"
},
{
"path": "daoyoucode/agents/executor.py",
"start": 312,
"end": 330,
"text": "def get_skill_info(skill_name: str) -> Optional[Dict[str, Any]]:\n    \"\"\"è·å–Skillè¯¦ç»†ä¿¡æ¯\"\"\"\n    skill_loader = get_skill_loader()\n    skill = skill_loader.get_skill(skill_name)\n    \n    if not skill:\n        return None\n    \n    return {\n        'name': skill.name,\n        'version': skill.version,\n        'description': skill.description,\n        'orchestrator': skill.orchestrator,\n        'agent': skill.agent,\n        'agents': skill.agents,\n        'middleware': skill.middleware\n    }\n\n"
},
{
"path": "daoyoucode/agents/executor.py",
"start": 331,
"end": 349,
"text": "def get_task_info(task_id: str) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    è·å–ä»»åŠ¡ä¿¡æ¯\n    \n    Args:\n        task_id: ä»»åŠ¡ID\n    \n    Returns:\n        ä»»åŠ¡ä¿¡æ¯å­—å…¸ï¼Œå¦‚æœä»»åŠ¡ä¸å­˜åœ¨è¿”å›None\n    \"\"\"\n    task_manager = get_task_manager()\n    task = task_manager.get_task(task_id)\n    \n    if not task:\n        return None\n    \n    return task.to_dict()\n\n"
},
{
"path": "daoyoucode/agents/executor.py",
"start": 350,
"end": 363,
"text": "def get_task_tree(task_id: str) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    è·å–ä»»åŠ¡æ ‘ï¼ˆåŒ…å«æ‰€æœ‰å­ä»»åŠ¡ï¼‰\n    \n    Args:\n        task_id: æ ¹ä»»åŠ¡ID\n    \n    Returns:\n        ä»»åŠ¡æ ‘å­—å…¸ï¼Œå¦‚æœä»»åŠ¡ä¸å­˜åœ¨è¿”å›None\n    \"\"\"\n    task_manager = get_task_manager()\n    return task_manager.get_task_tree(task_id)\n\n"
},
{
"path": "daoyoucode/agents/executor.py",
"start": 364,
"end": 374,
"text": "def get_task_stats() -> Dict[str, Any]:\n    \"\"\"\n    è·å–ä»»åŠ¡ç»Ÿè®¡ä¿¡æ¯\n    \n    Returns:\n        ç»Ÿè®¡ä¿¡æ¯å­—å…¸\n    \"\"\"\n    task_manager = get_task_manager()\n    return task_manager.get_stats()\n\n"
},
{
"path": "daoyoucode/agents/executor.py",
"start": 375,
"end": 413,
"text": "def _truncate_description(text: str, max_length: int = 500) -> str:\n    \"\"\"\n    æ™ºèƒ½æˆªæ–­æè¿°æ–‡æœ¬\n    \n    ç­–ç•¥ï¼š\n    - å¦‚æœæ–‡æœ¬é•¿åº¦ <= max_lengthï¼Œç›´æ¥è¿”å›\n    - å¦‚æœæ–‡æœ¬é•¿åº¦ > max_lengthï¼Œä¿ç•™å¼€å¤´å’Œç»“å°¾ï¼Œä¸­é—´ç”¨...è¿æ¥\n    \n    Args:\n        text: åŸå§‹æ–‡æœ¬\n        max_length: æœ€å¤§é•¿åº¦\n    \n    Returns:\n        æˆªæ–­åçš„æ–‡æœ¬\n    \n    Examples:\n        >>> _truncate_description(\"çŸ­æ–‡æœ¬\", 500)\n        \"çŸ­æ–‡æœ¬\"\n        \n        >>> _truncate_description(\"å¾ˆé•¿çš„æ–‡æœ¬\" * 100, 100)\n        \"å¾ˆé•¿çš„æ–‡æœ¬å¾ˆé•¿çš„æ–‡æœ¬å¾ˆé•¿çš„æ–‡æœ¬å¾ˆé•¿...çš„æ–‡æœ¬å¾ˆé•¿çš„æ–‡æœ¬å¾ˆé•¿çš„æ–‡æœ¬å¾ˆé•¿çš„æ–‡æœ¬\"\n    \"\"\"\n    if len(text) <= max_length:\n        return text\n    \n    # è®¡ç®—å¼€å¤´å’Œç»“å°¾çš„é•¿åº¦\n    # å¼€å¤´å 60%ï¼Œç»“å°¾å 40%ï¼Œä¸­é—´3ä¸ªå­—ç¬¦ç”¨äº...\n    separator = \"...\"\n    separator_len = len(separator)\n    available_len = max_length - separator_len\n    \n    head_len = int(available_len * 0.6)\n    tail_len = available_len - head_len\n    \n    # æˆªæ–­\n    head = text[:head_len]\n    tail = text[-tail_len:] if tail_len > 0 else \"\"\n    \n    return f\"{head}{separator}{tail}\""
},
{
"path": "daoyoucode/agents/init.py",
"start": 1,
"end": 13,
"text": "\"\"\"\nAgentç³»ç»Ÿç»Ÿä¸€åˆå§‹åŒ–\n\næä¾›å¹‚ç­‰çš„åˆå§‹åŒ–å‡½æ•°ï¼Œç¡®ä¿å·¥å…·ã€Agentã€ç¼–æ’å™¨éƒ½æ­£ç¡®æ³¨å†Œ\n\"\"\"\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n_initialized = False\n\n"
},
{
"path": "daoyoucode/agents/init.py",
"start": 14,
"end": 60,
"text": "def initialize_agent_system():\n    \"\"\"\n    åˆå§‹åŒ–Agentç³»ç»Ÿï¼ˆå¹‚ç­‰æ“ä½œï¼‰\n    \n    è¿™ä¸ªå‡½æ•°å¯ä»¥è¢«å¤šæ¬¡è°ƒç”¨ï¼Œä¸ä¼šé‡å¤åˆå§‹åŒ–\n    \n    Returns:\n        å·¥å…·æ³¨å†Œè¡¨å®ä¾‹\n    \"\"\"\n    global _initialized\n    \n    if _initialized:\n        logger.debug(\"Agentç³»ç»Ÿå·²åˆå§‹åŒ–ï¼Œè·³è¿‡\")\n        from .tools import get_tool_registry\n        return get_tool_registry()\n    \n    logger.info(\"å¼€å§‹åˆå§‹åŒ–Agentç³»ç»Ÿ...\")\n    \n    # 1. åˆå§‹åŒ–å·¥å…·æ³¨å†Œè¡¨\n    from .tools import get_tool_registry\n    tool_registry = get_tool_registry()\n    logger.info(f\"âœ“ å·¥å…·æ³¨å†Œè¡¨å·²åˆå§‹åŒ–: {len(tool_registry.list_tools())} ä¸ªå·¥å…·\")\n    \n    # 2. æ³¨å†Œå†…ç½®Agent\n    from .builtin import register_builtin_agents\n    register_builtin_agents()\n    logger.info(\"âœ“ å†…ç½®Agentå·²æ³¨å†Œ\")\n    \n    # 3. æ³¨å†Œå†…ç½®ç¼–æ’å™¨ï¼ˆå·²åœ¨__init__.pyä¸­å®Œæˆï¼‰\n    from .core.orchestrator import get_orchestrator_registry\n    orchestrator_registry = get_orchestrator_registry()\n    logger.info(f\"âœ“ ç¼–æ’å™¨å·²æ³¨å†Œ: {len(orchestrator_registry.list_orchestrators())} ä¸ª\")\n    \n    # 4. æ³¨å†Œå†…ç½®ä¸­é—´ä»¶\n    from .core.middleware import register_middleware\n    from .middleware.context import ContextMiddleware\n    from .middleware.followup import FollowupMiddleware\n    \n    register_middleware('context_management', ContextMiddleware)\n    register_middleware('memory_integration', ContextMiddleware)  # æš‚æ—¶ä½¿ç”¨ContextMiddleware\n    register_middleware('followup', FollowupMiddleware)\n    logger.info(\"âœ“ ä¸­é—´ä»¶å·²æ³¨å†Œ\")\n    \n    _initialized = True\n    logger.info(\"Agentç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ\")\n    \n    return tool_registry"
},
{
"path": "daoyoucode/agents/__init__.py",
"start": 1,
"end": 66,
"text": "\"\"\"\nAgentsç³»ç»Ÿ - ç»Ÿä¸€çš„Agentæ‰§è¡Œæ¡†æ¶\n\næ¶æ„:\n    Skill (é…ç½®) â†’ Orchestrator (ç¼–æ’) â†’ Agent (æ‰§è¡Œ) â†’ LLM (åŸºç¡€è®¾æ–½)\n\næ ¸å¿ƒç»„ä»¶:\n    - core: æ ¸å¿ƒåŸºç±»å’Œæ³¨å†Œè¡¨\n    - orchestrators: ç¼–æ’å™¨å®ç°\n    - middleware: ä¸­é—´ä»¶å®ç°\n    - builtin: å†…ç½®Agent\n    - llm: LLMåŸºç¡€è®¾æ–½\n    - hooks: Hookç³»ç»Ÿ\n\"\"\"\n\n# å¯¼å…¥å¹¶æ³¨å†Œå†…ç½®ç¼–æ’å™¨\nfrom . import orchestrators\n\n# åˆå§‹åŒ–å·¥å…·æ³¨å†Œè¡¨ï¼ˆç¡®ä¿å·¥å…·åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶å°±å¯ç”¨ï¼‰\nfrom .tools import get_tool_registry\n_tool_registry = get_tool_registry()  # è§¦å‘å·¥å…·æ³¨å†Œ\n\nfrom .init import initialize_agent_system\nfrom .executor import execute_skill, list_skills, get_skill_info\nfrom .core.agent import BaseAgent, AgentConfig, register_agent, get_agent_registry\nfrom .core.orchestrator import BaseOrchestrator, register_orchestrator, get_orchestrator\nfrom .core.middleware import BaseMiddleware, register_middleware, get_middleware\nfrom .core.skill import SkillConfig, SkillLoader\nfrom .core.hook import BaseHook, HookContext, register_hook, unregister_hook, get_hook_manager\n\n__all__ = [\n    # åˆå§‹åŒ–\n    'initialize_agent_system',\n    \n    # æ‰§è¡Œå™¨\n    'execute_skill',\n    'list_skills',\n    'get_skill_info',\n    \n    # Agent\n    'BaseAgent',\n    'AgentConfig',\n    'register_agent',\n    'get_agent_registry',\n    \n    # Orchestrator\n    'BaseOrchestrator',\n    'register_orchestrator',\n    'get_orchestrator',\n    \n    # Middleware\n    'BaseMiddleware',\n    'register_middleware',\n    'get_middleware',\n    \n    # Skill\n    'SkillConfig',\n    'SkillLoader',\n    \n    # Hook\n    'BaseHook',\n    'HookContext',\n    'register_hook',\n    'unregister_hook',\n    'get_hook_manager',\n]"
},
{
"path": "daoyoucode/agents/builtin/code_analyzer.py",
"start": 1,
"end": 10,
"text": "\"\"\"\nä»£ç åˆ†æAgent - æ¶æ„é¡¾é—®\n\nå€Ÿé‰´oh-my-opencodeçš„Oracleæ™ºèƒ½ä½“\nPrompté…ç½®åœ¨ skills/code-analysis/prompts/oracle.md\n\"\"\"\n\nfrom ..core.agent import BaseAgent, AgentConfig\n\n"
},
{
"path": "daoyoucode/agents/builtin/code_analyzer.py",
"start": 11,
"end": 13,
"text": "class CodeAnalyzerAgent(BaseAgent):\n    \"\"\"ä»£ç åˆ†æAgentï¼ˆæ¶æ„é¡¾é—®ï¼‰\"\"\"\n    "
},
{
"path": "daoyoucode/agents/builtin/code_analyzer.py",
"start": 14,
"end": 22,
"text": "    def __init__(self):\n        config = AgentConfig(\n            name=\"code_analyzer\",\n            description=\"ä»£ç æ¶æ„åˆ†æä¸“å®¶ï¼Œæä¾›é«˜IQåˆ†æå’Œå»ºè®®ï¼ˆå€Ÿé‰´oh-my-opencode Oracleï¼‰\",\n            model=\"qwen-max\",\n            temperature=0.1,\n            system_prompt=\"\"  # Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n        )\n        super().__init__(config)"
},
{
"path": "daoyoucode/agents/builtin/code_explorer.py",
"start": 1,
"end": 10,
"text": "\"\"\"\nä»£ç æ¢ç´¢Agent\n\nå€Ÿé‰´oh-my-opencodeçš„Exploreæ™ºèƒ½ä½“\nPrompté…ç½®åœ¨ skills/code-exploration/prompts/explore.md\n\"\"\"\n\nfrom ..core.agent import BaseAgent, AgentConfig\n\n"
},
{
"path": "daoyoucode/agents/builtin/code_explorer.py",
"start": 11,
"end": 13,
"text": "class CodeExplorerAgent(BaseAgent):\n    \"\"\"ä»£ç æ¢ç´¢Agent\"\"\"\n    "
},
{
"path": "daoyoucode/agents/builtin/code_explorer.py",
"start": 14,
"end": 22,
"text": "    def __init__(self):\n        config = AgentConfig(\n            name=\"code_explorer\",\n            description=\"ä»£ç åº“æœç´¢ä¸“å®¶ï¼Œå¿«é€ŸæŸ¥æ‰¾ä»£ç ä½ç½®\",\n            model=\"qwen-coder-plus\",\n            temperature=0.1,\n            system_prompt=\"\"  # Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n        )\n        super().__init__(config)"
},
{
"path": "daoyoucode/agents/builtin/librarian.py",
"start": 1,
"end": 12,
"text": "\"\"\"\nLibrarian - æ–‡æ¡£å’Œä»£ç æœç´¢Agent\n\nä¸“æ³¨äºä¿¡æ¯æ£€ç´¢å’ŒçŸ¥è¯†æœç´¢\nå€Ÿé‰´oh-my-opencodeçš„è®¾è®¡\n\nPrompté…ç½®åœ¨ skills/librarian/prompts/librarian.md\n\"\"\"\n\nfrom ..core.agent import BaseAgent, AgentConfig\n\n"
},
{
"path": "daoyoucode/agents/builtin/librarian.py",
"start": 13,
"end": 37,
"text": "class LibrarianAgent(BaseAgent):\n    \"\"\"\n    Librarian - æ–‡æ¡£å’Œä»£ç æœç´¢Agent\n    \n    èŒè´£ï¼š\n    - æœç´¢é¡¹ç›®æ–‡æ¡£\n    - æœç´¢ä»£ç å®ç°\n    - æŸ¥æ‰¾ç›¸å…³ç¤ºä¾‹\n    - æä¾›å‚è€ƒèµ„æ–™\n    \n    ç‰¹ç‚¹ï¼š\n    - åªè¯»æƒé™\n    - ä¸“æ³¨äºæœç´¢å’Œæ£€ç´¢\n    - å¿«é€Ÿå®šä½ä¿¡æ¯\n    - å¯ä»¥é›†æˆå¤–éƒ¨æœç´¢ï¼ˆwebsearch MCPï¼‰\n    \n    ä½¿ç”¨åœºæ™¯ï¼š\n    - æŸ¥æ‰¾æ–‡æ¡£\n    - æœç´¢ä»£ç ç¤ºä¾‹\n    - äº†è§£æœ€ä½³å®è·µ\n    - å­¦ä¹ æ–°æŠ€æœ¯\n    \n    Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/builtin/librarian.py",
"start": 38,
"end": 46,
"text": "    def __init__(self):\n        config = AgentConfig(\n            name=\"librarian\",\n            description=\"æ–‡æ¡£å’Œä»£ç æœç´¢Agentï¼Œä¸“æ³¨äºä¿¡æ¯æ£€ç´¢\",\n            model=\"qwen-max\",\n            temperature=0.1,\n            system_prompt=\"\"  # Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n        )\n        super().__init__(config)"
},
{
"path": "daoyoucode/agents/builtin/main_agent.py",
"start": 1,
"end": 10,
"text": "\"\"\"\nMainAgent - ä¸»å¯¹è¯Agent\n\né€šç”¨çš„å¯¹è¯Agentï¼Œæ”¯æŒä»£ç ç†è§£ã€ç¼–å†™å’Œé¡¹ç›®åˆ†æ\nPrompté…ç½®åœ¨ skills/chat-assistant/prompts/chat_assistant.md\n\"\"\"\n\nfrom ..core.agent import BaseAgent, AgentConfig\n\n"
},
{
"path": "daoyoucode/agents/builtin/main_agent.py",
"start": 11,
"end": 24,
"text": "class MainAgent(BaseAgent):\n    \"\"\"\n    ä¸»å¯¹è¯Agent\n    \n    è¿™æ˜¯ä¸€ä¸ªé€šç”¨çš„å¯¹è¯Agentï¼Œå¯ä»¥ï¼š\n    - ç†è§£é¡¹ç›®ä»£ç \n    - å›ç­”ç¼–ç¨‹é—®é¢˜\n    - ç¼–å†™å’Œä¿®æ”¹ä»£ç \n    - åˆ†æé¡¹ç›®ç»“æ„\n    - è°ƒç”¨å„ç§å·¥å…·\n    \n    Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/builtin/main_agent.py",
"start": 25,
"end": 33,
"text": "    def __init__(self):\n        config = AgentConfig(\n            name=\"MainAgent\",\n            description=\"ä¸»å¯¹è¯Agentï¼Œæ”¯æŒä»£ç ç†è§£ã€ç¼–å†™å’Œé¡¹ç›®åˆ†æ\",\n            model=\"qwen-max\",\n            temperature=0.7,\n            system_prompt=\"\"  # Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n        )\n        super().__init__(config)"
},
{
"path": "daoyoucode/agents/builtin/oracle.py",
"start": 1,
"end": 12,
"text": "\"\"\"\nOracle - é«˜IQå’¨è¯¢Agent\n\nåªè¯»åˆ†æï¼Œæä¾›æ¶æ„å»ºè®®å’ŒæŠ€æœ¯å’¨è¯¢\nå€Ÿé‰´oh-my-opencodeçš„è®¾è®¡\n\nPrompté…ç½®åœ¨ skills/oracle/prompts/oracle.md\n\"\"\"\n\nfrom ..core.agent import BaseAgent, AgentConfig\n\n"
},
{
"path": "daoyoucode/agents/builtin/oracle.py",
"start": 13,
"end": 45,
"text": "class OracleAgent(BaseAgent):\n    \"\"\"\n    Oracle - é«˜IQå’¨è¯¢Agent\n    \n    èŒè´£ï¼š\n    - æ¶æ„åˆ†æå’Œå†³ç­–\n    - ä»£ç å®¡æŸ¥å’Œå»ºè®®\n    - æ€§èƒ½åˆ†æ\n    - å®‰å…¨å®¡æŸ¥\n    - æŠ€æœ¯å’¨è¯¢\n    \n    ç‰¹ç‚¹ï¼š\n    - åªè¯»æƒé™ï¼ˆä¸ä¿®æ”¹ä»£ç ï¼‰\n    - ä½¿ç”¨æœ€å¼ºæ¨¡å‹\n    - ä¸“æ³¨äºé«˜è´¨é‡åˆ†æ\n    - é€‚åˆå¤æ‚å†³ç­–\n    \n    ä½¿ç”¨åœºæ™¯ï¼š\n    - æ¶æ„å†³ç­–\n    - å®Œæˆé‡è¦å·¥ä½œåçš„è‡ªæˆ‘å®¡æŸ¥\n    - 2æ¬¡ä»¥ä¸Šä¿®å¤å¤±è´¥å\n    - ä¸ç†Ÿæ‚‰çš„ä»£ç æ¨¡å¼\n    - å®‰å…¨/æ€§èƒ½é—®é¢˜\n    \n    é¿å…ä½¿ç”¨ï¼š\n    - ç®€å•æ–‡ä»¶æ“ä½œ\n    - ç¬¬ä¸€æ¬¡å°è¯•ä¿®å¤\n    - ä»å·²è¯»ä»£ç å¯ä»¥å›ç­”çš„é—®é¢˜\n    - çç¢å†³ç­–ï¼ˆå˜é‡å‘½åã€æ ¼å¼åŒ–ï¼‰\n    \n    Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/builtin/oracle.py",
"start": 46,
"end": 54,
"text": "    def __init__(self):\n        config = AgentConfig(\n            name=\"oracle\",\n            description=\"é«˜IQå’¨è¯¢Agentï¼Œæä¾›æ¶æ„åˆ†æå’ŒæŠ€æœ¯å»ºè®®ï¼ˆåªè¯»ï¼‰\",\n            model=\"qwen-max\",  # ä½¿ç”¨æœ€å¼ºæ¨¡å‹\n            temperature=0.1,   # ä½æ¸©åº¦ï¼Œæ›´å‡†ç¡®\n            system_prompt=\"\"   # Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n        )\n        super().__init__(config)"
},
{
"path": "daoyoucode/agents/builtin/programmer.py",
"start": 1,
"end": 9,
"text": "\"\"\"\nç¼–ç¨‹Agent\n\nPrompté…ç½®åœ¨ skills/programming/prompts/programmer.md\n\"\"\"\n\nfrom ..core.agent import BaseAgent, AgentConfig\n\n"
},
{
"path": "daoyoucode/agents/builtin/programmer.py",
"start": 10,
"end": 12,
"text": "class ProgrammerAgent(BaseAgent):\n    \"\"\"ç¼–ç¨‹Agent\"\"\"\n    "
},
{
"path": "daoyoucode/agents/builtin/programmer.py",
"start": 13,
"end": 21,
"text": "    def __init__(self):\n        config = AgentConfig(\n            name=\"programmer\",\n            description=\"ç¼–ç¨‹ä¸“å®¶\",\n            model=\"qwen-coder-plus\",\n            temperature=0.1,\n            system_prompt=\"\"  # Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n        )\n        super().__init__(config)"
},
{
"path": "daoyoucode/agents/builtin/refactor_master.py",
"start": 1,
"end": 10,
"text": "\"\"\"\né‡æ„ä¸“å®¶Agent\n\nä¸“æ³¨äºä»£ç é‡æ„ï¼Œæä¾›å®‰å…¨ã€æ¸è¿›å¼çš„é‡æ„æ–¹æ¡ˆ\nPrompté…ç½®åœ¨ skills/refactoring/prompts/refactor.md\n\"\"\"\n\nfrom ..core.agent import BaseAgent, AgentConfig\n\n"
},
{
"path": "daoyoucode/agents/builtin/refactor_master.py",
"start": 11,
"end": 13,
"text": "class RefactorMasterAgent(BaseAgent):\n    \"\"\"é‡æ„ä¸“å®¶Agent\"\"\"\n    "
},
{
"path": "daoyoucode/agents/builtin/refactor_master.py",
"start": 14,
"end": 22,
"text": "    def __init__(self):\n        config = AgentConfig(\n            name=\"refactor_master\",\n            description=\"ä»£ç é‡æ„ä¸“å®¶ï¼Œæä¾›å®‰å…¨æ¸è¿›å¼é‡æ„æ–¹æ¡ˆ\",\n            model=\"qwen-coder-plus\",\n            temperature=0.2,\n            system_prompt=\"\"  # Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n        )\n        super().__init__(config)"
},
{
"path": "daoyoucode/agents/builtin/sisyphus.py",
"start": 1,
"end": 12,
"text": "\"\"\"\nSisyphus - ä¸»ç¼–æ’Agent\n\nè´Ÿè´£æ™ºèƒ½ä»»åŠ¡åˆ†è§£å’ŒAgentè°ƒåº¦\nå€Ÿé‰´oh-my-opencodeçš„è®¾è®¡ï¼Œå®ç°todoé©±åŠ¨çš„å·¥ä½œæµ\n\nPrompté…ç½®åœ¨ skills/sisyphus/prompts/sisyphus.md\n\"\"\"\n\nfrom ..core.agent import BaseAgent, AgentConfig\n\n"
},
{
"path": "daoyoucode/agents/builtin/sisyphus.py",
"start": 13,
"end": 32,
"text": "class SisyphusAgent(BaseAgent):\n    \"\"\"\n    Sisyphus - ä¸»ç¼–æ’Agent\n    \n    èŒè´£ï¼š\n    - åˆ†æç”¨æˆ·è¯·æ±‚\n    - åˆ†è§£å¤æ‚ä»»åŠ¡\n    - é€‰æ‹©åˆé€‚çš„ä¸“ä¸šAgent\n    - éªŒè¯æ‰§è¡Œç»“æœ\n    - èšåˆæœ€ç»ˆç­”æ¡ˆ\n    \n    ç‰¹ç‚¹ï¼š\n    - Todoé©±åŠ¨å·¥ä½œæµ\n    - æ™ºèƒ½Agenté€‰æ‹©\n    - ç»“æœéªŒè¯\n    - åªä½¿ç”¨4ä¸ªåŸºç¡€å·¥å…·ï¼ˆå¿«é€Ÿæ¢ç´¢ï¼‰\n    \n    Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/builtin/sisyphus.py",
"start": 33,
"end": 41,
"text": "    def __init__(self):\n        config = AgentConfig(\n            name=\"sisyphus\",\n            description=\"ä¸»ç¼–æ’Agentï¼Œè´Ÿè´£ä»»åŠ¡åˆ†è§£å’ŒAgentè°ƒåº¦\",\n            model=\"qwen-max\",  # ä½¿ç”¨æœ€å¼ºæ¨¡å‹\n            temperature=0.1,   # ä½æ¸©åº¦ï¼Œæ›´å‡†ç¡®\n            system_prompt=\"\"   # Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n        )\n        super().__init__(config)"
},
{
"path": "daoyoucode/agents/builtin/test_expert.py",
"start": 1,
"end": 10,
"text": "\"\"\"\næµ‹è¯•ä¸“å®¶Agent\n\nä¸“æ³¨äºæµ‹è¯•ç¼–å†™ã€æµ‹è¯•ä¿®å¤å’Œæµ‹è¯•ç­–ç•¥\nPrompté…ç½®åœ¨ skills/testing/prompts/test.md\n\"\"\"\n\nfrom ..core.agent import BaseAgent, AgentConfig\n\n"
},
{
"path": "daoyoucode/agents/builtin/test_expert.py",
"start": 11,
"end": 13,
"text": "class TestExpertAgent(BaseAgent):\n    \"\"\"æµ‹è¯•ä¸“å®¶Agent\"\"\"\n    "
},
{
"path": "daoyoucode/agents/builtin/test_expert.py",
"start": 14,
"end": 22,
"text": "    def __init__(self):\n        config = AgentConfig(\n            name=\"test_expert\",\n            description=\"æµ‹è¯•ç¼–å†™å’Œä¿®å¤ä¸“å®¶ï¼ŒTDDå·¥ä½œæµæ”¯æŒ\",\n            model=\"qwen-coder-plus\",  # æ”¹ç”¨qwen-coder-plusï¼ˆå·²é…ç½®ï¼‰\n            temperature=0.3,\n            system_prompt=\"\"  # Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n        )\n        super().__init__(config)"
},
{
"path": "daoyoucode/agents/builtin/translator.py",
"start": 1,
"end": 9,
"text": "\"\"\"\nç¿»è¯‘Agent\n\nPrompté…ç½®åœ¨ skills/translation/prompts/translator.md\n\"\"\"\n\nfrom ..core.agent import BaseAgent, AgentConfig\n\n"
},
{
"path": "daoyoucode/agents/builtin/translator.py",
"start": 10,
"end": 12,
"text": "class TranslatorAgent(BaseAgent):\n    \"\"\"ç¿»è¯‘Agent\"\"\"\n    "
},
{
"path": "daoyoucode/agents/builtin/translator.py",
"start": 13,
"end": 21,
"text": "    def __init__(self):\n        config = AgentConfig(\n            name=\"translator\",\n            description=\"ä¸“ä¸šç¿»è¯‘ä¸“å®¶\",\n            model=\"qwen-max\",\n            temperature=0.3,\n            system_prompt=\"\"  # Promptç”±Skillé…ç½®æ–‡ä»¶ç®¡ç†\n        )\n        super().__init__(config)"
},
{
"path": "daoyoucode/agents/builtin/__init__.py",
"start": 1,
"end": 21,
"text": "\"\"\"\nå†…ç½®Agentæ³¨å†Œ\n\næ‰€æœ‰å†…ç½®Agentåœ¨è¿™é‡Œæ³¨å†Œåˆ°å…¨å±€æ³¨å†Œè¡¨\n\"\"\"\n\nfrom ..core.agent import register_agent\nfrom .main_agent import MainAgent\nfrom .translator import TranslatorAgent\nfrom .programmer import ProgrammerAgent\nfrom .code_analyzer import CodeAnalyzerAgent\nfrom .code_explorer import CodeExplorerAgent\nfrom .refactor_master import RefactorMasterAgent\nfrom .test_expert import TestExpertAgent\n\n# æ–°å¢ï¼šå€Ÿé‰´oh-my-opencodeçš„é«˜çº§Agent\nfrom .sisyphus import SisyphusAgent\nfrom .oracle import OracleAgent\nfrom .librarian import LibrarianAgent\n\n"
},
{
"path": "daoyoucode/agents/builtin/__init__.py",
"start": 22,
"end": 58,
"text": "def register_builtin_agents():\n    \"\"\"æ³¨å†Œæ‰€æœ‰å†…ç½®Agent\"\"\"\n    \n    # ä¸»Agent\n    register_agent(MainAgent())\n    \n    # ç¼–æ’Agentï¼ˆå€Ÿé‰´oh-my-opencodeï¼‰\n    register_agent(SisyphusAgent())          # ä¸»ç¼–æ’Agent\n    \n    # å’¨è¯¢Agentï¼ˆå€Ÿé‰´oh-my-opencodeï¼‰\n    register_agent(OracleAgent())            # é«˜IQå’¨è¯¢Agentï¼ˆåªè¯»ï¼‰\n    register_agent(LibrarianAgent())         # æ–‡æ¡£æœç´¢Agentï¼ˆåªè¯»ï¼‰\n    \n    # åŸºç¡€Agent\n    register_agent(TranslatorAgent())\n    register_agent(ProgrammerAgent())\n    \n    # ç¼–ç¨‹è¾…åŠ©Agent\n    register_agent(CodeAnalyzerAgent())      # æ¶æ„åˆ†æ\n    register_agent(CodeExplorerAgent())      # ä»£ç æ¢ç´¢\n    register_agent(RefactorMasterAgent())    # é‡æ„ä¸“å®¶\n    register_agent(TestExpertAgent())        # æµ‹è¯•ä¸“å®¶\n\n\n__all__ = [\n    'register_builtin_agents',\n    'MainAgent',\n    'SisyphusAgent',\n    'OracleAgent',\n    'LibrarianAgent',\n    'TranslatorAgent',\n    'ProgrammerAgent',\n    'CodeAnalyzerAgent',\n    'CodeExplorerAgent',\n    'RefactorMasterAgent',\n    'TestExpertAgent',\n]"
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 1,
"end": 15,
"text": "\"\"\"\nAgentåŸºç±»å’Œæ³¨å†Œè¡¨\n\nAgentæ˜¯æ‰§è¡Œä»»åŠ¡çš„ä¸“å®¶\n\"\"\"\n\nfrom typing import Dict, Any, Optional, List\nfrom dataclasses import dataclass, field\nfrom abc import ABC\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 16,
"end": 25,
"text": "class AgentConfig:\n    \"\"\"Agenté…ç½®\"\"\"\n    name: str\n    description: str\n    model: str\n    temperature: float = 0.7\n    system_prompt: str = \"\"\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 26,
"end": 36,
"text": "class AgentResult:\n    \"\"\"Agentæ‰§è¡Œç»“æœ\"\"\"\n    success: bool\n    content: str\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    error: Optional[str] = None\n    tools_used: list = field(default_factory=list)\n    tokens_used: int = 0\n    cost: float = 0.0\n\n"
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 37,
"end": 39,
"text": "class BaseAgent(ABC):\n    \"\"\"AgentåŸºç±»\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 40,
"end": 65,
"text": "    def __init__(self, config: AgentConfig):\n        self.config = config\n        self.name = config.name\n        self.logger = logging.getLogger(f\"agent.{self.name}\")\n        \n        # ç¡®ä¿å·¥å…·æ³¨å†Œè¡¨å·²åˆå§‹åŒ–ï¼ˆåŒä¿é™©ï¼‰\n        from ..tools import get_tool_registry\n        self._tool_registry = get_tool_registry()\n        self.logger.debug(f\"å·¥å…·æ³¨å†Œè¡¨å·²å°±ç»ª: {len(self._tool_registry.list_tools())} ä¸ªå·¥å…·\")\n        \n        # æ¥å…¥è®°å¿†æ¨¡å—ï¼ˆå•ä¾‹ï¼Œä¸ä¼šé‡å¤åŠ è½½ï¼‰\n        from ..memory import get_memory_manager\n        self.memory = get_memory_manager()\n        \n        # æ¥å…¥å·¥å…·åå¤„ç†å™¨\n        from ..tools.postprocessor import get_tool_postprocessor\n        self.tool_postprocessor = get_tool_postprocessor()\n        self.logger.debug(\"å·¥å…·åå¤„ç†å™¨å·²å°±ç»ª\")\n        \n        # ç”¨æˆ·ç”»åƒç¼“å­˜ï¼ˆæŒ‰éœ€åŠ è½½ï¼Œé¿å…æ¯è½®éƒ½è¯»å–ï¼‰\n        self._user_profile_cache: Dict[str, Dict[str, Any]] = {}\n        \n        # ç”¨æˆ·ç”»åƒæ£€æŸ¥æ—¶é—´ç¼“å­˜ï¼ˆé¿å…é¢‘ç¹æ£€æŸ¥ï¼‰\n        # æ ¼å¼ï¼š{user_id: last_check_timestamp}\n        self._profile_check_cache: Dict[str, float] = {}\n    "
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 66,
"end": 612,
"text": "    def get_user_profile(self, user_id: str, force_reload: bool = False) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        è·å–ç”¨æˆ·ç”»åƒï¼ˆå¸¦ç¼“å­˜ï¼‰\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n            force_reload: æ˜¯å¦å¼ºåˆ¶é‡æ–°åŠ è½½\n        \n        Returns:\n            ç”¨æˆ·ç”»åƒå­—å…¸ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›None\n        \"\"\"\n        if force_reload or user_id not in self._user_profile_cache:\n            profile = self.memory.long_term_memory.get_user_profile(user_id)\n            if profile:\n                self._user_profile_cache[user_id] = profile\n                self.logger.debug(f\"åŠ è½½ç”¨æˆ·ç”»åƒ: {user_id}\")\n        \n        return self._user_profile_cache.get(user_id)\n    \n    async def _check_and_update_profile(self, user_id: str, session_id: str):\n        \"\"\"\n        æ£€æŸ¥å¹¶æ›´æ–°ç”¨æˆ·ç”»åƒï¼ˆå¸¦æ—¶é—´çª—å£ä¼˜åŒ–ï¼‰\n        \n        ä¼˜åŒ–ç­–ç•¥ï¼š\n        - 1å°æ—¶å†…åªæ£€æŸ¥ä¸€æ¬¡ï¼Œé¿å…é¢‘ç¹çš„æ–‡ä»¶I/Oå’Œè®¡ç®—\n        - å‡å°‘90%çš„ä¸å¿…è¦æ£€æŸ¥\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n            session_id: å½“å‰ä¼šè¯ID\n        \"\"\"\n        import time\n        \n        try:\n            # æ£€æŸ¥æ—¶é—´çª—å£ï¼ˆ1å°æ—¶ = 3600ç§’ï¼‰\n            CHECK_INTERVAL = 3600\n            current_time = time.time()\n            last_check = self._profile_check_cache.get(user_id)\n            \n            if last_check and (current_time - last_check) < CHECK_INTERVAL:\n                # 1å°æ—¶å†…å·²ç»æ£€æŸ¥è¿‡ï¼Œè·³è¿‡\n                self.logger.debug(\n                    f\"è·³è¿‡ç”»åƒæ£€æŸ¥: user_id={user_id}, \"\n                    f\"è·ä¸Šæ¬¡æ£€æŸ¥ {int(current_time - last_check)}ç§’\"\n                )\n                return\n            \n            # æ›´æ–°æ£€æŸ¥æ—¶é—´\n            self._profile_check_cache[user_id] = current_time\n            \n            # è·å–ç”¨æˆ·çš„æ€»å¯¹è¯æ•°\n            tasks = self.memory.get_task_history(user_id, limit=1000)\n            total_conversations = len(tasks)\n            \n            # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°\n            should_update = self.memory.long_term_memory.should_update_profile(\n                user_id, total_conversations\n            )\n            \n            if should_update:\n                self.logger.info(f\"ğŸ”„ è§¦å‘ç”¨æˆ·ç”»åƒæ›´æ–°: user_id={user_id}, conversations={total_conversations}\")\n                \n                # å¼‚æ­¥æ›´æ–°ï¼ˆä¸é˜»å¡å½“å‰è¯·æ±‚ï¼‰\n                # è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥æ”¾åˆ°åå°ä»»åŠ¡é˜Ÿåˆ—\n                await self._update_user_profile_async(user_id)\n        \n        except Exception as e:\n            self.logger.warning(f\"æ£€æŸ¥ç”¨æˆ·ç”»åƒæ›´æ–°å¤±è´¥: {e}\")\n    \n    async def _update_user_profile_async(self, user_id: str):\n        \"\"\"\n        å¼‚æ­¥æ›´æ–°ç”¨æˆ·ç”»åƒ\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n        \"\"\"\n        try:\n            # æ”¶é›†ç”¨æˆ·çš„æ‰€æœ‰ä¼šè¯\n            all_sessions = self.memory.get_user_sessions(user_id)\n            \n            if not all_sessions:\n                self.logger.warning(f\"ç”¨æˆ· {user_id} æ²¡æœ‰ä¼šè¯è®°å½•ï¼Œè·³è¿‡ç”»åƒæ›´æ–°\")\n                return\n            \n            # è·å–LLMå®¢æˆ·ç«¯\n            from ..llm import get_client_manager\n            client_manager = get_client_manager()\n            llm_client = client_manager.get_client(self.config.model)\n            \n            # æ„å»ºç”¨æˆ·ç”»åƒ\n            profile = await self.memory.long_term_memory.build_user_profile(\n                user_id=user_id,\n                all_sessions=all_sessions,\n                llm_client=llm_client\n            )\n            \n            # æ¸…é™¤ç¼“å­˜ï¼Œä¸‹æ¬¡è®¿é—®æ—¶ä¼šé‡æ–°åŠ è½½\n            if user_id in self._user_profile_cache:\n                del self._user_profile_cache[user_id]\n            \n            self.logger.info(\n                f\"âœ… ç”¨æˆ·ç”»åƒå·²æ›´æ–°: user_id={user_id}, \"\n                f\"sessions={len(all_sessions)}, \"\n                f\"topics={len(profile.get('common_topics', []))}\"\n            )\n        \n        except Exception as e:\n            self.logger.error(f\"æ›´æ–°ç”¨æˆ·ç”»åƒå¤±è´¥: {e}\", exc_info=True)\n    \n    async def execute_stream(\n        self,\n        prompt_source: Dict[str, Any],\n        user_input: str,\n        context: Optional[Dict[str, Any]] = None,\n        llm_config: Optional[Dict[str, Any]] = None,\n        tools: Optional[List[str]] = None,\n        max_tool_iterations: int = 15  # ğŸ†• å¢åŠ åˆ° 15 æ¬¡\n    ):\n        \"\"\"\n        æµå¼æ‰§è¡Œä»»åŠ¡ï¼ˆyieldæ¯ä¸ªtokenï¼‰\n        \n        æ³¨æ„ï¼šæµå¼æ¨¡å¼ä¸æ”¯æŒå·¥å…·è°ƒç”¨ï¼Œå¦‚æœæä¾›äº†toolså‚æ•°ä¼šè‡ªåŠ¨é™çº§åˆ°æ™®é€šæ¨¡å¼\n        \n"
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 613,
"end": 956,
"text": "    def _render_prompt(\n        self,\n        prompt: str,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> str:\n        \"\"\"æ¸²æŸ“Promptï¼ˆæ”¯æŒJinja2æ¨¡æ¿ï¼‰\"\"\"\n        try:\n            from jinja2 import Template\n            template = Template(prompt)\n            return template.render(user_input=user_input, **context)\n        except Exception as e:\n            self.logger.warning(f\"Promptæ¸²æŸ“å¤±è´¥: {e}\")\n            return prompt.replace('{{user_input}}', user_input)\n    \n    async def _call_llm(\n        self,\n        prompt: str,\n        llm_config: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"è°ƒç”¨LLM\"\"\"\n        from ..llm import get_client_manager\n        \n        client_manager = get_client_manager()\n        \n        # åˆå¹¶é…ç½®\n        model = (llm_config or {}).get('model', self.config.model)\n        temperature = (llm_config or {}).get('temperature', self.config.temperature)\n        \n        # è·å–å®¢æˆ·ç«¯\n        client = client_manager.get_client(model=model)\n        \n        # æ„å»ºè¯·æ±‚\n        from ..llm.base import LLMRequest\n        request = LLMRequest(\n            prompt=prompt,\n            model=model,\n            temperature=temperature\n        )\n        \n        # è°ƒç”¨\n        llm_response = await client.chat(request)\n        \n        return llm_response.content\n    \n    async def _stream_llm(\n        self,\n        prompt: str,\n        llm_config: Optional[Dict[str, Any]] = None\n    ):\n        \"\"\"\n        æµå¼è°ƒç”¨LLM\n        \n        Args:\n            prompt: æç¤ºè¯\n            llm_config: LLMé…ç½®\n        \n        Yields:\n            str: æ¯ä¸ªtoken\n        \"\"\"\n        from ..llm import get_client_manager\n        \n        client_manager = get_client_manager()\n        \n        # åˆå¹¶é…ç½®\n        model = (llm_config or {}).get('model', self.config.model)\n        temperature = (llm_config or {}).get('temperature', self.config.temperature)\n        \n        # è·å–å®¢æˆ·ç«¯\n        client = client_manager.get_client(model=model)\n        \n        # æ„å»ºè¯·æ±‚\n        from ..llm.base import LLMRequest\n        request = LLMRequest(\n            prompt=prompt,\n            model=model,\n            temperature=temperature,\n            stream=True\n        )\n        \n        # æµå¼è°ƒç”¨\n        async for token in client.stream_chat(request):\n            yield token\n    \n    async def _call_llm_with_tools(\n        self,\n        initial_messages: List[Dict[str, Any]],  # æ”¹ä¸ºæ¥å—æ¶ˆæ¯åˆ—è¡¨\n        tool_names: List[str],\n        llm_config: Optional[Dict[str, Any]] = None,\n        max_iterations: int = 15,  # ğŸ†• å¢åŠ åˆ° 15 æ¬¡\n        context: Optional[Dict[str, Any]] = None,  # æ·»åŠ  context å‚æ•°\n        history: Optional[List[Dict[str, Any]]] = None  # æ·»åŠ  history å‚æ•°\n    ) -> tuple[str, List[str]]:\n        \"\"\"\n        è°ƒç”¨LLMå¹¶æ”¯æŒå·¥å…·è°ƒç”¨\n        \n        Args:\n            initial_messages: åˆå§‹æ¶ˆæ¯åˆ—è¡¨ï¼ˆåŒ…å«å†å²å¯¹è¯å’Œå½“å‰è¾“å…¥ï¼‰\n            tool_names: å¯ç”¨å·¥å…·åç§°åˆ—è¡¨\n            llm_config: LLMé…ç½®\n            max_iterations: æœ€å¤§è¿­ä»£æ¬¡æ•°\n            context: æ‰§è¡Œä¸Šä¸‹æ–‡ï¼ˆç”¨äºåå¤„ç†ï¼‰\n            history: å¯¹è¯å†å²ï¼ˆç”¨äºåå¤„ç†ï¼‰\n        \n        Returns:\n            (æœ€ç»ˆå“åº”, ä½¿ç”¨çš„å·¥å…·åˆ—è¡¨)\n        \"\"\"\n        import json\n        import time  # æ·»åŠ  time å¯¼å…¥\n        \n        # ä½¿ç”¨å·²åˆå§‹åŒ–çš„å·¥å…·æ³¨å†Œè¡¨\n        tool_registry = self._tool_registry\n        tools_used = []\n        \n        # è°ƒè¯•ï¼šåˆ—å‡ºæ‰€æœ‰å¯ç”¨å·¥å…·\n        available_tools = tool_registry.list_tools()\n        self.logger.info(f\"å¯ç”¨å·¥å…·æ•°é‡: {len(available_tools)}\")\n        self.logger.debug(f\"å¯ç”¨å·¥å…·åˆ—è¡¨: {', '.join(sorted(available_tools))}\")\n        \n        # è·å–å·¥å…·çš„Function schemas\n        function_schemas = tool_registry.get_function_schemas(tool_names)\n        \n        if not function_schemas:\n            # æ²¡æœ‰å¯ç”¨å·¥å…·ï¼Œç›´æ¥è°ƒç”¨\n            # ä»initial_messagesä¸­æå–æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯\n            last_user_message = \"\"\n            for msg in reversed(initial_messages):\n                if msg['role'] == 'user':\n                    last_user_message = msg['content']\n                    break\n            response = await self._call_llm(last_user_message, llm_config)\n            return response, []\n        \n        # ä½¿ç”¨åˆå§‹æ¶ˆæ¯ä½œä¸ºèµ·ç‚¹\n        messages = initial_message"
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 957,
"end": 959,
"text": "class AgentRegistry:\n    \"\"\"Agentæ³¨å†Œè¡¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 960,
"end": 962,
"text": "    def __init__(self):\n        self._agents: Dict[str, BaseAgent] = {}\n    "
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 963,
"end": 967,
"text": "    def register(self, agent: BaseAgent):\n        \"\"\"æ³¨å†ŒAgent\"\"\"\n        self._agents[agent.name] = agent\n        logger.info(f\"å·²æ³¨å†ŒAgent: {agent.name}\")\n    "
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 968,
"end": 971,
"text": "    def get_agent(self, name: str) -> Optional[BaseAgent]:\n        \"\"\"è·å–Agent\"\"\"\n        return self._agents.get(name)\n    "
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 972,
"end": 980,
"text": "    def list_agents(self) -> list:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰Agent\"\"\"\n        return list(self._agents.keys())\n\n\n# å…¨å±€æ³¨å†Œè¡¨\n_agent_registry = AgentRegistry()\n\n"
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 981,
"end": 985,
"text": "def get_agent_registry() -> AgentRegistry:\n    \"\"\"è·å–Agentæ³¨å†Œè¡¨\"\"\"\n    return _agent_registry\n\n"
},
{
"path": "daoyoucode/agents/core/agent.py",
"start": 986,
"end": 988,
"text": "def register_agent(agent: BaseAgent):\n    \"\"\"æ³¨å†ŒAgent\"\"\"\n    _agent_registry.register(agent)"
},
{
"path": "daoyoucode/agents/core/background.py",
"start": 1,
"end": 21,
"text": "\"\"\"\nåå°ä»»åŠ¡ç®¡ç†å™¨\n\nå€Ÿé‰´oh-my-opencodeçš„åå°ä»»åŠ¡æ‰§è¡Œæœºåˆ¶ï¼Œæ”¯æŒï¼š\n- å¼‚æ­¥ä»»åŠ¡æäº¤\n- ä»»åŠ¡çŠ¶æ€æŸ¥è¯¢\n- ä»»åŠ¡ç»“æœè·å–\n- ä»»åŠ¡å–æ¶ˆ\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, Any, Optional, Callable\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom datetime import datetime\nimport uuid\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/background.py",
"start": 22,
"end": 31,
"text": "class TaskStatus(Enum):\n    \"\"\"ä»»åŠ¡çŠ¶æ€\"\"\"\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/background.py",
"start": 32,
"end": 46,
"text": "class BackgroundTask:\n    \"\"\"åå°ä»»åŠ¡\"\"\"\n    task_id: str\n    agent_name: str\n    prompt: str\n    context: Dict[str, Any]\n    status: TaskStatus\n    created_at: datetime\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    result: Optional[Any] = None\n    error: Optional[str] = None\n    task: Optional[asyncio.Task] = None\n\n"
},
{
"path": "daoyoucode/agents/core/background.py",
"start": 47,
"end": 49,
"text": "class BackgroundTaskManager:\n    \"\"\"åå°ä»»åŠ¡ç®¡ç†å™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/background.py",
"start": 50,
"end": 192,
"text": "    def __init__(self):\n        self.tasks: Dict[str, BackgroundTask] = {}\n        self.logger = logging.getLogger(\"background_task\")\n    \n    async def submit(\n        self,\n        agent_name: str,\n        prompt: str,\n        context: Dict[str, Any],\n        task_id: Optional[str] = None\n    ) -> str:\n        \"\"\"\n        æäº¤åå°ä»»åŠ¡\n        \n        Args:\n            agent_name: Agentåç§°\n            prompt: Promptå†…å®¹\n            context: ä¸Šä¸‹æ–‡\n            task_id: ä»»åŠ¡IDï¼ˆå¯é€‰ï¼Œä¸æä¾›åˆ™è‡ªåŠ¨ç”Ÿæˆï¼‰\n        \n        Returns:\n            ä»»åŠ¡ID\n        \"\"\"\n        # ç”Ÿæˆä»»åŠ¡ID\n        if not task_id:\n            task_id = str(uuid.uuid4())\n        \n        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨\n        if task_id in self.tasks:\n            existing_task = self.tasks[task_id]\n            if existing_task.status in [TaskStatus.PENDING, TaskStatus.RUNNING]:\n                self.logger.info(f\"ä»»åŠ¡ {task_id} å·²å­˜åœ¨ä¸”æ­£åœ¨è¿è¡Œï¼Œå¤ç”¨\")\n                return task_id\n        \n        # åˆ›å»ºä»»åŠ¡å¯¹è±¡\n        bg_task = BackgroundTask(\n            task_id=task_id,\n            agent_name=agent_name,\n            prompt=prompt,\n            context=context,\n            status=TaskStatus.PENDING,\n            created_at=datetime.now()\n        )\n        \n        # åˆ›å»ºå¼‚æ­¥ä»»åŠ¡\n        task = asyncio.create_task(\n            self._execute_background(bg_task)\n        )\n        bg_task.task = task\n        \n        # ä¿å­˜\n        self.tasks[task_id] = bg_task\n        \n        self.logger.info(f\"å·²æäº¤åå°ä»»åŠ¡: {task_id} (Agent: {agent_name})\")\n        \n        return task_id\n    \n    async def _execute_background(self, bg_task: BackgroundTask):\n        \"\"\"æ‰§è¡Œåå°ä»»åŠ¡\"\"\"\n        try:\n            # æ›´æ–°çŠ¶æ€\n            bg_task.status = TaskStatus.RUNNING\n            bg_task.started_at = datetime.now()\n            \n            self.logger.info(f\"å¼€å§‹æ‰§è¡Œåå°ä»»åŠ¡: {bg_task.task_id}\")\n            \n            # è·å–Agent\n            from ..registry import get_agent_registry\n            agent_registry = get_agent_registry()\n            agent = agent_registry.get_agent(bg_task.agent_name)\n            \n            if not agent:\n                raise ValueError(f\"Agentä¸å­˜åœ¨: {bg_task.agent_name}\")\n            \n            # æ‰§è¡ŒAgent\n            result = await agent.execute(\n                prompt_source={'inline': bg_task.prompt},\n                user_input=\"\",\n                context=bg_task.context\n            )\n            \n            # ä¿å­˜ç»“æœ\n            bg_task.result = result\n            bg_task.status = TaskStatus.COMPLETED\n            bg_task.completed_at = datetime.now()\n            \n            self.logger.info(f\"åå°ä»»åŠ¡å®Œæˆ: {bg_task.task_id}\")\n        \n        except asyncio.CancelledError:\n            bg_task.status = TaskStatus.CANCELLED\n            bg_task.completed_at = datetime.now()\n            self.logger.info(f\"åå°ä»»åŠ¡å·²å–æ¶ˆ: {bg_task.task_id}\")\n        \n        except Exception as e:\n            bg_task.error = str(e)\n            bg_task.status = TaskStatus.FAILED\n            bg_task.completed_at = datetime.now()\n            self.logger.error(\n                f\"åå°ä»»åŠ¡å¤±è´¥: {bg_task.task_id}, é”™è¯¯: {e}\",\n                exc_info=True\n            )\n    \n    async def get_result(\n        self,\n        task_id: str,\n        timeout: Optional[float] = None\n    ) -> Any:\n        \"\"\"\n        è·å–ä»»åŠ¡ç»“æœ\n        \n        Args:\n            task_id: ä»»åŠ¡ID\n            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼ŒNoneè¡¨ç¤ºæ— é™ç­‰å¾…\n        \n        Returns:\n            ä»»åŠ¡ç»“æœ\n        \n        Raises:\n            ValueError: ä»»åŠ¡ä¸å­˜åœ¨\n            asyncio.TimeoutError: è¶…æ—¶\n        \"\"\"\n        if task_id not in self.tasks:\n            raise ValueError(f\"ä»»åŠ¡ä¸å­˜åœ¨: {task_id}\")\n        \n        bg_task = self.tasks[task_id]\n        \n        # å¦‚æœä»»åŠ¡è¿˜åœ¨è¿è¡Œï¼Œç­‰å¾…å®Œæˆ\n        if bg_task.status in [TaskStatus.PENDING, TaskStatus.RUNNING]:\n            if timeout:\n                await asyncio.wait_for(bg_task.task, timeout=timeout)\n            else:\n                await bg_task.task\n        \n        # è¿”å›ç»“æœ\n        if bg_task.status == TaskStatus.COMPLETED:\n            return bg_task.result\n        elif bg_task.status == TaskStatus.FAILED:\n            "
},
{
"path": "daoyoucode/agents/core/background.py",
"start": 193,
"end": 198,
"text": "    def get_status(self, task_id: str) -> Optional[TaskStatus]:\n        \"\"\"è·å–ä»»åŠ¡çŠ¶æ€\"\"\"\n        if task_id not in self.tasks:\n            return None\n        return self.tasks[task_id].status\n    "
},
{
"path": "daoyoucode/agents/core/background.py",
"start": 199,
"end": 219,
"text": "    def cancel(self, task_id: str) -> bool:\n        \"\"\"\n        å–æ¶ˆä»»åŠ¡\n        \n        Returns:\n            æ˜¯å¦æˆåŠŸå–æ¶ˆ\n        \"\"\"\n        if task_id not in self.tasks:\n            return False\n        \n        bg_task = self.tasks[task_id]\n        \n        if bg_task.status in [TaskStatus.PENDING, TaskStatus.RUNNING]:\n            if bg_task.task:\n                bg_task.task.cancel()\n            bg_task.status = TaskStatus.CANCELLED\n            self.logger.info(f\"å·²å–æ¶ˆä»»åŠ¡: {task_id}\")\n            return True\n        \n        return False\n    "
},
{
"path": "daoyoucode/agents/core/background.py",
"start": 220,
"end": 232,
"text": "    def list_tasks(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰ä»»åŠ¡\"\"\"\n        return {\n            task_id: {\n                'agent_name': task.agent_name,\n                'status': task.status.value,\n                'created_at': task.created_at.isoformat(),\n                'started_at': task.started_at.isoformat() if task.started_at else None,\n                'completed_at': task.completed_at.isoformat() if task.completed_at else None,\n            }\n            for task_id, task in self.tasks.items()\n        }\n    "
},
{
"path": "daoyoucode/agents/core/background.py",
"start": 233,
"end": 250,
"text": "    def clear_completed(self):\n        \"\"\"æ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡\"\"\"\n        completed_ids = [\n            task_id\n            for task_id, task in self.tasks.items()\n            if task.status in [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELLED]\n        ]\n        \n        for task_id in completed_ids:\n            del self.tasks[task_id]\n        \n        self.logger.info(f\"å·²æ¸…ç† {len(completed_ids)} ä¸ªå·²å®Œæˆä»»åŠ¡\")\n\n\n# å…¨å±€åå°ä»»åŠ¡ç®¡ç†å™¨\n_background_manager = BackgroundTaskManager()\n\n"
},
{
"path": "daoyoucode/agents/core/background.py",
"start": 251,
"end": 253,
"text": "def get_background_manager() -> BackgroundTaskManager:\n    \"\"\"è·å–åå°ä»»åŠ¡ç®¡ç†å™¨\"\"\"\n    return _background_manager"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 1,
"end": 14,
"text": "\"\"\"\nAgentè¡Œä¸ºæŒ‡å—\n\næä¾›ç»“æ„åŒ–çš„Agentè¡Œä¸ºæŒ‡å¯¼ï¼Œè®©Agentè¡Œä¸ºæ›´å¯é¢„æµ‹ã€‚\nçµæ„Ÿæ¥æºï¼šoh-my-opencodeçš„Sisyphusè¡Œä¸ºæŒ‡å—\n\"\"\"\n\nfrom typing import Dict, List, Any, Optional\nfrom enum import Enum\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 15,
"end": 24,
"text": "class Phase(Enum):\n    \"\"\"æ‰§è¡Œé˜¶æ®µ\"\"\"\n    INTENT_GATE = \"intent_gate\"                    # æ„å›¾è¯†åˆ«\n    CODEBASE_ASSESSMENT = \"codebase_assessment\"    # ä»£ç åº“è¯„ä¼°\n    EXPLORATION = \"exploration\"                     # æ¢ç´¢ç ”ç©¶\n    IMPLEMENTATION = \"implementation\"               # å®ç°\n    FAILURE_RECOVERY = \"failure_recovery\"          # å¤±è´¥æ¢å¤\n    COMPLETION = \"completion\"                       # å®Œæˆ\n\n"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 25,
"end": 36,
"text": "class RequestType(Enum):\n    \"\"\"è¯·æ±‚ç±»å‹\"\"\"\n    CHAT = \"chat\"                    # é—²èŠï¼ˆéä»£ç ç›¸å…³ï¼‰\n    SKILL_MATCH = \"skill_match\"      # åŒ¹é…Skill\n    TRIVIAL = \"trivial\"              # ç®€å•ä»»åŠ¡\n    EXPLICIT = \"explicit\"            # æ˜ç¡®ä»»åŠ¡\n    EXPLORATORY = \"exploratory\"      # æ¢ç´¢æ€§ä»»åŠ¡\n    OPEN_ENDED = \"open_ended\"        # å¼€æ”¾æ€§ä»»åŠ¡\n    GITHUB_WORK = \"github_work\"      # GitHubå·¥ä½œ\n    AMBIGUOUS = \"ambiguous\"          # æ¨¡ç³Šä»»åŠ¡\n\n"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 37,
"end": 45,
"text": "class CodebaseState(Enum):\n    \"\"\"ä»£ç åº“çŠ¶æ€\"\"\"\n    DISCIPLINED = \"disciplined\"      # è§„èŒƒçš„\n    TRANSITIONAL = \"transitional\"    # è¿‡æ¸¡çš„\n    LEGACY = \"legacy\"                # é—ç•™çš„\n    CHAOTIC = \"chaotic\"              # æ··ä¹±çš„\n    GREENFIELD = \"greenfield\"        # æ–°é¡¹ç›®\n\n"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 46,
"end": 145,
"text": "class BehaviorGuide:\n    \"\"\"Agentè¡Œä¸ºæŒ‡å—\"\"\"\n    \n    # é˜¶æ®µå®šä¹‰\n    PHASES = {\n        Phase.INTENT_GATE: {\n            'description': 'æ„å›¾è¯†åˆ«å’Œåˆ†ç±»',\n            'steps': [\n                'æ£€æŸ¥æ˜¯å¦åŒ¹é…Skillè§¦å‘å™¨',\n                'åˆ†ç±»è¯·æ±‚ç±»å‹',\n                'éªŒè¯å‡è®¾å’ŒèŒƒå›´',\n                'æ£€æŸ¥æ˜¯å¦éœ€è¦æ¾„æ¸…',\n            ],\n            'decision_rules': {\n                RequestType.CHAT: 'respond_directly',  # é—²èŠç›´æ¥å›å¤\n                RequestType.SKILL_MATCH: 'invoke_skill_immediately',\n                RequestType.TRIVIAL: 'use_direct_tools',\n                RequestType.EXPLICIT: 'execute_directly',\n                RequestType.EXPLORATORY: 'fire_explore_parallel',\n                RequestType.OPEN_ENDED: 'assess_codebase_first',\n                RequestType.GITHUB_WORK: 'full_cycle_workflow',\n                RequestType.AMBIGUOUS: 'ask_clarification',\n            }\n        },\n        Phase.CODEBASE_ASSESSMENT: {\n            'description': 'è¯„ä¼°ä»£ç åº“çŠ¶æ€',\n            'steps': [\n                'æ£€æŸ¥é…ç½®æ–‡ä»¶ï¼ˆlinter, formatter, type configï¼‰',\n                'é‡‡æ ·2-3ä¸ªç›¸ä¼¼æ–‡ä»¶æ£€æŸ¥ä¸€è‡´æ€§',\n                'è¯†åˆ«é¡¹ç›®æˆç†Ÿåº¦ä¿¡å·',\n                'åˆ†ç±»ä»£ç åº“çŠ¶æ€',\n            ],\n            'state_behaviors': {\n                CodebaseState.DISCIPLINED: 'follow_existing_patterns_strictly',\n                CodebaseState.TRANSITIONAL: 'ask_which_pattern_to_follow',\n                CodebaseState.LEGACY: 'modernize_with_caution',\n                CodebaseState.CHAOTIC: 'propose_best_practices',\n                CodebaseState.GREENFIELD: 'apply_modern_standards',\n            }\n        },\n        Phase.EXPLORATION: {\n            'description': 'æ¢ç´¢å’Œç ”ç©¶',\n            'steps': [\n                'é€‰æ‹©åˆé€‚çš„å·¥å…·ï¼ˆgrep/glob/lsp/exploreï¼‰',\n                'å¹¶è¡Œæ‰§è¡Œæ¢ç´¢ä»»åŠ¡',\n                'æ”¶é›†èƒŒæ™¯ä»»åŠ¡ç»“æœ',\n                'åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´å¤šä¿¡æ¯',\n            ],\n            'stop_conditions': [\n                'æœ‰è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡å¯ä»¥è‡ªä¿¡åœ°ç»§ç»­',\n                'ç›¸åŒä¿¡æ¯åœ¨å¤šä¸ªæ¥æºä¸­å‡ºç°',\n                '2æ¬¡æœç´¢è¿­ä»£æ²¡æœ‰æ–°çš„æœ‰ç”¨æ•°æ®',\n                'æ‰¾åˆ°ç›´æ¥ç­”æ¡ˆ',\n            ]\n        },\n        Phase.IMPLEMENTATION: {\n            'description': 'å®ç°',\n            'steps': [\n                'å¦‚æœä»»åŠ¡æœ‰2+æ­¥éª¤ï¼Œç«‹å³åˆ›å»ºtodoåˆ—è¡¨',\n                'å¼€å§‹å‰æ ‡è®°ä»»åŠ¡ä¸ºin_progress',\n                'å®Œæˆåç«‹å³æ ‡è®°ä¸ºcompleted',\n                'éªŒè¯ç»“æœ',\n            ],\n            'verification_requirements': {\n                'file_edit': 'lsp_diagnostics_clean',\n                'build_command': 'exit_code_0',\n                'test_run': 'all_pass_or_note_preexisting',\n                'delegation': 'agent_result_verified',\n            }\n        },\n        Phase.FAILURE_RECOVERY: {\n            'description': 'å¤±è´¥æ¢å¤',\n            'steps': [\n                'ä¿®å¤æ ¹æœ¬åŸå› ï¼Œè€Œéç—‡çŠ¶',\n                'æ¯æ¬¡ä¿®å¤å°è¯•åé‡æ–°éªŒè¯',\n                'é¿å…éšæœºè°ƒè¯•',\n            ],\n            'after_3_failures': [\n                'STOPæ‰€æœ‰è¿›ä¸€æ­¥çš„ç¼–è¾‘',\n                'REVERTåˆ°æœ€åå·²çŸ¥çš„å·¥ä½œçŠ¶æ€',\n                'DOCUMENTå°è¯•äº†ä»€ä¹ˆä»¥åŠå¤±è´¥äº†ä»€ä¹ˆ',\n                'CONSULT Oracleæˆ–ASK USER',\n            ]\n        },\n        Phase.COMPLETION: {\n            'description': 'å®Œæˆ',\n            'completion_criteria': [\n                'æ‰€æœ‰è®¡åˆ’çš„todoé¡¹ç›®æ ‡è®°ä¸ºå®Œæˆ',\n                'å˜æ›´æ–‡ä»¶çš„è¯Šæ–­æ¸…æ´',\n                'æ„å»ºé€šè¿‡ï¼ˆå¦‚æœé€‚ç”¨ï¼‰',\n                'ç”¨æˆ·çš„åŸå§‹è¯·æ±‚å®Œå…¨æ»¡è¶³',\n            ],\n            'before_final_answer': [\n                'å–æ¶ˆæ‰€æœ‰è¿è¡Œä¸­çš„èƒŒæ™¯ä»»åŠ¡',\n                'ä¿å­˜èµ„æºå¹¶ç¡®ä¿æ¸…æ´çš„å·¥ä½œæµå®Œæˆ',\n            ]\n        }\n    }\n    \n    @classmethod"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 146,
"end": 150,
"text": "    def get_phase_guide(cls, phase: Phase) -> Dict[str, Any]:\n        \"\"\"è·å–é˜¶æ®µæŒ‡å—\"\"\"\n        return cls.PHASES.get(phase, {})\n    \n    @classmethod"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 151,
"end": 279,
"text": "    def classify_request(cls, instruction: str) -> RequestType:\n        \"\"\"\n        åˆ†ç±»è¯·æ±‚ç±»å‹\n        \n        Args:\n            instruction: ç”¨æˆ·æŒ‡ä»¤\n        \n        Returns:\n            è¯·æ±‚ç±»å‹\n        \"\"\"\n        instruction_lower = instruction.lower()\n        \n        # é¦–å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯é—²èŠï¼ˆéä»£ç ç›¸å…³ï¼‰\n        chat_patterns = [\n            # é—®å€™\n            'hello', 'hi', 'hey', 'ä½ å¥½', 'æ‚¨å¥½', 'å—¨',\n            # æ„Ÿè°¢\n            'thank', 'thanks', 'è°¢è°¢', 'æ„Ÿè°¢',\n            # é—²èŠ\n            'how are you', 'what\\'s up', 'æ€ä¹ˆæ ·', 'æœ€è¿‘å¦‚ä½•',\n            # å¤©æ°”\n            'weather', 'å¤©æ°”',\n            # æ—¶é—´\n            'what time', 'what day', 'å‡ ç‚¹', 'æ˜ŸæœŸå‡ ',\n            # éæŠ€æœ¯é—®é¢˜\n            'tell me about yourself', 'ä»‹ç»ä¸€ä¸‹', 'ä½ æ˜¯è°',\n            'what can you do', 'ä½ èƒ½åšä»€ä¹ˆ', 'ä½ ä¼šä»€ä¹ˆ',\n            # æƒ…æ„Ÿ\n            'i love', 'i hate', 'i like', 'æˆ‘å–œæ¬¢', 'æˆ‘è®¨åŒ',\n        ]\n        \n        # ä»£ç ç›¸å…³å…³é”®è¯\n        code_keywords = [\n            'code', 'function', 'class', 'file', 'bug', 'error',\n            'test', 'debug', 'refactor', 'implement', 'fix',\n            'analyze', 'review', 'optimize', 'deploy',\n            'ä»£ç ', 'å‡½æ•°', 'ç±»', 'æ–‡ä»¶', 'é”™è¯¯', 'æµ‹è¯•',\n            'è°ƒè¯•', 'é‡æ„', 'å®ç°', 'ä¿®å¤', 'åˆ†æ', 'ä¼˜åŒ–',\n            '.py', '.js', '.ts', '.java', '.cpp', '.go',\n        ]\n        \n        # æ£€æŸ¥æ˜¯å¦åŒ…å«ä»£ç å…³é”®è¯\n        has_code_keywords = any(keyword in instruction_lower for keyword in code_keywords)\n        \n        # æ£€æŸ¥æ˜¯å¦æ˜¯çº¯é—²èŠ\n        is_chat = any(pattern in instruction_lower for pattern in chat_patterns)\n        \n        # å¦‚æœæ˜¯é—²èŠä¸”æ²¡æœ‰ä»£ç å…³é”®è¯ï¼Œåˆ¤å®šä¸ºé—²èŠ\n        if is_chat and not has_code_keywords:\n            return RequestType.CHAT\n        \n        # å¦‚æœæŒ‡ä»¤å¾ˆçŸ­ä¸”æ²¡æœ‰ä»£ç å…³é”®è¯ï¼Œå¯èƒ½æ˜¯é—²èŠ\n        if len(instruction) < 30 and not has_code_keywords:\n            # è¿›ä¸€æ­¥æ£€æŸ¥æ˜¯å¦åŒ…å«ç–‘é—®è¯\n            question_words = ['what', 'how', 'why', 'when', 'where', 'who',\n                            'ä»€ä¹ˆ', 'æ€ä¹ˆ', 'ä¸ºä»€ä¹ˆ', 'ä½•æ—¶', 'å“ªé‡Œ', 'è°']\n            has_question = any(word in instruction_lower for word in question_words)\n            \n            # å¦‚æœæœ‰ç–‘é—®è¯ä½†æ²¡æœ‰ä»£ç å…³é”®è¯ï¼Œå¯èƒ½æ˜¯é—²èŠ\n            if has_question and not has_code_keywords:\n                return RequestType.CHAT\n        \n        # ä»¥ä¸‹æ˜¯ä»£ç ç›¸å…³çš„åˆ†ç±»\n        \n        # æ£€æŸ¥GitHubå·¥ä½œæ¨¡å¼\n        github_patterns = [\n            'look into',\n            'create pr',\n            'make pr',\n            'investigate',\n            '@',  # æåŠ\n        ]\n        if any(pattern in instruction_lower for pattern in github_patterns):\n            return RequestType.GITHUB_WORK\n        \n        # æ£€æŸ¥æ¢ç´¢æ€§ä»»åŠ¡\n        exploratory_patterns = [\n            'how does',\n            'find',\n            'search',\n            'locate',\n            'å¦‚ä½•',\n            'æŸ¥æ‰¾',\n            'æœç´¢',\n        ]\n        if any(pattern in instruction_lower for pattern in exploratory_patterns) and has_code_keywords:\n            return RequestType.EXPLORATORY\n        \n        # æ£€æŸ¥å¼€æ”¾æ€§ä»»åŠ¡\n        open_ended_patterns = [\n            'improve',\n            'refactor',\n            'add feature',\n            'optimize',\n            'æ”¹è¿›',\n            'é‡æ„',\n            'æ·»åŠ åŠŸèƒ½',\n            'ä¼˜åŒ–',\n        ]\n        if any(pattern in instruction_lower for pattern in open_ended_patterns):\n            return RequestType.OPEN_ENDED\n        \n        # æ£€æŸ¥æ˜ç¡®ä»»åŠ¡\n        explicit_patterns = [\n            'file:',\n            'line:',\n            'function:',\n            'class:',\n        ]\n        if any(pattern in instruction_lower for pattern in explicit_patterns):\n            return RequestType.EXPLICIT\n        \n        # æ£€æŸ¥ç®€å•ä»»åŠ¡ï¼ˆä»£ç ç›¸å…³çš„ç®€å•æ“ä½œï¼‰\n        trivial_patterns = [\n            'add comment', 'remove comment', 'æ·»åŠ æ³¨é‡Š', 'åˆ é™¤æ³¨é‡Š',\n            'rename', 'é‡å‘½å',\n            'format', 'æ ¼å¼åŒ–',\n        ]\n        if any(pattern in instruction_lower for pattern in trivial_patterns):\n            return RequestType.TRIVIAL\n        \n        # æ£€æŸ¥ç®€å•ä»»åŠ¡ï¼ˆæŒ‡ä»¤çŸ­ä¸”æœ‰ä»£ç å…³é”®è¯ï¼‰\n        if len(instruction) < 50 and has_code_keywords:\n            return RequestType.TRIVIAL\n        \n        # é»˜è®¤ä¸ºæ¨¡ç³Šä»»åŠ¡\n        return RequestType.AMBIGUOUS\n    \n    @classmethod"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 280,
"end": 285,
"text": "    def get_action_for_request(cls, request_type: RequestType) -> str:\n        \"\"\"è·å–è¯·æ±‚ç±»å‹å¯¹åº”çš„è¡ŒåŠ¨\"\"\"\n        phase_guide = cls.get_phase_guide(Phase.INTENT_GATE)\n        return phase_guide['decision_rules'].get(request_type, 'ask_clarification')\n    \n    @classmethod"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 286,
"end": 368,
"text": "    def get_action(cls, request_type: RequestType) -> Dict[str, Any]:\n        \"\"\"\n        è·å–è¯·æ±‚ç±»å‹çš„è¯¦ç»†è¡ŒåŠ¨æŒ‡å—\n        \n        Returns:\n            {\n                'action': str,           # è¡ŒåŠ¨ç±»å‹\n                'description': str,      # æè¿°\n                'skip_steps': List[str], # å¯ä»¥è·³è¿‡çš„æ­¥éª¤\n                'required_steps': List[str], # å¿…é¡»çš„æ­¥éª¤\n            }\n        \"\"\"\n        action_guides = {\n            RequestType.CHAT: {\n                'action': 'respond_directly',\n                'description': 'è¿™æ˜¯é—²èŠï¼Œç›´æ¥å›å¤å³å¯',\n                'skip_steps': [\n                    'ä»£ç åº“è¯„ä¼°',\n                    'æ™ºèƒ½ä¸Šä¸‹æ–‡é€‰æ‹©',\n                    'æ‰§è¡Œè§„åˆ’',\n                    'æƒé™æ£€æŸ¥',\n                    'ç‹¬ç«‹éªŒè¯',\n                ],\n                'required_steps': [\n                    'è®°å¿†åŠ è½½ï¼ˆäº†è§£ç”¨æˆ·å†å²ï¼‰',\n                    'ç›´æ¥å›å¤',\n                ],\n                'use_simple_flow': True,\n            },\n            RequestType.SKILL_MATCH: {\n                'action': 'invoke_skill_immediately',\n                'description': 'åŒ¹é…åˆ°Skillï¼Œç«‹å³è°ƒç”¨',\n                'skip_steps': ['æ™ºèƒ½è·¯ç”±'],\n                'required_steps': ['æ‰§è¡ŒSkill'],\n                'use_simple_flow': False,\n            },\n            RequestType.TRIVIAL: {\n                'action': 'use_direct_tools',\n                'description': 'ç®€å•ä»»åŠ¡ï¼Œç›´æ¥ä½¿ç”¨å·¥å…·',\n                'skip_steps': ['æ‰§è¡Œè§„åˆ’', 'ä»£ç åº“è¯„ä¼°'],\n                'required_steps': ['æƒé™æ£€æŸ¥', 'æ‰§è¡Œå·¥å…·'],\n                'use_simple_flow': False,\n            },\n            RequestType.EXPLICIT: {\n                'action': 'execute_directly',\n                'description': 'æ˜ç¡®ä»»åŠ¡ï¼Œç›´æ¥æ‰§è¡Œ',\n                'skip_steps': ['ä»£ç åº“è¯„ä¼°'],\n                'required_steps': ['æƒé™æ£€æŸ¥', 'æ‰§è¡Œ', 'éªŒè¯'],\n                'use_simple_flow': False,\n            },\n            RequestType.EXPLORATORY: {\n                'action': 'fire_explore_parallel',\n                'description': 'æ¢ç´¢æ€§ä»»åŠ¡ï¼Œå¹¶è¡Œæ¢ç´¢',\n                'skip_steps': [],\n                'required_steps': ['å¹¶è¡Œæ¢ç´¢', 'ç»“æœèšåˆ'],\n                'use_simple_flow': False,\n            },\n            RequestType.OPEN_ENDED: {\n                'action': 'assess_codebase_first',\n                'description': 'å¼€æ”¾æ€§ä»»åŠ¡ï¼Œå…ˆè¯„ä¼°ä»£ç åº“',\n                'skip_steps': [],\n                'required_steps': ['ä»£ç åº“è¯„ä¼°', 'æ‰§è¡Œè§„åˆ’', 'æ‰§è¡Œ', 'éªŒè¯'],\n                'use_simple_flow': False,\n            },\n            RequestType.GITHUB_WORK: {\n                'action': 'full_cycle_workflow',\n                'description': 'GitHubå·¥ä½œï¼Œå®Œæ•´æµç¨‹',\n                'skip_steps': [],\n                'required_steps': ['æ‰€æœ‰æ­¥éª¤'],\n                'use_simple_flow': False,\n            },\n            RequestType.AMBIGUOUS: {\n                'action': 'ask_clarification',\n                'description': 'æ¨¡ç³Šä»»åŠ¡ï¼Œéœ€è¦æ¾„æ¸…',\n                'skip_steps': ['æ‰€æœ‰æ‰§è¡Œæ­¥éª¤'],\n                'required_steps': ['æ¾„æ¸…é—®é¢˜'],\n                'use_simple_flow': True,\n            },\n        }\n        \n        return action_guides.get(request_type, action_guides[RequestType.AMBIGUOUS])\n    \n    @classmethod"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 369,
"end": 402,
"text": "    def should_ask_clarification(\n        cls,\n        instruction: str,\n        multiple_interpretations: bool = False,\n        effort_difference: float = 1.0,\n        missing_critical_info: bool = False\n    ) -> bool:\n        \"\"\"\n        åˆ¤æ–­æ˜¯å¦éœ€è¦æ¾„æ¸…\n        \n        Args:\n            instruction: æŒ‡ä»¤\n            multiple_interpretations: æ˜¯å¦æœ‰å¤šç§è§£é‡Š\n            effort_difference: ä¸åŒè§£é‡Šçš„å·¥ä½œé‡å·®å¼‚ï¼ˆå€æ•°ï¼‰\n            missing_critical_info: æ˜¯å¦ç¼ºå°‘å…³é”®ä¿¡æ¯\n        \n        Returns:\n            æ˜¯å¦éœ€è¦æ¾„æ¸…\n        \"\"\"\n        # ç¼ºå°‘å…³é”®ä¿¡æ¯ï¼Œå¿…é¡»è¯¢é—®\n        if missing_critical_info:\n            return True\n        \n        # å¤šç§è§£é‡Šä¸”å·¥ä½œé‡å·®å¼‚å¤§ï¼ˆ2å€ä»¥ä¸Šï¼‰ï¼Œå¿…é¡»è¯¢é—®\n        if multiple_interpretations and effort_difference >= 2.0:\n            return True\n        \n        # æŒ‡ä»¤å¤ªçŸ­ä¸”æ¨¡ç³Š\n        if len(instruction) < 20 and cls.classify_request(instruction) == RequestType.AMBIGUOUS:\n            return True\n        \n        return False\n    \n    @classmethod"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 403,
"end": 441,
"text": "    def format_clarification_question(\n        cls,\n        understood: str,\n        unsure_about: str,\n        options: List[Dict[str, str]],\n        recommendation: Optional[str] = None\n    ) -> str:\n        \"\"\"\n        æ ¼å¼åŒ–æ¾„æ¸…é—®é¢˜\n        \n        Args:\n            understood: ç†è§£çš„å†…å®¹\n            unsure_about: ä¸ç¡®å®šçš„å†…å®¹\n            options: é€‰é¡¹åˆ—è¡¨ [{'option': '...', 'implications': '...'}]\n            recommendation: æ¨èæ–¹æ¡ˆ\n        \"\"\"\n        lines = [\n            \"æˆ‘æƒ³ç¡®ä¿æˆ‘ç†è§£æ­£ç¡®ã€‚\",\n            \"\",\n            f\"**æˆ‘ç†è§£çš„å†…å®¹**: {understood}\",\n            f\"**æˆ‘ä¸ç¡®å®šçš„å†…å®¹**: {unsure_about}\",\n            \"\",\n            \"**æˆ‘çœ‹åˆ°çš„é€‰é¡¹**:\",\n        ]\n        \n        for i, option in enumerate(options, 1):\n            lines.append(f\"{i}. {option['option']} - {option['implications']}\")\n        \n        if recommendation:\n            lines.append(\"\")\n            lines.append(f\"**æˆ‘çš„å»ºè®®**: {recommendation}\")\n        \n        lines.append(\"\")\n        lines.append(\"æ‚¨å¸Œæœ›æˆ‘æŒ‰ç…§å“ªä¸ªæ–¹æ¡ˆè¿›è¡Œï¼Ÿ\")\n        \n        return \"\\n\".join(lines)\n\n\n# ä¾¿æ·å‡½æ•°"
},
{
"path": "daoyoucode/agents/core/behavior_guide.py",
"start": 442,
"end": 444,
"text": "def get_behavior_guide() -> BehaviorGuide:\n    \"\"\"è·å–è¡Œä¸ºæŒ‡å—å®ä¾‹\"\"\"\n    return BehaviorGuide()"
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 1,
"end": 16,
"text": "\"\"\"\nç®€å•ç¼“å­˜å±‚\n\næä¾›å¸¦TTLçš„å†…å­˜ç¼“å­˜ï¼Œå‡å°‘æ–‡ä»¶I/O\n\"\"\"\n\nimport time\nimport logging\nfrom typing import Any, Optional, Dict, Callable\nfrom dataclasses import dataclass\nfrom threading import Lock\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 17,
"end": 22,
"text": "class CacheEntry:\n    \"\"\"ç¼“å­˜æ¡ç›®\"\"\"\n    value: Any\n    timestamp: float\n    ttl: int  # ç§’\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 23,
"end": 27,
"text": "    def is_expired(self) -> bool:\n        \"\"\"æ˜¯å¦è¿‡æœŸ\"\"\"\n        return time.time() - self.timestamp > self.ttl\n\n"
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 28,
"end": 44,
"text": "class SimpleCache:\n    \"\"\"\n    ç®€å•çš„å†…å­˜ç¼“å­˜ï¼ˆå¸¦TTLï¼‰\n    \n    ç‰¹æ€§ï¼š\n    1. æ”¯æŒTTLï¼ˆè¿‡æœŸæ—¶é—´ï¼‰\n    2. çº¿ç¨‹å®‰å…¨\n    3. è‡ªåŠ¨æ¸…ç†è¿‡æœŸæ¡ç›®\n    4. æ”¯æŒå‘½åç©ºé—´\n    5. ç»Ÿè®¡ä¿¡æ¯\n    \n    ä½¿ç”¨åœºæ™¯ï¼š\n    - ç”¨æˆ·ç”»åƒç¼“å­˜ï¼ˆTTL: 1å°æ—¶ï¼‰\n    - å¯¹è¯æ‘˜è¦ç¼“å­˜ï¼ˆTTL: 30åˆ†é’Ÿï¼‰\n    - ä¼šè¯å†å²ç¼“å­˜ï¼ˆTTL: 5åˆ†é’Ÿï¼‰\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 45,
"end": 68,
"text": "    def __init__(self, default_ttl: int = 300, max_size: int = 1000):\n        \"\"\"\n        åˆå§‹åŒ–ç¼“å­˜\n        \n        Args:\n            default_ttl: é»˜è®¤TTLï¼ˆç§’ï¼‰ï¼Œé»˜è®¤5åˆ†é’Ÿ\n            max_size: æœ€å¤§ç¼“å­˜æ¡ç›®æ•°\n        \"\"\"\n        self._cache: Dict[str, CacheEntry] = {}\n        self._lock = Lock()\n        self._default_ttl = default_ttl\n        self._max_size = max_size\n        \n        # ç»Ÿè®¡ä¿¡æ¯\n        self._stats = {\n            'hits': 0,\n            'misses': 0,\n            'sets': 0,\n            'deletes': 0,\n            'evictions': 0,\n        }\n        \n        logger.info(f\"ç¼“å­˜å·²åˆå§‹åŒ–: default_ttl={default_ttl}s, max_size={max_size}\")\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 69,
"end": 101,
"text": "    def get(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        è·å–ç¼“å­˜å€¼\n        \n        Args:\n            key: ç¼“å­˜é”®\n            default: é»˜è®¤å€¼ï¼ˆå¦‚æœä¸å­˜åœ¨æˆ–è¿‡æœŸï¼‰\n        \n        Returns:\n            ç¼“å­˜å€¼æˆ–é»˜è®¤å€¼\n        \"\"\"\n        with self._lock:\n            if key in self._cache:\n                entry = self._cache[key]\n                \n                # æ£€æŸ¥æ˜¯å¦è¿‡æœŸ\n                if entry.is_expired():\n                    # è¿‡æœŸï¼Œåˆ é™¤\n                    del self._cache[key]\n                    self._stats['misses'] += 1\n                    logger.debug(f\"ç¼“å­˜è¿‡æœŸ: {key}\")\n                    return default\n                \n                # å‘½ä¸­\n                self._stats['hits'] += 1\n                logger.debug(f\"ç¼“å­˜å‘½ä¸­: {key}\")\n                return entry.value\n            \n            # æœªå‘½ä¸­\n            self._stats['misses'] += 1\n            logger.debug(f\"ç¼“å­˜æœªå‘½ä¸­: {key}\")\n            return default\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 102,
"end": 125,
"text": "    def set(self, key: str, value: Any, ttl: Optional[int] = None):\n        \"\"\"\n        è®¾ç½®ç¼“å­˜å€¼\n        \n        Args:\n            key: ç¼“å­˜é”®\n            value: ç¼“å­˜å€¼\n            ttl: TTLï¼ˆç§’ï¼‰ï¼Œå¦‚æœä¸ºNoneåˆ™ä½¿ç”¨é»˜è®¤TTL\n        \"\"\"\n        with self._lock:\n            # æ£€æŸ¥æ˜¯å¦éœ€è¦æ¸…ç†\n            if len(self._cache) >= self._max_size:\n                self._evict_oldest()\n            \n            # è®¾ç½®ç¼“å­˜\n            self._cache[key] = CacheEntry(\n                value=value,\n                timestamp=time.time(),\n                ttl=ttl if ttl is not None else self._default_ttl\n            )\n            \n            self._stats['sets'] += 1\n            logger.debug(f\"ç¼“å­˜è®¾ç½®: {key}, ttl={ttl or self._default_ttl}s\")\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 126,
"end": 143,
"text": "    def delete(self, key: str) -> bool:\n        \"\"\"\n        åˆ é™¤ç¼“å­˜å€¼\n        \n        Args:\n            key: ç¼“å­˜é”®\n        \n        Returns:\n            æ˜¯å¦åˆ é™¤æˆåŠŸ\n        \"\"\"\n        with self._lock:\n            if key in self._cache:\n                del self._cache[key]\n                self._stats['deletes'] += 1\n                logger.debug(f\"ç¼“å­˜åˆ é™¤: {key}\")\n                return True\n            return False\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 144,
"end": 150,
"text": "    def clear(self):\n        \"\"\"æ¸…ç©ºç¼“å­˜\"\"\"\n        with self._lock:\n            count = len(self._cache)\n            self._cache.clear()\n            logger.info(f\"ç¼“å­˜å·²æ¸…ç©º: {count} æ¡ç›®\")\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 151,
"end": 179,
"text": "    def get_or_set(\n        self,\n        key: str,\n        factory: Callable[[], Any],\n        ttl: Optional[int] = None\n    ) -> Any:\n        \"\"\"\n        è·å–ç¼“å­˜å€¼ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è°ƒç”¨factoryç”Ÿæˆå¹¶ç¼“å­˜\n        \n        Args:\n            key: ç¼“å­˜é”®\n            factory: ç”Ÿæˆå€¼çš„å‡½æ•°\n            ttl: TTLï¼ˆç§’ï¼‰\n        \n        Returns:\n            ç¼“å­˜å€¼\n        \"\"\"\n        # å…ˆå°è¯•è·å–\n        value = self.get(key)\n        if value is not None:\n            return value\n        \n        # ä¸å­˜åœ¨ï¼Œç”Ÿæˆå¹¶ç¼“å­˜\n        value = factory()\n        if value is not None:\n            self.set(key, value, ttl)\n        \n        return value\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 180,
"end": 194,
"text": "    def _evict_oldest(self):\n        \"\"\"é©±é€æœ€è€çš„æ¡ç›®\"\"\"\n        if not self._cache:\n            return\n        \n        # æ‰¾åˆ°æœ€è€çš„æ¡ç›®\n        oldest_key = min(\n            self._cache.keys(),\n            key=lambda k: self._cache[k].timestamp\n        )\n        \n        del self._cache[oldest_key]\n        self._stats['evictions'] += 1\n        logger.debug(f\"ç¼“å­˜é©±é€: {oldest_key}\")\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 195,
"end": 215,
"text": "    def cleanup_expired(self) -> int:\n        \"\"\"\n        æ¸…ç†æ‰€æœ‰è¿‡æœŸæ¡ç›®\n        \n        Returns:\n            æ¸…ç†çš„æ¡ç›®æ•°\n        \"\"\"\n        with self._lock:\n            expired_keys = [\n                key for key, entry in self._cache.items()\n                if entry.is_expired()\n            ]\n            \n            for key in expired_keys:\n                del self._cache[key]\n            \n            if expired_keys:\n                logger.info(f\"æ¸…ç†è¿‡æœŸç¼“å­˜: {len(expired_keys)} æ¡ç›®\")\n            \n            return len(expired_keys)\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 216,
"end": 237,
"text": "    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        è·å–ç»Ÿè®¡ä¿¡æ¯\n        \n        Returns:\n            ç»Ÿè®¡ä¿¡æ¯å­—å…¸\n        \"\"\"\n        with self._lock:\n            total_requests = self._stats['hits'] + self._stats['misses']\n            hit_rate = (\n                self._stats['hits'] / total_requests * 100\n                if total_requests > 0 else 0\n            )\n            \n            return {\n                **self._stats,\n                'size': len(self._cache),\n                'max_size': self._max_size,\n                'hit_rate': f\"{hit_rate:.1f}%\",\n                'total_requests': total_requests,\n            }\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 238,
"end": 241,
"text": "    def __len__(self) -> int:\n        \"\"\"ç¼“å­˜å¤§å°\"\"\"\n        return len(self._cache)\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 242,
"end": 246,
"text": "    def __contains__(self, key: str) -> bool:\n        \"\"\"æ˜¯å¦åŒ…å«é”®ï¼ˆä¸æ£€æŸ¥è¿‡æœŸï¼‰\"\"\"\n        return key in self._cache\n\n"
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 247,
"end": 253,
"text": "class NamespacedCache:\n    \"\"\"\n    å¸¦å‘½åç©ºé—´çš„ç¼“å­˜\n    \n    ç”¨äºéš”ç¦»ä¸åŒç±»å‹çš„ç¼“å­˜æ•°æ®\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 254,
"end": 264,
"text": "    def __init__(self, cache: SimpleCache, namespace: str):\n        \"\"\"\n        åˆå§‹åŒ–å‘½åç©ºé—´ç¼“å­˜\n        \n        Args:\n            cache: åº•å±‚ç¼“å­˜å®ä¾‹\n            namespace: å‘½åç©ºé—´\n        \"\"\"\n        self._cache = cache\n        self._namespace = namespace\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 265,
"end": 268,
"text": "    def _make_key(self, key: str) -> str:\n        \"\"\"ç”Ÿæˆå¸¦å‘½åç©ºé—´çš„é”®\"\"\"\n        return f\"{self._namespace}:{key}\"\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 269,
"end": 272,
"text": "    def get(self, key: str, default: Any = None) -> Any:\n        \"\"\"è·å–ç¼“å­˜å€¼\"\"\"\n        return self._cache.get(self._make_key(key), default)\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 273,
"end": 276,
"text": "    def set(self, key: str, value: Any, ttl: Optional[int] = None):\n        \"\"\"è®¾ç½®ç¼“å­˜å€¼\"\"\"\n        self._cache.set(self._make_key(key), value, ttl)\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 277,
"end": 280,
"text": "    def delete(self, key: str) -> bool:\n        \"\"\"åˆ é™¤ç¼“å­˜å€¼\"\"\"\n        return self._cache.delete(self._make_key(key))\n    "
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 281,
"end": 294,
"text": "    def get_or_set(\n        self,\n        key: str,\n        factory: Callable[[], Any],\n        ttl: Optional[int] = None\n    ) -> Any:\n        \"\"\"è·å–æˆ–è®¾ç½®ç¼“å­˜å€¼\"\"\"\n        return self._cache.get_or_set(self._make_key(key), factory, ttl)\n\n\n# å…¨å±€ç¼“å­˜å®ä¾‹\n_global_cache: Optional[SimpleCache] = None\n\n"
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 295,
"end": 313,
"text": "def get_cache() -> SimpleCache:\n    \"\"\"\n    è·å–å…¨å±€ç¼“å­˜å®ä¾‹ï¼ˆå•ä¾‹ï¼‰\n    \n    Returns:\n        SimpleCacheå®ä¾‹\n    \"\"\"\n    global _global_cache\n    \n    if _global_cache is None:\n        _global_cache = SimpleCache(\n            default_ttl=300,  # 5åˆ†é’Ÿ\n            max_size=1000\n        )\n        logger.info(\"å…¨å±€ç¼“å­˜å·²åˆ›å»º\")\n    \n    return _global_cache\n\n"
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 314,
"end": 328,
"text": "def get_namespaced_cache(namespace: str) -> NamespacedCache:\n    \"\"\"\n    è·å–å‘½åç©ºé—´ç¼“å­˜\n    \n    Args:\n        namespace: å‘½åç©ºé—´åç§°\n    \n    Returns:\n        NamespacedCacheå®ä¾‹\n    \"\"\"\n    cache = get_cache()\n    return NamespacedCache(cache, namespace)\n\n\n# é¢„å®šä¹‰çš„å‘½åç©ºé—´ç¼“å­˜"
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 329,
"end": 333,
"text": "def get_profile_cache() -> NamespacedCache:\n    \"\"\"è·å–ç”¨æˆ·ç”»åƒç¼“å­˜ï¼ˆTTL: 1å°æ—¶ï¼‰\"\"\"\n    return get_namespaced_cache(\"profile\")\n\n"
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 334,
"end": 338,
"text": "def get_summary_cache() -> NamespacedCache:\n    \"\"\"è·å–æ‘˜è¦ç¼“å­˜ï¼ˆTTL: 30åˆ†é’Ÿï¼‰\"\"\"\n    return get_namespaced_cache(\"summary\")\n\n"
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 339,
"end": 343,
"text": "def get_history_cache() -> NamespacedCache:\n    \"\"\"è·å–å†å²ç¼“å­˜ï¼ˆTTL: 5åˆ†é’Ÿï¼‰\"\"\"\n    return get_namespaced_cache(\"history\")\n\n"
},
{
"path": "daoyoucode/agents/core/cache.py",
"start": 344,
"end": 346,
"text": "def get_preference_cache() -> NamespacedCache:\n    \"\"\"è·å–åå¥½ç¼“å­˜ï¼ˆTTL: 1å°æ—¶ï¼‰\"\"\"\n    return get_namespaced_cache(\"preference\")"
},
{
"path": "daoyoucode/agents/core/codebase_assessor.py",
"start": 1,
"end": 15,
"text": "\"\"\"\nä»£ç åº“è¯„ä¼°å™¨\n\nè¯„ä¼°ä»£ç åº“æˆç†Ÿåº¦å’ŒçŠ¶æ€ã€‚\nçµæ„Ÿæ¥æºï¼šoh-my-opencodeçš„Codebase Assessment\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Dict, Any\nimport logging\nfrom .behavior_guide import CodebaseState\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/codebase_assessor.py",
"start": 16,
"end": 18,
"text": "class CodebaseAssessor:\n    \"\"\"ä»£ç åº“è¯„ä¼°å™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/codebase_assessor.py",
"start": 19,
"end": 21,
"text": "    def __init__(self, repo_path: Path):\n        self.repo_path = Path(repo_path)\n    "
},
{
"path": "daoyoucode/agents/core/codebase_assessor.py",
"start": 22,
"end": 48,
"text": "    def assess(self) -> CodebaseState:\n        \"\"\"è¯„ä¼°ä»£ç åº“çŠ¶æ€\"\"\"\n        # 1. æ£€æŸ¥é…ç½®æ–‡ä»¶\n        has_linter = self._check_linter_config()\n        has_formatter = self._check_formatter_config()\n        has_type_config = self._check_type_config()\n        \n        # 2. æ£€æŸ¥æµ‹è¯•\n        has_tests = self._check_tests()\n        \n        # 3. æ£€æŸ¥ä¾èµ–\n        dependency_age = self._check_dependency_age()\n        \n        # 4. åˆ†ç±»\n        config_score = sum([has_linter, has_formatter, has_type_config])\n        \n        if config_score >= 2 and has_tests:\n            return CodebaseState.DISCIPLINED\n        elif config_score >= 1:\n            return CodebaseState.TRANSITIONAL\n        elif dependency_age > 3:\n            return CodebaseState.LEGACY\n        elif not list(self.repo_path.rglob('*.py')):\n            return CodebaseState.GREENFIELD\n        else:\n            return CodebaseState.CHAOTIC\n    "
},
{
"path": "daoyoucode/agents/core/codebase_assessor.py",
"start": 49,
"end": 74,
"text": "    def get_behavior_guide(self, state: CodebaseState) -> Dict[str, str]:\n        \"\"\"æ ¹æ®çŠ¶æ€è·å–è¡Œä¸ºæŒ‡å—\"\"\"\n        guides = {\n            CodebaseState.DISCIPLINED: {\n                'approach': 'follow_existing_patterns',\n                'message': 'ä»£ç åº“è§„èŒƒè‰¯å¥½ï¼Œä¸¥æ ¼éµå¾ªç°æœ‰é£æ ¼',\n            },\n            CodebaseState.TRANSITIONAL: {\n                'approach': 'ask_user',\n                'message': 'ä»£ç åº“å­˜åœ¨å¤šç§æ¨¡å¼ï¼Œè¯·é€‰æ‹©è¦éµå¾ªçš„æ¨¡å¼',\n            },\n            CodebaseState.LEGACY: {\n                'approach': 'modernize',\n                'message': 'ä»£ç åº“è¾ƒæ—§ï¼Œå»ºè®®åº”ç”¨ç°ä»£æœ€ä½³å®è·µ',\n            },\n            CodebaseState.CHAOTIC: {\n                'approach': 'propose_standards',\n                'message': 'ä»£ç åº“ç¼ºä¹è§„èŒƒï¼Œå»ºè®®å¼•å…¥æ ‡å‡†',\n            },\n            CodebaseState.GREENFIELD: {\n                'approach': 'modern_standards',\n                'message': 'æ–°é¡¹ç›®ï¼Œåº”ç”¨ç°ä»£æœ€ä½³å®è·µ',\n            },\n        }\n        return guides[state]\n    "
},
{
"path": "daoyoucode/agents/core/codebase_assessor.py",
"start": 75,
"end": 79,
"text": "    def _check_linter_config(self) -> bool:\n        \"\"\"æ£€æŸ¥linteré…ç½®\"\"\"\n        configs = ['.pylintrc', '.flake8', 'pyproject.toml', '.eslintrc', '.eslintrc.json']\n        return any((self.repo_path / config).exists() for config in configs)\n    "
},
{
"path": "daoyoucode/agents/core/codebase_assessor.py",
"start": 80,
"end": 84,
"text": "    def _check_formatter_config(self) -> bool:\n        \"\"\"æ£€æŸ¥formatteré…ç½®\"\"\"\n        configs = ['.black', 'pyproject.toml', '.prettierrc', '.prettierrc.json']\n        return any((self.repo_path / config).exists() for config in configs)\n    "
},
{
"path": "daoyoucode/agents/core/codebase_assessor.py",
"start": 85,
"end": 89,
"text": "    def _check_type_config(self) -> bool:\n        \"\"\"æ£€æŸ¥ç±»å‹é…ç½®\"\"\"\n        configs = ['mypy.ini', 'pyproject.toml', 'tsconfig.json']\n        return any((self.repo_path / config).exists() for config in configs)\n    "
},
{
"path": "daoyoucode/agents/core/codebase_assessor.py",
"start": 90,
"end": 94,
"text": "    def _check_tests(self) -> bool:\n        \"\"\"æ£€æŸ¥æµ‹è¯•\"\"\"\n        test_dirs = ['tests', 'test', '__tests__']\n        return any((self.repo_path / test_dir).exists() for test_dir in test_dirs)\n    "
},
{
"path": "daoyoucode/agents/core/codebase_assessor.py",
"start": 95,
"end": 106,
"text": "    def _check_dependency_age(self) -> int:\n        \"\"\"æ£€æŸ¥ä¾èµ–å¹´é¾„ï¼ˆç®€åŒ–ç‰ˆï¼‰\"\"\"\n        # ç®€åŒ–å®ç°ï¼šæ£€æŸ¥requirements.txtæˆ–package.jsonçš„ä¿®æ”¹æ—¶é—´\n        dep_files = ['requirements.txt', 'package.json', 'Pipfile']\n        for dep_file in dep_files:\n            file_path = self.repo_path / dep_file\n            if file_path.exists():\n                import time\n                mtime = file_path.stat().st_mtime\n                age_years = (time.time() - mtime) / (365 * 24 * 3600)\n                return int(age_years)\n        return 0"
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 1,
"end": 26,
"text": "\"\"\"\nä¸Šä¸‹æ–‡ç®¡ç†å™¨\n\næä¾›ç»“æ„åŒ–çš„ä¸Šä¸‹æ–‡ç®¡ç†ï¼Œæ”¯æŒï¼š\n1. ä¸Šä¸‹æ–‡ç”Ÿå‘½å‘¨æœŸç®¡ç†\n2. ä¸Šä¸‹æ–‡ç‰ˆæœ¬æ§åˆ¶ï¼ˆå¿«ç…§å’Œå›æ»šï¼‰\n3. ä¸Šä¸‹æ–‡å˜é‡è¿½è¸ª\n4. ä¸Šä¸‹æ–‡å†å²è®°å½•\n5. RepoMapé›†æˆï¼ˆæ™ºèƒ½æ·»åŠ ç›¸å…³ä»£ç ï¼‰\n6. Tokené¢„ç®—æ§åˆ¶ï¼ˆæ™ºèƒ½å‰ªæï¼‰\n7. æ™ºèƒ½æ‘˜è¦ï¼ˆLLMå‹ç¼©ï¼‰\n\"\"\"\n\nfrom typing import Dict, Any, Optional, List, Tuple\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom copy import deepcopy\nimport uuid\nimport logging\nimport asyncio\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 27,
"end": 33,
"text": "class ContextSnapshot:\n    \"\"\"ä¸Šä¸‹æ–‡å¿«ç…§\"\"\"\n    id: str\n    variables: Dict[str, Any]\n    timestamp: datetime\n    description: str = \"\"\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 34,
"end": 44,
"text": "    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"è½¬æ¢ä¸ºå­—å…¸\"\"\"\n        return {\n            'id': self.id,\n            'variables': self.variables,\n            'timestamp': self.timestamp.isoformat(),\n            'description': self.description\n        }\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 45,
"end": 52,
"text": "class ContextChange:\n    \"\"\"ä¸Šä¸‹æ–‡å˜æ›´è®°å½•\"\"\"\n    key: str\n    old_value: Any\n    new_value: Any\n    timestamp: datetime\n    operation: str  # set, delete, update\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 53,
"end": 63,
"text": "    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"è½¬æ¢ä¸ºå­—å…¸\"\"\"\n        return {\n            'key': self.key,\n            'old_value': str(self.old_value)[:100] if self.old_value else None,\n            'new_value': str(self.new_value)[:100] if self.new_value else None,\n            'timestamp': self.timestamp.isoformat(),\n            'operation': self.operation\n        }\n\n"
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 64,
"end": 74,
"text": "class Context:\n    \"\"\"\n    ç»“æ„åŒ–ä¸Šä¸‹æ–‡\n    \n    åŠŸèƒ½ï¼š\n    1. å˜é‡ç®¡ç†\n    2. å¿«ç…§å’Œå›æ»š\n    3. å˜æ›´å†å²\n    4. åµŒå¥—ä¸Šä¸‹æ–‡\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 75,
"end": 112,
"text": "    def __init__(\n        self,\n        session_id: str,\n        parent: Optional['Context'] = None,\n        max_history: int = 100,\n        max_snapshots: int = 10\n    ):\n        \"\"\"\n        åˆå§‹åŒ–ä¸Šä¸‹æ–‡\n        \n        Args:\n            session_id: ä¼šè¯ID\n            parent: çˆ¶ä¸Šä¸‹æ–‡ï¼ˆæ”¯æŒåµŒå¥—ï¼‰\n            max_history: æœ€å¤§å†å²è®°å½•æ•°\n            max_snapshots: æœ€å¤§å¿«ç…§æ•°\n        \"\"\"\n        self.session_id = session_id\n        self.parent = parent\n        self.max_history = max_history\n        self.max_snapshots = max_snapshots\n        \n        # å˜é‡å­˜å‚¨\n        self.variables: Dict[str, Any] = {}\n        \n        # å˜æ›´å†å²\n        self.history: List[ContextChange] = []\n        \n        # å¿«ç…§åˆ—è¡¨\n        self.snapshots: List[ContextSnapshot] = []\n        \n        # å…ƒæ•°æ®\n        self.metadata: Dict[str, Any] = {\n            'created_at': datetime.now(),\n            'last_modified': datetime.now()\n        }\n        \n        logger.debug(f\"åˆ›å»ºä¸Šä¸‹æ–‡: session={session_id}\")\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 113,
"end": 131,
"text": "    def set(self, key: str, value: Any, track_change: bool = True):\n        \"\"\"\n        è®¾ç½®å˜é‡\n        \n        Args:\n            key: å˜é‡å\n            value: å˜é‡å€¼\n            track_change: æ˜¯å¦è¿½è¸ªå˜æ›´\n        \"\"\"\n        old_value = self.variables.get(key)\n        operation = 'update' if key in self.variables else 'set'\n        \n        self.variables[key] = value\n        self.metadata['last_modified'] = datetime.now()\n        \n        # è®°å½•å˜æ›´\n        if track_change:\n            self._record_change(key, old_value, value, operation)\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 132,
"end": 152,
"text": "    def get(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        è·å–å˜é‡\n        \n        Args:\n            key: å˜é‡å\n            default: é»˜è®¤å€¼\n        \n        Returns:\n            å˜é‡å€¼ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›default\n        \"\"\"\n        # å…ˆæŸ¥æ‰¾å½“å‰ä¸Šä¸‹æ–‡\n        if key in self.variables:\n            return self.variables[key]\n        \n        # å¦‚æœæœ‰çˆ¶ä¸Šä¸‹æ–‡ï¼ŒæŸ¥æ‰¾çˆ¶ä¸Šä¸‹æ–‡\n        if self.parent:\n            return self.parent.get(key, default)\n        \n        return default\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 153,
"end": 169,
"text": "    def delete(self, key: str, track_change: bool = True):\n        \"\"\"\n        åˆ é™¤å˜é‡\n        \n        Args:\n            key: å˜é‡å\n            track_change: æ˜¯å¦è¿½è¸ªå˜æ›´\n        \"\"\"\n        if key in self.variables:\n            old_value = self.variables[key]\n            del self.variables[key]\n            self.metadata['last_modified'] = datetime.now()\n            \n            # è®°å½•å˜æ›´\n            if track_change:\n                self._record_change(key, old_value, None, 'delete')\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 170,
"end": 187,
"text": "    def has(self, key: str) -> bool:\n        \"\"\"\n        æ£€æŸ¥å˜é‡æ˜¯å¦å­˜åœ¨\n        \n        Args:\n            key: å˜é‡å\n        \n        Returns:\n            æ˜¯å¦å­˜åœ¨\n        \"\"\"\n        if key in self.variables:\n            return True\n        \n        if self.parent:\n            return self.parent.has(key)\n        \n        return False\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 188,
"end": 198,
"text": "    def update(self, variables: Dict[str, Any], track_change: bool = True):\n        \"\"\"\n        æ‰¹é‡æ›´æ–°å˜é‡\n        \n        Args:\n            variables: å˜é‡å­—å…¸\n            track_change: æ˜¯å¦è¿½è¸ªå˜æ›´\n        \"\"\"\n        for key, value in variables.items():\n            self.set(key, value, track_change)\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 199,
"end": 212,
"text": "    def clear(self, track_change: bool = True):\n        \"\"\"\n        æ¸…ç©ºæ‰€æœ‰å˜é‡\n        \n        Args:\n            track_change: æ˜¯å¦è¿½è¸ªå˜æ›´\n        \"\"\"\n        if track_change:\n            for key in list(self.variables.keys()):\n                self.delete(key, track_change=True)\n        else:\n            self.variables.clear()\n            self.metadata['last_modified'] = datetime.now()\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 213,
"end": 223,
"text": "    def keys(self) -> List[str]:\n        \"\"\"è·å–æ‰€æœ‰å˜é‡å\"\"\"\n        keys = list(self.variables.keys())\n        \n        # åŒ…å«çˆ¶ä¸Šä¸‹æ–‡çš„key\n        if self.parent:\n            parent_keys = self.parent.keys()\n            keys.extend([k for k in parent_keys if k not in keys])\n        \n        return keys\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 224,
"end": 238,
"text": "    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"è½¬æ¢ä¸ºå­—å…¸\"\"\"\n        result = self.variables.copy()\n        \n        # åŒ…å«çˆ¶ä¸Šä¸‹æ–‡çš„å˜é‡\n        if self.parent:\n            parent_dict = self.parent.to_dict()\n            for key, value in parent_dict.items():\n                if key not in result:\n                    result[key] = value\n        \n        return result\n    \n    # ========== å¿«ç…§å’Œå›æ»š ==========\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 239,
"end": 265,
"text": "    def create_snapshot(self, description: str = \"\") -> str:\n        \"\"\"\n        åˆ›å»ºå¿«ç…§\n        \n        Args:\n            description: å¿«ç…§æè¿°\n        \n        Returns:\n            å¿«ç…§ID\n        \"\"\"\n        snapshot = ContextSnapshot(\n            id=str(uuid.uuid4()),\n            variables=deepcopy(self.variables),\n            timestamp=datetime.now(),\n            description=description\n        )\n        \n        self.snapshots.append(snapshot)\n        \n        # ä¿æŒæœ€å¤§å¿«ç…§æ•°\n        if len(self.snapshots) > self.max_snapshots:\n            self.snapshots = self.snapshots[-self.max_snapshots:]\n        \n        logger.info(f\"åˆ›å»ºå¿«ç…§: {snapshot.id[:8]}... - {description}\")\n        \n        return snapshot.id\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 266,
"end": 300,
"text": "    def rollback_to_snapshot(self, snapshot_id: str) -> bool:\n        \"\"\"\n        å›æ»šåˆ°å¿«ç…§\n        \n        Args:\n            snapshot_id: å¿«ç…§ID\n        \n        Returns:\n            æ˜¯å¦æˆåŠŸ\n        \"\"\"\n        snapshot = next(\n            (s for s in self.snapshots if s.id == snapshot_id),\n            None\n        )\n        \n        if not snapshot:\n            logger.warning(f\"å¿«ç…§ä¸å­˜åœ¨: {snapshot_id}\")\n            return False\n        \n        # å›æ»šå˜é‡\n        self.variables = deepcopy(snapshot.variables)\n        self.metadata['last_modified'] = datetime.now()\n        \n        # è®°å½•å›æ»šæ“ä½œ\n        self._record_change(\n            '__rollback__',\n            None,\n            snapshot_id,\n            'rollback'\n        )\n        \n        logger.info(f\"å›æ»šåˆ°å¿«ç…§: {snapshot_id[:8]}...\")\n        \n        return True\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 301,
"end": 304,
"text": "    def list_snapshots(self) -> List[Dict[str, Any]]:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰å¿«ç…§\"\"\"\n        return [s.to_dict() for s in self.snapshots]\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 305,
"end": 313,
"text": "    def get_snapshot(self, snapshot_id: str) -> Optional[ContextSnapshot]:\n        \"\"\"è·å–å¿«ç…§\"\"\"\n        return next(\n            (s for s in self.snapshots if s.id == snapshot_id),\n            None\n        )\n    \n    # ========== å˜æ›´å†å² ==========\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 314,
"end": 335,
"text": "    def _record_change(\n        self,\n        key: str,\n        old_value: Any,\n        new_value: Any,\n        operation: str\n    ):\n        \"\"\"è®°å½•å˜æ›´\"\"\"\n        change = ContextChange(\n            key=key,\n            old_value=old_value,\n            new_value=new_value,\n            timestamp=datetime.now(),\n            operation=operation\n        )\n        \n        self.history.append(change)\n        \n        # ä¿æŒæœ€å¤§å†å²æ•°\n        if len(self.history) > self.max_history:\n            self.history = self.history[-self.max_history:]\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 336,
"end": 352,
"text": "    def get_history(self, limit: Optional[int] = None) -> List[Dict[str, Any]]:\n        \"\"\"\n        è·å–å˜æ›´å†å²\n        \n        Args:\n            limit: æœ€å¤šè¿”å›å¤šå°‘æ¡\n        \n        Returns:\n            å˜æ›´å†å²åˆ—è¡¨\n        \"\"\"\n        history = self.history\n        \n        if limit:\n            history = history[-limit:]\n        \n        return [c.to_dict() for c in history]\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 353,
"end": 367,
"text": "    def get_changes_for_key(self, key: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        è·å–æŒ‡å®šå˜é‡çš„å˜æ›´å†å²\n        \n        Args:\n            key: å˜é‡å\n        \n        Returns:\n            å˜æ›´å†å²åˆ—è¡¨\n        \"\"\"\n        changes = [c for c in self.history if c.key == key]\n        return [c.to_dict() for c in changes]\n    \n    # ========== åµŒå¥—ä¸Šä¸‹æ–‡ ==========\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 368,
"end": 386,
"text": "    def create_child(self) -> 'Context':\n        \"\"\"\n        åˆ›å»ºå­ä¸Šä¸‹æ–‡\n        \n        Returns:\n            å­ä¸Šä¸‹æ–‡\n        \"\"\"\n        child = Context(\n            session_id=f\"{self.session_id}_child\",\n            parent=self,\n            max_history=self.max_history,\n            max_snapshots=self.max_snapshots\n        )\n        \n        logger.debug(f\"åˆ›å»ºå­ä¸Šä¸‹æ–‡: parent={self.session_id}\")\n        \n        return child\n\n"
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 387,
"end": 399,
"text": "class ContextManager:\n    \"\"\"\n    ä¸Šä¸‹æ–‡ç®¡ç†å™¨\n    \n    èŒè´£ï¼š\n    1. ç®¡ç†å¤šä¸ªä¼šè¯çš„ä¸Šä¸‹æ–‡\n    2. æä¾›ä¸Šä¸‹æ–‡åˆ›å»ºå’Œé”€æ¯\n    3. æä¾›ä¸Šä¸‹æ–‡æŸ¥è¯¢å’Œç»Ÿè®¡\n    4. RepoMapé›†æˆï¼ˆæ™ºèƒ½æ·»åŠ ç›¸å…³ä»£ç ï¼‰\n    5. Tokené¢„ç®—æ§åˆ¶ï¼ˆæ™ºèƒ½å‰ªæï¼‰\n    6. æ™ºèƒ½æ‘˜è¦ï¼ˆLLMå‹ç¼©ï¼‰\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 400,
"end": 424,
"text": "    def __init__(\n        self,\n        max_contexts: int = 1000,\n        default_token_budget: int = 8000,\n        enable_auto_repomap: bool = True\n    ):\n        \"\"\"\n        åˆå§‹åŒ–ä¸Šä¸‹æ–‡ç®¡ç†å™¨\n        \n        Args:\n            max_contexts: æœ€å¤§ä¸Šä¸‹æ–‡æ•°\n            default_token_budget: é»˜è®¤Tokené¢„ç®—\n            enable_auto_repomap: æ˜¯å¦è‡ªåŠ¨æ·»åŠ RepoMap\n        \"\"\"\n        self.max_contexts = max_contexts\n        self.default_token_budget = default_token_budget\n        self.enable_auto_repomap = enable_auto_repomap\n        self.contexts: Dict[str, Context] = {}\n        \n        # å»¶è¿Ÿå¯¼å…¥å·¥å…·ï¼ˆé¿å…å¾ªç¯ä¾èµ–ï¼‰\n        self._repomap_tool = None\n        self._llm_client = None\n        \n        logger.info(\"ä¸Šä¸‹æ–‡ç®¡ç†å™¨å·²åˆå§‹åŒ–\")\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 425,
"end": 455,
"text": "    def create_context(\n        self,\n        session_id: str,\n        parent_session_id: Optional[str] = None\n    ) -> Context:\n        \"\"\"\n        åˆ›å»ºä¸Šä¸‹æ–‡\n        \n        Args:\n            session_id: ä¼šè¯ID\n            parent_session_id: çˆ¶ä¼šè¯IDï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            ä¸Šä¸‹æ–‡\n        \"\"\"\n        # è·å–çˆ¶ä¸Šä¸‹æ–‡\n        parent = None\n        if parent_session_id and parent_session_id in self.contexts:\n            parent = self.contexts[parent_session_id]\n        \n        # åˆ›å»ºä¸Šä¸‹æ–‡\n        context = Context(session_id, parent)\n        self.contexts[session_id] = context\n        \n        # æ¸…ç†æ—§ä¸Šä¸‹æ–‡\n        self._cleanup_old_contexts()\n        \n        logger.info(f\"åˆ›å»ºä¸Šä¸‹æ–‡: {session_id}\")\n        \n        return context\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 456,
"end": 467,
"text": "    def get_context(self, session_id: str) -> Optional[Context]:\n        \"\"\"\n        è·å–ä¸Šä¸‹æ–‡\n        \n        Args:\n            session_id: ä¼šè¯ID\n        \n        Returns:\n            ä¸Šä¸‹æ–‡ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›None\n        \"\"\"\n        return self.contexts.get(session_id)\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 468,
"end": 482,
"text": "    def get_or_create_context(self, session_id: str) -> Context:\n        \"\"\"\n        è·å–æˆ–åˆ›å»ºä¸Šä¸‹æ–‡\n        \n        Args:\n            session_id: ä¼šè¯ID\n        \n        Returns:\n            ä¸Šä¸‹æ–‡\n        \"\"\"\n        if session_id not in self.contexts:\n            return self.create_context(session_id)\n        \n        return self.contexts[session_id]\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 483,
"end": 493,
"text": "    def delete_context(self, session_id: str):\n        \"\"\"\n        åˆ é™¤ä¸Šä¸‹æ–‡\n        \n        Args:\n            session_id: ä¼šè¯ID\n        \"\"\"\n        if session_id in self.contexts:\n            del self.contexts[session_id]\n            logger.info(f\"åˆ é™¤ä¸Šä¸‹æ–‡: {session_id}\")\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 494,
"end": 497,
"text": "    def list_contexts(self) -> List[str]:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰ä¸Šä¸‹æ–‡çš„session_id\"\"\"\n        return list(self.contexts.keys())\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 498,
"end": 524,
"text": "    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        è·å–ç»Ÿè®¡ä¿¡æ¯\n        \n        Returns:\n            ç»Ÿè®¡ä¿¡æ¯\n        \"\"\"\n        total_variables = sum(\n            len(ctx.variables) for ctx in self.contexts.values()\n        )\n        \n        total_snapshots = sum(\n            len(ctx.snapshots) for ctx in self.contexts.values()\n        )\n        \n        total_history = sum(\n            len(ctx.history) for ctx in self.contexts.values()\n        )\n        \n        return {\n            'total_contexts': len(self.contexts),\n            'total_variables': total_variables,\n            'total_snapshots': total_snapshots,\n            'total_history': total_history,\n            'max_contexts': self.max_contexts\n        }\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 525,
"end": 600,
"text": "    def _cleanup_old_contexts(self):\n        \"\"\"æ¸…ç†æ—§ä¸Šä¸‹æ–‡\"\"\"\n        if len(self.contexts) <= self.max_contexts:\n            return\n        \n        # æŒ‰æœ€åä¿®æ”¹æ—¶é—´æ’åº\n        sorted_contexts = sorted(\n            self.contexts.items(),\n            key=lambda x: x[1].metadata['last_modified']\n        )\n        \n        # åˆ é™¤æœ€æ—§çš„ä¸Šä¸‹æ–‡\n        to_delete = len(self.contexts) - self.max_contexts\n        for session_id, _ in sorted_contexts[:to_delete]:\n            del self.contexts[session_id]\n            logger.debug(f\"æ¸…ç†æ—§ä¸Šä¸‹æ–‡: {session_id}\")\n    \n    # ========== RepoMapé›†æˆ ==========\n    \n    async def add_repo_map(\n        self,\n        session_id: str,\n        repo_path: str,\n        chat_files: Optional[List[str]] = None,\n        mentioned_idents: Optional[List[str]] = None,\n        max_tokens: int = 2000\n    ) -> bool:\n        \"\"\"\n        æ·»åŠ RepoMapåˆ°ä¸Šä¸‹æ–‡\n        \n        Args:\n            session_id: ä¼šè¯ID\n            repo_path: ä»“åº“è·¯å¾„\n            chat_files: å¯¹è¯ä¸­çš„æ–‡ä»¶\n            mentioned_idents: æåˆ°çš„æ ‡è¯†ç¬¦\n            max_tokens: æœ€å¤§tokenæ•°\n            \n        Returns:\n            æ˜¯å¦æˆåŠŸ\n        \"\"\"\n        context = self.get_context(session_id)\n        if not context:\n            logger.warning(f\"ä¸Šä¸‹æ–‡ä¸å­˜åœ¨: {session_id}\")\n            return False\n        \n        try:\n            # å»¶è¿Ÿå¯¼å…¥\n            if self._repomap_tool is None:\n                from ..tools.repomap_tools import RepoMapTool\n                self._repomap_tool = RepoMapTool()\n            \n            # ç”ŸæˆRepoMap\n            result = await self._repomap_tool.execute(\n                repo_path=repo_path,\n                chat_files=chat_files,\n                mentioned_idents=mentioned_idents,\n                max_tokens=max_tokens\n            )\n            \n            if not result.success:\n                logger.error(f\"ç”ŸæˆRepoMapå¤±è´¥: {result.error}\")\n                return False\n            \n            # æ·»åŠ åˆ°ä¸Šä¸‹æ–‡\n            context.set('repo_map', result.content)\n            context.set('repo_map_metadata', result.metadata)\n            \n            logger.info(f\"å·²æ·»åŠ RepoMapåˆ°ä¸Šä¸‹æ–‡: {session_id}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"æ·»åŠ RepoMapå¤±è´¥: {e}\", exc_info=True)\n            return False\n    \n    # ========== Tokené¢„ç®—æ§åˆ¶ ==========\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 601,
"end": 682,
"text": "    def enforce_token_budget(\n        self,\n        session_id: str,\n        token_budget: Optional[int] = None,\n        priority_keys: Optional[List[str]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        å¼ºåˆ¶æ‰§è¡ŒTokené¢„ç®—ï¼Œæ™ºèƒ½å‰ªæä½ä¼˜å…ˆçº§å†…å®¹\n        \n        Args:\n            session_id: ä¼šè¯ID\n            token_budget: Tokené¢„ç®—ï¼ˆNoneåˆ™ä½¿ç”¨é»˜è®¤å€¼ï¼‰\n            priority_keys: é«˜ä¼˜å…ˆçº§keyåˆ—è¡¨ï¼ˆè¿™äº›keyä¸ä¼šè¢«å‰ªæï¼‰\n            \n        Returns:\n            å‰ªæç»Ÿè®¡ä¿¡æ¯\n        \"\"\"\n        context = self.get_context(session_id)\n        if not context:\n            logger.warning(f\"ä¸Šä¸‹æ–‡ä¸å­˜åœ¨: {session_id}\")\n            return {'success': False, 'error': 'context_not_found'}\n        \n        if token_budget is None:\n            token_budget = self.default_token_budget\n        \n        priority_keys = priority_keys or []\n        \n        # è®¡ç®—å½“å‰tokenæ•°\n        current_tokens = self._estimate_tokens(context.to_dict())\n        \n        if current_tokens <= token_budget:\n            logger.debug(f\"Tokené¢„ç®—å……è¶³: {current_tokens}/{token_budget}\")\n            return {\n                'success': True,\n                'pruned': False,\n                'original_tokens': current_tokens,\n                'final_tokens': current_tokens,\n                'budget': token_budget\n            }\n        \n        logger.info(f\"Tokenè¶…å‡ºé¢„ç®—: {current_tokens}/{token_budget}ï¼Œå¼€å§‹å‰ªæ\")\n        \n        # æŒ‰ä¼˜å…ˆçº§æ’åºå˜é‡\n        variables = context.to_dict()\n        sorted_vars = self._sort_by_priority(variables, priority_keys)\n        \n        # äºŒåˆ†æŸ¥æ‰¾æœ€ä¼˜å˜é‡æ•°é‡\n        pruned_vars = self._binary_search_optimal_vars(\n            sorted_vars,\n            token_budget,\n            priority_keys\n        )\n        \n        # æ›´æ–°ä¸Šä¸‹æ–‡\n        original_keys = set(variables.keys())\n        pruned_keys = set(pruned_vars.keys())\n        removed_keys = original_keys - pruned_keys\n        \n        # åˆ›å»ºå¿«ç…§ï¼ˆä»¥ä¾¿å›æ»šï¼‰\n        snapshot_id = context.create_snapshot(\"token_budget_enforcement\")\n        \n        # æ¸…ç©ºå¹¶é‡æ–°è®¾ç½®\n        context.clear(track_change=False)\n        context.update(pruned_vars, track_change=False)\n        \n        final_tokens = self._estimate_tokens(pruned_vars)\n        \n        logger.info(\n            f\"Tokenå‰ªæå®Œæˆ: {current_tokens} -> {final_tokens} \"\n            f\"(ç§»é™¤ {len(removed_keys)} ä¸ªå˜é‡)\"\n        )\n        \n        return {\n            'success': True,\n            'pruned': True,\n            'original_tokens': current_tokens,\n            'final_tokens': final_tokens,\n            'budget': token_budget,\n            'removed_keys': list(removed_keys),\n            'snapshot_id': snapshot_id\n        }\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 683,
"end": 691,
"text": "    def _estimate_tokens(self, data: Dict[str, Any]) -> int:\n        \"\"\"\n        ä¼°ç®—tokenæ•°é‡\n        \n        ç®€åŒ–ç‰ˆï¼š1 token â‰ˆ 4 å­—ç¬¦\n        \"\"\"\n        text = str(data)\n        return len(text) // 4\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 692,
"end": 722,
"text": "    def _sort_by_priority(\n        self,\n        variables: Dict[str, Any],\n        priority_keys: List[str]\n    ) -> List[Tuple[str, Any, int]]:\n        \"\"\"\n        æŒ‰ä¼˜å…ˆçº§æ’åºå˜é‡\n        \n        Returns:\n            [(key, value, priority), ...] æŒ‰ä¼˜å…ˆçº§é™åº\n        \"\"\"\n        result = []\n        \n        for key, value in variables.items():\n            # è®¡ç®—ä¼˜å…ˆçº§\n            if key in priority_keys:\n                priority = 1000  # é«˜ä¼˜å…ˆçº§\n            elif key.startswith('repo_map'):\n                priority = 100  # RepoMapä¸­ç­‰ä¼˜å…ˆçº§\n            elif key.startswith('_'):\n                priority = 1  # å†…éƒ¨å˜é‡ä½ä¼˜å…ˆçº§\n            else:\n                priority = 50  # é»˜è®¤ä¼˜å…ˆçº§\n            \n            result.append((key, value, priority))\n        \n        # æŒ‰ä¼˜å…ˆçº§é™åºæ’åº\n        result.sort(key=lambda x: x[2], reverse=True)\n        \n        return result\n    "
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 723,
"end": 930,
"text": "    def _binary_search_optimal_vars(\n        self,\n        sorted_vars: List[Tuple[str, Any, int]],\n        token_budget: int,\n        priority_keys: List[str]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        äºŒåˆ†æŸ¥æ‰¾æœ€ä¼˜å˜é‡æ•°é‡\n        \n        Returns:\n            å‰ªæåçš„å˜é‡å­—å…¸\n        \"\"\"\n        # ç¡®ä¿é«˜ä¼˜å…ˆçº§å˜é‡ä¸€å®šåŒ…å«\n        must_include = {\n            key: value\n            for key, value, _ in sorted_vars\n            if key in priority_keys\n        }\n        \n        must_include_tokens = self._estimate_tokens(must_include)\n        \n        if must_include_tokens > token_budget:\n            logger.warning(\n                f\"é«˜ä¼˜å…ˆçº§å˜é‡å·²è¶…å‡ºé¢„ç®—: {must_include_tokens}/{token_budget}\"\n            )\n            return must_include\n        \n        # å‰©ä½™å¯ç”¨token\n        remaining_budget = token_budget - must_include_tokens\n        \n        # å¯é€‰å˜é‡ï¼ˆéé«˜ä¼˜å…ˆçº§ï¼‰\n        optional_vars = [\n            (key, value)\n            for key, value, _ in sorted_vars\n            if key not in priority_keys\n        ]\n        \n        if not optional_vars:\n            return must_include\n        \n        # äºŒåˆ†æŸ¥æ‰¾\n        left, right = 0, len(optional_vars)\n        best_count = 0\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            # å°è¯•åŒ…å«å‰midä¸ªå˜é‡\n            test_vars = dict(optional_vars[:mid])\n            test_tokens = self._estimate_tokens(test_vars)\n            \n            if test_tokens <= remaining_budget:\n                best_count = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # æ„å»ºæœ€ç»ˆç»“æœ\n        result = must_include.copy()\n        result.update(dict(optional_vars[:best_count]))\n        \n        return result\n    \n    # ========== æ™ºèƒ½æ‘˜è¦ ==========\n    \n    async def summarize_content(\n        self,\n        session_id: str,\n        key: str,\n        target_ratio: float = 0.33,\n        model: str = \"gpt-4o-mini\"\n    ) -> bool:\n        \"\"\"\n        ä½¿ç”¨LLMå‹ç¼©å†…å®¹åˆ°ç›®æ ‡æ¯”ä¾‹\n        \n        Args:\n            session_id: ä¼šè¯ID\n            key: è¦å‹ç¼©çš„å˜é‡å\n            target_ratio: ç›®æ ‡å‹ç¼©æ¯”ä¾‹ï¼ˆ0.33 = å‹ç¼©åˆ°1/3ï¼‰\n            model: LLMæ¨¡å‹\n            \n        Returns:\n            æ˜¯å¦æˆåŠŸ\n        \"\"\"\n        context = self.get_context(session_id)\n        if not context:\n            logger.warning(f\"ä¸Šä¸‹æ–‡ä¸å­˜åœ¨: {session_id}\")\n            return False\n        \n        content = context.get(key)\n        if not content:\n            logger.warning(f\"å˜é‡ä¸å­˜åœ¨: {key}\")\n            return False\n        \n        try:\n            # å»¶è¿Ÿå¯¼å…¥\n            if self._llm_client is None:\n                from ..llm.client import LLMClient\n                self._llm_client = LLMClient()\n            \n            # è®¡ç®—ç›®æ ‡é•¿åº¦\n            original_length = len(str(content))\n            target_length = int(original_length * target_ratio)\n            \n            # æ„å»ºæç¤º\n            prompt = f\"\"\"è¯·å°†ä»¥ä¸‹å†…å®¹å‹ç¼©åˆ°çº¦{target_length}å­—ç¬¦ï¼Œä¿ç•™å…³é”®ä¿¡æ¯ï¼š\n\n{content}\n\nè¦æ±‚ï¼š\n1. ä¿ç•™æ‰€æœ‰é‡è¦çš„æŠ€æœ¯ç»†èŠ‚\n2. åˆ é™¤å†—ä½™å’Œé‡å¤å†…å®¹\n3. ä½¿ç”¨ç®€æ´çš„è¯­è¨€\n4. ä¿æŒåŸæœ‰çš„ç»“æ„å’Œé€»è¾‘\n\nå‹ç¼©åçš„å†…å®¹ï¼š\"\"\"\n            \n            # è°ƒç”¨LLM\n            response = await self._llm_client.chat(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                model=model,\n                temperature=0.3\n            )\n            \n            summary = response.get('content', '').strip()\n            \n            if not summary:\n                logger.error(\"LLMè¿”å›ç©ºå†…å®¹\")\n                return False\n            \n            # åˆ›å»ºå¿«ç…§\n            snapshot_id = context.create_snapshot(f\"summarize_{key}\")\n            \n            # æ›´æ–°å†…å®¹\n            context.set(f\"{key}_original\", content)\n            context.set(key, summary)\n            context.set(f\"{key}_summary_metadata\", {\n                'original_length': original_length,\n                'summary_length': len(summary),\n                'ratio': len(summary) / original_length,\n                'snapshot_id': snapshot_id,\n                'model': model\n            })\n            \n            logger.info(\n                f\"å†…å®¹å·²å‹ç¼©: {key} \"\n                f\"({original_length} -> {len(summary)} å­—ç¬¦, \"\n"
},
{
"path": "daoyoucode/agents/core/context.py",
"start": 931,
"end": 939,
"text": "def get_context_manager() -> ContextManager:\n    \"\"\"è·å–ä¸Šä¸‹æ–‡ç®¡ç†å™¨å•ä¾‹\"\"\"\n    global _context_manager_instance\n    \n    if _context_manager_instance is None:\n        _context_manager_instance = ContextManager()\n        logger.info(\"ä¸Šä¸‹æ–‡ç®¡ç†å™¨å•ä¾‹å·²åˆ›å»º\")\n    \n    return _context_manager_instance"
},
{
"path": "daoyoucode/agents/core/context_selector.py",
"start": 1,
"end": 15,
"text": "\"\"\"\næ™ºèƒ½ä¸Šä¸‹æ–‡é€‰æ‹©å™¨\n\nè‡ªåŠ¨é€‰æ‹©å’Œæ·»åŠ ç›¸å…³æ–‡ä»¶åˆ°ä¸Šä¸‹æ–‡ã€‚\nçµæ„Ÿæ¥æºï¼šdaoyouCodePilotçš„auto_add_related_files\n\"\"\"\n\nfrom typing import List, Set, Dict, Optional\nfrom pathlib import Path\nimport re\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/context_selector.py",
"start": 16,
"end": 18,
"text": "class ContextSelector:\n    \"\"\"æ™ºèƒ½ä¸Šä¸‹æ–‡é€‰æ‹©å™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/context_selector.py",
"start": 19,
"end": 21,
"text": "    def __init__(self, repo_path: Path):\n        self.repo_path = Path(repo_path)\n    "
},
{
"path": "daoyoucode/agents/core/context_selector.py",
"start": 22,
"end": 84,
"text": "    def auto_select_files(\n        self,\n        instruction: str,\n        current_files: Set[str],\n        max_files: int = 10,\n        max_file_size: int = 100 * 1024  # 100KB\n    ) -> List[str]:\n        \"\"\"\n        è‡ªåŠ¨é€‰æ‹©ç›¸å…³æ–‡ä»¶\n        \n        Args:\n            instruction: æŒ‡ä»¤\n            current_files: å½“å‰å·²æœ‰çš„æ–‡ä»¶\n            max_files: æœ€å¤§æ–‡ä»¶æ•°\n            max_file_size: æœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰\n        \n        Returns:\n            æ–°æ·»åŠ çš„æ–‡ä»¶åˆ—è¡¨\n        \"\"\"\n        added_files = []\n        \n        try:\n            # 1. æå–å¼•ç”¨\n            references = self._extract_references(instruction)\n            \n            # 2. æ·»åŠ ç›´æ¥æåˆ°çš„æ–‡ä»¶\n            for file_path in references['files']:\n                if file_path not in current_files:\n                    abs_path = self.repo_path / file_path\n                    if abs_path.exists() and abs_path.stat().st_size <= max_file_size:\n                        added_files.append(file_path)\n                        if len(added_files) >= max_files:\n                            break\n            \n            # 3. æŸ¥æ‰¾å‡½æ•°å®šä¹‰æ‰€åœ¨æ–‡ä»¶\n            if len(added_files) < max_files:\n                for func_name in references['functions']:\n                    file_path = self._find_function_definition(func_name, current_files)\n                    if file_path and file_path not in current_files and file_path not in added_files:\n                        abs_path = self.repo_path / file_path\n                        if abs_path.exists() and abs_path.stat().st_size <= max_file_size:\n                            added_files.append(file_path)\n                            if len(added_files) >= max_files:\n                                break\n            \n            # 4. æŸ¥æ‰¾ç±»å®šä¹‰æ‰€åœ¨æ–‡ä»¶\n            if len(added_files) < max_files:\n                for class_name in references['classes']:\n                    file_path = self._find_class_definition(class_name, current_files)\n                    if file_path and file_path not in current_files and file_path not in added_files:\n                        abs_path = self.repo_path / file_path\n                        if abs_path.exists() and abs_path.stat().st_size <= max_file_size:\n                            added_files.append(file_path)\n                            if len(added_files) >= max_files:\n                                break\n            \n            logger.info(f\"è‡ªåŠ¨é€‰æ‹©äº† {len(added_files)} ä¸ªç›¸å…³æ–‡ä»¶\")\n            \n        except Exception as e:\n            logger.warning(f\"è‡ªåŠ¨é€‰æ‹©æ–‡ä»¶å¤±è´¥: {e}\")\n        \n        return added_files\n    "
},
{
"path": "daoyoucode/agents/core/context_selector.py",
"start": 85,
"end": 101,
"text": "    def _extract_references(self, instruction: str) -> Dict[str, List[str]]:\n        \"\"\"\n        æå–æŒ‡ä»¤ä¸­çš„å¼•ç”¨\n        \n        Returns:\n            {\n                'files': List[str],\n                'functions': List[str],\n                'classes': List[str]\n            }\n        \"\"\"\n        return {\n            'files': self._extract_file_paths(instruction),\n            'functions': self._extract_function_names(instruction),\n            'classes': self._extract_class_names(instruction),\n        }\n    "
},
{
"path": "daoyoucode/agents/core/context_selector.py",
"start": 102,
"end": 126,
"text": "    def _extract_file_paths(self, instruction: str) -> List[str]:\n        \"\"\"æå–æ–‡ä»¶è·¯å¾„\"\"\"\n        file_paths = []\n        \n        # åŒ¹é…å¸¸è§çš„æ–‡ä»¶è·¯å¾„æ¨¡å¼\n        patterns = [\n            r'`([^`]+\\.(py|js|ts|jsx|tsx|java|cpp|c|h|go|rs|rb|php))`',  # åå¼•å·åŒ…è£¹\n            r'\"([^\"]+\\.(py|js|ts|jsx|tsx|java|cpp|c|h|go|rs|rb|php))\"',  # åŒå¼•å·åŒ…è£¹\n            r\"'([^']+\\.(py|js|ts|jsx|tsx|java|cpp|c|h|go|rs|rb|php))'\",  # å•å¼•å·åŒ…è£¹\n            r'(\\w+/[\\w/]+\\.(py|js|ts|jsx|tsx|java|cpp|c|h|go|rs|rb|php))',  # è·¯å¾„å½¢å¼\n        ]\n        \n        for pattern in patterns:\n            matches = re.findall(pattern, instruction)\n            for match in matches:\n                if isinstance(match, tuple):\n                    file_path = match[0]\n                else:\n                    file_path = match\n                \n                if file_path not in file_paths:\n                    file_paths.append(file_path)\n        \n        return file_paths\n    "
},
{
"path": "daoyoucode/agents/core/context_selector.py",
"start": 127,
"end": 148,
"text": "    def _extract_function_names(self, instruction: str) -> List[str]:\n        \"\"\"æå–å‡½æ•°å\"\"\"\n        function_names = []\n        \n        # åŒ¹é…å‡½æ•°åæ¨¡å¼\n        patterns = [\n            r'å‡½æ•°\\s*`?(\\w+)`?',\n            r'æ–¹æ³•\\s*`?(\\w+)`?',\n            r'function\\s+`?(\\w+)`?',\n            r'method\\s+`?(\\w+)`?',\n            r'def\\s+(\\w+)',\n            r'async\\s+def\\s+(\\w+)',\n        ]\n        \n        for pattern in patterns:\n            matches = re.findall(pattern, instruction, re.IGNORECASE)\n            for match in matches:\n                if match not in function_names and len(match) > 2:  # è¿‡æ»¤å¤ªçŸ­çš„\n                    function_names.append(match)\n        \n        return function_names\n    "
},
{
"path": "daoyoucode/agents/core/context_selector.py",
"start": 149,
"end": 174,
"text": "    def _extract_class_names(self, instruction: str) -> List[str]:\n        \"\"\"æå–ç±»å\"\"\"\n        class_names = []\n        \n        # åŒ¹é…ç±»åæ¨¡å¼\n        patterns = [\n            r'ç±»\\s*`([A-Z]\\w+)`',  # ç±» `ClassName`\n            r'ç±»\\s+([A-Z]\\w+)',     # ç±» ClassName\n            r'class\\s+`([A-Z]\\w+)`',  # class `ClassName`\n            r'class\\s+([A-Z]\\w+)',    # class ClassName\n            r'æ¥å£\\s*`([A-Z]\\w+)`',\n            r'æ¥å£\\s+([A-Z]\\w+)',\n            r'interface\\s+`([A-Z]\\w+)`',\n            r'interface\\s+([A-Z]\\w+)',\n            r'`([A-Z][a-zA-Z0-9_]+)`',  # ä»»ä½•åå¼•å·åŒ…è£¹çš„å¤§å†™å¼€å¤´æ ‡è¯†ç¬¦\n            r'\\b([A-Z][a-zA-Z0-9_]{2,})\\b',  # ä»»ä½•å¤§å†™å¼€å¤´çš„æ ‡è¯†ç¬¦ï¼ˆè‡³å°‘3ä¸ªå­—ç¬¦ï¼‰\n        ]\n        \n        for pattern in patterns:\n            matches = re.findall(pattern, instruction)\n            for match in matches:\n                if match not in class_names:\n                    class_names.append(match)\n        \n        return class_names\n    "
},
{
"path": "daoyoucode/agents/core/context_selector.py",
"start": 175,
"end": 212,
"text": "    def _find_function_definition(\n        self,\n        func_name: str,\n        exclude_files: Set[str]\n    ) -> Optional[str]:\n        \"\"\"æŸ¥æ‰¾å‡½æ•°å®šä¹‰æ‰€åœ¨æ–‡ä»¶\"\"\"\n        try:\n            # æœç´¢Pythonæ–‡ä»¶\n            for py_file in self.repo_path.rglob('*.py'):\n                if str(py_file.relative_to(self.repo_path)) in exclude_files:\n                    continue\n                \n                try:\n                    content = py_file.read_text(encoding='utf-8', errors='ignore')\n                    # åŒ¹é…å‡½æ•°å®šä¹‰\n                    if re.search(rf'def\\s+{re.escape(func_name)}\\s*\\(', content):\n                        return str(py_file.relative_to(self.repo_path))\n                except Exception:\n                    continue\n            \n            # æœç´¢JavaScript/TypeScriptæ–‡ä»¶\n            for js_file in list(self.repo_path.rglob('*.js')) + list(self.repo_path.rglob('*.ts')):\n                if str(js_file.relative_to(self.repo_path)) in exclude_files:\n                    continue\n                \n                try:\n                    content = js_file.read_text(encoding='utf-8', errors='ignore')\n                    # åŒ¹é…å‡½æ•°å®šä¹‰\n                    if re.search(rf'function\\s+{re.escape(func_name)}\\s*\\(', content):\n                        return str(js_file.relative_to(self.repo_path))\n                except Exception:\n                    continue\n        \n        except Exception as e:\n            logger.debug(f\"æŸ¥æ‰¾å‡½æ•°å®šä¹‰å¤±è´¥: {e}\")\n        \n        return None\n    "
},
{
"path": "daoyoucode/agents/core/context_selector.py",
"start": 213,
"end": 249,
"text": "    def _find_class_definition(\n        self,\n        class_name: str,\n        exclude_files: Set[str]\n    ) -> Optional[str]:\n        \"\"\"æŸ¥æ‰¾ç±»å®šä¹‰æ‰€åœ¨æ–‡ä»¶\"\"\"\n        try:\n            # æœç´¢Pythonæ–‡ä»¶\n            for py_file in self.repo_path.rglob('*.py'):\n                if str(py_file.relative_to(self.repo_path)) in exclude_files:\n                    continue\n                \n                try:\n                    content = py_file.read_text(encoding='utf-8', errors='ignore')\n                    # åŒ¹é…ç±»å®šä¹‰\n                    if re.search(rf'class\\s+{re.escape(class_name)}\\s*[:\\(]', content):\n                        return str(py_file.relative_to(self.repo_path))\n                except Exception:\n                    continue\n            \n            # æœç´¢JavaScript/TypeScriptæ–‡ä»¶\n            for js_file in list(self.repo_path.rglob('*.js')) + list(self.repo_path.rglob('*.ts')):\n                if str(js_file.relative_to(self.repo_path)) in exclude_files:\n                    continue\n                \n                try:\n                    content = js_file.read_text(encoding='utf-8', errors='ignore')\n                    # åŒ¹é…ç±»å®šä¹‰\n                    if re.search(rf'class\\s+{re.escape(class_name)}\\s*[{{]', content):\n                        return str(js_file.relative_to(self.repo_path))\n                except Exception:\n                    continue\n        \n        except Exception as e:\n            logger.debug(f\"æŸ¥æ‰¾ç±»å®šä¹‰å¤±è´¥: {e}\")\n        \n        return None"
},
{
"path": "daoyoucode/agents/core/decorators.py",
"start": 1,
"end": 13,
"text": "\"\"\"\nè£…é¥°å™¨\n\næä¾›å¸¸ç”¨çš„è£…é¥°å™¨åŠŸèƒ½\n\"\"\"\n\nfrom functools import wraps\nfrom typing import Callable\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/decorators.py",
"start": 14,
"end": 26,
"text": "def require_permission(action: str, path_param: str = 'path'):\n    \"\"\"\n    æƒé™æ£€æŸ¥è£…é¥°å™¨\n    \n    Args:\n        action: æƒé™åŠ¨ä½œ (read/write/execute/delete)\n        path_param: è·¯å¾„å‚æ•°å\n    \n    Example:\n        @require_permission('write', 'file_path')\n        async def write_file(file_path: str, content: str):\n            ...\n    \"\"\""
},
{
"path": "daoyoucode/agents/core/decorators.py",
"start": 27,
"end": 64,
"text": "    def decorator(func: Callable):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            from .permission import get_permission_manager\n            \n            # è·å–è·¯å¾„å‚æ•°\n            path = kwargs.get(path_param)\n            if not path:\n                # å°è¯•ä»ä½ç½®å‚æ•°è·å–\n                import inspect\n                sig = inspect.signature(func)\n                params = list(sig.parameters.keys())\n                if path_param in params:\n                    idx = params.index(path_param)\n                    if idx < len(args):\n                        path = args[idx]\n            \n            if not path:\n                raise ValueError(f\"æ— æ³•è·å–è·¯å¾„å‚æ•°: {path_param}\")\n            \n            # æ£€æŸ¥æƒé™\n            manager = get_permission_manager()\n            agent_name = kwargs.get('agent_name')\n            \n            allowed = await manager.check_permission(action, path, agent_name)\n            \n            if not allowed:\n                raise PermissionError(\n                    f\"æƒé™è¢«æ‹’ç»: {action} {path}\"\n                )\n            \n            # æ‰§è¡Œå‡½æ•°\n            return await func(*args, **kwargs)\n        \n        return wrapper\n    return decorator\n\n"
},
{
"path": "daoyoucode/agents/core/decorators.py",
"start": 65,
"end": 76,
"text": "def log_execution(level: str = 'INFO'):\n    \"\"\"\n    æ—¥å¿—è£…é¥°å™¨\n    \n    Args:\n        level: æ—¥å¿—çº§åˆ«\n    \n    Example:\n        @log_execution('DEBUG')\n        async def my_function():\n            ...\n    \"\"\""
},
{
"path": "daoyoucode/agents/core/decorators.py",
"start": 77,
"end": 110,
"text": "    def decorator(func: Callable):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            func_name = func.__name__\n            \n            # è®°å½•å¼€å§‹\n            logger.log(\n                getattr(logging, level),\n                f\"å¼€å§‹æ‰§è¡Œ: {func_name}\"\n            )\n            \n            try:\n                result = await func(*args, **kwargs)\n                \n                # è®°å½•æˆåŠŸ\n                logger.log(\n                    getattr(logging, level),\n                    f\"æ‰§è¡ŒæˆåŠŸ: {func_name}\"\n                )\n                \n                return result\n            \n            except Exception as e:\n                # è®°å½•å¤±è´¥\n                logger.error(\n                    f\"æ‰§è¡Œå¤±è´¥: {func_name}, é”™è¯¯: {e}\",\n                    exc_info=True\n                )\n                raise\n        \n        return wrapper\n    return decorator\n\n"
},
{
"path": "daoyoucode/agents/core/decorators.py",
"start": 111,
"end": 123,
"text": "def retry_on_error(max_retries: int = 3, delay: float = 1.0):\n    \"\"\"\n    é‡è¯•è£…é¥°å™¨\n    \n    Args:\n        max_retries: æœ€å¤§é‡è¯•æ¬¡æ•°\n        delay: é‡è¯•å»¶è¿Ÿï¼ˆç§’ï¼‰\n    \n    Example:\n        @retry_on_error(max_retries=3, delay=1.0)\n        async def unstable_function():\n            ...\n    \"\"\""
},
{
"path": "daoyoucode/agents/core/decorators.py",
"start": 124,
"end": 154,
"text": "    def decorator(func: Callable):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            import asyncio\n            \n            last_error = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                \n                except Exception as e:\n                    last_error = e\n                    \n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"æ‰§è¡Œå¤±è´¥ï¼ˆç¬¬{attempt + 1}æ¬¡ï¼‰ï¼Œ\"\n                            f\"{delay}ç§’åé‡è¯•: {e}\"\n                        )\n                        await asyncio.sleep(delay)\n                    else:\n                        logger.error(\n                            f\"è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°({max_retries})ï¼Œæ”¾å¼ƒ: {e}\"\n                        )\n            \n            raise last_error\n        \n        return wrapper\n    return decorator\n\n"
},
{
"path": "daoyoucode/agents/core/decorators.py",
"start": 155,
"end": 166,
"text": "def cache_result(ttl: int = 60):\n    \"\"\"\n    ç¼“å­˜è£…é¥°å™¨\n    \n    Args:\n        ttl: ç¼“å­˜æ—¶é—´ï¼ˆç§’ï¼‰\n    \n    Example:\n        @cache_result(ttl=60)\n        async def expensive_function(arg):\n            ...\n    \"\"\""
},
{
"path": "daoyoucode/agents/core/decorators.py",
"start": 167,
"end": 201,
"text": "    def decorator(func: Callable):\n        cache = {}\n        \n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            import time\n            import hashlib\n            import json\n            \n            # ç”Ÿæˆç¼“å­˜é”®\n            key_data = {\n                'args': args,\n                'kwargs': kwargs\n            }\n            key = hashlib.md5(\n                json.dumps(key_data, sort_keys=True).encode()\n            ).hexdigest()\n            \n            # æ£€æŸ¥ç¼“å­˜\n            if key in cache:\n                cached_value, cached_time = cache[key]\n                if time.time() - cached_time < ttl:\n                    logger.debug(f\"ä½¿ç”¨ç¼“å­˜ç»“æœ: {func.__name__}\")\n                    return cached_value\n            \n            # æ‰§è¡Œå‡½æ•°\n            result = await func(*args, **kwargs)\n            \n            # ç¼“å­˜ç»“æœ\n            cache[key] = (result, time.time())\n            \n            return result\n        \n        return wrapper\n    return decorator"
},
{
"path": "daoyoucode/agents/core/delegation.py",
"start": 1,
"end": 16,
"text": "\"\"\"\nç»“æ„åŒ–å§”æ‰˜ç³»ç»Ÿ\n\næä¾›7æ®µå¼å§”æ‰˜æç¤ºç»“æ„ï¼Œæå‡å­AgentæˆåŠŸç‡ã€‚\nçµæ„Ÿæ¥æºï¼šoh-my-opencodeçš„Delegation Prompt Structure\n\"\"\"\n\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass, field\nimport json\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/delegation.py",
"start": 17,
"end": 38,
"text": "class DelegationPrompt:\n    \"\"\"\n    ç»“æ„åŒ–çš„å§”æ‰˜æç¤º\n    \n    7æ®µå¼ç»“æ„ï¼š\n    1. TASK: åŸå­åŒ–ã€å…·ä½“çš„ç›®æ ‡\n    2. EXPECTED OUTCOME: å…·ä½“çš„äº¤ä»˜ç‰©å’ŒæˆåŠŸæ ‡å‡†\n    3. REQUIRED SKILLS: éœ€è¦è°ƒç”¨çš„æŠ€èƒ½\n    4. REQUIRED TOOLS: æ˜ç¡®çš„å·¥å…·ç™½åå•\n    5. MUST DO: è¯¦å°½çš„éœ€æ±‚\n    6. MUST NOT DO: ç¦æ­¢çš„è¡Œä¸º\n    7. CONTEXT: æ–‡ä»¶è·¯å¾„ã€ç°æœ‰æ¨¡å¼ã€çº¦æŸ\n    \"\"\"\n    \n    task: str                                    # 1. ä»»åŠ¡æè¿°\n    expected_outcome: str                        # 2. é¢„æœŸç»“æœ\n    required_skills: List[str] = field(default_factory=list)   # 3. éœ€è¦çš„æŠ€èƒ½\n    required_tools: List[str] = field(default_factory=list)    # 4. éœ€è¦çš„å·¥å…·\n    must_do: List[str] = field(default_factory=list)           # 5. å¿…é¡»åšçš„äº‹\n    must_not_do: List[str] = field(default_factory=list)       # 6. ç¦æ­¢åšçš„äº‹\n    context: Dict[str, Any] = field(default_factory=dict)      # 7. ä¸Šä¸‹æ–‡ä¿¡æ¯\n    "
},
{
"path": "daoyoucode/agents/core/delegation.py",
"start": 39,
"end": 84,
"text": "    def to_prompt(self) -> str:\n        \"\"\"è½¬æ¢ä¸ºæç¤ºæ–‡æœ¬\"\"\"\n        sections = []\n        \n        # 1. TASK\n        sections.append(\"## TASK\")\n        sections.append(self.task)\n        sections.append(\"\")\n        \n        # 2. EXPECTED OUTCOME\n        sections.append(\"## EXPECTED OUTCOME\")\n        sections.append(self.expected_outcome)\n        sections.append(\"\")\n        \n        # 3. REQUIRED SKILLS\n        if self.required_skills:\n            sections.append(\"## REQUIRED SKILLS\")\n            sections.extend(f\"- {skill}\" for skill in self.required_skills)\n            sections.append(\"\")\n        \n        # 4. REQUIRED TOOLS\n        if self.required_tools:\n            sections.append(\"## REQUIRED TOOLS\")\n            sections.extend(f\"- {tool}\" for tool in self.required_tools)\n            sections.append(\"\")\n        \n        # 5. MUST DO\n        if self.must_do:\n            sections.append(\"## MUST DO\")\n            sections.extend(f\"- {item}\" for item in self.must_do)\n            sections.append(\"\")\n        \n        # 6. MUST NOT DO\n        if self.must_not_do:\n            sections.append(\"## MUST NOT DO\")\n            sections.extend(f\"- {item}\" for item in self.must_not_do)\n            sections.append(\"\")\n        \n        # 7. CONTEXT\n        if self.context:\n            sections.append(\"## CONTEXT\")\n            sections.append(json.dumps(self.context, indent=2, ensure_ascii=False))\n            sections.append(\"\")\n        \n        return \"\\n\".join(sections)\n    "
},
{
"path": "daoyoucode/agents/core/delegation.py",
"start": 85,
"end": 97,
"text": "    def validate(self) -> bool:\n        \"\"\"éªŒè¯æç¤ºæ˜¯å¦å®Œæ•´\"\"\"\n        if not self.task:\n            logger.warning(\"å§”æ‰˜æç¤ºç¼ºå°‘TASK\")\n            return False\n        \n        if not self.expected_outcome:\n            logger.warning(\"å§”æ‰˜æç¤ºç¼ºå°‘EXPECTED OUTCOME\")\n            return False\n        \n        return True\n\n"
},
{
"path": "daoyoucode/agents/core/delegation.py",
"start": 98,
"end": 100,
"text": "class DelegationManager:\n    \"\"\"å§”æ‰˜ç®¡ç†å™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/delegation.py",
"start": 101,
"end": 187,
"text": "    def __init__(self):\n        self.delegation_history: List[Dict] = []\n    \n    async def delegate(\n        self,\n        agent: Any,\n        prompt: DelegationPrompt,\n        verify: bool = True,\n        max_retries: int = 2\n    ) -> Dict[str, Any]:\n        \"\"\"\n        å§”æ‰˜ä»»åŠ¡ç»™å­Agent\n        \n        Args:\n            agent: å­Agent\n            prompt: ç»“æ„åŒ–æç¤º\n            verify: æ˜¯å¦éªŒè¯ç»“æœ\n            max_retries: æœ€å¤§é‡è¯•æ¬¡æ•°\n        \n        Returns:\n            æ‰§è¡Œç»“æœ\n        \"\"\"\n        # 1. éªŒè¯æç¤º\n        if not prompt.validate():\n            return {\n                'status': 'error',\n                'error': 'å§”æ‰˜æç¤ºä¸å®Œæ•´'\n            }\n        \n        # 2. ç”Ÿæˆå®Œæ•´æç¤º\n        full_prompt = prompt.to_prompt()\n        \n        # 3. è®°å½•å§”æ‰˜\n        delegation_record = {\n            'agent': agent.__class__.__name__ if hasattr(agent, '__class__') else str(agent),\n            'task': prompt.task,\n            'expected_outcome': prompt.expected_outcome,\n        }\n        \n        # 4. æ‰§è¡Œå§”æ‰˜ï¼ˆå¸¦é‡è¯•ï¼‰\n        for attempt in range(max_retries + 1):\n            try:\n                logger.info(f\"å§”æ‰˜ä»»åŠ¡ç»™ {delegation_record['agent']} (å°è¯• {attempt + 1}/{max_retries + 1})\")\n                \n                # æ‰§è¡Œ\n                if hasattr(agent, 'execute'):\n                    result = await agent.execute(full_prompt)\n                else:\n                    result = await agent(full_prompt)\n                \n                # 5. éªŒè¯ç»“æœï¼ˆå¦‚æœå¯ç”¨ï¼‰\n                if verify:\n                    verification = self._verify_result(result, prompt.expected_outcome)\n                    if not verification['success']:\n                        if attempt < max_retries:\n                            logger.warning(f\"ç»“æœéªŒè¯å¤±è´¥: {verification['reason']}, é‡è¯•...\")\n                            continue\n                        else:\n                            logger.error(f\"ç»“æœéªŒè¯å¤±è´¥: {verification['reason']}, å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°\")\n                            result['verification_failed'] = True\n                            result['verification_reason'] = verification['reason']\n                \n                # 6. è®°å½•æˆåŠŸ\n                delegation_record['status'] = 'success'\n                delegation_record['attempts'] = attempt + 1\n                self.delegation_history.append(delegation_record)\n                \n                return result\n            \n            except Exception as e:\n                logger.error(f\"å§”æ‰˜æ‰§è¡Œå¤±è´¥ (å°è¯• {attempt + 1}): {e}\")\n                if attempt >= max_retries:\n                    delegation_record['status'] = 'failed'\n                    delegation_record['error'] = str(e)\n                    delegation_record['attempts'] = attempt + 1\n                    self.delegation_history.append(delegation_record)\n                    \n                    return {\n                        'status': 'error',\n                        'error': str(e)\n                    }\n        \n        return {\n            'status': 'error',\n            'error': 'æœªçŸ¥é”™è¯¯'\n        }\n    "
},
{
"path": "daoyoucode/agents/core/delegation.py",
"start": 188,
"end": 231,
"text": "    def _verify_result(\n        self,\n        result: Dict[str, Any],\n        expected_outcome: str\n    ) -> Dict[str, Any]:\n        \"\"\"\n        éªŒè¯ç»“æœæ˜¯å¦ç¬¦åˆé¢„æœŸ\n        \n        Args:\n            result: æ‰§è¡Œç»“æœ\n            expected_outcome: é¢„æœŸç»“æœæè¿°\n        \n        Returns:\n            {\n                'success': bool,\n                'reason': str\n            }\n        \"\"\"\n        # åŸºæœ¬éªŒè¯\n        if not result:\n            return {\n                'success': False,\n                'reason': 'ç»“æœä¸ºç©º'\n            }\n        \n        if result.get('status') == 'error':\n            return {\n                'success': False,\n                'reason': f\"æ‰§è¡Œé”™è¯¯: {result.get('error', 'æœªçŸ¥é”™è¯¯')}\"\n            }\n        \n        # TODO: å¯ä»¥ä½¿ç”¨LLMè¿›è¡Œæ›´æ™ºèƒ½çš„éªŒè¯\n        # è¿™é‡Œç®€åŒ–ä¸ºæ£€æŸ¥æ˜¯å¦æœ‰ç»“æœ\n        if result.get('status') == 'success':\n            return {\n                'success': True,\n                'reason': 'æ‰§è¡ŒæˆåŠŸ'\n            }\n        \n        return {\n            'success': True,\n            'reason': 'åŸºæœ¬éªŒè¯é€šè¿‡'\n        }\n    "
},
{
"path": "daoyoucode/agents/core/delegation.py",
"start": 232,
"end": 255,
"text": "    def get_delegation_stats(self) -> Dict[str, Any]:\n        \"\"\"è·å–å§”æ‰˜ç»Ÿè®¡\"\"\"\n        total = len(self.delegation_history)\n        if total == 0:\n            return {\n                'total': 0,\n                'success': 0,\n                'failed': 0,\n                'success_rate': 0.0\n            }\n        \n        success = sum(1 for d in self.delegation_history if d.get('status') == 'success')\n        failed = total - success\n        \n        return {\n            'total': total,\n            'success': success,\n            'failed': failed,\n            'success_rate': success / total if total > 0 else 0.0,\n            'avg_attempts': sum(d.get('attempts', 1) for d in self.delegation_history) / total\n        }\n\n\n# ä¾¿æ·å‡½æ•°"
},
{
"path": "daoyoucode/agents/core/delegation.py",
"start": 256,
"end": 277,
"text": "def create_delegation_prompt(\n    task: str,\n    expected_outcome: str,\n    **kwargs\n) -> DelegationPrompt:\n    \"\"\"\n    åˆ›å»ºå§”æ‰˜æç¤º\n    \n    Args:\n        task: ä»»åŠ¡æè¿°\n        expected_outcome: é¢„æœŸç»“æœ\n        **kwargs: å…¶ä»–å‚æ•°ï¼ˆrequired_skills, required_tools, must_do, must_not_do, contextï¼‰\n    \"\"\"\n    return DelegationPrompt(\n        task=task,\n        expected_outcome=expected_outcome,\n        required_skills=kwargs.get('required_skills', []),\n        required_tools=kwargs.get('required_tools', []),\n        must_do=kwargs.get('must_do', []),\n        must_not_do=kwargs.get('must_not_do', []),\n        context=kwargs.get('context', {})\n    )"
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 1,
"end": 22,
"text": "\"\"\"\nåé¦ˆå¾ªç¯\n\næ‰§è¡Œåçš„è¯„ä¼°å’Œå­¦ä¹ ç³»ç»Ÿï¼š\n1. ç»“æœè´¨é‡è¯„ä¼°\n2. é—®é¢˜è¯†åˆ«\n3. æ”¹è¿›å»ºè®®ç”Ÿæˆ\n4. å¤±è´¥åˆ†æå’Œå­¦ä¹ \n5. ç­–ç•¥è°ƒæ•´\n\næ³¨æ„ï¼šFeedbackLoopæ˜¯å¯é€‰çš„ï¼Œä¸å½±å“åŸæœ‰çš„æ‰§è¡Œæµç¨‹\n\"\"\"\n\nfrom typing import Dict, Any, Optional, List\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 23,
"end": 31,
"text": "class Evaluation:\n    \"\"\"è¯„ä¼°ç»“æœ\"\"\"\n    quality_score: float  # 0-1\n    issues: List[str]\n    suggestions: List[str]\n    strengths: List[str]\n    weaknesses: List[str]\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 32,
"end": 44,
"text": "    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"è½¬æ¢ä¸ºå­—å…¸\"\"\"\n        return {\n            'quality_score': self.quality_score,\n            'issues': self.issues,\n            'suggestions': self.suggestions,\n            'strengths': self.strengths,\n            'weaknesses': self.weaknesses,\n            'metadata': self.metadata\n        }\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 45,
"end": 52,
"text": "class FailureAnalysis:\n    \"\"\"å¤±è´¥åˆ†æ\"\"\"\n    root_cause: str\n    error_type: str\n    affected_components: List[str]\n    recovery_suggestions: List[str]\n    prevention_suggestions: List[str]\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 53,
"end": 63,
"text": "    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"è½¬æ¢ä¸ºå­—å…¸\"\"\"\n        return {\n            'root_cause': self.root_cause,\n            'error_type': self.error_type,\n            'affected_components': self.affected_components,\n            'recovery_suggestions': self.recovery_suggestions,\n            'prevention_suggestions': self.prevention_suggestions\n        }\n\n"
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 64,
"end": 77,
"text": "class FeedbackLoop:\n    \"\"\"\n    åé¦ˆå¾ªç¯\n    \n    èŒè´£ï¼š\n    1. è¯„ä¼°æ‰§è¡Œç»“æœè´¨é‡\n    2. è¯†åˆ«é—®é¢˜å’Œä¼˜ç‚¹\n    3. ç”Ÿæˆæ”¹è¿›å»ºè®®\n    4. åˆ†æå¤±è´¥åŸå› \n    5. å­¦ä¹ å’Œè°ƒæ•´ç­–ç•¥\n    \n    æ³¨æ„ï¼šè¿™æ˜¯å¯é€‰åŠŸèƒ½ï¼Œä¸å½±å“åŸæœ‰çš„æ‰§è¡Œæµç¨‹\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 78,
"end": 246,
"text": "    def __init__(self):\n        # è´¨é‡è¯„ä¼°è§„åˆ™\n        self.quality_rules = {\n            'completeness': 0.3,  # å®Œæ•´æ€§æƒé‡\n            'correctness': 0.3,   # æ­£ç¡®æ€§æƒé‡\n            'efficiency': 0.2,    # æ•ˆç‡æƒé‡\n            'clarity': 0.2        # æ¸…æ™°åº¦æƒé‡\n        }\n        \n        # å¸¸è§é—®é¢˜æ¨¡å¼\n        self.issue_patterns = {\n            'incomplete': ['æœªå®Œæˆ', 'ä¸å®Œæ•´', 'ç¼ºå°‘', 'é—æ¼'],\n            'incorrect': ['é”™è¯¯', 'ä¸æ­£ç¡®', 'æœ‰è¯¯', 'é—®é¢˜'],\n            'inefficient': ['æ…¢', 'è€—æ—¶', 'æ€§èƒ½', 'ä¼˜åŒ–'],\n            'unclear': ['ä¸æ¸…æ¥š', 'æ¨¡ç³Š', 'éš¾æ‡‚', 'æ··ä¹±']\n        }\n        \n        # é”™è¯¯ç±»å‹åˆ†ç±»\n        self.error_types = {\n            'timeout': ['è¶…æ—¶', 'timeout', 'time out'],\n            'resource': ['å†…å­˜', 'èµ„æº', 'resource', 'memory'],\n            'permission': ['æƒé™', 'æ‹’ç»', 'permission', 'denied'],\n            'network': ['ç½‘ç»œ', 'è¿æ¥', 'network', 'connection'],\n            'syntax': ['è¯­æ³•', 'syntax', 'parse'],\n            'logic': ['é€»è¾‘', 'logic', 'ä¸šåŠ¡']\n        }\n        \n        # å­¦ä¹ å†å²ï¼ˆç”¨äºç­–ç•¥è°ƒæ•´ï¼‰\n        self.learning_history: List[Dict[str, Any]] = []\n        self.max_history = 100\n        \n        logger.info(\"åé¦ˆå¾ªç¯å·²åˆå§‹åŒ–\")\n    \n    async def evaluate(\n        self,\n        task_description: str,\n        result: Dict[str, Any],\n        context: Optional[Dict[str, Any]] = None\n    ) -> Evaluation:\n        \"\"\"\n        è¯„ä¼°æ‰§è¡Œç»“æœ\n        \n        Args:\n            task_description: ä»»åŠ¡æè¿°\n            result: æ‰§è¡Œç»“æœ\n            context: ä¸Šä¸‹æ–‡ï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            è¯„ä¼°ç»“æœ\n        \"\"\"\n        if context is None:\n            context = {}\n        \n        logger.info(f\"è¯„ä¼°ä»»åŠ¡ç»“æœ: {task_description[:50]}...\")\n        \n        # 1. è®¡ç®—è´¨é‡åˆ†æ•°\n        quality_score = self._calculate_quality_score(\n            task_description,\n            result,\n            context\n        )\n        \n        # 2. è¯†åˆ«é—®é¢˜\n        issues = self._identify_issues(result, context)\n        \n        # 3. è¯†åˆ«ä¼˜ç‚¹\n        strengths = self._identify_strengths(result, context)\n        \n        # 4. è¯†åˆ«å¼±ç‚¹\n        weaknesses = self._identify_weaknesses(result, context)\n        \n        # 5. ç”Ÿæˆæ”¹è¿›å»ºè®®\n        suggestions = self._generate_suggestions(\n            task_description,\n            result,\n            issues,\n            weaknesses,\n            context\n        )\n        \n        evaluation = Evaluation(\n            quality_score=quality_score,\n            issues=issues,\n            suggestions=suggestions,\n            strengths=strengths,\n            weaknesses=weaknesses,\n            metadata={\n                'task_description': task_description[:100],\n                'evaluated_at': datetime.now().isoformat()\n            }\n        )\n        \n        # 6. è®°å½•åˆ°å­¦ä¹ å†å²\n        self._record_learning(task_description, result, evaluation)\n        \n        logger.info(f\"è¯„ä¼°å®Œæˆ: è´¨é‡åˆ†æ•°={quality_score:.2f}\")\n        \n        return evaluation\n    \n    async def analyze_failure(\n        self,\n        task_description: str,\n        error: Exception,\n        context: Optional[Dict[str, Any]] = None\n    ) -> FailureAnalysis:\n        \"\"\"\n        åˆ†æå¤±è´¥åŸå› \n        \n        Args:\n            task_description: ä»»åŠ¡æè¿°\n            error: é”™è¯¯å¼‚å¸¸\n            context: ä¸Šä¸‹æ–‡ï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            å¤±è´¥åˆ†æ\n        \"\"\"\n        if context is None:\n            context = {}\n        \n        logger.info(f\"åˆ†æå¤±è´¥: {task_description[:50]}...\")\n        \n        error_str = str(error).lower()\n        \n        # 1. è¯†åˆ«é”™è¯¯ç±»å‹\n        error_type = self._classify_error(error_str)\n        \n        # 2. åˆ†ææ ¹æœ¬åŸå› \n        root_cause = self._analyze_root_cause(\n            task_description,\n            error_str,\n            error_type,\n            context\n        )\n        \n        # 3. è¯†åˆ«å—å½±å“çš„ç»„ä»¶\n        affected_components = self._identify_affected_components(\n            error_str,\n            context\n        )\n        \n        # 4. ç”Ÿæˆæ¢å¤å»ºè®®\n        recovery_suggestions = self._generate_recovery_suggestions(\n            error_type,\n            root_cause,\n            context\n        )\n        \n        # 5. ç”Ÿæˆé¢„é˜²å»ºè®®\n        prevention_suggestions = self._generate_prevention"
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 247,
"end": 283,
"text": "    def _calculate_quality_score(\n        self,\n        task_description: str,\n        result: Dict[str, Any],\n        context: Dict[str, Any]\n    ) -> float:\n        \"\"\"\n        è®¡ç®—è´¨é‡åˆ†æ•°ï¼ˆ0-1ï¼‰\n        \n        Args:\n            task_description: ä»»åŠ¡æè¿°\n            result: æ‰§è¡Œç»“æœ\n            context: ä¸Šä¸‹æ–‡\n        \n        Returns:\n            è´¨é‡åˆ†æ•°\n        \"\"\"\n        score = 0.0\n        \n        # 1. å®Œæ•´æ€§è¯„åˆ†\n        completeness = self._evaluate_completeness(result)\n        score += completeness * self.quality_rules['completeness']\n        \n        # 2. æ­£ç¡®æ€§è¯„åˆ†\n        correctness = self._evaluate_correctness(result)\n        score += correctness * self.quality_rules['correctness']\n        \n        # 3. æ•ˆç‡è¯„åˆ†\n        efficiency = self._evaluate_efficiency(result, context)\n        score += efficiency * self.quality_rules['efficiency']\n        \n        # 4. æ¸…æ™°åº¦è¯„åˆ†\n        clarity = self._evaluate_clarity(result)\n        score += clarity * self.quality_rules['clarity']\n        \n        return min(max(score, 0.0), 1.0)\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 284,
"end": 297,
"text": "    def _evaluate_completeness(self, result: Dict[str, Any]) -> float:\n        \"\"\"è¯„ä¼°å®Œæ•´æ€§\"\"\"\n        score = 0.5  # åŸºç¡€åˆ†\n        \n        # æœ‰å†…å®¹\n        if result.get('content'):\n            score += 0.3\n        \n        # æˆåŠŸæ ‡å¿—\n        if result.get('success'):\n            score += 0.2\n        \n        return min(score, 1.0)\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 298,
"end": 307,
"text": "    def _evaluate_correctness(self, result: Dict[str, Any]) -> float:\n        \"\"\"è¯„ä¼°æ­£ç¡®æ€§\"\"\"\n        # ç®€åŒ–ç‰ˆï¼šåŸºäºsuccessæ ‡å¿—\n        if result.get('success'):\n            return 0.9\n        elif result.get('error'):\n            return 0.3\n        else:\n            return 0.6\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 308,
"end": 330,
"text": "    def _evaluate_efficiency(\n        self,\n        result: Dict[str, Any],\n        context: Dict[str, Any]\n    ) -> float:\n        \"\"\"è¯„ä¼°æ•ˆç‡\"\"\"\n        score = 0.7  # åŸºç¡€åˆ†\n        \n        # æ£€æŸ¥tokensä½¿ç”¨\n        tokens_used = result.get('tokens_used', 0)\n        if tokens_used > 0:\n            if tokens_used < 1000:\n                score += 0.2\n            elif tokens_used > 5000:\n                score -= 0.2\n        \n        # æ£€æŸ¥å·¥å…·ä½¿ç”¨\n        tools_used = result.get('tools_used', [])\n        if len(tools_used) > 10:\n            score -= 0.1  # å·¥å…·ä½¿ç”¨è¿‡å¤š\n        \n        return min(max(score, 0.0), 1.0)\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 331,
"end": 348,
"text": "    def _evaluate_clarity(self, result: Dict[str, Any]) -> float:\n        \"\"\"è¯„ä¼°æ¸…æ™°åº¦\"\"\"\n        score = 0.7  # åŸºç¡€åˆ†\n        \n        content = result.get('content', '')\n        \n        # å†…å®¹é•¿åº¦é€‚ä¸­\n        if 50 < len(content) < 2000:\n            score += 0.2\n        elif len(content) > 5000:\n            score -= 0.1  # å¤ªé•¿\n        \n        # æœ‰ç»“æ„ï¼ˆç®€å•æ£€æµ‹ï¼‰\n        if '\\n' in content:\n            score += 0.1\n        \n        return min(max(score, 0.0), 1.0)\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 349,
"end": 383,
"text": "    def _identify_issues(\n        self,\n        result: Dict[str, Any],\n        context: Dict[str, Any]\n    ) -> List[str]:\n        \"\"\"è¯†åˆ«é—®é¢˜\"\"\"\n        issues = []\n        \n        # æ£€æŸ¥å¤±è´¥\n        if not result.get('success'):\n            issues.append(\"ä»»åŠ¡æ‰§è¡Œå¤±è´¥\")\n        \n        # æ£€æŸ¥é”™è¯¯\n        if result.get('error'):\n            issues.append(f\"é”™è¯¯: {result['error'][:100]}\")\n        \n        # æ£€æŸ¥å†…å®¹\n        content = result.get('content', '')\n        if not content:\n            issues.append(\"ç»“æœå†…å®¹ä¸ºç©º\")\n        elif len(content) < 10:\n            issues.append(\"ç»“æœå†…å®¹è¿‡çŸ­\")\n        \n        # æ£€æŸ¥tokensä½¿ç”¨\n        tokens_used = result.get('tokens_used', 0)\n        if tokens_used > 10000:\n            issues.append(f\"tokensä½¿ç”¨è¿‡å¤š: {tokens_used}\")\n        \n        # æ£€æŸ¥æˆæœ¬\n        cost = result.get('cost', 0)\n        if cost > 1.0:\n            issues.append(f\"æˆæœ¬è¾ƒé«˜: ${cost:.2f}\")\n        \n        return issues\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 384,
"end": 412,
"text": "    def _identify_strengths(\n        self,\n        result: Dict[str, Any],\n        context: Dict[str, Any]\n    ) -> List[str]:\n        \"\"\"è¯†åˆ«ä¼˜ç‚¹\"\"\"\n        strengths = []\n        \n        # æˆåŠŸå®Œæˆ\n        if result.get('success'):\n            strengths.append(\"ä»»åŠ¡æˆåŠŸå®Œæˆ\")\n        \n        # å†…å®¹ä¸°å¯Œ\n        content = result.get('content', '')\n        if len(content) > 500:\n            strengths.append(\"ç»“æœå†…å®¹è¯¦ç»†\")\n        \n        # æ•ˆç‡é«˜\n        tokens_used = result.get('tokens_used', 0)\n        if 0 < tokens_used < 1000:\n            strengths.append(\"tokensä½¿ç”¨é«˜æ•ˆ\")\n        \n        # ä½¿ç”¨äº†å·¥å…·\n        tools_used = result.get('tools_used', [])\n        if tools_used:\n            strengths.append(f\"æœ‰æ•ˆä½¿ç”¨äº†{len(tools_used)}ä¸ªå·¥å…·\")\n        \n        return strengths\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 413,
"end": 437,
"text": "    def _identify_weaknesses(\n        self,\n        result: Dict[str, Any],\n        context: Dict[str, Any]\n    ) -> List[str]:\n        \"\"\"è¯†åˆ«å¼±ç‚¹\"\"\"\n        weaknesses = []\n        \n        # å†…å®¹è¿‡é•¿\n        content = result.get('content', '')\n        if len(content) > 5000:\n            weaknesses.append(\"ç»“æœå†…å®¹è¿‡é•¿ï¼Œå¯èƒ½ä¸å¤Ÿç²¾ç‚¼\")\n        \n        # tokensä½¿ç”¨å¤š\n        tokens_used = result.get('tokens_used', 0)\n        if tokens_used > 5000:\n            weaknesses.append(\"tokensä½¿ç”¨è¾ƒå¤šï¼Œå¯ä»¥ä¼˜åŒ–\")\n        \n        # å·¥å…·ä½¿ç”¨å¤š\n        tools_used = result.get('tools_used', [])\n        if len(tools_used) > 10:\n            weaknesses.append(\"å·¥å…·è°ƒç”¨æ¬¡æ•°è¾ƒå¤šï¼Œå¯èƒ½æ•ˆç‡ä¸é«˜\")\n        \n        return weaknesses\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 438,
"end": 473,
"text": "    def _generate_suggestions(\n        self,\n        task_description: str,\n        result: Dict[str, Any],\n        issues: List[str],\n        weaknesses: List[str],\n        context: Dict[str, Any]\n    ) -> List[str]:\n        \"\"\"ç”Ÿæˆæ”¹è¿›å»ºè®®\"\"\"\n        suggestions = []\n        \n        # åŸºäºé—®é¢˜çš„å»ºè®®\n        if \"ä»»åŠ¡æ‰§è¡Œå¤±è´¥\" in str(issues):\n            suggestions.append(\"å»ºè®®æ£€æŸ¥ä»»åŠ¡æè¿°æ˜¯å¦æ¸…æ™°\")\n            suggestions.append(\"å»ºè®®æ£€æŸ¥Agenté…ç½®æ˜¯å¦æ­£ç¡®\")\n        \n        if \"å†…å®¹ä¸ºç©º\" in str(issues):\n            suggestions.append(\"å»ºè®®ä¼˜åŒ–promptï¼Œæä¾›æ›´å¤šä¸Šä¸‹æ–‡\")\n        \n        if \"tokensä½¿ç”¨è¿‡å¤š\" in str(issues):\n            suggestions.append(\"å»ºè®®ç²¾ç®€promptï¼Œå‡å°‘ä¸å¿…è¦çš„ä¸Šä¸‹æ–‡\")\n            suggestions.append(\"å»ºè®®è€ƒè™‘åˆ†æ­¥æ‰§è¡Œ\")\n        \n        # åŸºäºå¼±ç‚¹çš„å»ºè®®\n        if \"å†…å®¹è¿‡é•¿\" in str(weaknesses):\n            suggestions.append(\"å»ºè®®åœ¨promptä¸­è¦æ±‚ç®€æ´å›ç­”\")\n        \n        if \"å·¥å…·è°ƒç”¨æ¬¡æ•°è¾ƒå¤š\" in str(weaknesses):\n            suggestions.append(\"å»ºè®®ä¼˜åŒ–å·¥å…·ä½¿ç”¨ç­–ç•¥\")\n        \n        # é€šç”¨å»ºè®®\n        if not suggestions:\n            suggestions.append(\"ç»“æœæ•´ä½“è‰¯å¥½ï¼Œç»§ç»­ä¿æŒ\")\n        \n        return suggestions\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 474,
"end": 481,
"text": "    def _classify_error(self, error_str: str) -> str:\n        \"\"\"åˆ†ç±»é”™è¯¯ç±»å‹\"\"\"\n        for error_type, keywords in self.error_types.items():\n            if any(kw in error_str for kw in keywords):\n                return error_type\n        \n        return 'unknown'\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 482,
"end": 504,
"text": "    def _analyze_root_cause(\n        self,\n        task_description: str,\n        error_str: str,\n        error_type: str,\n        context: Dict[str, Any]\n    ) -> str:\n        \"\"\"åˆ†ææ ¹æœ¬åŸå› \"\"\"\n        if error_type == 'timeout':\n            return \"ä»»åŠ¡æ‰§è¡Œè¶…æ—¶ï¼Œå¯èƒ½æ˜¯ä»»åŠ¡è¿‡äºå¤æ‚æˆ–èµ„æºä¸è¶³\"\n        elif error_type == 'resource':\n            return \"èµ„æºä¸è¶³ï¼Œå¯èƒ½æ˜¯å†…å­˜æˆ–CPUä½¿ç”¨è¿‡é«˜\"\n        elif error_type == 'permission':\n            return \"æƒé™ä¸è¶³ï¼Œéœ€è¦æ£€æŸ¥è®¿é—®æƒé™é…ç½®\"\n        elif error_type == 'network':\n            return \"ç½‘ç»œè¿æ¥é—®é¢˜ï¼Œå¯èƒ½æ˜¯APIä¸å¯è¾¾æˆ–ç½‘ç»œä¸ç¨³å®š\"\n        elif error_type == 'syntax':\n            return \"è¯­æ³•é”™è¯¯ï¼Œå¯èƒ½æ˜¯promptæ ¼å¼ä¸æ­£ç¡®æˆ–å‚æ•°é”™è¯¯\"\n        elif error_type == 'logic':\n            return \"ä¸šåŠ¡é€»è¾‘é”™è¯¯ï¼Œéœ€è¦æ£€æŸ¥ä»»åŠ¡é€»è¾‘\"\n        else:\n            return f\"æœªçŸ¥é”™è¯¯: {error_str[:100]}\"\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 505,
"end": 531,
"text": "    def _identify_affected_components(\n        self,\n        error_str: str,\n        context: Dict[str, Any]\n    ) -> List[str]:\n        \"\"\"è¯†åˆ«å—å½±å“çš„ç»„ä»¶\"\"\"\n        components = []\n        \n        # ä»ä¸Šä¸‹æ–‡è·å–\n        if context.get('orchestrator'):\n            components.append(f\"ç¼–æ’å™¨: {context['orchestrator']}\")\n        \n        if context.get('agent'):\n            components.append(f\"Agent: {context['agent']}\")\n        \n        if context.get('skill_name'):\n            components.append(f\"Skill: {context['skill_name']}\")\n        \n        # ä»é”™è¯¯ä¿¡æ¯æ¨æ–­\n        if 'llm' in error_str or 'model' in error_str:\n            components.append(\"LLMå®¢æˆ·ç«¯\")\n        \n        if 'tool' in error_str:\n            components.append(\"å·¥å…·ç³»ç»Ÿ\")\n        \n        return components if components else [\"æœªçŸ¥ç»„ä»¶\"]\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 532,
"end": 560,
"text": "    def _generate_recovery_suggestions(\n        self,\n        error_type: str,\n        root_cause: str,\n        context: Dict[str, Any]\n    ) -> List[str]:\n        \"\"\"ç”Ÿæˆæ¢å¤å»ºè®®\"\"\"\n        suggestions = []\n        \n        if error_type == 'timeout':\n            suggestions.append(\"å¢åŠ è¶…æ—¶æ—¶é—´\")\n            suggestions.append(\"ç®€åŒ–ä»»åŠ¡æˆ–åˆ†æ­¥æ‰§è¡Œ\")\n        elif error_type == 'resource':\n            suggestions.append(\"é‡Šæ”¾èµ„æºåé‡è¯•\")\n            suggestions.append(\"å‡å°‘å¹¶å‘ä»»åŠ¡æ•°\")\n        elif error_type == 'permission':\n            suggestions.append(\"æ£€æŸ¥å¹¶æ›´æ–°æƒé™é…ç½®\")\n        elif error_type == 'network':\n            suggestions.append(\"æ£€æŸ¥ç½‘ç»œè¿æ¥\")\n            suggestions.append(\"ç¨åé‡è¯•\")\n        elif error_type == 'syntax':\n            suggestions.append(\"æ£€æŸ¥promptæ ¼å¼\")\n            suggestions.append(\"éªŒè¯å‚æ•°æ­£ç¡®æ€§\")\n        else:\n            suggestions.append(\"æŸ¥çœ‹è¯¦ç»†é”™è¯¯æ—¥å¿—\")\n            suggestions.append(\"è”ç³»æŠ€æœ¯æ”¯æŒ\")\n        \n        return suggestions\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 561,
"end": 589,
"text": "    def _generate_prevention_suggestions(\n        self,\n        error_type: str,\n        root_cause: str,\n        context: Dict[str, Any]\n    ) -> List[str]:\n        \"\"\"ç”Ÿæˆé¢„é˜²å»ºè®®\"\"\"\n        suggestions = []\n        \n        if error_type == 'timeout':\n            suggestions.append(\"ä½¿ç”¨ExecutionPlanneré¢„ä¼°æ‰§è¡Œæ—¶é—´\")\n            suggestions.append(\"å¯¹å¤æ‚ä»»åŠ¡è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´\")\n        elif error_type == 'resource':\n            suggestions.append(\"ç›‘æ§èµ„æºä½¿ç”¨æƒ…å†µ\")\n            suggestions.append(\"è®¾ç½®èµ„æºä½¿ç”¨é™åˆ¶\")\n        elif error_type == 'permission':\n            suggestions.append(\"åœ¨éƒ¨ç½²æ—¶éªŒè¯æ‰€æœ‰æƒé™\")\n        elif error_type == 'network':\n            suggestions.append(\"å®ç°é‡è¯•æœºåˆ¶\")\n            suggestions.append(\"æ·»åŠ ç½‘ç»œå¥åº·æ£€æŸ¥\")\n        elif error_type == 'syntax':\n            suggestions.append(\"ä½¿ç”¨promptæ¨¡æ¿\")\n            suggestions.append(\"æ·»åŠ å‚æ•°éªŒè¯\")\n        else:\n            suggestions.append(\"æ·»åŠ æ›´è¯¦ç»†çš„æ—¥å¿—è®°å½•\")\n            suggestions.append(\"å®ç°é”™è¯¯ç›‘æ§å’Œå‘Šè­¦\")\n        \n        return suggestions\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 590,
"end": 608,
"text": "    def _record_learning(\n        self,\n        task_description: str,\n        result: Dict[str, Any],\n        evaluation: Evaluation\n    ):\n        \"\"\"è®°å½•å­¦ä¹ å†å²\"\"\"\n        self.learning_history.append({\n            'task_description': task_description[:100],\n            'success': result.get('success', False),\n            'quality_score': evaluation.quality_score,\n            'issues_count': len(evaluation.issues),\n            'timestamp': datetime.now().isoformat()\n        })\n        \n        # ä¿æŒå†å²å¤§å°\n        if len(self.learning_history) > self.max_history:\n            self.learning_history = self.learning_history[-self.max_history:]\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 609,
"end": 627,
"text": "    def _record_failure(\n        self,\n        task_description: str,\n        error: Exception,\n        analysis: FailureAnalysis\n    ):\n        \"\"\"è®°å½•å¤±è´¥å†å²\"\"\"\n        self.learning_history.append({\n            'task_description': task_description[:100],\n            'success': False,\n            'error_type': analysis.error_type,\n            'root_cause': analysis.root_cause[:100],\n            'timestamp': datetime.now().isoformat()\n        })\n        \n        # ä¿æŒå†å²å¤§å°\n        if len(self.learning_history) > self.max_history:\n            self.learning_history = self.learning_history[-self.max_history:]\n    "
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 628,
"end": 661,
"text": "    def get_learning_stats(self) -> Dict[str, Any]:\n        \"\"\"è·å–å­¦ä¹ ç»Ÿè®¡\"\"\"\n        if not self.learning_history:\n            return {\n                'total_tasks': 0,\n                'success_rate': 0.0,\n                'average_quality': 0.0\n            }\n        \n        total = len(self.learning_history)\n        successes = sum(1 for h in self.learning_history if h.get('success'))\n        \n        quality_scores = [\n            h.get('quality_score', 0)\n            for h in self.learning_history\n            if 'quality_score' in h\n        ]\n        avg_quality = sum(quality_scores) / len(quality_scores) if quality_scores else 0.0\n        \n        return {\n            'total_tasks': total,\n            'success_rate': successes / total if total > 0 else 0.0,\n            'average_quality': avg_quality,\n            'recent_failures': [\n                h for h in self.learning_history[-10:]\n                if not h.get('success')\n            ]\n        }\n\n\n# å•ä¾‹æ¨¡å¼ï¼ˆå¯é€‰ï¼‰\n_feedback_loop_instance = None\n\n"
},
{
"path": "daoyoucode/agents/core/feedback.py",
"start": 662,
"end": 670,
"text": "def get_feedback_loop() -> FeedbackLoop:\n    \"\"\"è·å–åé¦ˆå¾ªç¯å•ä¾‹\"\"\"\n    global _feedback_loop_instance\n    \n    if _feedback_loop_instance is None:\n        _feedback_loop_instance = FeedbackLoop()\n        logger.info(\"åé¦ˆå¾ªç¯å•ä¾‹å·²åˆ›å»º\")\n    \n    return _feedback_loop_instance"
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 1,
"end": 15,
"text": "\"\"\"\nHookç³»ç»Ÿ\n\næä¾›ç»Ÿä¸€çš„æ‰©å±•ç‚¹ï¼Œç±»ä¼¼oh-my-opencodeçš„31ä¸ªHook\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, Optional, List\nfrom dataclasses import dataclass\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 16,
"end": 22,
"text": "class HookContext:\n    \"\"\"Hookä¸Šä¸‹æ–‡\"\"\"\n    skill_name: str\n    user_input: str\n    session_id: Optional[str] = None\n    metadata: Dict[str, Any] = None\n    "
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 23,
"end": 27,
"text": "    def __post_init__(self):\n        if self.metadata is None:\n            self.metadata = {}\n\n"
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 28,
"end": 30,
"text": "class BaseHook(ABC):\n    \"\"\"HookåŸºç±»\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 31,
"end": 87,
"text": "    def __init__(self, name: str):\n        self.name = name\n        self.enabled = True\n        self.logger = logging.getLogger(f\"hook.{name}\")\n    \n    @abstractmethod\n    async def on_before_execute(\n        self,\n        context: HookContext\n    ) -> HookContext:\n        \"\"\"\n        æ‰§è¡Œå‰Hook\n        \n        Args:\n            context: Hookä¸Šä¸‹æ–‡\n        \n        Returns:\n            ä¿®æ”¹åçš„ä¸Šä¸‹æ–‡\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    async def on_after_execute(\n        self,\n        context: HookContext,\n        result: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        æ‰§è¡ŒåHook\n        \n        Args:\n            context: Hookä¸Šä¸‹æ–‡\n            result: æ‰§è¡Œç»“æœ\n        \n        Returns:\n            ä¿®æ”¹åçš„ç»“æœ\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    async def on_error(\n        self,\n        context: HookContext,\n        error: Exception\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        é”™è¯¯Hook\n        \n        Args:\n            context: Hookä¸Šä¸‹æ–‡\n            error: å¼‚å¸¸å¯¹è±¡\n        \n        Returns:\n            é”™è¯¯å¤„ç†ç»“æœï¼ˆNoneè¡¨ç¤ºç»§ç»­æŠ›å‡ºå¼‚å¸¸ï¼‰\n        \"\"\"\n        pass\n    "
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 88,
"end": 92,
"text": "    def enable(self):\n        \"\"\"å¯ç”¨Hook\"\"\"\n        self.enabled = True\n        self.logger.info(f\"Hook '{self.name}' å·²å¯ç”¨\")\n    "
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 93,
"end": 98,
"text": "    def disable(self):\n        \"\"\"ç¦ç”¨Hook\"\"\"\n        self.enabled = False\n        self.logger.info(f\"Hook '{self.name}' å·²ç¦ç”¨\")\n\n"
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 99,
"end": 101,
"text": "class HookManager:\n    \"\"\"Hookç®¡ç†å™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 102,
"end": 105,
"text": "    def __init__(self):\n        self.hooks: List[BaseHook] = []\n        self.logger = logging.getLogger(\"hook.manager\")\n    "
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 106,
"end": 110,
"text": "    def register(self, hook: BaseHook):\n        \"\"\"æ³¨å†ŒHook\"\"\"\n        self.hooks.append(hook)\n        self.logger.info(f\"å·²æ³¨å†ŒHook: {hook.name}\")\n    "
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 111,
"end": 115,
"text": "    def unregister(self, hook_name: str):\n        \"\"\"æ³¨é”€Hook\"\"\"\n        self.hooks = [h for h in self.hooks if h.name != hook_name]\n        self.logger.info(f\"å·²æ³¨é”€Hook: {hook_name}\")\n    "
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 116,
"end": 122,
"text": "    def get_hook(self, hook_name: str) -> Optional[BaseHook]:\n        \"\"\"è·å–Hook\"\"\"\n        for hook in self.hooks:\n            if hook.name == hook_name:\n                return hook\n        return None\n    "
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 123,
"end": 193,
"text": "    def list_hooks(self) -> List[str]:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰Hook\"\"\"\n        return [h.name for h in self.hooks]\n    \n    async def run_before_hooks(\n        self,\n        context: HookContext\n    ) -> HookContext:\n        \"\"\"è¿è¡Œæ‰€æœ‰before hooks\"\"\"\n        for hook in self.hooks:\n            if not hook.enabled:\n                continue\n            \n            try:\n                context = await hook.on_before_execute(context)\n            except Exception as e:\n                self.logger.error(\n                    f\"Hook '{hook.name}' beforeæ‰§è¡Œå¤±è´¥: {e}\",\n                    exc_info=True\n                )\n        \n        return context\n    \n    async def run_after_hooks(\n        self,\n        context: HookContext,\n        result: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"è¿è¡Œæ‰€æœ‰after hooks\"\"\"\n        for hook in self.hooks:\n            if not hook.enabled:\n                continue\n            \n            try:\n                result = await hook.on_after_execute(context, result)\n            except Exception as e:\n                self.logger.error(\n                    f\"Hook '{hook.name}' afteræ‰§è¡Œå¤±è´¥: {e}\",\n                    exc_info=True\n                )\n        \n        return result\n    \n    async def run_error_hooks(\n        self,\n        context: HookContext,\n        error: Exception\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"è¿è¡Œæ‰€æœ‰error hooks\"\"\"\n        for hook in self.hooks:\n            if not hook.enabled:\n                continue\n            \n            try:\n                result = await hook.on_error(context, error)\n                if result is not None:\n                    # Hookå¤„ç†äº†é”™è¯¯ï¼Œè¿”å›ç»“æœ\n                    return result\n            except Exception as e:\n                self.logger.error(\n                    f\"Hook '{hook.name}' erroræ‰§è¡Œå¤±è´¥: {e}\",\n                    exc_info=True\n                )\n        \n        return None\n\n\n# å…¨å±€Hookç®¡ç†å™¨\n_hook_manager = HookManager()\n\n"
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 194,
"end": 198,
"text": "def get_hook_manager() -> HookManager:\n    \"\"\"è·å–Hookç®¡ç†å™¨\"\"\"\n    return _hook_manager\n\n"
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 199,
"end": 203,
"text": "def register_hook(hook: BaseHook):\n    \"\"\"æ³¨å†ŒHook\"\"\"\n    _hook_manager.register(hook)\n\n"
},
{
"path": "daoyoucode/agents/core/hook.py",
"start": 204,
"end": 206,
"text": "def unregister_hook(hook_name: str):\n    \"\"\"æ³¨é”€Hook\"\"\"\n    _hook_manager.unregister(hook_name)"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 1,
"end": 15,
"text": "\"\"\"\nHookç”Ÿå‘½å‘¨æœŸç³»ç»Ÿ\n\næä¾›çµæ´»çš„æ‰©å±•ç‚¹ï¼Œå…è®¸ç”¨æˆ·åœ¨æ‰§è¡Œæµç¨‹çš„å…³é”®èŠ‚ç‚¹æ³¨å…¥è‡ªå®šä¹‰é€»è¾‘ã€‚\nçµæ„Ÿæ¥æºï¼šoh-my-opencodeçš„31ä¸ªç”Ÿå‘½å‘¨æœŸHook\n\"\"\"\n\nfrom typing import Callable, Dict, List, Any, Optional\nfrom enum import Enum\nimport logging\nfrom dataclasses import dataclass, field\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 16,
"end": 50,
"text": "class HookEvent(Enum):\n    \"\"\"Hookäº‹ä»¶ç±»å‹\"\"\"\n    # Executorçº§åˆ«\n    PRE_EXECUTE = \"pre_execute\"           # æ‰§è¡Œå‰\n    POST_EXECUTE = \"post_execute\"         # æ‰§è¡Œå\n    ON_ERROR = \"on_error\"                 # é”™è¯¯æ—¶\n    \n    # Orchestratorçº§åˆ«\n    PRE_ORCHESTRATE = \"pre_orchestrate\"   # ç¼–æ’å‰\n    POST_ORCHESTRATE = \"post_orchestrate\" # ç¼–æ’å\n    \n    # Agentçº§åˆ«\n    PRE_AGENT = \"pre_agent\"               # Agentæ‰§è¡Œå‰\n    POST_AGENT = \"post_agent\"             # Agentæ‰§è¡Œå\n    \n    # Toolçº§åˆ«\n    PRE_TOOL = \"pre_tool\"                 # å·¥å…·è°ƒç”¨å‰\n    POST_TOOL = \"post_tool\"               # å·¥å…·è°ƒç”¨å\n    \n    # Taskçº§åˆ«\n    TASK_CREATED = \"task_created\"         # ä»»åŠ¡åˆ›å»º\n    TASK_STARTED = \"task_started\"         # ä»»åŠ¡å¼€å§‹\n    TASK_COMPLETED = \"task_completed\"     # ä»»åŠ¡å®Œæˆ\n    TASK_FAILED = \"task_failed\"           # ä»»åŠ¡å¤±è´¥\n    \n    # Contextçº§åˆ«\n    CONTEXT_CREATED = \"context_created\"   # ä¸Šä¸‹æ–‡åˆ›å»º\n    CONTEXT_UPDATED = \"context_updated\"   # ä¸Šä¸‹æ–‡æ›´æ–°\n    \n    # Memoryçº§åˆ«\n    MEMORY_SAVED = \"memory_saved\"         # è®°å¿†ä¿å­˜\n    MEMORY_LOADED = \"memory_loaded\"       # è®°å¿†åŠ è½½\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 51,
"end": 56,
"text": "class HookContext:\n    \"\"\"Hookä¸Šä¸‹æ–‡\"\"\"\n    event: HookEvent\n    data: Dict[str, Any] = field(default_factory=dict)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 57,
"end": 60,
"text": "    def get(self, key: str, default: Any = None) -> Any:\n        \"\"\"è·å–æ•°æ®\"\"\"\n        return self.data.get(key, default)\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 61,
"end": 65,
"text": "    def set(self, key: str, value: Any):\n        \"\"\"è®¾ç½®æ•°æ®\"\"\"\n        self.data[key] = value\n\n"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 66,
"end": 68,
"text": "class Hook:\n    \"\"\"HookåŸºç±»\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 69,
"end": 91,
"text": "    def __init__(self, name: str, priority: int = 100):\n        \"\"\"\n        åˆå§‹åŒ–Hook\n        \n        Args:\n            name: Hookåç§°\n            priority: ä¼˜å…ˆçº§ï¼ˆæ•°å­—è¶Šå°è¶Šå…ˆæ‰§è¡Œï¼‰\n        \"\"\"\n        self.name = name\n        self.priority = priority\n    \n    async def execute(self, context: HookContext) -> Optional[HookContext]:\n        \"\"\"\n        æ‰§è¡ŒHook\n        \n        Args:\n            context: Hookä¸Šä¸‹æ–‡\n            \n        Returns:\n            ä¿®æ”¹åçš„ä¸Šä¸‹æ–‡ï¼Œæˆ–Noneè¡¨ç¤ºä¸­æ–­æ‰§è¡Œ\n        \"\"\"\n        raise NotImplementedError\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 92,
"end": 95,
"text": "    def __repr__(self):\n        return f\"Hook(name={self.name}, priority={self.priority})\"\n\n"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 96,
"end": 98,
"text": "class FunctionHook(Hook):\n    \"\"\"å‡½æ•°Hook\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 99,
"end": 115,
"text": "    def __init__(self, name: str, func: Callable, priority: int = 100):\n        super().__init__(name, priority)\n        self.func = func\n    \n    async def execute(self, context: HookContext) -> Optional[HookContext]:\n        \"\"\"æ‰§è¡Œå‡½æ•°Hook\"\"\"\n        try:\n            result = self.func(context)\n            # æ”¯æŒå¼‚æ­¥å‡½æ•°\n            if hasattr(result, '__await__'):\n                result = await result\n            return result  # ç›´æ¥è¿”å›ç»“æœï¼ŒåŒ…æ‹¬None\n        except Exception as e:\n            logger.error(f\"Hook {self.name} æ‰§è¡Œå¤±è´¥: {e}\", exc_info=True)\n            return context\n\n"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 116,
"end": 120,
"text": "class HookManager:\n    \"\"\"Hookç®¡ç†å™¨ï¼ˆå•ä¾‹ï¼‰\"\"\"\n    \n    _instance = None\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 121,
"end": 126,
"text": "    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 127,
"end": 134,
"text": "    def __init__(self):\n        if self._initialized:\n            return\n        \n        self.hooks: Dict[HookEvent, List[Hook]] = {event: [] for event in HookEvent}\n        self._initialized = True\n        logger.info(\"HookManager åˆå§‹åŒ–å®Œæˆ\")\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 135,
"end": 147,
"text": "    def register(self, event: HookEvent, hook: Hook):\n        \"\"\"\n        æ³¨å†ŒHook\n        \n        Args:\n            event: Hookäº‹ä»¶\n            hook: Hookå®ä¾‹\n        \"\"\"\n        self.hooks[event].append(hook)\n        # æŒ‰ä¼˜å…ˆçº§æ’åº\n        self.hooks[event].sort(key=lambda h: h.priority)\n        logger.info(f\"æ³¨å†ŒHook: {hook.name} -> {event.value}\")\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 148,
"end": 167,
"text": "    def register_function(\n        self, \n        event: HookEvent, \n        func: Callable, \n        name: Optional[str] = None,\n        priority: int = 100\n    ):\n        \"\"\"\n        æ³¨å†Œå‡½æ•°Hook\n        \n        Args:\n            event: Hookäº‹ä»¶\n            func: Hookå‡½æ•°\n            name: Hookåç§°ï¼ˆé»˜è®¤ä½¿ç”¨å‡½æ•°åï¼‰\n            priority: ä¼˜å…ˆçº§\n        \"\"\"\n        hook_name = name or func.__name__\n        hook = FunctionHook(hook_name, func, priority)\n        self.register(event, hook)\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 168,
"end": 223,
"text": "    def unregister(self, event: HookEvent, name: str):\n        \"\"\"\n        æ³¨é”€Hook\n        \n        Args:\n            event: Hookäº‹ä»¶\n            name: Hookåç§°\n        \"\"\"\n        self.hooks[event] = [h for h in self.hooks[event] if h.name != name]\n        logger.info(f\"æ³¨é”€Hook: {name} <- {event.value}\")\n    \n    async def trigger(\n        self, \n        event: HookEvent, \n        data: Optional[Dict[str, Any]] = None,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> HookContext:\n        \"\"\"\n        è§¦å‘Hook\n        \n        Args:\n            event: Hookäº‹ä»¶\n            data: Hookæ•°æ®\n            metadata: Hookå…ƒæ•°æ®\n            \n        Returns:\n            æœ€ç»ˆçš„Hookä¸Šä¸‹æ–‡\n        \"\"\"\n        context = HookContext(\n            event=event,\n            data=data or {},\n            metadata=metadata or {}\n        )\n        \n        hooks = self.hooks.get(event, [])\n        if not hooks:\n            return context\n        \n        logger.debug(f\"è§¦å‘Hook: {event.value}, å…± {len(hooks)} ä¸ª\")\n        \n        for hook in hooks:\n            try:\n                result = await hook.execute(context)\n                if result is None:\n                    # Hookè¿”å›Noneè¡¨ç¤ºä¸­æ–­æ‰§è¡Œ\n                    logger.warning(f\"Hook {hook.name} ä¸­æ–­äº†æ‰§è¡Œæµç¨‹\")\n                    context.set('_interrupted', True)\n                    context.set('_interrupted_by', hook.name)\n                    break\n                context = result\n            except Exception as e:\n                logger.error(f\"Hook {hook.name} æ‰§è¡Œå¤±è´¥: {e}\", exc_info=True)\n                # ç»§ç»­æ‰§è¡Œå…¶ä»–Hook\n        \n        return context\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 224,
"end": 242,
"text": "    def list_hooks(self, event: Optional[HookEvent] = None) -> Dict[str, List[str]]:\n        \"\"\"\n        åˆ—å‡ºæ‰€æœ‰Hook\n        \n        Args:\n            event: å¯é€‰çš„äº‹ä»¶è¿‡æ»¤\n            \n        Returns:\n            äº‹ä»¶åˆ°Hookåç§°åˆ—è¡¨çš„æ˜ å°„\n        \"\"\"\n        if event:\n            return {event.value: [h.name for h in self.hooks[event]]}\n        \n        return {\n            e.value: [h.name for h in hooks]\n            for e, hooks in self.hooks.items()\n            if hooks\n        }\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 243,
"end": 262,
"text": "    def clear(self, event: Optional[HookEvent] = None):\n        \"\"\"\n        æ¸…ç©ºHook\n        \n        Args:\n            event: å¯é€‰çš„äº‹ä»¶è¿‡æ»¤ï¼ŒNoneè¡¨ç¤ºæ¸…ç©ºæ‰€æœ‰\n        \"\"\"\n        if event:\n            self.hooks[event] = []\n            logger.info(f\"æ¸…ç©ºHook: {event.value}\")\n        else:\n            for e in HookEvent:\n                self.hooks[e] = []\n            logger.info(\"æ¸…ç©ºæ‰€æœ‰Hook\")\n\n\n# å…¨å±€Hookç®¡ç†å™¨å®ä¾‹\n_hook_manager = HookManager()\n\n"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 263,
"end": 268,
"text": "def get_hook_manager() -> HookManager:\n    \"\"\"è·å–Hookç®¡ç†å™¨å®ä¾‹\"\"\"\n    return _hook_manager\n\n\n# ä¾¿æ·è£…é¥°å™¨"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 269,
"end": 274,
"text": "def hook(event: HookEvent, priority: int = 100):\n    \"\"\"\n    Hookè£…é¥°å™¨\n    \n    ä½¿ç”¨ç¤ºä¾‹:\n        @hook(HookEvent.PRE_EXECUTE, priority=50)"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 275,
"end": 278,
"text": "        def my_hook(context: HookContext) -> HookContext:\n            print(f\"æ‰§è¡Œå‰: {context.data}\")\n            return context\n    \"\"\""
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 279,
"end": 286,
"text": "    def decorator(func: Callable):\n        manager = get_hook_manager()\n        manager.register_function(event, func, priority=priority)\n        return func\n    return decorator\n\n\n# å†…ç½®Hookç¤ºä¾‹"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 287,
"end": 289,
"text": "class LoggingHook(Hook):\n    \"\"\"æ—¥å¿—Hook\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 290,
"end": 298,
"text": "    def __init__(self, priority: int = 1000):\n        super().__init__(\"logging\", priority)\n    \n    async def execute(self, context: HookContext) -> HookContext:\n        \"\"\"è®°å½•æ—¥å¿—\"\"\"\n        logger.info(f\"[Hook] {context.event.value}: {context.data.get('name', 'unknown')}\")\n        return context\n\n"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 299,
"end": 301,
"text": "class TimingHook(Hook):\n    \"\"\"è®¡æ—¶Hook\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 302,
"end": 322,
"text": "    def __init__(self, priority: int = 10):\n        super().__init__(\"timing\", priority)\n    \n    async def execute(self, context: HookContext) -> HookContext:\n        \"\"\"è®°å½•æ—¶é—´\"\"\"\n        import time\n        \n        if context.event.value.startswith('pre_'):\n            # å¼€å§‹è®¡æ—¶\n            context.metadata['start_time'] = time.time()\n        elif context.event.value.startswith('post_'):\n            # ç»“æŸè®¡æ—¶\n            start_time = context.metadata.get('start_time')\n            if start_time:\n                elapsed = time.time() - start_time\n                context.metadata['elapsed_time'] = elapsed\n                logger.info(f\"[Timing] {context.data.get('name', 'unknown')}: {elapsed:.2f}s\")\n        \n        return context\n\n"
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 323,
"end": 325,
"text": "class ValidationHook(Hook):\n    \"\"\"éªŒè¯Hook\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/hooks.py",
"start": 326,
"end": 338,
"text": "    def __init__(self, priority: int = 5):\n        super().__init__(\"validation\", priority)\n    \n    async def execute(self, context: HookContext) -> Optional[HookContext]:\n        \"\"\"éªŒè¯æ•°æ®\"\"\"\n        # ç¤ºä¾‹ï¼šéªŒè¯å¿…éœ€å­—æ®µ\n        required_fields = context.metadata.get('required_fields', [])\n        for field in required_fields:\n            if field not in context.data:\n                logger.error(f\"éªŒè¯å¤±è´¥: ç¼ºå°‘å¿…éœ€å­—æ®µ {field}\")\n                return None  # ä¸­æ–­æ‰§è¡Œ\n        \n        return context"
},
{
"path": "daoyoucode/agents/core/middleware.py",
"start": 1,
"end": 13,
"text": "\"\"\"\nä¸­é—´ä»¶åŸºç±»å’Œæ³¨å†Œè¡¨\n\nä¸­é—´ä»¶æä¾›å¯é€‰çš„èƒ½åŠ›å¢å¼º\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/middleware.py",
"start": 14,
"end": 16,
"text": "class BaseMiddleware(ABC):\n    \"\"\"ä¸­é—´ä»¶åŸºç±»\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/middleware.py",
"start": 17,
"end": 30,
"text": "    def __init__(self):\n        self.name = self.__class__.__name__\n        self.logger = logging.getLogger(f\"middleware.{self.name}\")\n    \n    @abstractmethod\n    async def process(\n        self,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"å¤„ç†è¯·æ±‚ï¼Œå¢å¼ºä¸Šä¸‹æ–‡\"\"\"\n        pass\n\n"
},
{
"path": "daoyoucode/agents/core/middleware.py",
"start": 31,
"end": 33,
"text": "class MiddlewareRegistry:\n    \"\"\"ä¸­é—´ä»¶æ³¨å†Œè¡¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/middleware.py",
"start": 34,
"end": 37,
"text": "    def __init__(self):\n        self._middleware: Dict[str, type] = {}\n        self._instances: Dict[str, BaseMiddleware] = {}\n    "
},
{
"path": "daoyoucode/agents/core/middleware.py",
"start": 38,
"end": 45,
"text": "    def register(self, name: str, middleware_class: type):\n        \"\"\"æ³¨å†Œä¸­é—´ä»¶\"\"\"\n        if not issubclass(middleware_class, BaseMiddleware):\n            raise TypeError(f\"{middleware_class} must inherit from BaseMiddleware\")\n        \n        self._middleware[name] = middleware_class\n        logger.info(f\"å·²æ³¨å†Œä¸­é—´ä»¶: {name}\")\n    "
},
{
"path": "daoyoucode/agents/core/middleware.py",
"start": 46,
"end": 56,
"text": "    def get(self, name: str) -> BaseMiddleware:\n        \"\"\"è·å–ä¸­é—´ä»¶å®ä¾‹ï¼ˆå•ä¾‹ï¼‰\"\"\"\n        if name not in self._middleware:\n            logger.warning(f\"ä¸­é—´ä»¶ '{name}' æœªæ³¨å†Œ\")\n            return None\n        \n        if name not in self._instances:\n            self._instances[name] = self._middleware[name]()\n        \n        return self._instances[name]\n    "
},
{
"path": "daoyoucode/agents/core/middleware.py",
"start": 57,
"end": 65,
"text": "    def list_middleware(self) -> list:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰ä¸­é—´ä»¶\"\"\"\n        return list(self._middleware.keys())\n\n\n# å…¨å±€æ³¨å†Œè¡¨\n_middleware_registry = MiddlewareRegistry()\n\n"
},
{
"path": "daoyoucode/agents/core/middleware.py",
"start": 66,
"end": 70,
"text": "def get_middleware_registry() -> MiddlewareRegistry:\n    \"\"\"è·å–ä¸­é—´ä»¶æ³¨å†Œè¡¨\"\"\"\n    return _middleware_registry\n\n"
},
{
"path": "daoyoucode/agents/core/middleware.py",
"start": 71,
"end": 75,
"text": "def get_middleware(name: str) -> BaseMiddleware:\n    \"\"\"è·å–ä¸­é—´ä»¶\"\"\"\n    return _middleware_registry.get(name)\n\n"
},
{
"path": "daoyoucode/agents/core/middleware.py",
"start": 76,
"end": 78,
"text": "def register_middleware(name: str, middleware_class: type):\n    \"\"\"æ³¨å†Œä¸­é—´ä»¶\"\"\"\n    _middleware_registry.register(name, middleware_class)"
},
{
"path": "daoyoucode/agents/core/model_selector.py",
"start": 1,
"end": 14,
"text": "\"\"\"\næ™ºèƒ½æ¨¡å‹é€‰æ‹©å™¨\n\næ ¹æ®ä»»åŠ¡å¤æ‚åº¦å’Œä¸Šä¸‹æ–‡å¤§å°åŠ¨æ€é€‰æ‹©æœ€ä¼˜æ¨¡å‹ã€‚\nçµæ„Ÿæ¥æºï¼šdaoyouCodePilotçš„æ¨¡å‹è§’è‰²ç³»ç»Ÿ\n\"\"\"\n\nfrom typing import Tuple, Optional, Dict, Any\nimport re\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/model_selector.py",
"start": 15,
"end": 19,
"text": "class ModelSelector:\n    \"\"\"æ™ºèƒ½æ¨¡å‹é€‰æ‹©å™¨ï¼ˆå•ä¾‹ï¼‰\"\"\"\n    \n    _instance = None\n    "
},
{
"path": "daoyoucode/agents/core/model_selector.py",
"start": 20,
"end": 25,
"text": "    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    "
},
{
"path": "daoyoucode/agents/core/model_selector.py",
"start": 26,
"end": 35,
"text": "    def __init__(self):\n        if self._initialized:\n            return\n        \n        self.main_model = None\n        self.weak_model = None\n        self.editor_model = None\n        self._initialized = True\n        logger.info(\"ModelSelector åˆå§‹åŒ–å®Œæˆ\")\n    "
},
{
"path": "daoyoucode/agents/core/model_selector.py",
"start": 36,
"end": 54,
"text": "    def configure(\n        self,\n        main_model: str,\n        weak_model: Optional[str] = None,\n        editor_model: Optional[str] = None\n    ):\n        \"\"\"\n        é…ç½®æ¨¡å‹\n        \n        Args:\n            main_model: ä¸»æ¨¡å‹ï¼ˆå¤æ‚ä»»åŠ¡ï¼‰\n            weak_model: å¼±æ¨¡å‹ï¼ˆç®€å•ä»»åŠ¡ã€æ‘˜è¦ï¼‰\n            editor_model: ç¼–è¾‘æ¨¡å‹ï¼ˆä»£ç ä¿®æ”¹ï¼‰\n        \"\"\"\n        self.main_model = main_model\n        self.weak_model = weak_model or main_model\n        self.editor_model = editor_model or main_model\n        logger.info(f\"æ¨¡å‹é…ç½®: main={main_model}, weak={weak_model}, editor={editor_model}\")\n    "
},
{
"path": "daoyoucode/agents/core/model_selector.py",
"start": 55,
"end": 92,
"text": "    def select_model(\n        self,\n        instruction: str,\n        context_size: int = 0,\n        task_type: Optional[str] = None\n    ) -> Tuple[str, str]:\n        \"\"\"\n        é€‰æ‹©æœ€ä¼˜æ¨¡å‹\n        \n        Args:\n            instruction: æŒ‡ä»¤\n            context_size: ä¸Šä¸‹æ–‡å¤§å°ï¼ˆå­—èŠ‚ï¼‰\n            task_type: ä»»åŠ¡ç±»å‹ï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            (model_name, task_type)\n        \"\"\"\n        # å¦‚æœæ˜ç¡®æŒ‡å®šäº†ä»»åŠ¡ç±»å‹\n        if task_type:\n            return self._get_model_by_task(task_type), task_type\n        \n        # 1. åˆ†ææŒ‡ä»¤å¤æ‚åº¦\n        complexity = self._analyze_complexity(instruction)\n        \n        # 2. æ ¹æ®å¤æ‚åº¦å’Œä¸Šä¸‹æ–‡å¤§å°é€‰æ‹©\n        if complexity == 'simple' and context_size < 10000:\n            return self.weak_model, 'weak'\n        elif complexity == 'edit':\n            return self.editor_model, 'editor'\n        elif complexity == 'complex':\n            return self.main_model, 'main'\n        else:\n            # ä¸­ç­‰å¤æ‚åº¦ï¼Œæ ¹æ®ä¸Šä¸‹æ–‡å¤§å°å†³å®š\n            if context_size < 50000:\n                return self.weak_model, 'weak'\n            else:\n                return self.main_model, 'main'\n    "
},
{
"path": "daoyoucode/agents/core/model_selector.py",
"start": 93,
"end": 101,
"text": "    def _get_model_by_task(self, task_type: str) -> str:\n        \"\"\"æ ¹æ®ä»»åŠ¡ç±»å‹è·å–æ¨¡å‹\"\"\"\n        if task_type == 'weak':\n            return self.weak_model\n        elif task_type == 'editor':\n            return self.editor_model\n        else:\n            return self.main_model\n    "
},
{
"path": "daoyoucode/agents/core/model_selector.py",
"start": 102,
"end": 175,
"text": "    def _analyze_complexity(self, instruction: str) -> str:\n        \"\"\"\n        åˆ†ææŒ‡ä»¤å¤æ‚åº¦\n        \n        Returns:\n            'simple', 'edit', 'medium', 'complex'\n        \"\"\"\n        instruction_lower = instruction.lower()\n        \n        # ç®€å•ä»»åŠ¡ç‰¹å¾\n        simple_patterns = [\n            r'æ·»åŠ æ³¨é‡Š',\n            r'ä¿®æ”¹å˜é‡å',\n            r'æ ¼å¼åŒ–ä»£ç ',\n            r'æ·»åŠ ç±»å‹æç¤º',\n            r'æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²',\n            r'ä¿®å¤æ‹¼å†™',\n            r'æ›´æ–°ç‰ˆæœ¬å·',\n            r'add comment',\n            r'rename variable',\n            r'format code',\n            r'add type hint',\n            r'fix typo',\n        ]\n        \n        # ç¼–è¾‘ä»»åŠ¡ç‰¹å¾\n        edit_patterns = [\n            r'ä¿®æ”¹.*ä»£ç ',\n            r'æ›´æ–°.*å®ç°',\n            r'è°ƒæ•´.*é€»è¾‘',\n            r'ä¿®å¤.*bug',\n            r'edit.*code',\n            r'update.*implementation',\n            r'fix.*bug',\n            r'change.*logic',\n        ]\n        \n        # å¤æ‚ä»»åŠ¡ç‰¹å¾\n        complex_patterns = [\n            r'é‡æ„',\n            r'å®ç°.*åŠŸèƒ½',\n            r'è®¾è®¡.*æ¶æ„',\n            r'ä¼˜åŒ–.*æ€§èƒ½',\n            r'åˆ›å»º.*ç³»ç»Ÿ',\n            r'æ„å»º.*æ¨¡å—',\n            r'refactor',\n            r'implement.*feature',\n            r'design.*architecture',\n            r'optimize.*performance',\n            r'create.*system',\n            r'build.*module',\n        ]\n        \n        # åŒ¹é…æ¨¡å¼\n        for pattern in simple_patterns:\n            if re.search(pattern, instruction_lower):\n                return 'simple'\n        \n        for pattern in edit_patterns:\n            if re.search(pattern, instruction_lower):\n                return 'edit'\n        \n        for pattern in complex_patterns:\n            if re.search(pattern, instruction_lower):\n                return 'complex'\n        \n        # æ ¹æ®æŒ‡ä»¤é•¿åº¦åˆ¤æ–­\n        if len(instruction) < 50:\n            return 'simple'\n        elif len(instruction) < 200:\n            return 'medium'\n        else:\n            return 'complex'\n    "
},
{
"path": "daoyoucode/agents/core/model_selector.py",
"start": 176,
"end": 210,
"text": "    def get_model_info(\n        self,\n        instruction: str,\n        context_size: int = 0\n    ) -> Dict[str, Any]:\n        \"\"\"\n        è·å–æ¨¡å‹é€‰æ‹©ä¿¡æ¯ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰\n        \n        Returns:\n            {\n                'model': str,\n                'task_type': str,\n                'complexity': str,\n                'reason': str\n            }\n        \"\"\"\n        complexity = self._analyze_complexity(instruction)\n        model, task_type = self.select_model(instruction, context_size)\n        \n        reasons = {\n            'simple': 'ç®€å•ä»»åŠ¡ï¼Œä½¿ç”¨è½»é‡æ¨¡å‹',\n            'edit': 'ä»£ç ç¼–è¾‘ä»»åŠ¡ï¼Œä½¿ç”¨ç¼–è¾‘æ¨¡å‹',\n            'medium': 'ä¸­ç­‰å¤æ‚åº¦ä»»åŠ¡',\n            'complex': 'å¤æ‚ä»»åŠ¡ï¼Œä½¿ç”¨ä¸»æ¨¡å‹',\n        }\n        \n        return {\n            'model': model,\n            'task_type': task_type,\n            'complexity': complexity,\n            'reason': reasons.get(complexity, 'è‡ªåŠ¨é€‰æ‹©'),\n            'context_size': context_size,\n        }\n\n"
},
{
"path": "daoyoucode/agents/core/model_selector.py",
"start": 211,
"end": 213,
"text": "def get_model_selector() -> ModelSelector:\n    \"\"\"è·å–æ¨¡å‹é€‰æ‹©å™¨å®ä¾‹\"\"\"\n    return ModelSelector()"
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 1,
"end": 13,
"text": "\"\"\"\nç¼–æ’å™¨åŸºç±»å’Œæ³¨å†Œè¡¨\n\nç¼–æ’å™¨è´Ÿè´£åè°ƒSkillçš„æ‰§è¡Œæµç¨‹\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, Optional\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 14,
"end": 16,
"text": "class BaseOrchestrator(ABC):\n    \"\"\"ç¼–æ’å™¨åŸºç±»\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 17,
"end": 30,
"text": "    def __init__(self):\n        self.name = self.__class__.__name__\n        self.logger = logging.getLogger(f\"orchestrator.{self.name}\")\n    \n    @abstractmethod\n    async def execute(\n        self,\n        skill: 'SkillConfig',\n        user_input: str,\n        context: Optional[Dict[str, Any]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"æ‰§è¡ŒSkill\"\"\"\n        pass\n    "
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 31,
"end": 58,
"text": "    def _get_agent(self, agent_name: str):\n        \"\"\"è·å–Agentå®ä¾‹\"\"\"\n        from .agent import get_agent_registry\n        \n        registry = get_agent_registry()\n        agent = registry.get_agent(agent_name)\n        \n        if not agent:\n            raise ValueError(f\"Agent '{agent_name}' not found\")\n        \n        return agent\n    \n    async def _apply_middleware(\n        self,\n        middleware_name: str,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"åº”ç”¨ä¸­é—´ä»¶\"\"\"\n        from .middleware import get_middleware\n        \n        middleware = get_middleware(middleware_name)\n        if middleware:\n            context = await middleware.process(user_input, context)\n        \n        return context\n\n"
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 59,
"end": 61,
"text": "class OrchestratorRegistry:\n    \"\"\"ç¼–æ’å™¨æ³¨å†Œè¡¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 62,
"end": 65,
"text": "    def __init__(self):\n        self._orchestrators: Dict[str, type] = {}\n        self._instances: Dict[str, BaseOrchestrator] = {}\n    "
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 66,
"end": 73,
"text": "    def register(self, name: str, orchestrator_class: type):\n        \"\"\"æ³¨å†Œç¼–æ’å™¨\"\"\"\n        if not issubclass(orchestrator_class, BaseOrchestrator):\n            raise TypeError(f\"{orchestrator_class} must inherit from BaseOrchestrator\")\n        \n        self._orchestrators[name] = orchestrator_class\n        logger.info(f\"å·²æ³¨å†Œç¼–æ’å™¨: {name}\")\n    "
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 74,
"end": 84,
"text": "    def get(self, name: str) -> Optional[BaseOrchestrator]:\n        \"\"\"è·å–ç¼–æ’å™¨å®ä¾‹ï¼ˆå•ä¾‹ï¼‰\"\"\"\n        if name not in self._orchestrators:\n            logger.error(f\"ç¼–æ’å™¨ '{name}' æœªæ³¨å†Œ\")\n            return None\n        \n        if name not in self._instances:\n            self._instances[name] = self._orchestrators[name]()\n        \n        return self._instances[name]\n    "
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 85,
"end": 93,
"text": "    def list_orchestrators(self) -> list:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰ç¼–æ’å™¨\"\"\"\n        return list(self._orchestrators.keys())\n\n\n# å…¨å±€æ³¨å†Œè¡¨\n_orchestrator_registry = OrchestratorRegistry()\n\n"
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 94,
"end": 98,
"text": "def get_orchestrator_registry() -> OrchestratorRegistry:\n    \"\"\"è·å–ç¼–æ’å™¨æ³¨å†Œè¡¨\"\"\"\n    return _orchestrator_registry\n\n"
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 99,
"end": 103,
"text": "def get_orchestrator(name: str) -> Optional[BaseOrchestrator]:\n    \"\"\"è·å–ç¼–æ’å™¨\"\"\"\n    return _orchestrator_registry.get(name)\n\n"
},
{
"path": "daoyoucode/agents/core/orchestrator.py",
"start": 104,
"end": 106,
"text": "def register_orchestrator(name: str, orchestrator_class: type):\n    \"\"\"æ³¨å†Œç¼–æ’å™¨\"\"\"\n    _orchestrator_registry.register(name, orchestrator_class)"
},
{
"path": "daoyoucode/agents/core/parallel_executor.py",
"start": 1,
"end": 15,
"text": "\"\"\"\nå¹¶è¡Œæ‰§è¡Œå™¨\n\næ”¯æŒçœŸæ­£çš„åå°ä»»åŠ¡å¹¶è¡Œæ‰§è¡Œã€‚\nçµæ„Ÿæ¥æºï¼šoh-my-opencodeçš„Parallel Execution\n\"\"\"\n\nimport asyncio\nfrom typing import Dict, Any, Optional\nimport logging\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/parallel_executor.py",
"start": 16,
"end": 20,
"text": "class ParallelExecutor:\n    \"\"\"å¹¶è¡Œæ‰§è¡Œå™¨ï¼ˆå•ä¾‹ï¼‰\"\"\"\n    \n    _instance = None\n    "
},
{
"path": "daoyoucode/agents/core/parallel_executor.py",
"start": 21,
"end": 26,
"text": "    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    "
},
{
"path": "daoyoucode/agents/core/parallel_executor.py",
"start": 27,
"end": 119,
"text": "    def __init__(self):\n        if self._initialized:\n            return\n        \n        self.tasks: Dict[str, asyncio.Task] = {}\n        self.results: Dict[str, Any] = {}\n        self.metadata: Dict[str, Dict] = {}\n        self._initialized = True\n        logger.info(\"ParallelExecutor åˆå§‹åŒ–å®Œæˆ\")\n    \n    async def submit(\n        self,\n        task_id: str,\n        coro,\n        metadata: Optional[Dict] = None\n    ) -> str:\n        \"\"\"\n        æäº¤åå°ä»»åŠ¡\n        \n        Args:\n            task_id: ä»»åŠ¡ID\n            coro: åç¨‹\n            metadata: å…ƒæ•°æ®\n        \n        Returns:\n            task_id\n        \"\"\"\n        # åˆ›å»ºå¼‚æ­¥ä»»åŠ¡\n        task = asyncio.create_task(coro)\n        self.tasks[task_id] = task\n        self.metadata[task_id] = {\n            'submitted_at': datetime.now(),\n            'status': 'running',\n            **(metadata or {})\n        }\n        \n        logger.info(f\"æäº¤åå°ä»»åŠ¡: {task_id}\")\n        return task_id\n    \n    async def get_result(\n        self,\n        task_id: str,\n        timeout: Optional[float] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        è·å–ä»»åŠ¡ç»“æœ\n        \n        Args:\n            task_id: ä»»åŠ¡ID\n            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰\n        \n        Returns:\n            ä»»åŠ¡ç»“æœ\n        \"\"\"\n        # æ£€æŸ¥ç¼“å­˜\n        if task_id in self.results:\n            return self.results[task_id]\n        \n        # è·å–ä»»åŠ¡\n        task = self.tasks.get(task_id)\n        if not task:\n            return {\n                'status': 'error',\n                'error': f'Task {task_id} not found'\n            }\n        \n        try:\n            # ç­‰å¾…ç»“æœ\n            result = await asyncio.wait_for(task, timeout=timeout)\n            \n            # ç¼“å­˜ç»“æœ\n            self.results[task_id] = result\n            self.metadata[task_id]['status'] = 'completed'\n            self.metadata[task_id]['completed_at'] = datetime.now()\n            \n            logger.info(f\"ä»»åŠ¡å®Œæˆ: {task_id}\")\n            return result\n        \n        except asyncio.TimeoutError:\n            logger.warning(f\"ä»»åŠ¡è¶…æ—¶: {task_id}\")\n            return {\n                'status': 'timeout',\n                'task_id': task_id\n            }\n        \n        except Exception as e:\n            logger.error(f\"ä»»åŠ¡å¤±è´¥: {task_id}, {e}\")\n            self.metadata[task_id]['status'] = 'failed'\n            return {\n                'status': 'error',\n                'error': str(e)\n            }\n    "
},
{
"path": "daoyoucode/agents/core/parallel_executor.py",
"start": 120,
"end": 129,
"text": "    def cancel(self, task_id: str) -> bool:\n        \"\"\"å–æ¶ˆä»»åŠ¡\"\"\"\n        task = self.tasks.get(task_id)\n        if task:\n            task.cancel()\n            self.metadata[task_id]['status'] = 'cancelled'\n            logger.info(f\"å–æ¶ˆä»»åŠ¡: {task_id}\")\n            return True\n        return False\n    "
},
{
"path": "daoyoucode/agents/core/parallel_executor.py",
"start": 130,
"end": 139,
"text": "    def cancel_all(self):\n        \"\"\"å–æ¶ˆæ‰€æœ‰ä»»åŠ¡\"\"\"\n        for task_id, task in self.tasks.items():\n            if not task.done():\n                task.cancel()\n                self.metadata[task_id]['status'] = 'cancelled'\n        \n        logger.info(f\"å–æ¶ˆæ‰€æœ‰ä»»åŠ¡: {len(self.tasks)} ä¸ª\")\n        self.tasks.clear()\n    "
},
{
"path": "daoyoucode/agents/core/parallel_executor.py",
"start": 140,
"end": 143,
"text": "    def get_status(self, task_id: str) -> Optional[str]:\n        \"\"\"è·å–ä»»åŠ¡çŠ¶æ€\"\"\"\n        return self.metadata.get(task_id, {}).get('status')\n    "
},
{
"path": "daoyoucode/agents/core/parallel_executor.py",
"start": 144,
"end": 148,
"text": "    def list_tasks(self) -> Dict[str, Dict]:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰ä»»åŠ¡\"\"\"\n        return self.metadata.copy()\n\n"
},
{
"path": "daoyoucode/agents/core/parallel_executor.py",
"start": 149,
"end": 151,
"text": "def get_parallel_executor() -> ParallelExecutor:\n    \"\"\"è·å–å¹¶è¡Œæ‰§è¡Œå™¨å®ä¾‹\"\"\"\n    return ParallelExecutor()"
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 1,
"end": 20,
"text": "\"\"\"\nç»†ç²’åº¦æƒé™æ§åˆ¶ç³»ç»Ÿ\n\næä¾›æ–‡ä»¶çº§åˆ«ã€ç›®å½•çº§åˆ«ã€æ“ä½œçº§åˆ«çš„æƒé™æ§åˆ¶ã€‚\nçµæ„Ÿæ¥æºï¼šopencodeçš„ç»†ç²’åº¦æƒé™è§„åˆ™\n\"\"\"\n\nfrom typing import Dict, List, Literal, Optional, Union, Any\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nimport fnmatch\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nPermissionAction = Literal[\"allow\", \"deny\", \"ask\"]\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 21,
"end": 27,
"text": "class PermissionRule:\n    \"\"\"æƒé™è§„åˆ™\"\"\"\n    pattern: str                          # åŒ¹é…æ¨¡å¼ï¼ˆæ”¯æŒé€šé…ç¬¦ï¼‰\n    action: PermissionAction              # æƒé™åŠ¨ä½œ\n    priority: int = 100                   # ä¼˜å…ˆçº§ï¼ˆæ•°å­—è¶Šå°è¶Šä¼˜å…ˆï¼‰\n    reason: Optional[str] = None          # åŸå› è¯´æ˜\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 28,
"end": 31,
"text": "    def matches(self, path: str) -> bool:\n        \"\"\"æ£€æŸ¥è·¯å¾„æ˜¯å¦åŒ¹é…\"\"\"\n        return fnmatch.fnmatch(path, self.pattern)\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 32,
"end": 36,
"text": "    def __repr__(self):\n        return f\"Rule({self.pattern} -> {self.action})\"\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 37,
"end": 42,
"text": "class PermissionCategory:\n    \"\"\"æƒé™ç±»åˆ«\"\"\"\n    name: str\n    rules: List[PermissionRule] = field(default_factory=list)\n    default_action: PermissionAction = \"ask\"\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 43,
"end": 49,
"text": "    def add_rule(self, pattern: str, action: PermissionAction, priority: int = 100, reason: Optional[str] = None):\n        \"\"\"æ·»åŠ è§„åˆ™\"\"\"\n        rule = PermissionRule(pattern, action, priority, reason)\n        self.rules.append(rule)\n        # æŒ‰ä¼˜å…ˆçº§æ’åº\n        self.rules.sort(key=lambda r: r.priority)\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 50,
"end": 62,
"text": "    def check(self, path: str) -> PermissionAction:\n        \"\"\"æ£€æŸ¥æƒé™\"\"\"\n        # æŒ‰ä¼˜å…ˆçº§é¡ºåºæ£€æŸ¥è§„åˆ™\n        for rule in self.rules:\n            if rule.matches(path):\n                logger.debug(f\"æƒé™åŒ¹é…: {path} -> {rule}\")\n                return rule.action\n        \n        # æ²¡æœ‰åŒ¹é…çš„è§„åˆ™ï¼Œä½¿ç”¨é»˜è®¤åŠ¨ä½œ\n        logger.debug(f\"æƒé™é»˜è®¤: {path} -> {self.default_action}\")\n        return self.default_action\n\n"
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 63,
"end": 67,
"text": "class PermissionManager:\n    \"\"\"æƒé™ç®¡ç†å™¨ï¼ˆå•ä¾‹ï¼‰\"\"\"\n    \n    _instance = None\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 68,
"end": 73,
"text": "    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 74,
"end": 82,
"text": "    def __init__(self):\n        if self._initialized:\n            return\n        \n        self.categories: Dict[str, PermissionCategory] = {}\n        self._init_default_permissions()\n        self._initialized = True\n        logger.info(\"PermissionManager åˆå§‹åŒ–å®Œæˆ\")\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 83,
"end": 226,
"text": "    def _init_default_permissions(self):\n        \"\"\"åˆå§‹åŒ–é»˜è®¤æƒé™\"\"\"\n        # è¯»å–æƒé™ï¼ˆçµæ„Ÿæ¥è‡ªopencodeï¼‰\n        read_category = PermissionCategory(\"read\", default_action=\"allow\")\n        read_category.add_rule(\"*\", \"allow\", priority=1000)\n        # æ•æ„Ÿæ–‡ä»¶éœ€è¦ç¡®è®¤\n        read_category.add_rule(\"*.env\", \"ask\", priority=10, reason=\"æ•æ„Ÿæ–‡ä»¶\")\n        read_category.add_rule(\"*.env.*\", \"ask\", priority=10, reason=\"æ•æ„Ÿæ–‡ä»¶\")\n        read_category.add_rule(\"*.env.example\", \"allow\", priority=5)  # ç¤ºä¾‹æ–‡ä»¶å¯ä»¥è¯»å–\n        read_category.add_rule(\"*.env.local\", \"ask\", priority=8, reason=\"æœ¬åœ°ç¯å¢ƒå˜é‡\")\n        read_category.add_rule(\"*.env.production\", \"ask\", priority=5, reason=\"ç”Ÿäº§ç¯å¢ƒå˜é‡\")\n        read_category.add_rule(\"*.key\", \"ask\", priority=10, reason=\"å¯†é’¥æ–‡ä»¶\")\n        read_category.add_rule(\"*.pem\", \"ask\", priority=10, reason=\"è¯ä¹¦æ–‡ä»¶\")\n        read_category.add_rule(\"*.crt\", \"ask\", priority=10, reason=\"è¯ä¹¦æ–‡ä»¶\")\n        read_category.add_rule(\"*.p12\", \"ask\", priority=10, reason=\"è¯ä¹¦æ–‡ä»¶\")\n        read_category.add_rule(\"*secret*\", \"ask\", priority=20, reason=\"å¯èƒ½åŒ…å«æ•æ„Ÿä¿¡æ¯\")\n        read_category.add_rule(\"*password*\", \"ask\", priority=20, reason=\"å¯èƒ½åŒ…å«å¯†ç \")\n        read_category.add_rule(\"*token*\", \"ask\", priority=20, reason=\"å¯èƒ½åŒ…å«ä»¤ç‰Œ\")\n        read_category.add_rule(\"*credential*\", \"ask\", priority=20, reason=\"å¯èƒ½åŒ…å«å‡­è¯\")\n        read_category.add_rule(\".git/config\", \"ask\", priority=15, reason=\"Gité…ç½®\")\n        read_category.add_rule(\".ssh/*\", \"ask\", priority=10, reason=\"SSHå¯†é’¥\")\n        self.categories[\"read\"] = read_category\n        \n        # å†™å…¥æƒé™ï¼ˆæ›´ç»†ç²’åº¦ï¼‰\n        write_category = PermissionCategory(\"write\", default_action=\"ask\")\n        # å…è®¸å†™å…¥å¸¸è§ä»£ç æ–‡ä»¶\n        write_category.add_rule(\"*.py\", \"allow\", priority=100)\n        write_category.add_rule(\"*.js\", \"allow\", priority=100)\n        write_category.add_rule(\"*.ts\", \"allow\", priority=100)\n        write_category.add_rule(\"*.jsx\", \"allow\", priority=100)\n        write_category.add_rule(\"*.tsx\", \"allow\", priority=100)\n        write_category.add_rule(\"*.java\", \"allow\", priority=100)\n        write_category.add_rule(\"*.cpp\", \"allow\", priority=100)\n        write_category.add_rule(\"*.c\", \"allow\", priority=100)\n        write_category.add_rule(\"*.h\", \"allow\", priority=100)\n        write_category.add_rule(\"*.go\", \"allow\", priority=100)\n        write_category.add_rule(\"*.rs\", \"allow\", priority=100)\n        write_category.add_rule(\"*.md\", \"allow\", priority=100)\n        write_category.add_rule(\"*.txt\", \"allow\", priority=100)\n        write_category.add_rule(\"*.json\", \"allow\", priority=100)\n        write_category.add_rule(\"*.yaml\", \"allow\", priority=100)\n        write_category.add_rule(\"*.yml\", \"allow\", priority=100)\n        write_category.add_rule(\"*.toml\", \"allow\", priority=100)\n        write_category.add_rule(\"*.ini\", \"allow\", priority=100)\n        write_category.add_rule(\"*.cfg\", \"allow\", priority=100)\n        # ç¦æ­¢å†™å…¥æ•æ„Ÿæ–‡ä»¶\n        write_category.add_rule(\"*.env\", \"deny\", priority=10, reason=\"ç¦æ­¢ä¿®æ”¹ç¯å¢ƒå˜é‡æ–‡ä»¶\")\n        write_category.add_rule(\"*.env.*\", \"ask\", priority=15, reason=\"ç¯å¢ƒå˜é‡æ–‡ä»¶éœ€è¦ç¡®è®¤\")\n        write_category.add_rule(\"*.env.example\", \"allow\", priority=5)  # ç¤ºä¾‹æ–‡ä»¶å¯ä»¥ä¿®æ”¹\n        write_category.add_rule(\"*.key\", \"deny\", priority=10, reason=\"ç¦æ­¢ä¿®æ”¹å¯†é’¥æ–‡ä»¶\")\n        write_category.add_rule(\"*.pem\", \"deny\", priority=10, reason=\"ç¦æ­¢ä¿®æ”¹è¯ä¹¦æ–‡ä»¶\")\n        write_category.add_rule(\"*.crt\", \"deny\", priority=10, reason=\"ç¦æ­¢ä¿®æ”¹è¯ä¹¦æ–‡ä»¶\")\n        write_category.add_rule(\".git/*\", \"deny\", priority=10, reason=\"ç¦æ­¢ç›´æ¥ä¿®æ”¹Gitç›®å½•\")\n        write_category.add_rule(\".gitignore\", \"allow\", priority=5)  # ä½†å…è®¸ä¿®æ”¹.gitignore\n        write_category.add_rule(\"package-lock.json\", \"ask\", priority=20, reason=\"é”æ–‡ä»¶éœ€è¦ç¡®è®¤\")\n        write_category.add_rule(\"yarn.lock\", \"ask\", priority=20, reason=\"é”æ–‡ä»¶éœ€è¦ç¡®è®¤\")\n        write_category.add_rule(\"Pipfile.lock\", \"ask\", priority=20, reason=\"é”æ–‡ä»¶éœ€è¦ç¡®è®¤\")\n        write_category.add_rule(\"poetry.lock\", \"ask\", priority=20, reason=\"é”æ–‡ä»¶éœ€è¦ç¡®è®¤\")\n        self.categories[\"write\"] = write_category\n        \n        # åˆ é™¤æƒé™ï¼ˆæ›´ç»†ç²’åº¦ï¼‰\n        delete_category = PermissionCategory(\"delete\", default_action=\"ask\""
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 227,
"end": 255,
"text": "    def check_permission(\n        self, \n        category: str, \n        path: str,\n        auto_approve: bool = False\n    ) -> PermissionAction:\n        \"\"\"\n        æ£€æŸ¥æƒé™\n        \n        Args:\n            category: æƒé™ç±»åˆ«ï¼ˆread, write, delete, executeç­‰ï¼‰\n            path: è·¯å¾„æˆ–å‘½ä»¤\n            auto_approve: æ˜¯å¦è‡ªåŠ¨æ‰¹å‡†ï¼ˆç”¨äºæµ‹è¯•ï¼‰\n            \n        Returns:\n            æƒé™åŠ¨ä½œ\n        \"\"\"\n        if auto_approve:\n            return \"allow\"\n        \n        cat = self.categories.get(category)\n        if not cat:\n            logger.warning(f\"æœªçŸ¥çš„æƒé™ç±»åˆ«: {category}\")\n            return \"ask\"\n        \n        action = cat.check(path)\n        logger.info(f\"æƒé™æ£€æŸ¥: {category}:{path} -> {action}\")\n        return action\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 256,
"end": 279,
"text": "    def add_rule(\n        self, \n        category: str, \n        pattern: str, \n        action: PermissionAction,\n        priority: int = 100,\n        reason: Optional[str] = None\n    ):\n        \"\"\"\n        æ·»åŠ æƒé™è§„åˆ™\n        \n        Args:\n            category: æƒé™ç±»åˆ«\n            pattern: åŒ¹é…æ¨¡å¼\n            action: æƒé™åŠ¨ä½œ\n            priority: ä¼˜å…ˆçº§\n            reason: åŸå› è¯´æ˜\n        \"\"\"\n        if category not in self.categories:\n            self.categories[category] = PermissionCategory(category)\n        \n        self.categories[category].add_rule(pattern, action, priority, reason)\n        logger.info(f\"æ·»åŠ æƒé™è§„åˆ™: {category}:{pattern} -> {action}\")\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 280,
"end": 304,
"text": "    def load_config(self, config: Dict[str, Any]):\n        \"\"\"\n        ä»é…ç½®åŠ è½½æƒé™è§„åˆ™\n        \n        é…ç½®æ ¼å¼:\n        {\n            \"read\": {\n                \"*.secret\": \"deny\",\n                \"*.public\": \"allow\"\n            },\n            \"write\": {\n                \"*.lock\": \"deny\"\n            }\n        }\n        \"\"\"\n        for category, rules in config.items():\n            if isinstance(rules, dict):\n                for pattern, action in rules.items():\n                    if action in [\"allow\", \"deny\", \"ask\"]:\n                        self.add_rule(category, pattern, action)\n                    else:\n                        logger.warning(f\"æ— æ•ˆçš„æƒé™åŠ¨ä½œ: {action}\")\n            else:\n                logger.warning(f\"æ— æ•ˆçš„æƒé™é…ç½®: {category}\")\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 305,
"end": 308,
"text": "    def get_category(self, category: str) -> Optional[PermissionCategory]:\n        \"\"\"è·å–æƒé™ç±»åˆ«\"\"\"\n        return self.categories.get(category)\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 309,
"end": 312,
"text": "    def list_categories(self) -> List[str]:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰æƒé™ç±»åˆ«\"\"\"\n        return list(self.categories.keys())\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 313,
"end": 331,
"text": "    def list_rules(self, category: Optional[str] = None) -> Dict[str, List[PermissionRule]]:\n        \"\"\"\n        åˆ—å‡ºæƒé™è§„åˆ™\n        \n        Args:\n            category: å¯é€‰çš„ç±»åˆ«è¿‡æ»¤\n            \n        Returns:\n            ç±»åˆ«åˆ°è§„åˆ™åˆ—è¡¨çš„æ˜ å°„\n        \"\"\"\n        if category:\n            cat = self.categories.get(category)\n            return {category: cat.rules if cat else []}\n        \n        return {\n            name: cat.rules\n            for name, cat in self.categories.items()\n        }\n    "
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 332,
"end": 352,
"text": "    def clear(self, category: Optional[str] = None):\n        \"\"\"\n        æ¸…ç©ºæƒé™è§„åˆ™\n        \n        Args:\n            category: å¯é€‰çš„ç±»åˆ«è¿‡æ»¤ï¼ŒNoneè¡¨ç¤ºæ¸…ç©ºæ‰€æœ‰\n        \"\"\"\n        if category:\n            if category in self.categories:\n                self.categories[category].rules = []\n                logger.info(f\"æ¸…ç©ºæƒé™è§„åˆ™: {category}\")\n        else:\n            for cat in self.categories.values():\n                cat.rules = []\n            logger.info(\"æ¸…ç©ºæ‰€æœ‰æƒé™è§„åˆ™\")\n\n\n# å…¨å±€æƒé™ç®¡ç†å™¨å®ä¾‹\n_permission_manager = PermissionManager()\n\n"
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 353,
"end": 357,
"text": "def get_permission_manager() -> PermissionManager:\n    \"\"\"è·å–æƒé™ç®¡ç†å™¨å®ä¾‹\"\"\"\n    return _permission_manager\n\n"
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 358,
"end": 377,
"text": "def check_permission(\n    category: str, \n    path: str,\n    auto_approve: bool = False\n) -> PermissionAction:\n    \"\"\"\n    ä¾¿æ·å‡½æ•°ï¼šæ£€æŸ¥æƒé™\n    \n    Args:\n        category: æƒé™ç±»åˆ«\n        path: è·¯å¾„æˆ–å‘½ä»¤\n        auto_approve: æ˜¯å¦è‡ªåŠ¨æ‰¹å‡†\n        \n    Returns:\n        æƒé™åŠ¨ä½œ\n    \"\"\"\n    manager = get_permission_manager()\n    return manager.check_permission(category, path, auto_approve)\n\n"
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 378,
"end": 383,
"text": "def require_permission(category: str):\n    \"\"\"\n    æƒé™è£…é¥°å™¨\n    \n    ä½¿ç”¨ç¤ºä¾‹:\n        @require_permission(\"write\")"
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 384,
"end": 387,
"text": "        def write_file(path: str, content: str):\n            # è‡ªåŠ¨æ£€æŸ¥å†™å…¥æƒé™\n            ...\n    \"\"\""
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 388,
"end": 388,
"text": "    def decorator(func):"
},
{
"path": "daoyoucode/agents/core/permission.py",
"start": 389,
"end": 407,
"text": "        def wrapper(*args, **kwargs):\n            # å°è¯•ä»å‚æ•°ä¸­æå–è·¯å¾„\n            path = kwargs.get('path') or (args[0] if args else None)\n            if not path:\n                logger.warning(f\"æ— æ³•ä»å‚æ•°ä¸­æå–è·¯å¾„ï¼Œè·³è¿‡æƒé™æ£€æŸ¥\")\n                return func(*args, **kwargs)\n            \n            action = check_permission(category, str(path))\n            \n            if action == \"deny\":\n                raise PermissionError(f\"æƒé™è¢«æ‹’ç»: {category}:{path}\")\n            elif action == \"ask\":\n                # è¿™é‡Œåº”è¯¥è¯¢é—®ç”¨æˆ·ï¼Œç®€åŒ–èµ·è§ç›´æ¥æ‹’ç»\n                logger.warning(f\"éœ€è¦ç”¨æˆ·ç¡®è®¤: {category}:{path}\")\n                raise PermissionError(f\"éœ€è¦ç”¨æˆ·ç¡®è®¤: {category}:{path}\")\n            \n            return func(*args, **kwargs)\n        return wrapper\n    return decorator"
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 1,
"end": 22,
"text": "\"\"\"\næ‰§è¡Œè®¡åˆ’å™¨\n\nåœ¨æ‰§è¡Œå‰è¿›è¡Œæ™ºèƒ½è§„åˆ’ï¼š\n1. ä»»åŠ¡å¤æ‚åº¦åˆ†æ\n2. æ‰§è¡Œæ­¥éª¤ç”Ÿæˆ\n3. æˆæœ¬é¢„ä¼°ï¼ˆtokensã€æ—¶é—´ï¼‰\n4. é£é™©è¯†åˆ«\n5. ç¼–æ’å™¨æ™ºèƒ½é€‰æ‹©ï¼ˆä¸Routeré…åˆï¼‰\n\næ³¨æ„ï¼šExecutionPlanneræ˜¯å¯é€‰çš„ï¼Œä¸å½±å“åŸæœ‰çš„ç›´æ¥æ‰§è¡Œæµç¨‹\n\"\"\"\n\nfrom typing import Dict, Any, Optional, List, Tuple\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 23,
"end": 32,
"text": "class ExecutionStep:\n    \"\"\"æ‰§è¡Œæ­¥éª¤\"\"\"\n    step_id: int\n    description: str\n    orchestrator: str\n    agent: Optional[str] = None\n    estimated_tokens: int = 0\n    estimated_time: float = 0.0  # ç§’\n    dependencies: List[int] = field(default_factory=list)  # ä¾èµ–çš„æ­¥éª¤ID\n    "
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 33,
"end": 46,
"text": "    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"è½¬æ¢ä¸ºå­—å…¸\"\"\"\n        return {\n            'step_id': self.step_id,\n            'description': self.description,\n            'orchestrator': self.orchestrator,\n            'agent': self.agent,\n            'estimated_tokens': self.estimated_tokens,\n            'estimated_time': self.estimated_time,\n            'dependencies': self.dependencies\n        }\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 47,
"end": 58,
"text": "class ExecutionPlan:\n    \"\"\"æ‰§è¡Œè®¡åˆ’\"\"\"\n    plan_id: str\n    task_description: str\n    complexity: int  # 1-5\n    steps: List[ExecutionStep]\n    total_estimated_tokens: int\n    total_estimated_time: float  # ç§’\n    risks: List[str]\n    recommendations: List[str]\n    created_at: datetime = field(default_factory=datetime.now)\n    "
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 59,
"end": 73,
"text": "    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"è½¬æ¢ä¸ºå­—å…¸\"\"\"\n        return {\n            'plan_id': self.plan_id,\n            'task_description': self.task_description,\n            'complexity': self.complexity,\n            'steps': [s.to_dict() for s in self.steps],\n            'total_estimated_tokens': self.total_estimated_tokens,\n            'total_estimated_time': self.total_estimated_time,\n            'risks': self.risks,\n            'recommendations': self.recommendations,\n            'created_at': self.created_at.isoformat()\n        }\n\n"
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 74,
"end": 87,
"text": "class ExecutionPlanner:\n    \"\"\"\n    æ‰§è¡Œè®¡åˆ’å™¨\n    \n    èŒè´£ï¼š\n    1. åˆ†æä»»åŠ¡å¤æ‚åº¦\n    2. ç”Ÿæˆæ‰§è¡Œæ­¥éª¤\n    3. é¢„ä¼°æˆæœ¬ï¼ˆtokensã€æ—¶é—´ï¼‰\n    4. è¯†åˆ«é£é™©\n    5. æä¾›å»ºè®®\n    \n    æ³¨æ„ï¼šè¿™æ˜¯å¯é€‰åŠŸèƒ½ï¼Œä¸å½±å“åŸæœ‰çš„ç›´æ¥æ‰§è¡Œæµç¨‹\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 88,
"end": 207,
"text": "    def __init__(self, use_router: bool = True):\n        \"\"\"\n        åˆå§‹åŒ–æ‰§è¡Œè®¡åˆ’å™¨\n        \n        Args:\n            use_router: æ˜¯å¦ä½¿ç”¨IntelligentRouterï¼ˆå¯é€‰ï¼‰\n        \"\"\"\n        self.use_router = use_router\n        \n        # å¤æ‚åº¦è¯„ä¼°è§„åˆ™\n        self.complexity_rules = {\n            'keywords': {\n                'simple': ['ç®€å•', 'å¿«é€Ÿ', 'ç›´æ¥', 'æŸ¥çœ‹'],\n                'medium': ['åˆ†æ', 'ç”Ÿæˆ', 'ä¿®æ”¹', 'ä¼˜åŒ–'],\n                'complex': ['é‡æ„', 'è®¾è®¡', 'æ¶æ„', 'å®Œæ•´'],\n                'very_complex': ['ç³»ç»Ÿ', 'å…¨é¢', 'æ·±åº¦', 'å¤æ‚']\n            },\n            'length_thresholds': {\n                'simple': 20,\n                'medium': 50,\n                'complex': 100,\n                'very_complex': 200\n            }\n        }\n        \n        # æˆæœ¬ä¼°ç®—è§„åˆ™ï¼ˆåŸºäºç»éªŒå€¼ï¼‰\n        self.cost_rules = {\n            'simple': {'tokens': 500, 'time': 2.0},\n            'workflow': {'tokens': 2000, 'time': 10.0},\n            'parallel': {'tokens': 1500, 'time': 5.0},\n            'multi_agent': {'tokens': 3000, 'time': 15.0},\n            'conditional': {'tokens': 1000, 'time': 5.0},\n            'parallel_explore': {'tokens': 2500, 'time': 12.0}\n        }\n        \n        logger.info(\"æ‰§è¡Œè®¡åˆ’å™¨å·²åˆå§‹åŒ–\")\n    \n    async def create_plan(\n        self,\n        task_description: str,\n        context: Optional[Dict[str, Any]] = None,\n        orchestrator: Optional[str] = None\n    ) -> ExecutionPlan:\n        \"\"\"\n        åˆ›å»ºæ‰§è¡Œè®¡åˆ’\n        \n        Args:\n            task_description: ä»»åŠ¡æè¿°\n            context: ä¸Šä¸‹æ–‡ï¼ˆå¯é€‰ï¼‰\n            orchestrator: æŒ‡å®šçš„ç¼–æ’å™¨ï¼ˆå¯é€‰ï¼Œå¦‚æœä¸æŒ‡å®šåˆ™è‡ªåŠ¨é€‰æ‹©ï¼‰\n        \n        Returns:\n            æ‰§è¡Œè®¡åˆ’\n        \"\"\"\n        if context is None:\n            context = {}\n        \n        import uuid\n        plan_id = str(uuid.uuid4())\n        \n        # 1. åˆ†æä»»åŠ¡å¤æ‚åº¦\n        complexity = self._analyze_complexity(task_description, context)\n        \n        logger.info(f\"ä»»åŠ¡å¤æ‚åº¦: {complexity}/5\")\n        \n        # 2. é€‰æ‹©ç¼–æ’å™¨ï¼ˆå¦‚æœæœªæŒ‡å®šï¼‰\n        if not orchestrator:\n            orchestrator = await self._select_orchestrator(\n                task_description,\n                complexity,\n                context\n            )\n        \n        logger.info(f\"é€‰æ‹©ç¼–æ’å™¨: {orchestrator}\")\n        \n        # 3. ç”Ÿæˆæ‰§è¡Œæ­¥éª¤\n        steps = await self._generate_steps(\n            task_description,\n            orchestrator,\n            complexity,\n            context\n        )\n        \n        # 4. é¢„ä¼°æˆæœ¬\n        total_tokens, total_time = self._estimate_cost(steps, orchestrator)\n        \n        # 5. è¯†åˆ«é£é™©\n        risks = self._identify_risks(\n            task_description,\n            orchestrator,\n            complexity,\n            steps\n        )\n        \n        # 6. ç”Ÿæˆå»ºè®®\n        recommendations = self._generate_recommendations(\n            task_description,\n            orchestrator,\n            complexity,\n            risks\n        )\n        \n        plan = ExecutionPlan(\n            plan_id=plan_id,\n            task_description=task_description,\n            complexity=complexity,\n            steps=steps,\n            total_estimated_tokens=total_tokens,\n            total_estimated_time=total_time,\n            risks=risks,\n            recommendations=recommendations\n        )\n        \n        logger.info(f\"æ‰§è¡Œè®¡åˆ’å·²åˆ›å»º: {plan_id[:8]}...\")\n        logger.info(f\"  æ­¥éª¤æ•°: {len(steps)}\")\n        logger.info(f\"  é¢„ä¼°tokens: {total_tokens}\")\n        logger.info(f\"  é¢„ä¼°æ—¶é—´: {total_time:.1f}ç§’\")\n        \n        return plan\n    "
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 208,
"end": 444,
"text": "    def _analyze_complexity(\n        self,\n        task_description: str,\n        context: Dict[str, Any]\n    ) -> int:\n        \"\"\"\n        åˆ†æä»»åŠ¡å¤æ‚åº¦ï¼ˆ1-5ï¼‰\n        \n        Args:\n            task_description: ä»»åŠ¡æè¿°\n            context: ä¸Šä¸‹æ–‡\n        \n        Returns:\n            å¤æ‚åº¦ï¼ˆ1-5ï¼‰\n        \"\"\"\n        complexity = 1\n        task_lower = task_description.lower()\n        \n        # 1. åŸºäºå…³é”®è¯\n        for level, keywords in self.complexity_rules['keywords'].items():\n            if any(kw in task_lower for kw in keywords):\n                if level == 'simple':\n                    complexity = max(complexity, 1)\n                elif level == 'medium':\n                    complexity = max(complexity, 2)\n                elif level == 'complex':\n                    complexity = max(complexity, 3)\n                elif level == 'very_complex':\n                    complexity = max(complexity, 4)\n        \n        # 2. åŸºäºé•¿åº¦\n        length = len(task_description)\n        if length > self.complexity_rules['length_thresholds']['very_complex']:\n            complexity = max(complexity, 5)\n        elif length > self.complexity_rules['length_thresholds']['complex']:\n            complexity = max(complexity, 4)\n        elif length > self.complexity_rules['length_thresholds']['medium']:\n            complexity = max(complexity, 3)\n        \n        # 3. åŸºäºåˆ†å¥æ•°\n        sentence_count = task_description.count('ã€‚') + task_description.count('ï¼Œ')\n        if sentence_count >= 5:\n            complexity = max(complexity, 4)\n        elif sentence_count >= 3:\n            complexity = max(complexity, 3)\n        \n        # 4. åŸºäºä¸Šä¸‹æ–‡\n        if context.get('has_dependencies'):\n            complexity += 1\n        \n        if context.get('requires_multiple_agents'):\n            complexity += 1\n        \n        return min(complexity, 5)\n    \n    async def _select_orchestrator(\n        self,\n        task_description: str,\n        complexity: int,\n        context: Dict[str, Any]\n    ) -> str:\n        \"\"\"\n        é€‰æ‹©æœ€ä¼˜ç¼–æ’å™¨\n        \n        Args:\n            task_description: ä»»åŠ¡æè¿°\n            complexity: å¤æ‚åº¦\n            context: ä¸Šä¸‹æ–‡\n        \n        Returns:\n            ç¼–æ’å™¨åç§°\n        \"\"\"\n        # å¦‚æœå¯ç”¨äº†Routerï¼Œä½¿ç”¨Routeré€‰æ‹©\n        if self.use_router:\n            try:\n                from .router import get_intelligent_router\n                router = get_intelligent_router()\n                decision = await router.route(task_description, context)\n                return decision.orchestrator\n            except Exception as e:\n                logger.warning(f\"Routeré€‰æ‹©å¤±è´¥: {e}ï¼Œä½¿ç”¨é»˜è®¤è§„åˆ™\")\n        \n        # å¦åˆ™ä½¿ç”¨ç®€å•è§„åˆ™\n        task_lower = task_description.lower()\n        \n        # æ¢ç´¢ä»»åŠ¡\n        if any(kw in task_lower for kw in ['æŸ¥æ‰¾', 'æœç´¢', 'æ¢ç´¢', 'åˆ—å‡º']):\n            return 'parallel_explore'\n        \n        # å¤šæ­¥éª¤ä»»åŠ¡\n        if any(kw in task_lower for kw in ['æ­¥éª¤', 'æµç¨‹', 'å…ˆ', 'ç„¶å']):\n            return 'workflow'\n        \n        # æ¡ä»¶ä»»åŠ¡\n        if any(kw in task_lower for kw in ['å¦‚æœ', 'æ ¹æ®', 'åˆ¤æ–­']):\n            return 'conditional'\n        \n        # è¾©è®ºä»»åŠ¡\n        if any(kw in task_lower for kw in ['è®¨è®º', 'è¾©è®º', 'å¯¹æ¯”']):\n            return 'multi_agent'\n        \n        # å¹¶è¡Œä»»åŠ¡\n        if any(kw in task_lower for kw in ['æ‰¹é‡', 'å¤šä¸ª', 'æ‰€æœ‰']):\n            return 'parallel'\n        \n        # é»˜è®¤ï¼šç®€å•ä»»åŠ¡\n        return 'simple'\n    \n    async def _generate_steps(\n        self,\n        task_description: str,\n        orchestrator: str,\n        complexity: int,\n        context: Dict[str, Any]\n    ) -> List[ExecutionStep]:\n        \"\"\"\n        ç”Ÿæˆæ‰§è¡Œæ­¥éª¤\n        \n        Args:\n            task_description: ä»»åŠ¡æè¿°\n            orchestrator: ç¼–æ’å™¨\n            complexity: å¤æ‚åº¦\n            context: ä¸Šä¸‹æ–‡\n        \n        Returns:\n            æ‰§è¡Œæ­¥éª¤åˆ—è¡¨\n        \"\"\"\n        steps = []\n        \n        # æ ¹æ®ç¼–æ’å™¨ç±»å‹ç”Ÿæˆæ­¥éª¤\n        if orchestrator == 'simple':\n            # ç®€å•ä»»åŠ¡ï¼šå•æ­¥éª¤\n            steps.append(ExecutionStep(\n                step_id=1,\n                description=task_description,\n                orchestrator='simple',\n        "
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 445,
"end": 470,
"text": "    def _estimate_cost(\n        self,\n        steps: List[ExecutionStep],\n        orchestrator: str\n    ) -> Tuple[int, float]:\n        \"\"\"\n        é¢„ä¼°æˆæœ¬\n        \n        Args:\n            steps: æ‰§è¡Œæ­¥éª¤\n            orchestrator: ç¼–æ’å™¨\n        \n        Returns:\n            (æ€»tokens, æ€»æ—¶é—´)\n        \"\"\"\n        # åŸºäºæ­¥éª¤çš„ä¼°ç®—\n        total_tokens = sum(step.estimated_tokens for step in steps)\n        total_time = sum(step.estimated_time for step in steps)\n        \n        # æ·»åŠ ç¼–æ’å™¨å¼€é”€\n        orch_cost = self.cost_rules.get(orchestrator, {'tokens': 0, 'time': 0})\n        total_tokens += orch_cost['tokens'] * 0.1  # 10%å¼€é”€\n        total_time += orch_cost['time'] * 0.1\n        \n        return int(total_tokens), total_time\n    "
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 471,
"end": 518,
"text": "    def _identify_risks(\n        self,\n        task_description: str,\n        orchestrator: str,\n        complexity: int,\n        steps: List[ExecutionStep]\n    ) -> List[str]:\n        \"\"\"\n        è¯†åˆ«é£é™©\n        \n        Args:\n            task_description: ä»»åŠ¡æè¿°\n            orchestrator: ç¼–æ’å™¨\n            complexity: å¤æ‚åº¦\n            steps: æ‰§è¡Œæ­¥éª¤\n        \n        Returns:\n            é£é™©åˆ—è¡¨\n        \"\"\"\n        risks = []\n        \n        # 1. å¤æ‚åº¦é£é™©\n        if complexity >= 4:\n            risks.append(\"ä»»åŠ¡å¤æ‚åº¦è¾ƒé«˜ï¼Œå¯èƒ½éœ€è¦å¤šæ¬¡è¿­ä»£\")\n        \n        # 2. æ­¥éª¤æ•°é£é™©\n        if len(steps) > 5:\n            risks.append(f\"æ‰§è¡Œæ­¥éª¤è¾ƒå¤šï¼ˆ{len(steps)}æ­¥ï¼‰ï¼Œå¯èƒ½è€—æ—¶è¾ƒé•¿\")\n        \n        # 3. ä¾èµ–é£é™©\n        has_dependencies = any(step.dependencies for step in steps)\n        if has_dependencies:\n            risks.append(\"å­˜åœ¨æ­¥éª¤ä¾èµ–ï¼Œå‰ç½®æ­¥éª¤å¤±è´¥ä¼šå½±å“åç»­æ­¥éª¤\")\n        \n        # 4. ç¼–æ’å™¨ç‰¹å®šé£é™©\n        if orchestrator == 'multi_agent':\n            risks.append(\"å¤šæ™ºèƒ½ä½“åä½œå¯èƒ½äº§ç”Ÿä¸ä¸€è‡´çš„è§‚ç‚¹\")\n        \n        if orchestrator == 'parallel':\n            risks.append(\"å¹¶è¡Œæ‰§è¡Œå¯èƒ½å¯¼è‡´èµ„æºç«äº‰\")\n        \n        # 5. æˆæœ¬é£é™©\n        total_tokens = sum(step.estimated_tokens for step in steps)\n        if total_tokens > 5000:\n            risks.append(f\"é¢„ä¼°tokensè¾ƒé«˜ï¼ˆ{total_tokens}ï¼‰ï¼Œæˆæœ¬è¾ƒå¤§\")\n        \n        return risks\n    "
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 519,
"end": 570,
"text": "    def _generate_recommendations(\n        self,\n        task_description: str,\n        orchestrator: str,\n        complexity: int,\n        risks: List[str]\n    ) -> List[str]:\n        \"\"\"\n        ç”Ÿæˆå»ºè®®\n        \n        Args:\n            task_description: ä»»åŠ¡æè¿°\n            orchestrator: ç¼–æ’å™¨\n            complexity: å¤æ‚åº¦\n            risks: é£é™©åˆ—è¡¨\n        \n        Returns:\n            å»ºè®®åˆ—è¡¨\n        \"\"\"\n        recommendations = []\n        \n        # 1. åŸºäºå¤æ‚åº¦çš„å»ºè®®\n        if complexity >= 4:\n            recommendations.append(\"å»ºè®®åˆ†é˜¶æ®µæ‰§è¡Œï¼Œæ¯é˜¶æ®µéªŒè¯ç»“æœ\")\n        \n        # 2. åŸºäºç¼–æ’å™¨çš„å»ºè®®\n        if orchestrator == 'workflow':\n            recommendations.append(\"å»ºè®®åœ¨å…³é”®æ­¥éª¤è®¾ç½®æ£€æŸ¥ç‚¹\")\n        \n        if orchestrator == 'multi_agent':\n            recommendations.append(\"å»ºè®®è®¾ç½®æ˜ç¡®çš„è¯„åˆ¤æ ‡å‡†\")\n        \n        if orchestrator == 'parallel':\n            recommendations.append(\"å»ºè®®æ§åˆ¶å¹¶è¡Œåº¦ï¼Œé¿å…èµ„æºè€—å°½\")\n        \n        # 3. åŸºäºé£é™©çš„å»ºè®®\n        if \"tokensè¾ƒé«˜\" in str(risks):\n            recommendations.append(\"å»ºè®®ä¼˜åŒ–promptï¼Œå‡å°‘ä¸å¿…è¦çš„ä¸Šä¸‹æ–‡\")\n        \n        if \"æ­¥éª¤è¾ƒå¤š\" in str(risks):\n            recommendations.append(\"å»ºè®®è€ƒè™‘æ˜¯å¦å¯ä»¥åˆå¹¶æŸäº›æ­¥éª¤\")\n        \n        # 4. é€šç”¨å»ºè®®\n        recommendations.append(\"å»ºè®®å¯ç”¨æ—¥å¿—è®°å½•ï¼Œä¾¿äºè°ƒè¯•\")\n        \n        return recommendations\n\n\n# å•ä¾‹æ¨¡å¼ï¼ˆå¯é€‰ï¼‰\n_planner_instance = None\n\n"
},
{
"path": "daoyoucode/agents/core/planner.py",
"start": 571,
"end": 587,
"text": "def get_execution_planner(use_router: bool = True) -> ExecutionPlanner:\n    \"\"\"\n    è·å–æ‰§è¡Œè®¡åˆ’å™¨å•ä¾‹\n    \n    Args:\n        use_router: æ˜¯å¦ä½¿ç”¨IntelligentRouter\n    \n    Returns:\n        æ‰§è¡Œè®¡åˆ’å™¨å®ä¾‹\n    \"\"\"\n    global _planner_instance\n    \n    if _planner_instance is None:\n        _planner_instance = ExecutionPlanner(use_router)\n        logger.info(\"æ‰§è¡Œè®¡åˆ’å™¨å•ä¾‹å·²åˆ›å»º\")\n    \n    return _planner_instance"
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 1,
"end": 19,
"text": "\"\"\"\nåŠ¨æ€Promptæ„å»ºå™¨\n\næ”¯æŒï¼š\n- æ¡ä»¶åŒ–å†…å®¹\n- æ¨¡æ¿æ¸²æŸ“\n- Promptä¼˜åŒ–\n- Tokenè®¡æ•°\n\"\"\"\n\nimport logging\nfrom typing import Dict, Any, List, Optional, Callable\nfrom dataclasses import dataclass\nfrom jinja2 import Template\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 20,
"end": 27,
"text": "class PromptSection:\n    \"\"\"Promptæ®µè½\"\"\"\n    name: str\n    content: str\n    condition: Optional[Callable[[Dict], bool]] = None\n    priority: int = 0  # ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå¤§è¶Šé‡è¦\n\n"
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 28,
"end": 30,
"text": "class DynamicPromptBuilder:\n    \"\"\"åŠ¨æ€Promptæ„å»ºå™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 31,
"end": 34,
"text": "    def __init__(self):\n        self.sections: List[PromptSection] = []\n        self.logger = logging.getLogger(\"prompt_builder\")\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 35,
"end": 59,
"text": "    def add_section(\n        self,\n        name: str,\n        content: str,\n        condition: Optional[Callable[[Dict], bool]] = None,\n        priority: int = 0\n    ):\n        \"\"\"\n        æ·»åŠ Promptæ®µè½\n        \n        Args:\n            name: æ®µè½åç§°\n            content: æ®µè½å†…å®¹ï¼ˆæ”¯æŒJinja2æ¨¡æ¿ï¼‰\n            condition: æ¡ä»¶å‡½æ•°ï¼Œè¿”å›Trueæ—¶åŒ…å«æ­¤æ®µè½\n            priority: ä¼˜å…ˆçº§ï¼ˆç”¨äºä¼˜åŒ–æ—¶ä¿ç•™é‡è¦æ®µè½ï¼‰\n        \"\"\"\n        section = PromptSection(\n            name=name,\n            content=content,\n            condition=condition,\n            priority=priority\n        )\n        self.sections.append(section)\n        self.logger.debug(f\"æ·»åŠ æ®µè½: {name} (ä¼˜å…ˆçº§: {priority})\")\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 60,
"end": 124,
"text": "    def build(\n        self,\n        context: Dict[str, Any],\n        max_tokens: Optional[int] = None\n    ) -> str:\n        \"\"\"\n        æ„å»ºæœ€ç»ˆPrompt\n        \n        Args:\n            context: ä¸Šä¸‹æ–‡æ•°æ®\n            max_tokens: æœ€å¤§tokenæ•°ï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            æ„å»ºçš„Prompt\n        \"\"\"\n        parts = []\n        \n        # 1. ç­›é€‰æ®µè½ï¼ˆæ ¹æ®æ¡ä»¶ï¼‰\n        active_sections = []\n        for section in self.sections:\n            if section.condition:\n                try:\n                    if not section.condition(context):\n                        self.logger.debug(f\"è·³è¿‡æ®µè½ {section.name}ï¼ˆæ¡ä»¶ä¸æ»¡è¶³ï¼‰\")\n                        continue\n                except Exception as e:\n                    self.logger.warning(f\"æ®µè½ {section.name} æ¡ä»¶è¯„ä¼°å¤±è´¥: {e}\")\n                    continue\n            \n            active_sections.append(section)\n        \n        # 2. æ¸²æŸ“æ®µè½\n        rendered_sections = []\n        for section in active_sections:\n            try:\n                rendered = self._render_template(section.content, context)\n                rendered_sections.append({\n                    'name': section.name,\n                    'content': rendered,\n                    'priority': section.priority,\n                    'tokens': self._count_tokens(rendered)\n                })\n            except Exception as e:\n                self.logger.error(f\"æ®µè½ {section.name} æ¸²æŸ“å¤±è´¥: {e}\")\n        \n        # 3. ä¼˜åŒ–ï¼ˆå¦‚æœéœ€è¦ï¼‰\n        if max_tokens:\n            rendered_sections = self._optimize_sections(\n                rendered_sections,\n                max_tokens\n            )\n        \n        # 4. æ‹¼æ¥\n        for section in rendered_sections:\n            parts.append(section['content'])\n        \n        final_prompt = \"\\n\\n\".join(parts)\n        \n        self.logger.info(\n            f\"æ„å»ºPromptå®Œæˆ: {len(rendered_sections)} ä¸ªæ®µè½, \"\n            f\"{self._count_tokens(final_prompt)} tokens\"\n        )\n        \n        return final_prompt\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 125,
"end": 128,
"text": "    def _render_template(self, template: str, context: Dict[str, Any]) -> str:\n        \"\"\"æ¸²æŸ“æ¨¡æ¿\"\"\"\n        return Template(template).render(**context)\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 129,
"end": 137,
"text": "    def _count_tokens(self, text: str) -> int:\n        \"\"\"è®¡ç®—tokensï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰\"\"\"\n        # ç®€åŒ–è®¡ç®—ï¼š1 token â‰ˆ 4 å­—ç¬¦ï¼ˆè‹±æ–‡ï¼‰æˆ– 1.5 å­—ç¬¦ï¼ˆä¸­æ–‡ï¼‰\n        # å®é™…åº”è¯¥ä½¿ç”¨tiktokenæˆ–litellm\n        chinese_chars = sum(1 for c in text if '\\u4e00' <= c <= '\\u9fff')\n        other_chars = len(text) - chinese_chars\n        \n        return int(chinese_chars / 1.5 + other_chars / 4)\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 138,
"end": 190,
"text": "    def _optimize_sections(\n        self,\n        sections: List[Dict],\n        max_tokens: int\n    ) -> List[Dict]:\n        \"\"\"\n        ä¼˜åŒ–æ®µè½ä»¥é€‚åº”tokené™åˆ¶\n        \n        ç­–ç•¥ï¼š\n        1. æŒ‰ä¼˜å…ˆçº§æ’åº\n        2. ä¿ç•™é«˜ä¼˜å…ˆçº§æ®µè½\n        3. å‹ç¼©æˆ–ç§»é™¤ä½ä¼˜å…ˆçº§æ®µè½\n        \"\"\"\n        # è®¡ç®—æ€»tokens\n        total_tokens = sum(s['tokens'] for s in sections)\n        \n        if total_tokens <= max_tokens:\n            return sections\n        \n        self.logger.info(\n            f\"Promptè¿‡é•¿ ({total_tokens} tokens > {max_tokens}), å¼€å§‹ä¼˜åŒ–\"\n        )\n        \n        # æŒ‰ä¼˜å…ˆçº§æ’åºï¼ˆé™åºï¼‰\n        sorted_sections = sorted(\n            sections,\n            key=lambda s: s['priority'],\n            reverse=True\n        )\n        \n        # ä¿ç•™æ®µè½ç›´åˆ°è¾¾åˆ°é™åˆ¶\n        optimized = []\n        current_tokens = 0\n        \n        for section in sorted_sections:\n            if current_tokens + section['tokens'] <= max_tokens:\n                optimized.append(section)\n                current_tokens += section['tokens']\n            else:\n                self.logger.debug(\n                    f\"ç§»é™¤æ®µè½ {section['name']} (ä¼˜å…ˆçº§: {section['priority']})\"\n                )\n        \n        # æ¢å¤åŸå§‹é¡ºåº\n        optimized.sort(key=lambda s: sections.index(s))\n        \n        self.logger.info(\n            f\"ä¼˜åŒ–å®Œæˆ: ä¿ç•™ {len(optimized)}/{len(sections)} ä¸ªæ®µè½, \"\n            f\"{current_tokens} tokens\"\n        )\n        \n        return optimized\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 191,
"end": 195,
"text": "    def clear(self):\n        \"\"\"æ¸…ç©ºæ‰€æœ‰æ®µè½\"\"\"\n        self.sections.clear()\n\n"
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 196,
"end": 198,
"text": "class PromptOptimizer:\n    \"\"\"Promptä¼˜åŒ–å™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 199,
"end": 248,
"text": "    def __init__(self):\n        self.logger = logging.getLogger(\"prompt_optimizer\")\n    \n    async def optimize(\n        self,\n        prompt: str,\n        context: Dict[str, Any],\n        max_tokens: int\n    ) -> str:\n        \"\"\"\n        ä¼˜åŒ–Prompté•¿åº¦\n        \n        ç­–ç•¥ï¼š\n        1. ç§»é™¤ç¤ºä¾‹\n        2. å‹ç¼©å†å²\n        3. æ‘˜è¦åŒ–\n        \"\"\"\n        current_tokens = self._count_tokens(prompt)\n        \n        if current_tokens <= max_tokens:\n            return prompt\n        \n        self.logger.info(\n            f\"Promptè¿‡é•¿ ({current_tokens} > {max_tokens}), å¼€å§‹ä¼˜åŒ–\"\n        )\n        \n        # 1. ç§»é™¤ç¤ºä¾‹\n        prompt = self._remove_examples(prompt)\n        current_tokens = self._count_tokens(prompt)\n        \n        if current_tokens <= max_tokens:\n            self.logger.info(\"ä¼˜åŒ–å®Œæˆï¼ˆç§»é™¤ç¤ºä¾‹ï¼‰\")\n            return prompt\n        \n        # 2. å‹ç¼©å†å²\n        if 'conversation_history' in context:\n            context['conversation_history'] = self._compress_history(\n                context['conversation_history'],\n                max_length=5\n            )\n            # é‡æ–°æ¸²æŸ“promptï¼ˆå¦‚æœæ˜¯æ¨¡æ¿ï¼‰\n            # è¿™é‡Œç®€åŒ–å¤„ç†\n        \n        # 3. æˆªæ–­\n        if current_tokens > max_tokens:\n            prompt = self._truncate(prompt, max_tokens)\n        \n        self.logger.info(\"ä¼˜åŒ–å®Œæˆ\")\n        return prompt\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 249,
"end": 254,
"text": "    def _count_tokens(self, text: str) -> int:\n        \"\"\"è®¡ç®—tokens\"\"\"\n        chinese_chars = sum(1 for c in text if '\\u4e00' <= c <= '\\u9fff')\n        other_chars = len(text) - chinese_chars\n        return int(chinese_chars / 1.5 + other_chars / 4)\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 255,
"end": 265,
"text": "    def _remove_examples(self, prompt: str) -> str:\n        \"\"\"ç§»é™¤ç¤ºä¾‹\"\"\"\n        import re\n        # ç§»é™¤ <example>...</example> æ ‡ç­¾\n        return re.sub(\n            r'<example>.*?</example>',\n            '',\n            prompt,\n            flags=re.DOTALL\n        )\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 266,
"end": 277,
"text": "    def _compress_history(\n        self,\n        history: List[Dict],\n        max_length: int\n    ) -> List[Dict]:\n        \"\"\"å‹ç¼©å†å²\"\"\"\n        if len(history) <= max_length:\n            return history\n        \n        # ä¿ç•™æœ€è¿‘çš„Næ¡\n        return history[-max_length:]\n    "
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 278,
"end": 289,
"text": "    def _truncate(self, prompt: str, max_tokens: int) -> str:\n        \"\"\"æˆªæ–­prompt\"\"\"\n        # ç®€åŒ–ï¼šæŒ‰å­—ç¬¦æˆªæ–­\n        max_chars = max_tokens * 4  # ç²—ç•¥ä¼°è®¡\n        \n        if len(prompt) <= max_chars:\n            return prompt\n        \n        return prompt[:max_chars] + \"\\n\\n[å†…å®¹å·²æˆªæ–­]\"\n\n\n# é¢„å®šä¹‰çš„å¸¸ç”¨æ¡ä»¶"
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 290,
"end": 294,
"text": "def is_followup(context: Dict) -> bool:\n    \"\"\"æ˜¯å¦æ˜¯è¿½é—®\"\"\"\n    return context.get('is_followup', False)\n\n"
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 295,
"end": 299,
"text": "def has_history(context: Dict) -> bool:\n    \"\"\"æ˜¯å¦æœ‰å†å²\"\"\"\n    return bool(context.get('conversation_history'))\n\n"
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 300,
"end": 304,
"text": "def has_tools(context: Dict) -> bool:\n    \"\"\"æ˜¯å¦æœ‰å·¥å…·\"\"\"\n    return bool(context.get('tools'))\n\n"
},
{
"path": "daoyoucode/agents/core/prompt_builder.py",
"start": 305,
"end": 327,
"text": "def has_code_context(context: Dict) -> bool:\n    \"\"\"æ˜¯å¦æœ‰ä»£ç ä¸Šä¸‹æ–‡\"\"\"\n    return bool(context.get('code_context'))\n\n\n# é¢„å®šä¹‰çš„Promptæ¨¡æ¿\nROLE_TEMPLATE = \"\"\"ä½ æ˜¯{{agent_name}}ï¼Œä¸“æ³¨äº{{domain}}ã€‚\"\"\"\n\nHISTORY_TEMPLATE = \"\"\"å†å²å¯¹è¯æ‘˜è¦ï¼š\n{{summary}}\"\"\"\n\nTOOLS_TEMPLATE = \"\"\"å¯ç”¨å·¥å…·ï¼š\n{% for tool in tools %}\n- {{tool.name}}: {{tool.description}}\n{% endfor %}\"\"\"\n\nCODE_CONTEXT_TEMPLATE = \"\"\"ç›¸å…³ä»£ç ï¼š\n{% for name, code in code_context.items() %}\n[{{name}}]\n```\n{{code}}\n```\n{% endfor %}\"\"\""
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 1,
"end": 18,
"text": "\"\"\"\nå¤±è´¥æ¢å¤ç®¡ç†å™¨\n\nå€Ÿé‰´daoyouCodePilotçš„è‡ªåŠ¨é‡è¯•å’Œå¤±è´¥åˆ†ææœºåˆ¶ï¼Œæä¾›ï¼š\n- è‡ªåŠ¨é‡è¯•ï¼ˆæœ€å¤šNæ¬¡ï¼‰\n- ç»“æœéªŒè¯\n- é”™è¯¯åˆ†æå’Œä¿®å¤å»ºè®®\n- å›æ»šæœºåˆ¶\n\"\"\"\n\nimport logging\nfrom typing import Callable, Optional, Dict, Any, List\nfrom dataclasses import dataclass\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 19,
"end": 21,
"text": "class MaxRetriesExceeded(Exception):\n    \"\"\"è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 22,
"end": 27,
"text": "    def __init__(self, message: str, last_error: Optional[Exception] = None):\n        super().__init__(message)\n        self.last_error = last_error\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 28,
"end": 35,
"text": "class RecoveryConfig:\n    \"\"\"æ¢å¤é…ç½®\"\"\"\n    max_retries: int = 3\n    enable_analysis: bool = True\n    enable_rollback: bool = False\n    retry_delay: float = 1.0  # é‡è¯•å»¶è¿Ÿï¼ˆç§’ï¼‰\n\n"
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 36,
"end": 38,
"text": "class RecoveryManager:\n    \"\"\"å¤±è´¥æ¢å¤ç®¡ç†å™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 39,
"end": 146,
"text": "    def __init__(self, config: Optional[RecoveryConfig] = None):\n        self.config = config or RecoveryConfig()\n        self.retry_count = 0\n        self.history: List[Dict] = []\n    \n    async def execute_with_recovery(\n        self,\n        func: Callable,\n        *args,\n        validator: Optional[Callable[[Any], bool]] = None,\n        analyzer: Optional[Callable[[Any, Optional[Exception]], str]] = None,\n        **kwargs\n    ) -> Any:\n        \"\"\"\n        å¸¦æ¢å¤æœºåˆ¶çš„æ‰§è¡Œ\n        \n        Args:\n            func: è¦æ‰§è¡Œçš„å‡½æ•°\n            validator: ç»“æœéªŒè¯å‡½æ•°ï¼Œè¿”å›Trueè¡¨ç¤ºç»“æœæœ‰æ•ˆ\n            analyzer: é”™è¯¯åˆ†æå‡½æ•°ï¼Œè¿”å›ä¿®å¤å»ºè®®\n            *args, **kwargs: ä¼ é€’ç»™funcçš„å‚æ•°\n        \n        Returns:\n            æ‰§è¡Œç»“æœ\n        \n        Raises:\n            MaxRetriesExceeded: è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°\n        \"\"\"\n        last_error = None\n        \n        while self.retry_count < self.config.max_retries:\n            try:\n                logger.info(f\"æ‰§è¡Œå°è¯• {self.retry_count + 1}/{self.config.max_retries}\")\n                \n                # æ‰§è¡Œå‡½æ•°\n                result = await func(*args, **kwargs)\n                \n                # è®°å½•å†å²\n                self.history.append({\n                    'attempt': self.retry_count + 1,\n                    'success': True,\n                    'result': result\n                })\n                \n                # éªŒè¯ç»“æœ\n                if validator:\n                    is_valid = validator(result)\n                    if not is_valid:\n                        logger.warning(f\"ç»“æœéªŒè¯å¤±è´¥: {result}\")\n                        \n                        # åˆ†æå¹¶ä¿®å¤\n                        if self.config.enable_analysis and analyzer:\n                            fix_instruction = analyzer(result, None)\n                            if fix_instruction:\n                                logger.info(f\"ä¿®å¤å»ºè®®: {fix_instruction}\")\n                                # æ›´æ–°è¾“å…¥\n                                if 'user_input' in kwargs:\n                                    kwargs['user_input'] = fix_instruction\n                                self.retry_count += 1\n                                await asyncio.sleep(self.config.retry_delay)\n                                continue\n                        \n                        # æ— æ³•ä¿®å¤ï¼Œè¿”å›ç»“æœ\n                        logger.warning(\"æ— æ³•ç”Ÿæˆä¿®å¤å»ºè®®ï¼Œè¿”å›å½“å‰ç»“æœ\")\n                        return result\n                \n                # éªŒè¯é€šè¿‡æˆ–æ— éœ€éªŒè¯\n                logger.info(\"æ‰§è¡ŒæˆåŠŸ\")\n                return result\n            \n            except Exception as e:\n                last_error = e\n                logger.error(f\"æ‰§è¡Œå¤±è´¥ (ç¬¬{self.retry_count + 1}æ¬¡): {e}\")\n                \n                # è®°å½•å†å²\n                self.history.append({\n                    'attempt': self.retry_count + 1,\n                    'success': False,\n                    'error': str(e)\n                })\n                \n                # åˆ†æé”™è¯¯\n                if self.config.enable_analysis and analyzer:\n                    fix_instruction = analyzer(None, e)\n                    if fix_instruction:\n                        logger.info(f\"ä¿®å¤å»ºè®®: {fix_instruction}\")\n                        # æ›´æ–°è¾“å…¥\n                        if 'user_input' in kwargs:\n                            kwargs['user_input'] = fix_instruction\n                        self.retry_count += 1\n                        await asyncio.sleep(self.config.retry_delay)\n                        continue\n                \n                # æ— æ³•ä¿®å¤ï¼Œé‡è¯•\n                self.retry_count += 1\n                if self.retry_count < self.config.max_retries:\n                    await asyncio.sleep(self.config.retry_delay)\n                    continue\n                \n                # é‡è¯•æ¬¡æ•°ç”¨å®Œ\n                break\n        \n        # é‡è¯•æ¬¡æ•°ç”¨å®Œ\n        raise MaxRetriesExceeded(\n            f\"æ‰§è¡Œå¤±è´¥ï¼Œå·²é‡è¯•{self.config.max_retries}æ¬¡\",\n            last_error=last_error\n        )\n    "
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 147,
"end": 151,
"text": "    def reset(self):\n        \"\"\"é‡ç½®çŠ¶æ€\"\"\"\n        self.retry_count = 0\n        self.history.clear()\n    "
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 152,
"end": 157,
"text": "    def get_history(self) -> List[Dict]:\n        \"\"\"è·å–æ‰§è¡Œå†å²\"\"\"\n        return self.history.copy()\n\n\n# å¸¸ç”¨éªŒè¯å™¨"
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 158,
"end": 164,
"text": "def validate_non_empty(result: Any) -> bool:\n    \"\"\"éªŒè¯ç»“æœéç©º\"\"\"\n    if isinstance(result, dict):\n        return bool(result.get('content') or result.get('response'))\n    return bool(result)\n\n"
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 165,
"end": 171,
"text": "def validate_success_flag(result: Any) -> bool:\n    \"\"\"éªŒè¯successæ ‡å¿—\"\"\"\n    if isinstance(result, dict):\n        return result.get('success', False)\n    return True\n\n"
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 172,
"end": 179,
"text": "def validate_no_error(result: Any) -> bool:\n    \"\"\"éªŒè¯æ— é”™è¯¯\"\"\"\n    if isinstance(result, dict):\n        return 'error' not in result\n    return True\n\n\n# å¸¸ç”¨åˆ†æå™¨"
},
{
"path": "daoyoucode/agents/core/recovery.py",
"start": 180,
"end": 241,
"text": "def simple_analyzer(result: Optional[Any], error: Optional[Exception]) -> str:\n    \"\"\"ç®€å•åˆ†æå™¨\"\"\"\n    if error:\n        return f\"ä¸Šæ¬¡æ‰§è¡Œå‡ºé”™: {error}ï¼Œè¯·é‡æ–°å°è¯•\"\n    \n    if result:\n        return f\"ä¸Šæ¬¡ç»“æœä¸ç¬¦åˆé¢„æœŸ: {result}ï¼Œè¯·æ”¹è¿›\"\n    \n    return \"\"\n\n\nasync def llm_analyzer(\n    result: Optional[Any],\n    error: Optional[Exception],\n    llm_client = None\n) -> str:\n    \"\"\"\n    ä½¿ç”¨LLMåˆ†æé”™è¯¯\n    \n    Args:\n        result: æ‰§è¡Œç»“æœ\n        error: é”™è¯¯ä¿¡æ¯\n        llm_client: LLMå®¢æˆ·ç«¯\n    \n    Returns:\n        ä¿®å¤å»ºè®®\n    \"\"\"\n    if not llm_client:\n        return simple_analyzer(result, error)\n    \n    # æ„å»ºåˆ†æPrompt\n    if error:\n        prompt = f\"\"\"åˆ†æä»¥ä¸‹é”™è¯¯å¹¶ç»™å‡ºä¿®å¤å»ºè®®ï¼š\n\né”™è¯¯ç±»å‹: {type(error).__name__}\né”™è¯¯ä¿¡æ¯: {str(error)}\n\nè¯·ç»™å‡ºå…·ä½“çš„ä¿®å¤æŒ‡ä»¤ï¼Œç›´æ¥è¯´æ˜å¦‚ä½•ä¿®å¤ï¼Œä¸è¦è§£é‡Šã€‚\"\"\"\n    \n    elif result:\n        prompt = f\"\"\"åˆ†æä»¥ä¸‹æ‰§è¡Œç»“æœå¹¶ç»™å‡ºæ”¹è¿›å»ºè®®ï¼š\n\nç»“æœ: {result}\n\nè¯·ç»™å‡ºå…·ä½“çš„æ”¹è¿›æŒ‡ä»¤ï¼Œç›´æ¥è¯´æ˜å¦‚ä½•æ”¹è¿›ï¼Œä¸è¦è§£é‡Šã€‚\"\"\"\n    \n    else:\n        return \"\"\n    \n    try:\n        # è°ƒç”¨LLM\n        response = await llm_client.chat(\n            messages=[{\"role\": \"user\", \"content\": prompt}],\n            temperature=0.3,\n            max_tokens=200\n        )\n        \n        return response.get('content', '')\n    \n    except Exception as e:\n        logger.error(f\"LLMåˆ†æå¤±è´¥: {e}\")\n        return simple_analyzer(result, error)"
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 1,
"end": 15,
"text": "\"\"\"\næ™ºèƒ½è·¯ç”±å™¨\n\næ ¹æ®ä»»åŠ¡ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜ç¼–æ’å™¨å’ŒAgent\n\"\"\"\n\nfrom typing import Dict, Any, Optional, List, Tuple\nfrom dataclasses import dataclass\nimport logging\nimport re\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 16,
"end": 26,
"text": "class TaskFeatures:\n    \"\"\"ä»»åŠ¡ç‰¹å¾\"\"\"\n    is_exploration: bool = False      # æ˜¯å¦æ˜¯æ¢ç´¢ä»»åŠ¡\n    is_multi_step: bool = False       # æ˜¯å¦æ˜¯å¤šæ­¥éª¤ä»»åŠ¡\n    is_parallel: bool = False         # æ˜¯å¦æ˜¯å¹¶è¡Œä»»åŠ¡\n    is_conditional: bool = False      # æ˜¯å¦æ˜¯æ¡ä»¶ä»»åŠ¡\n    is_debate: bool = False           # æ˜¯å¦éœ€è¦è¾©è®º\n    complexity: int = 1               # å¤æ‚åº¦ï¼ˆ1-5ï¼‰\n    domain: Optional[str] = None      # é¢†åŸŸï¼ˆcode, doc, testç­‰ï¼‰\n    keywords: List[str] = None        # å…³é”®è¯\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 27,
"end": 32,
"text": "    def __post_init__(self):\n        if self.keywords is None:\n            self.keywords = []\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 33,
"end": 40,
"text": "class RoutingDecision:\n    \"\"\"è·¯ç”±å†³ç­–\"\"\"\n    orchestrator: str                 # é€‰æ‹©çš„ç¼–æ’å™¨\n    agent: Optional[str] = None       # é€‰æ‹©çš„Agent\n    confidence: float = 0.0           # ç½®ä¿¡åº¦ï¼ˆ0-1ï¼‰\n    reasoning: str = \"\"               # å†³ç­–ç†ç”±\n    alternatives: List[Tuple[str, float]] = None  # å¤‡é€‰æ–¹æ¡ˆ\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 41,
"end": 45,
"text": "    def __post_init__(self):\n        if self.alternatives is None:\n            self.alternatives = []\n\n"
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 46,
"end": 61,
"text": "class IntelligentRouter:\n    \"\"\"\n    æ™ºèƒ½è·¯ç”±å™¨\n    \n    èŒè´£ï¼š\n    1. åˆ†æä»»åŠ¡ç‰¹å¾\n    2. é€‰æ‹©æœ€ä¼˜ç¼–æ’å™¨\n    3. é€‰æ‹©åˆé€‚çš„Agent\n    4. æä¾›å†³ç­–ç†ç”±\n    \n    æ”¯æŒï¼š\n    - è‡ªåŠ¨å‘ç°å·²æ³¨å†Œçš„Agent\n    - é€šè¿‡é…ç½®æ–‡ä»¶å®šä¹‰Agentå…³é”®è¯\n    - åŠ¨æ€é€‚é…æ–°å¢Agent\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 62,
"end": 115,
"text": "    def __init__(self, agent_config_path: Optional[str] = None):\n        \"\"\"\n        åˆå§‹åŒ–æ™ºèƒ½è·¯ç”±å™¨\n        \n        Args:\n            agent_config_path: Agenté…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰\n                å¦‚æœä¸æä¾›ï¼Œä½¿ç”¨é»˜è®¤é…ç½®\n        \"\"\"\n        # ç¼–æ’å™¨ç‰¹å¾åŒ¹é…è§„åˆ™\n        self.orchestrator_rules = {\n            'parallel_explore': {\n                'keywords': ['æŸ¥æ‰¾', 'æœç´¢', 'æ¢ç´¢', 'å‘ç°', 'åˆ—å‡º', 'æ‰€æœ‰', 'å“ªäº›'],\n                'features': ['is_exploration', 'is_parallel'],\n                'complexity_range': (2, 5),\n                'description': 'å¹¶è¡Œæ¢ç´¢ç¼–æ’å™¨ï¼Œé€‚åˆä»£ç æ¢ç´¢å’Œæœç´¢ä»»åŠ¡'\n            },\n            'workflow': {\n                'keywords': ['æ­¥éª¤', 'æµç¨‹', 'å…ˆ', 'ç„¶å', 'æœ€å', 'ä¾æ¬¡', 'é¡ºåº'],\n                'features': ['is_multi_step'],\n                'complexity_range': (3, 5),\n                'description': 'å·¥ä½œæµç¼–æ’å™¨ï¼Œé€‚åˆå¤šæ­¥éª¤å¤æ‚ä»»åŠ¡'\n            },\n            'conditional': {\n                'keywords': ['å¦‚æœ', 'æ ¹æ®', 'åˆ¤æ–­', 'æ¡ä»¶', 'å¦åˆ™', 'é€‰æ‹©'],\n                'features': ['is_conditional'],\n                'complexity_range': (2, 4),\n                'description': 'æ¡ä»¶ç¼–æ’å™¨ï¼Œé€‚åˆéœ€è¦æ¡ä»¶åˆ¤æ–­çš„ä»»åŠ¡'\n            },\n            'multi_agent': {\n                'keywords': ['è®¨è®º', 'è¾©è®º', 'å¯¹æ¯”', 'å¤šè§’åº¦', 'ç»¼åˆ'],\n                'features': ['is_debate'],\n                'complexity_range': (3, 5),\n                'description': 'å¤šæ™ºèƒ½ä½“ç¼–æ’å™¨ï¼Œé€‚åˆéœ€è¦å¤šè§’åº¦åˆ†æçš„ä»»åŠ¡'\n            },\n            'parallel': {\n                'keywords': ['æ‰¹é‡', 'å¤šä¸ª', 'åŒæ—¶', 'å¹¶è¡Œ'],\n                'features': ['is_parallel'],\n                'complexity_range': (2, 4),\n                'description': 'å¹¶è¡Œç¼–æ’å™¨ï¼Œé€‚åˆæ‰¹é‡å¤„ç†ä»»åŠ¡'\n            },\n            'simple': {\n                'keywords': ['ç®€å•', 'å¿«é€Ÿ', 'ç›´æ¥'],\n                'features': [],\n                'complexity_range': (1, 2),\n                'description': 'ç®€å•ç¼–æ’å™¨ï¼Œé€‚åˆå•ä¸€ç®€å•ä»»åŠ¡'\n            }\n        }\n        \n        # Agenté¢†åŸŸåŒ¹é…è§„åˆ™ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰\n        # æ”¯æŒä»é…ç½®æ–‡ä»¶åŠ è½½æˆ–ä½¿ç”¨é»˜è®¤é…ç½®\n        self.agent_domains = self._load_agent_config(agent_config_path)\n        \n        logger.info(\"æ™ºèƒ½è·¯ç”±å™¨å·²åˆå§‹åŒ–\")\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 116,
"end": 143,
"text": "    def _load_agent_config(self, config_path: Optional[str] = None) -> Dict[str, List[str]]:\n        \"\"\"\n        åŠ è½½Agenté…ç½®\n        \n        Args:\n            config_path: é…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            Agentå…³é”®è¯æ˜ å°„\n        \"\"\"\n        # å¦‚æœæä¾›äº†é…ç½®æ–‡ä»¶ï¼Œå°è¯•åŠ è½½\n        if config_path:\n            try:\n                import yaml\n                from pathlib import Path\n                \n                path = Path(config_path)\n                if path.exists():\n                    with open(path, 'r', encoding='utf-8') as f:\n                        config = yaml.safe_load(f)\n                        logger.info(f\"ä»é…ç½®æ–‡ä»¶åŠ è½½Agentè§„åˆ™: {config_path}\")\n                        return config.get('agent_domains', self._get_default_agent_config())\n            except Exception as e:\n                logger.warning(f\"åŠ è½½Agenté…ç½®å¤±è´¥: {e}ï¼Œä½¿ç”¨é»˜è®¤é…ç½®\")\n        \n        # ä½¿ç”¨é»˜è®¤é…ç½®\n        return self._get_default_agent_config()\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 144,
"end": 154,
"text": "    def _get_default_agent_config(self) -> Dict[str, List[str]]:\n        \"\"\"è·å–é»˜è®¤Agenté…ç½®\"\"\"\n        return {\n            'test_writer': ['æµ‹è¯•', 'test', 'ç”¨ä¾‹', 'å•å…ƒæµ‹è¯•'],\n            'doc_writer': ['æ–‡æ¡£', 'è¯´æ˜', 'readme', 'api'],\n            'debugger': ['è°ƒè¯•', 'bug', 'é”™è¯¯', 'ä¿®å¤', 'é—®é¢˜'],\n            'code_reviewer': ['å®¡æŸ¥', 'æ£€æŸ¥', 'ä¼˜åŒ–', 'æ”¹è¿›', 'é‡æ„'],\n            'code_writer': ['ç¼–å†™', 'ç”Ÿæˆ', 'åˆ›å»º', 'å®ç°', 'å†™', 'hello', 'world'],\n            'code_analyzer': ['åˆ†æ', 'ç»“æ„', 'æŸ¥çœ‹', 'ç†è§£'],\n        }\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 155,
"end": 168,
"text": "    def register_agent_keywords(self, agent_name: str, keywords: List[str]):\n        \"\"\"\n        åŠ¨æ€æ³¨å†ŒAgentå…³é”®è¯\n        \n        Args:\n            agent_name: Agentåç§°\n            keywords: å…³é”®è¯åˆ—è¡¨\n        \n        Example:\n            router.register_agent_keywords('data_scientist', ['æ•°æ®', 'åˆ†æ', 'ç»Ÿè®¡', 'æœºå™¨å­¦ä¹ '])\n        \"\"\"\n        self.agent_domains[agent_name] = keywords\n        logger.info(f\"æ³¨å†ŒAgentå…³é”®è¯: {agent_name} -> {keywords}\")\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 169,
"end": 179,
"text": "    def unregister_agent(self, agent_name: str):\n        \"\"\"\n        å–æ¶ˆæ³¨å†ŒAgent\n        \n        Args:\n            agent_name: Agentåç§°\n        \"\"\"\n        if agent_name in self.agent_domains:\n            del self.agent_domains[agent_name]\n            logger.info(f\"å–æ¶ˆæ³¨å†ŒAgent: {agent_name}\")\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 180,
"end": 188,
"text": "    def list_registered_agents(self) -> List[str]:\n        \"\"\"\n        åˆ—å‡ºæ‰€æœ‰å·²æ³¨å†Œçš„Agent\n        \n        Returns:\n            Agentåç§°åˆ—è¡¨\n        \"\"\"\n        return list(self.agent_domains.keys())\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 189,
"end": 223,
"text": "    def auto_discover_agents(self):\n        \"\"\"\n        è‡ªåŠ¨å‘ç°å·²æ³¨å†Œçš„Agent\n        \n        ä»AgentRegistryä¸­è·å–æ‰€æœ‰å·²æ³¨å†Œçš„Agentï¼Œ\n        å¦‚æœAgentä¸åœ¨é…ç½®ä¸­ï¼Œä½¿ç”¨Agentçš„descriptionä½œä¸ºå…³é”®è¯\n        \"\"\"\n        from .agent import get_agent_registry\n        \n        registry = get_agent_registry()\n        registered_agents = registry.list_agents()\n        \n        discovered_count = 0\n        \n        for agent_name in registered_agents:\n            if agent_name not in self.agent_domains:\n                # è·å–Agentå®ä¾‹\n                agent = registry.get_agent(agent_name)\n                \n                if agent and agent.config.description:\n                    # ä»descriptionæå–å…³é”®è¯ï¼ˆç®€å•åˆ†è¯ï¼‰\n                    keywords = self._extract_keywords_from_description(\n                        agent.config.description\n                    )\n                    \n                    if keywords:\n                        self.agent_domains[agent_name] = keywords\n                        discovered_count += 1\n                        logger.info(f\"è‡ªåŠ¨å‘ç°Agent: {agent_name} -> {keywords}\")\n        \n        if discovered_count > 0:\n            logger.info(f\"è‡ªåŠ¨å‘ç°äº† {discovered_count} ä¸ªæ–°Agent\")\n        \n        return discovered_count\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 224,
"end": 314,
"text": "    def _extract_keywords_from_description(self, description: str) -> List[str]:\n        \"\"\"\n        ä»Agentæè¿°ä¸­æå–å…³é”®è¯\n        \n        Args:\n            description: Agentæè¿°\n        \n        Returns:\n            å…³é”®è¯åˆ—è¡¨\n        \"\"\"\n        import re\n        \n        # æå–ä¸­æ–‡è¯ï¼ˆ2-4ä¸ªå­—ï¼‰\n        chinese_words = re.findall(r'[\\u4e00-\\u9fa5]{2,4}', description.lower())\n        \n        # æå–è‹±æ–‡è¯\n        english_words = re.findall(r'[a-z]{3,}', description.lower())\n        \n        # åˆå¹¶å¹¶å»é‡\n        keywords = list(set(chinese_words + english_words))\n        \n        # é™åˆ¶æ•°é‡\n        return keywords[:10]\n    \n    async def route(\n        self,\n        user_input: str,\n        context: Optional[Dict[str, Any]] = None\n    ) -> RoutingDecision:\n        \"\"\"\n        æ™ºèƒ½è·¯ç”±\n        \n        Args:\n            user_input: ç”¨æˆ·è¾“å…¥\n            context: ä¸Šä¸‹æ–‡ï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            è·¯ç”±å†³ç­–\n        \"\"\"\n        if context is None:\n            context = {}\n        \n        # 1. æå–ä»»åŠ¡ç‰¹å¾\n        features = self._extract_features(user_input, context)\n        \n        logger.info(f\"ä»»åŠ¡ç‰¹å¾: æ¢ç´¢={features.is_exploration}, \"\n                   f\"å¤šæ­¥éª¤={features.is_multi_step}, \"\n                   f\"å¹¶è¡Œ={features.is_parallel}, \"\n                   f\"æ¡ä»¶={features.is_conditional}, \"\n                   f\"å¤æ‚åº¦={features.complexity}\")\n        \n        # 2. è®¡ç®—ç¼–æ’å™¨åŒ¹é…åˆ†æ•°\n        orchestrator_scores = self._calculate_orchestrator_scores(features, user_input)\n        \n        # 3. é€‰æ‹©æœ€ä¼˜ç¼–æ’å™¨\n        best_orchestrator = max(orchestrator_scores.items(), key=lambda x: x[1])\n        orchestrator_name = best_orchestrator[0]\n        confidence = best_orchestrator[1]\n        \n        # 4. é€‰æ‹©Agent\n        agent = self._select_agent(user_input, features)\n        \n        # 5. ç”Ÿæˆå†³ç­–ç†ç”±\n        reasoning = self._generate_reasoning(\n            orchestrator_name,\n            agent,\n            features,\n            user_input\n        )\n        \n        # 6. è·å–å¤‡é€‰æ–¹æ¡ˆ\n        alternatives = sorted(\n            [(k, v) for k, v in orchestrator_scores.items() if k != orchestrator_name],\n            key=lambda x: x[1],\n            reverse=True\n        )[:3]  # å‰3ä¸ªå¤‡é€‰\n        \n        decision = RoutingDecision(\n            orchestrator=orchestrator_name,\n            agent=agent,\n            confidence=confidence,\n            reasoning=reasoning,\n            alternatives=alternatives\n        )\n        \n        logger.info(f\"è·¯ç”±å†³ç­–: {orchestrator_name} (ç½®ä¿¡åº¦: {confidence:.2f})\")\n        if agent:\n            logger.info(f\"é€‰æ‹©Agent: {agent}\")\n        \n        return decision\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 315,
"end": 378,
"text": "    def _extract_features(\n        self,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> TaskFeatures:\n        \"\"\"æå–ä»»åŠ¡ç‰¹å¾\"\"\"\n        \n        user_input_lower = user_input.lower()\n        \n        # æ£€æµ‹æ¢ç´¢ä»»åŠ¡\n        is_exploration = any(\n            kw in user_input_lower\n            for kw in ['æŸ¥æ‰¾', 'æœç´¢', 'æ¢ç´¢', 'å‘ç°', 'åˆ—å‡º', 'å“ªäº›']\n        )\n        \n        # æ£€æµ‹å¤šæ­¥éª¤ä»»åŠ¡\n        is_multi_step = any(\n            kw in user_input_lower\n            for kw in ['æ­¥éª¤', 'æµç¨‹', 'å…ˆ', 'ç„¶å', 'æœ€å', 'ä¾æ¬¡']\n        ) or user_input.count('ï¼Œ') >= 2 or user_input.count('ã€‚') >= 2\n        \n        # æ£€æµ‹å¹¶è¡Œä»»åŠ¡\n        is_parallel = any(\n            kw in user_input_lower\n            for kw in ['æ‰¹é‡', 'å¤šä¸ª', 'æ‰€æœ‰', 'åŒæ—¶', 'å¹¶è¡Œ']\n        )\n        \n        # æ£€æµ‹æ¡ä»¶ä»»åŠ¡\n        is_conditional = any(\n            kw in user_input_lower\n            for kw in ['å¦‚æœ', 'æ ¹æ®', 'åˆ¤æ–­', 'æ¡ä»¶', 'å¦åˆ™']\n        )\n        \n        # æ£€æµ‹è¾©è®ºä»»åŠ¡\n        is_debate = any(\n            kw in user_input_lower\n            for kw in ['è®¨è®º', 'è¾©è®º', 'å¯¹æ¯”', 'å¤šè§’åº¦', 'ç»¼åˆ']\n        )\n        \n        # è®¡ç®—å¤æ‚åº¦\n        complexity = self._calculate_complexity(\n            user_input,\n            is_multi_step,\n            is_parallel,\n            is_conditional\n        )\n        \n        # è¯†åˆ«é¢†åŸŸ\n        domain = self._identify_domain(user_input_lower)\n        \n        # æå–å…³é”®è¯\n        keywords = self._extract_keywords(user_input_lower)\n        \n        return TaskFeatures(\n            is_exploration=is_exploration,\n            is_multi_step=is_multi_step,\n            is_parallel=is_parallel,\n            is_conditional=is_conditional,\n            is_debate=is_debate,\n            complexity=complexity,\n            domain=domain,\n            keywords=keywords\n        )\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 379,
"end": 410,
"text": "    def _calculate_complexity(\n        self,\n        user_input: str,\n        is_multi_step: bool,\n        is_parallel: bool,\n        is_conditional: bool\n    ) -> int:\n        \"\"\"è®¡ç®—ä»»åŠ¡å¤æ‚åº¦ï¼ˆ1-5ï¼‰\"\"\"\n        \n        complexity = 1\n        \n        # åŸºäºé•¿åº¦\n        if len(user_input) > 100:\n            complexity += 1\n        if len(user_input) > 200:\n            complexity += 1\n        \n        # åŸºäºç‰¹å¾\n        if is_multi_step:\n            complexity += 1\n        if is_parallel:\n            complexity += 1\n        if is_conditional:\n            complexity += 1\n        \n        # åŸºäºåˆ†å¥æ•°\n        sentence_count = user_input.count('ã€‚') + user_input.count('ï¼Œ')\n        if sentence_count >= 3:\n            complexity += 1\n        \n        return min(complexity, 5)\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 411,
"end": 427,
"text": "    def _identify_domain(self, user_input_lower: str) -> Optional[str]:\n        \"\"\"è¯†åˆ«ä»»åŠ¡é¢†åŸŸ\"\"\"\n        \n        domain_keywords = {\n            'code': ['ä»£ç ', 'å‡½æ•°', 'ç±»', 'æ–¹æ³•', 'python', 'javascript', 'java', 'æ–‡ä»¶', 'ç»“æ„'],\n            'doc': ['æ–‡æ¡£', 'è¯´æ˜', 'æ³¨é‡Š', 'readme', 'apiæ–‡æ¡£'],\n            'test': ['æµ‹è¯•', 'test', 'ç”¨ä¾‹', 'å•å…ƒæµ‹è¯•'],\n            'debug': ['è°ƒè¯•', 'bug', 'é”™è¯¯', 'ä¿®å¤'],\n            'refactor': ['é‡æ„', 'ä¼˜åŒ–', 'æ”¹è¿›']\n        }\n        \n        for domain, keywords in domain_keywords.items():\n            if any(kw in user_input_lower for kw in keywords):\n                return domain\n        \n        return 'code'  # é»˜è®¤ä¸ºcodeé¢†åŸŸ\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 428,
"end": 439,
"text": "    def _extract_keywords(self, user_input_lower: str) -> List[str]:\n        \"\"\"æå–å…³é”®è¯\"\"\"\n        \n        # ç®€å•çš„å…³é”®è¯æå–ï¼ˆå¯ä»¥ç”¨æ›´å¤æ‚çš„NLPæ–¹æ³•ï¼‰\n        keywords = []\n        \n        # æå–æ‰€æœ‰ä¸­æ–‡è¯ï¼ˆ2-4ä¸ªå­—ï¼‰\n        chinese_words = re.findall(r'[\\u4e00-\\u9fa5]{2,4}', user_input_lower)\n        keywords.extend(chinese_words[:10])  # é™åˆ¶æ•°é‡\n        \n        return keywords\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 440,
"end": 489,
"text": "    def _calculate_orchestrator_scores(\n        self,\n        features: TaskFeatures,\n        user_input: str\n    ) -> Dict[str, float]:\n        \"\"\"è®¡ç®—ç¼–æ’å™¨åŒ¹é…åˆ†æ•°\"\"\"\n        \n        scores = {}\n        user_input_lower = user_input.lower()\n        \n        for orch_name, rules in self.orchestrator_rules.items():\n            score = 0.0\n            \n            # 1. å…³é”®è¯åŒ¹é…ï¼ˆæƒé‡ï¼š0.4ï¼‰\n            keyword_matches = sum(\n                1 for kw in rules['keywords']\n                if kw in user_input_lower\n            )\n            if rules['keywords']:\n                keyword_score = keyword_matches / len(rules['keywords'])\n                score += keyword_score * 0.4\n            \n            # 2. ç‰¹å¾åŒ¹é…ï¼ˆæƒé‡ï¼š0.4ï¼‰\n            feature_matches = sum(\n                1 for feature in rules['features']\n                if getattr(features, feature, False)\n            )\n            if rules['features']:\n                feature_score = feature_matches / len(rules['features'])\n                score += feature_score * 0.4\n            else:\n                # å¦‚æœæ²¡æœ‰ç‰¹å®šç‰¹å¾è¦æ±‚ï¼Œç»™åŸºç¡€åˆ†\n                score += 0.2\n            \n            # 3. å¤æ‚åº¦åŒ¹é…ï¼ˆæƒé‡ï¼š0.2ï¼‰\n            min_complexity, max_complexity = rules['complexity_range']\n            if min_complexity <= features.complexity <= max_complexity:\n                complexity_score = 1.0\n            else:\n                # è¶…å‡ºèŒƒå›´ï¼Œåˆ†æ•°é€’å‡\n                if features.complexity < min_complexity:\n                    complexity_score = features.complexity / min_complexity\n                else:\n                    complexity_score = max_complexity / features.complexity\n            score += complexity_score * 0.2\n            \n            scores[orch_name] = score\n        \n        return scores\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 490,
"end": 522,
"text": "    def _select_agent(\n        self,\n        user_input: str,\n        features: TaskFeatures\n    ) -> Optional[str]:\n        \"\"\"é€‰æ‹©Agent\"\"\"\n        \n        user_input_lower = user_input.lower()\n        \n        # è®¡ç®—æ¯ä¸ªAgentçš„åŒ¹é…åˆ†æ•°\n        agent_scores = {}\n        \n        for agent_name, keywords in self.agent_domains.items():\n            score = sum(1 for kw in keywords if kw in user_input_lower)\n            if score > 0:\n                agent_scores[agent_name] = score\n        \n        if not agent_scores:\n            # å¦‚æœæ²¡æœ‰åŒ¹é…ï¼Œæ ¹æ®domainé€‰æ‹©é»˜è®¤Agent\n            if features.domain == 'code':\n                return 'code_analyzer'\n            elif features.domain == 'test':\n                return 'test_writer'\n            elif features.domain == 'doc':\n                return 'doc_writer'\n            elif features.domain == 'debug':\n                return 'debugger'\n            return None\n        \n        # è¿”å›æœ€é«˜åˆ†çš„Agent\n        best_agent = max(agent_scores.items(), key=lambda x: x[1])\n        return best_agent[0]\n    "
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 523,
"end": 567,
"text": "    def _generate_reasoning(\n        self,\n        orchestrator: str,\n        agent: Optional[str],\n        features: TaskFeatures,\n        user_input: str\n    ) -> str:\n        \"\"\"ç”Ÿæˆå†³ç­–ç†ç”±\"\"\"\n        \n        reasons = []\n        \n        # ç¼–æ’å™¨ç†ç”±\n        orch_rule = self.orchestrator_rules.get(orchestrator, {})\n        reasons.append(f\"é€‰æ‹©{orchestrator}ç¼–æ’å™¨ï¼š{orch_rule.get('description', '')}\")\n        \n        # ç‰¹å¾ç†ç”±\n        feature_reasons = []\n        if features.is_exploration:\n            feature_reasons.append(\"ä»»åŠ¡æ¶‰åŠæ¢ç´¢å’Œæœç´¢\")\n        if features.is_multi_step:\n            feature_reasons.append(\"ä»»åŠ¡åŒ…å«å¤šä¸ªæ­¥éª¤\")\n        if features.is_parallel:\n            feature_reasons.append(\"ä»»åŠ¡å¯ä»¥å¹¶è¡Œå¤„ç†\")\n        if features.is_conditional:\n            feature_reasons.append(\"ä»»åŠ¡éœ€è¦æ¡ä»¶åˆ¤æ–­\")\n        if features.is_debate:\n            feature_reasons.append(\"ä»»åŠ¡éœ€è¦å¤šè§’åº¦åˆ†æ\")\n        \n        if feature_reasons:\n            reasons.append(\"ä»»åŠ¡ç‰¹å¾ï¼š\" + \"ã€\".join(feature_reasons))\n        \n        # å¤æ‚åº¦ç†ç”±\n        reasons.append(f\"ä»»åŠ¡å¤æ‚åº¦ï¼š{features.complexity}/5\")\n        \n        # Agentç†ç”±\n        if agent:\n            reasons.append(f\"é€‰æ‹©{agent}å¤„ç†{features.domain}ç›¸å…³ä»»åŠ¡\")\n        \n        return \"ï¼›\".join(reasons)\n\n\n# å•ä¾‹æ¨¡å¼\n_router_instance = None\n\n"
},
{
"path": "daoyoucode/agents/core/router.py",
"start": 568,
"end": 593,
"text": "def get_intelligent_router(\n    config_path: Optional[str] = None,\n    auto_discover: bool = True\n) -> IntelligentRouter:\n    \"\"\"\n    è·å–æ™ºèƒ½è·¯ç”±å™¨å•ä¾‹\n    \n    Args:\n        config_path: Agenté…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰\n        auto_discover: æ˜¯å¦è‡ªåŠ¨å‘ç°å·²æ³¨å†Œçš„Agentï¼ˆé»˜è®¤Trueï¼‰\n    \n    Returns:\n        æ™ºèƒ½è·¯ç”±å™¨å®ä¾‹\n    \"\"\"\n    global _router_instance\n    \n    if _router_instance is None:\n        _router_instance = IntelligentRouter(config_path)\n        \n        # è‡ªåŠ¨å‘ç°Agent\n        if auto_discover:\n            _router_instance.auto_discover_agents()\n        \n        logger.info(\"æ™ºèƒ½è·¯ç”±å™¨å•ä¾‹å·²åˆ›å»º\")\n    \n    return _router_instance"
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 1,
"end": 15,
"text": "\"\"\"\nAgentä¼šè¯ç®¡ç†\n\næ”¯æŒä¼šè¯æ¢å¤å’Œä¸Šä¸‹æ–‡ä¿æŒã€‚\nçµæ„Ÿæ¥æºï¼šoh-my-opencodeçš„Resume Previous Agent\n\"\"\"\n\nfrom typing import Dict, List, Any, Optional\nfrom datetime import datetime, timedelta\nimport uuid\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 16,
"end": 18,
"text": "class AgentSession:\n    \"\"\"Agentä¼šè¯\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 19,
"end": 47,
"text": "    def __init__(self, session_id: str, agent: Any):\n        self.session_id = session_id\n        self.agent = agent\n        self.history: List[Dict] = []\n        self.context: Dict = {}\n        self.created_at = datetime.now()\n        self.last_used_at = datetime.now()\n    \n    async def execute(self, instruction: str, **kwargs) -> Dict:\n        \"\"\"åœ¨ä¼šè¯ä¸­æ‰§è¡ŒæŒ‡ä»¤\"\"\"\n        self.last_used_at = datetime.now()\n        \n        # ä½¿ç”¨å†å²ä¸Šä¸‹æ–‡\n        result = await self.agent.execute(\n            instruction,\n            history=self.history,\n            context=self.context,\n            **kwargs\n        )\n        \n        # æ›´æ–°å†å²\n        self.history.append({\n            'instruction': instruction,\n            'result': result,\n            'timestamp': datetime.now()\n        })\n        \n        return result\n    "
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 48,
"end": 52,
"text": "    def get_age_hours(self) -> float:\n        \"\"\"è·å–ä¼šè¯å¹´é¾„ï¼ˆå°æ—¶ï¼‰\"\"\"\n        return (datetime.now() - self.last_used_at).total_seconds() / 3600\n\n"
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 53,
"end": 57,
"text": "class SessionManager:\n    \"\"\"ä¼šè¯ç®¡ç†å™¨ï¼ˆå•ä¾‹ï¼‰\"\"\"\n    \n    _instance = None\n    "
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 58,
"end": 63,
"text": "    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    "
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 64,
"end": 71,
"text": "    def __init__(self):\n        if self._initialized:\n            return\n        \n        self.sessions: Dict[str, AgentSession] = {}\n        self._initialized = True\n        logger.info(\"SessionManager åˆå§‹åŒ–å®Œæˆ\")\n    "
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 72,
"end": 121,
"text": "    def create_session(\n        self,\n        agent: Any,\n        session_id: Optional[str] = None\n    ) -> str:\n        \"\"\"\n        åˆ›å»ºæ–°ä¼šè¯\n        \n        Args:\n            agent: Agentå®ä¾‹\n            session_id: ä¼šè¯IDï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            session_id\n        \"\"\"\n        if session_id is None:\n            session_id = f\"ses_{uuid.uuid4().hex[:8]}\"\n        \n        session = AgentSession(session_id, agent)\n        self.sessions[session_id] = session\n        \n        logger.info(f\"åˆ›å»ºä¼šè¯: {session_id}\")\n        return session_id\n    \n    async def execute(\n        self,\n        session_id: str,\n        instruction: str,\n        **kwargs\n    ) -> Dict:\n        \"\"\"\n        åœ¨ä¼šè¯ä¸­æ‰§è¡Œ\n        \n        Args:\n            session_id: ä¼šè¯ID\n            instruction: æŒ‡ä»¤\n            **kwargs: å…¶ä»–å‚æ•°\n        \n        Returns:\n            æ‰§è¡Œç»“æœ\n        \"\"\"\n        session = self.sessions.get(session_id)\n        if not session:\n            return {\n                'status': 'error',\n                'error': f'Session {session_id} not found'\n            }\n        \n        return await session.execute(instruction, **kwargs)\n    "
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 122,
"end": 125,
"text": "    def get_session(self, session_id: str) -> Optional[AgentSession]:\n        \"\"\"è·å–ä¼šè¯\"\"\"\n        return self.sessions.get(session_id)\n    "
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 126,
"end": 133,
"text": "    def delete_session(self, session_id: str) -> bool:\n        \"\"\"åˆ é™¤ä¼šè¯\"\"\"\n        if session_id in self.sessions:\n            del self.sessions[session_id]\n            logger.info(f\"åˆ é™¤ä¼šè¯: {session_id}\")\n            return True\n        return False\n    "
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 134,
"end": 152,
"text": "    def cleanup_old_sessions(self, max_age_hours: int = 24):\n        \"\"\"\n        æ¸…ç†æ—§ä¼šè¯\n        \n        Args:\n            max_age_hours: æœ€å¤§å¹´é¾„ï¼ˆå°æ—¶ï¼‰\n        \"\"\"\n        to_remove = []\n        \n        for session_id, session in self.sessions.items():\n            if session.get_age_hours() > max_age_hours:\n                to_remove.append(session_id)\n        \n        for session_id in to_remove:\n            del self.sessions[session_id]\n        \n        if to_remove:\n            logger.info(f\"æ¸…ç†äº† {len(to_remove)} ä¸ªæ—§ä¼šè¯\")\n    "
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 153,
"end": 165,
"text": "    def list_sessions(self) -> Dict[str, Dict]:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰ä¼šè¯\"\"\"\n        return {\n            session_id: {\n                'created_at': session.created_at,\n                'last_used_at': session.last_used_at,\n                'age_hours': session.get_age_hours(),\n                'history_length': len(session.history),\n            }\n            for session_id, session in self.sessions.items()\n        }\n\n"
},
{
"path": "daoyoucode/agents/core/session.py",
"start": 166,
"end": 168,
"text": "def get_session_manager() -> SessionManager:\n    \"\"\"è·å–ä¼šè¯ç®¡ç†å™¨å®ä¾‹\"\"\"\n    return SessionManager()"
},
{
"path": "daoyoucode/agents/core/skill.py",
"start": 1,
"end": 17,
"text": "\"\"\"\nSkillé…ç½®å’ŒåŠ è½½å™¨\n\nè´Ÿè´£åŠ è½½å’Œç®¡ç†Skillé…ç½®\n\"\"\"\n\nimport os\nimport yaml\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, field\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/skill.py",
"start": 18,
"end": 61,
"text": "class SkillConfig:\n    \"\"\"Skillé…ç½®\"\"\"\n    name: str\n    version: str\n    description: str\n    \n    # ç¼–æ’å™¨é…ç½®\n    orchestrator: str = \"simple\"\n    \n    # Agenté…ç½®\n    agent: str = None  # å•ä¸ªAgent\n    agents: List[str] = field(default_factory=list)  # å¤šä¸ªAgent\n    \n    # Prompté…ç½®ï¼ˆå¯æ’æ‹”ï¼‰\n    prompt: Dict = field(default_factory=dict)\n    \n    # LLMé…ç½®\n    llm: Dict = field(default_factory=lambda: {\n        'model': 'qwen-max',\n        'temperature': 0.7,\n        'max_tokens': 2000\n    })\n    \n    # ä¸­é—´ä»¶é…ç½®\n    middleware: List[str] = field(default_factory=list)\n    \n    # å·¥å…·é…ç½®\n    tools: List[str] = field(default_factory=list)\n    \n    # æƒé™é…ç½®\n    permissions: Dict = field(default_factory=dict)\n    \n    # Hooké…ç½®\n    hooks: List[str] = field(default_factory=list)\n    \n    # è¾“å…¥è¾“å‡º\n    inputs: List[Dict] = field(default_factory=list)\n    outputs: List[Dict] = field(default_factory=list)\n    \n    # å…ƒæ•°æ®\n    metadata: Dict = field(default_factory=dict)\n    skill_path: Path = None\n\n"
},
{
"path": "daoyoucode/agents/core/skill.py",
"start": 62,
"end": 64,
"text": "class SkillLoader:\n    \"\"\"SkillåŠ è½½å™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/skill.py",
"start": 65,
"end": 79,
"text": "    def __init__(self, skills_dirs: Optional[List[str]] = None):\n        if skills_dirs is None:\n            # å°è¯•å¤šä¸ªå¯èƒ½çš„è·¯å¾„\n            possible_dirs = [\n                \"skills\",\n                \"../skills\",\n                Path(__file__).parent.parent.parent.parent / \"skills\"\n            ]\n            skills_dirs = [str(d) for d in possible_dirs if Path(d).exists()]\n        \n        self.skills_dirs = [Path(d) for d in skills_dirs if Path(d).exists()]\n        self.skills: Dict[str, SkillConfig] = {}\n        \n        logger.info(f\"SkillåŠ è½½å™¨åˆå§‹åŒ–ï¼Œæœç´¢è·¯å¾„: {[str(d) for d in self.skills_dirs]}\")\n    "
},
{
"path": "daoyoucode/agents/core/skill.py",
"start": 80,
"end": 100,
"text": "    def load_all_skills(self) -> Dict[str, SkillConfig]:\n        \"\"\"åŠ è½½æ‰€æœ‰Skill\"\"\"\n        for skills_dir in self.skills_dirs:\n            if not skills_dir.exists():\n                continue\n            \n            for skill_dir in skills_dir.iterdir():\n                if not skill_dir.is_dir() or skill_dir.name.startswith(('_', '.')):\n                    continue\n                \n                try:\n                    skill = self.load_skill(skill_dir)\n                    if skill and skill.name not in self.skills:\n                        self.skills[skill.name] = skill\n                        logger.info(f\"å·²åŠ è½½Skill: {skill.name} v{skill.version}\")\n                except Exception as e:\n                    logger.error(f\"åŠ è½½Skill {skill_dir.name} å¤±è´¥: {e}\")\n        \n        logger.info(f\"å…±åŠ è½½äº† {len(self.skills)} ä¸ªSkill\")\n        return self.skills\n    "
},
{
"path": "daoyoucode/agents/core/skill.py",
"start": 101,
"end": 146,
"text": "    def load_skill(self, skill_path: Path) -> Optional[SkillConfig]:\n        \"\"\"åŠ è½½å•ä¸ªSkill\"\"\"\n        if not skill_path.is_dir():\n            return None\n        \n        yaml_path = skill_path / \"skill.yaml\"\n        if not yaml_path.exists():\n            logger.warning(f\"Skillç›®å½• {skill_path} ç¼ºå°‘ skill.yaml\")\n            return None\n        \n        with open(yaml_path, 'r', encoding='utf-8') as f:\n            config = yaml.safe_load(f)\n        \n        # éªŒè¯å¿…éœ€å­—æ®µ\n        required_fields = ['name', 'version', 'description']\n        for field in required_fields:\n            if field not in config:\n                raise ValueError(f\"Missing required field '{field}' in {yaml_path}\")\n        \n        # å¤„ç†prompté…ç½®\n        prompt_config = config.get('prompt', {})\n        if isinstance(prompt_config, dict) and 'file' in prompt_config:\n            # è½¬æ¢ä¸ºç»å¯¹è·¯å¾„\n            prompt_file = skill_path / prompt_config['file']\n            if prompt_file.exists():\n                prompt_config['file'] = str(prompt_file)\n        \n        return SkillConfig(\n            name=config['name'],\n            version=config['version'],\n            description=config['description'],\n            orchestrator=config.get('orchestrator', 'simple'),\n            agent=config.get('agent'),\n            agents=config.get('agents', []),\n            prompt=prompt_config,\n            llm=config.get('llm', {}),\n            middleware=config.get('middleware', []),\n            tools=config.get('tools', []),\n            permissions=config.get('permissions', {}),\n            hooks=config.get('hooks', []),\n            inputs=config.get('inputs', []),\n            outputs=config.get('outputs', []),\n            metadata=config.get('metadata', {}),\n            skill_path=skill_path\n        )\n    "
},
{
"path": "daoyoucode/agents/core/skill.py",
"start": 147,
"end": 150,
"text": "    def get_skill(self, name: str) -> Optional[SkillConfig]:\n        \"\"\"è·å–æŒ‡å®šSkill\"\"\"\n        return self.skills.get(name)\n    "
},
{
"path": "daoyoucode/agents/core/skill.py",
"start": 151,
"end": 167,
"text": "    def list_skills(self) -> List[Dict[str, str]]:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰Skillä¿¡æ¯\"\"\"\n        return [\n            {\n                'name': skill.name,\n                'version': skill.version,\n                'description': skill.description,\n                'orchestrator': skill.orchestrator\n            }\n            for skill in self.skills.values()\n        ]\n\n\n# å…¨å±€å•ä¾‹\n_skill_loader = None\n\n"
},
{
"path": "daoyoucode/agents/core/skill.py",
"start": 168,
"end": 174,
"text": "def get_skill_loader(skills_dirs: Optional[List[str]] = None) -> SkillLoader:\n    \"\"\"è·å–SkillåŠ è½½å™¨å•ä¾‹\"\"\"\n    global _skill_loader\n    if _skill_loader is None:\n        _skill_loader = SkillLoader(skills_dirs)\n        _skill_loader.load_all_skills()\n    return _skill_loader"
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 1,
"end": 16,
"text": "\"\"\"\nä»»åŠ¡æŠ½è±¡å’Œä»»åŠ¡ç®¡ç†å™¨\n\næä¾›ç»Ÿä¸€çš„ä»»åŠ¡å»ºæ¨¡å’Œç®¡ç†\n\"\"\"\n\nfrom typing import Dict, Any, Optional, List\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom enum import Enum\nimport uuid\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 17,
"end": 26,
"text": "class TaskStatus(Enum):\n    \"\"\"ä»»åŠ¡çŠ¶æ€\"\"\"\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 27,
"end": 46,
"text": "class Task:\n    \"\"\"\n    ä»»åŠ¡æŠ½è±¡\n    \n    è¡¨ç¤ºä¸€ä¸ªå¯æ‰§è¡Œçš„ä»»åŠ¡å•å…ƒ\n    \"\"\"\n    id: str\n    description: str\n    status: TaskStatus\n    orchestrator: str\n    agent: Optional[str] = None\n    parent_id: Optional[str] = None\n    subtasks: List['Task'] = field(default_factory=list)\n    result: Optional[Any] = None\n    error: Optional[str] = None\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    created_at: datetime = field(default_factory=datetime.now)\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 47,
"end": 65,
"text": "    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"è½¬æ¢ä¸ºå­—å…¸\"\"\"\n        return {\n            'id': self.id,\n            'description': self.description,\n            'status': self.status.value,\n            'orchestrator': self.orchestrator,\n            'agent': self.agent,\n            'parent_id': self.parent_id,\n            'subtasks': [st.to_dict() for st in self.subtasks],\n            'result': self.result,\n            'error': self.error,\n            'metadata': self.metadata,\n            'created_at': self.created_at.isoformat(),\n            'started_at': self.started_at.isoformat() if self.started_at else None,\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n"
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 66,
"end": 76,
"text": "class TaskManager:\n    \"\"\"\n    å…¨å±€ä»»åŠ¡ç®¡ç†å™¨\n    \n    èŒè´£ï¼š\n    1. åˆ›å»ºå’Œè¿½è¸ªä»»åŠ¡\n    2. ç®¡ç†ä»»åŠ¡å±‚æ¬¡ç»“æ„ï¼ˆçˆ¶å­å…³ç³»ï¼‰\n    3. æ›´æ–°ä»»åŠ¡çŠ¶æ€\n    4. æä¾›ä»»åŠ¡æŸ¥è¯¢å’Œç»Ÿè®¡\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 77,
"end": 83,
"text": "    def __init__(self):\n        self.tasks: Dict[str, Task] = {}\n        self.task_history: List[Task] = []\n        self.max_history = 1000\n        \n        logger.info(\"ä»»åŠ¡ç®¡ç†å™¨å·²åˆå§‹åŒ–\")\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 84,
"end": 125,
"text": "    def create_task(\n        self,\n        description: str,\n        orchestrator: str,\n        agent: Optional[str] = None,\n        parent_id: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> Task:\n        \"\"\"\n        åˆ›å»ºä»»åŠ¡\n        \n        Args:\n            description: ä»»åŠ¡æè¿°\n            orchestrator: ä½¿ç”¨çš„ç¼–æ’å™¨\n            agent: ä½¿ç”¨çš„Agentï¼ˆå¯é€‰ï¼‰\n            parent_id: çˆ¶ä»»åŠ¡IDï¼ˆå¯é€‰ï¼‰\n            metadata: å…ƒæ•°æ®ï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            åˆ›å»ºçš„ä»»åŠ¡\n        \"\"\"\n        task = Task(\n            id=str(uuid.uuid4()),\n            description=description,\n            status=TaskStatus.PENDING,\n            orchestrator=orchestrator,\n            agent=agent,\n            parent_id=parent_id,\n            metadata=metadata or {}\n        )\n        \n        self.tasks[task.id] = task\n        \n        # å¦‚æœæœ‰çˆ¶ä»»åŠ¡ï¼Œæ·»åŠ åˆ°çˆ¶ä»»åŠ¡çš„subtasks\n        if parent_id and parent_id in self.tasks:\n            parent = self.tasks[parent_id]\n            parent.subtasks.append(task)\n        \n        logger.info(f\"åˆ›å»ºä»»åŠ¡: {task.id[:8]}... - {description[:50]}\")\n        \n        return task\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 126,
"end": 129,
"text": "    def get_task(self, task_id: str) -> Optional[Task]:\n        \"\"\"è·å–ä»»åŠ¡\"\"\"\n        return self.tasks.get(task_id)\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 130,
"end": 171,
"text": "    def update_status(\n        self,\n        task_id: str,\n        status: TaskStatus,\n        result: Optional[Any] = None,\n        error: Optional[str] = None\n    ):\n        \"\"\"\n        æ›´æ–°ä»»åŠ¡çŠ¶æ€\n        \n        Args:\n            task_id: ä»»åŠ¡ID\n            status: æ–°çŠ¶æ€\n            result: æ‰§è¡Œç»“æœï¼ˆå¯é€‰ï¼‰\n            error: é”™è¯¯ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰\n        \"\"\"\n        if task_id not in self.tasks:\n            logger.warning(f\"ä»»åŠ¡ä¸å­˜åœ¨: {task_id}\")\n            return\n        \n        task = self.tasks[task_id]\n        old_status = task.status\n        task.status = status\n        \n        # æ›´æ–°æ—¶é—´æˆ³\n        if status == TaskStatus.RUNNING and not task.started_at:\n            task.started_at = datetime.now()\n        elif status in [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELLED]:\n            task.completed_at = datetime.now()\n        \n        # æ›´æ–°ç»“æœå’Œé”™è¯¯\n        if result is not None:\n            task.result = result\n        if error is not None:\n            task.error = error\n        \n        logger.info(f\"ä»»åŠ¡çŠ¶æ€æ›´æ–°: {task_id[:8]}... {old_status.value} -> {status.value}\")\n        \n        # å¦‚æœä»»åŠ¡å®Œæˆæˆ–å¤±è´¥ï¼Œç§»åˆ°å†å²\n        if status in [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELLED]:\n            self._archive_task(task)\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 172,
"end": 179,
"text": "    def _archive_task(self, task: Task):\n        \"\"\"å½’æ¡£ä»»åŠ¡åˆ°å†å²\"\"\"\n        self.task_history.append(task)\n        \n        # ä¿æŒå†å²å¤§å°\n        if len(self.task_history) > self.max_history:\n            self.task_history = self.task_history[-self.max_history:]\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 180,
"end": 195,
"text": "    def get_task_tree(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        è·å–ä»»åŠ¡æ ‘ï¼ˆåŒ…å«æ‰€æœ‰å­ä»»åŠ¡ï¼‰\n        \n        Args:\n            task_id: æ ¹ä»»åŠ¡ID\n        \n        Returns:\n            ä»»åŠ¡æ ‘å­—å…¸\n        \"\"\"\n        task = self.get_task(task_id)\n        if not task:\n            return {}\n        \n        return self._build_task_tree(task)\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 196,
"end": 206,
"text": "    def _build_task_tree(self, task: Task) -> Dict[str, Any]:\n        \"\"\"é€’å½’æ„å»ºä»»åŠ¡æ ‘\"\"\"\n        tree = task.to_dict()\n        \n        if task.subtasks:\n            tree['subtasks'] = [\n                self._build_task_tree(st) for st in task.subtasks\n            ]\n        \n        return tree\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 207,
"end": 213,
"text": "    def get_active_tasks(self) -> List[Task]:\n        \"\"\"è·å–æ‰€æœ‰æ´»è·ƒä»»åŠ¡ï¼ˆpendingæˆ–runningï¼‰\"\"\"\n        return [\n            task for task in self.tasks.values()\n            if task.status in [TaskStatus.PENDING, TaskStatus.RUNNING]\n        ]\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 214,
"end": 220,
"text": "    def get_tasks_by_orchestrator(self, orchestrator: str) -> List[Task]:\n        \"\"\"è·å–æŒ‡å®šç¼–æ’å™¨çš„æ‰€æœ‰ä»»åŠ¡\"\"\"\n        return [\n            task for task in self.tasks.values()\n            if task.orchestrator == orchestrator\n        ]\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 221,
"end": 227,
"text": "    def get_tasks_by_agent(self, agent: str) -> List[Task]:\n        \"\"\"è·å–æŒ‡å®šAgentçš„æ‰€æœ‰ä»»åŠ¡\"\"\"\n        return [\n            task for task in self.tasks.values()\n            if task.agent == agent\n        ]\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 228,
"end": 256,
"text": "    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        è·å–ç»Ÿè®¡ä¿¡æ¯\n        \n        Returns:\n            ç»Ÿè®¡ä¿¡æ¯å­—å…¸\n        \"\"\"\n        total = len(self.tasks)\n        \n        status_counts = {}\n        for status in TaskStatus:\n            status_counts[status.value] = sum(\n                1 for task in self.tasks.values()\n                if task.status == status\n            )\n        \n        orchestrator_counts = {}\n        for task in self.tasks.values():\n            orchestrator_counts[task.orchestrator] = \\\n                orchestrator_counts.get(task.orchestrator, 0) + 1\n        \n        return {\n            'total_tasks': total,\n            'active_tasks': len(self.get_active_tasks()),\n            'history_size': len(self.task_history),\n            'status_counts': status_counts,\n            'orchestrator_counts': orchestrator_counts\n        }\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 257,
"end": 268,
"text": "    def clear_completed(self):\n        \"\"\"æ¸…é™¤å·²å®Œæˆçš„ä»»åŠ¡\"\"\"\n        completed_ids = [\n            task_id for task_id, task in self.tasks.items()\n            if task.status in [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELLED]\n        ]\n        \n        for task_id in completed_ids:\n            del self.tasks[task_id]\n        \n        logger.info(f\"æ¸…é™¤äº† {len(completed_ids)} ä¸ªå·²å®Œæˆä»»åŠ¡\")\n    "
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 269,
"end": 290,
"text": "    def get_task_duration(self, task_id: str) -> Optional[float]:\n        \"\"\"\n        è·å–ä»»åŠ¡æ‰§è¡Œæ—¶é•¿ï¼ˆç§’ï¼‰\n        \n        Args:\n            task_id: ä»»åŠ¡ID\n        \n        Returns:\n            æ‰§è¡Œæ—¶é•¿ï¼ˆç§’ï¼‰ï¼Œå¦‚æœä»»åŠ¡æœªå®Œæˆè¿”å›None\n        \"\"\"\n        task = self.get_task(task_id)\n        if not task or not task.started_at or not task.completed_at:\n            return None\n        \n        duration = (task.completed_at - task.started_at).total_seconds()\n        return duration\n\n\n# å•ä¾‹æ¨¡å¼\n_task_manager_instance = None\n\n"
},
{
"path": "daoyoucode/agents/core/task.py",
"start": 291,
"end": 299,
"text": "def get_task_manager() -> TaskManager:\n    \"\"\"è·å–ä»»åŠ¡ç®¡ç†å™¨å•ä¾‹\"\"\"\n    global _task_manager_instance\n    \n    if _task_manager_instance is None:\n        _task_manager_instance = TaskManager()\n        logger.info(\"ä»»åŠ¡ç®¡ç†å™¨å•ä¾‹å·²åˆ›å»º\")\n    \n    return _task_manager_instance"
},
{
"path": "daoyoucode/agents/core/timeout_handler.py",
"start": 1,
"end": 90,
"text": "\"\"\"\nè¶…æ—¶å¤„ç†å™¨\n\nåœ¨ executor å±‚é¢é›†æˆè¶…æ—¶æ¢å¤ç­–ç•¥\n\"\"\"\n\nimport logging\nfrom typing import Dict, Any, Optional\nimport asyncio\n\nfrom .timeout_recovery import TimeoutRecoveryStrategy, TimeoutRecoveryConfig, get_user_friendly_timeout_message\nfrom ..llm.exceptions import LLMTimeoutError\n\nlogger = logging.getLogger(__name__)\n\n\nasync def execute_with_timeout_handling(\n    execute_func,\n    skill_name: str,\n    user_input: str,\n    context: Dict[str, Any],\n    enable_recovery: bool = True\n) -> Dict[str, Any]:\n    \"\"\"\n    å¸¦è¶…æ—¶å¤„ç†çš„æ‰§è¡Œ\n    \n    Args:\n        execute_func: æ‰§è¡Œå‡½æ•°ï¼ˆå¯ä»¥æ˜¯ _execute_skill_internal æˆ–åŒ…è£…åçš„å‡½æ•°ï¼‰\n        skill_name: Skill åç§°\n        user_input: ç”¨æˆ·è¾“å…¥\n        context: ä¸Šä¸‹æ–‡\n        enable_recovery: æ˜¯å¦å¯ç”¨è¶…æ—¶æ¢å¤\n    \n    Returns:\n        æ‰§è¡Œç»“æœ\n    \"\"\"\n    if not enable_recovery:\n        # ä¸å¯ç”¨æ¢å¤ï¼Œç›´æ¥æ‰§è¡Œ\n        return await execute_func(skill_name, user_input, context)\n    \n    # åˆ›å»ºè¶…æ—¶æ¢å¤ç­–ç•¥\n    recovery_config = TimeoutRecoveryConfig(\n        max_retries=3,\n        initial_timeout=60.0,\n        timeout_multiplier=1.5,\n        max_timeout=180.0,\n        retry_delay=2.0,\n        enable_prompt_simplification=True,\n        enable_fallback_model=False  # æš‚æ—¶ç¦ç”¨å¤‡ç”¨æ¨¡å‹ï¼ˆéœ€è¦æ›´å¤šé…ç½®ï¼‰\n    )\n    \n    strategy = TimeoutRecoveryStrategy(recovery_config)\n    \n    try:\n        # åŒ…è£…æ‰§è¡Œå‡½æ•°ï¼Œä½¿å…¶ç¬¦åˆ timeout_recovery çš„ç­¾å\n        async def wrapped_execute():\n            return await execute_func(skill_name, user_input, context)\n        \n        # ä½¿ç”¨è¶…æ—¶æ¢å¤ç­–ç•¥æ‰§è¡Œ\n        result = await strategy.execute_with_timeout_recovery(\n            wrapped_execute,\n            context=context\n        )\n        \n        return result\n    \n    except LLMTimeoutError as e:\n        # æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥ï¼Œè¿”å›å‹å¥½çš„é”™è¯¯æ¶ˆæ¯\n        error_message = get_user_friendly_timeout_message(strategy.retry_count)\n        \n        logger.error(f\"âŒ è¶…æ—¶æ¢å¤å¤±è´¥: {error_message}\")\n        \n        return {\n            'success': False,\n            'content': '',\n            'error': error_message,\n            'timeout_retries': strategy.retry_count\n        }\n    \n    except Exception as e:\n        # å…¶ä»–é”™è¯¯\n        logger.error(f\"âŒ æ‰§è¡Œå¤±è´¥: {e}\", exc_info=True)\n        \n        return {\n            'success': False,\n            'content': '',\n            'error': str(e)\n        }\n\n"
},
{
"path": "daoyoucode/agents/core/timeout_handler.py",
"start": 91,
"end": 113,
"text": "def should_enable_timeout_recovery(context: Dict[str, Any]) -> bool:\n    \"\"\"\n    åˆ¤æ–­æ˜¯å¦åº”è¯¥å¯ç”¨è¶…æ—¶æ¢å¤\n    \n    Args:\n        context: ä¸Šä¸‹æ–‡\n    \n    Returns:\n        æ˜¯å¦å¯ç”¨\n    \"\"\"\n    # å¯ä»¥æ ¹æ®ä¸Šä¸‹æ–‡å†³å®šæ˜¯å¦å¯ç”¨\n    # ä¾‹å¦‚ï¼šæŸäº› skill å¯èƒ½ä¸éœ€è¦æ¢å¤\n    \n    # æ£€æŸ¥æ˜¯å¦æ˜ç¡®ç¦ç”¨\n    if context.get('disable_timeout_recovery'):\n        return False\n    \n    # æ£€æŸ¥æ˜¯å¦æ˜¯æµ‹è¯•ç¯å¢ƒ\n    if context.get('test_mode'):\n        return False\n    \n    # é»˜è®¤å¯ç”¨\n    return True"
},
{
"path": "daoyoucode/agents/core/timeout_recovery.py",
"start": 1,
"end": 17,
"text": "\"\"\"\nè¶…æ—¶æ¢å¤ç­–ç•¥\n\nä¸“é—¨å¤„ç† LLM è¯·æ±‚è¶…æ—¶çš„æ¢å¤æœºåˆ¶\n\"\"\"\n\nimport logging\nfrom typing import Optional, Dict, Any, Callable\nimport asyncio\nfrom dataclasses import dataclass\n\nfrom ..llm.exceptions import LLMTimeoutError\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/timeout_recovery.py",
"start": 18,
"end": 28,
"text": "class TimeoutRecoveryConfig:\n    \"\"\"è¶…æ—¶æ¢å¤é…ç½®\"\"\"\n    max_retries: int = 3  # æœ€å¤§é‡è¯•æ¬¡æ•°\n    initial_timeout: float = 1800.0  # åˆå§‹è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰- 30åˆ†é’Ÿï¼Œæ”¯æŒå¤šæ¬¡å·¥å…·è°ƒç”¨å’Œå¤§è§„æ¨¡æ–‡ä»¶æ“ä½œ\n    timeout_multiplier: float = 1.2  # æ¯æ¬¡é‡è¯•è¶…æ—¶æ—¶é—´å€æ•°ï¼ˆé™ä½å€æ•°ï¼Œå› ä¸ºåŸºç¡€æ—¶é—´å·²ç»å¾ˆé•¿ï¼‰\n    max_timeout: float = 3600.0  # æœ€å¤§è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰- 1å°æ—¶\n    retry_delay: float = 2.0  # é‡è¯•å»¶è¿Ÿï¼ˆç§’ï¼‰\n    enable_prompt_simplification: bool = True  # æ˜¯å¦å¯ç”¨ prompt ç®€åŒ–\n    enable_fallback_model: bool = True  # æ˜¯å¦å¯ç”¨å¤‡ç”¨æ¨¡å‹\n\n"
},
{
"path": "daoyoucode/agents/core/timeout_recovery.py",
"start": 29,
"end": 31,
"text": "class TimeoutRecoveryStrategy:\n    \"\"\"è¶…æ—¶æ¢å¤ç­–ç•¥\"\"\"\n    "
},
{
"path": "daoyoucode/agents/core/timeout_recovery.py",
"start": 32,
"end": 119,
"text": "    def __init__(self, config: Optional[TimeoutRecoveryConfig] = None):\n        self.config = config or TimeoutRecoveryConfig()\n        self.retry_count = 0\n        self.current_timeout = self.config.initial_timeout\n    \n    async def execute_with_timeout_recovery(\n        self,\n        func: Callable,\n        *args,\n        context: Optional[Dict[str, Any]] = None,\n        **kwargs\n    ) -> Any:\n        \"\"\"\n        å¸¦è¶…æ—¶æ¢å¤çš„æ‰§è¡Œ\n        \n        ç­–ç•¥ï¼š\n        1. ç¬¬ä¸€æ¬¡ï¼šæ­£å¸¸æ‰§è¡Œ\n        2. ç¬¬äºŒæ¬¡ï¼šå¢åŠ è¶…æ—¶æ—¶é—´\n        3. ç¬¬ä¸‰æ¬¡ï¼šç®€åŒ– prompt + å¢åŠ è¶…æ—¶\n        4. ç¬¬å››æ¬¡ï¼šä½¿ç”¨å¤‡ç”¨æ¨¡å‹ï¼ˆå¦‚æœå¯ç”¨ï¼‰\n        \n        Args:\n            func: è¦æ‰§è¡Œçš„å‡½æ•°\n            context: ä¸Šä¸‹æ–‡ï¼ˆåŒ…å« promptã€model ç­‰ï¼‰\n            *args, **kwargs: ä¼ é€’ç»™ func çš„å‚æ•°\n        \n        Returns:\n            æ‰§è¡Œç»“æœ\n        \n        Raises:\n            LLMTimeoutError: æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥\n        \"\"\"\n        last_error = None\n        original_prompt = None\n        original_model = None\n        \n        # ä¿å­˜åŸå§‹å‚æ•°\n        if context:\n            original_prompt = context.get('prompt')\n            original_model = context.get('model')\n        \n        while self.retry_count < self.config.max_retries:\n            try:\n                attempt = self.retry_count + 1\n                logger.info(f\"ğŸ”„ è¶…æ—¶æ¢å¤å°è¯• {attempt}/{self.config.max_retries}\")\n                \n                # åº”ç”¨æ¢å¤ç­–ç•¥\n                self._apply_recovery_strategy(attempt, context, original_prompt, original_model)\n                \n                # æ‰§è¡Œå‡½æ•°\n                result = await func(*args, **kwargs)\n                \n                logger.info(f\"âœ… æ‰§è¡ŒæˆåŠŸï¼ˆç¬¬ {attempt} æ¬¡å°è¯•ï¼‰\")\n                return result\n            \n            except LLMTimeoutError as e:\n                last_error = e\n                self.retry_count += 1\n                \n                logger.warning(\n                    f\"âš ï¸ è¶…æ—¶é”™è¯¯ï¼ˆç¬¬ {attempt} æ¬¡å°è¯•ï¼‰: {e}\\n\"\n                    f\"   å½“å‰è¶…æ—¶è®¾ç½®: {self.current_timeout}ç§’\"\n                )\n                \n                if self.retry_count < self.config.max_retries:\n                    logger.info(f\"â³ ç­‰å¾… {self.config.retry_delay} ç§’åé‡è¯•...\")\n                    await asyncio.sleep(self.config.retry_delay)\n                    continue\n                \n                # é‡è¯•æ¬¡æ•°ç”¨å®Œ\n                break\n            \n            except Exception as e:\n                # éè¶…æ—¶é”™è¯¯ï¼Œç›´æ¥æŠ›å‡º\n                logger.error(f\"âŒ éè¶…æ—¶é”™è¯¯: {e}\")\n                raise\n        \n        # æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥\n        logger.error(\n            f\"âŒ è¶…æ—¶æ¢å¤å¤±è´¥ï¼Œå·²é‡è¯• {self.config.max_retries} æ¬¡\\n\"\n            f\"   æœ€åé”™è¯¯: {last_error}\"\n        )\n        \n        raise LLMTimeoutError(\n            f\"è¯·æ±‚è¶…æ—¶ï¼Œå·²é‡è¯• {self.config.max_retries} æ¬¡ä»ç„¶å¤±è´¥ã€‚\"\n            f\"å»ºè®®ï¼š1) æ£€æŸ¥ç½‘ç»œè¿æ¥ 2) ç®€åŒ–é—®é¢˜ 3) ç¨åé‡è¯•\"\n        )\n    "
},
{
"path": "daoyoucode/agents/core/timeout_recovery.py",
"start": 120,
"end": 159,
"text": "    def _apply_recovery_strategy(\n        self,\n        attempt: int,\n        context: Optional[Dict[str, Any]],\n        original_prompt: Optional[str],\n        original_model: Optional[str]\n    ):\n        \"\"\"\n        åº”ç”¨æ¢å¤ç­–ç•¥\n        \n        Args:\n            attempt: å½“å‰å°è¯•æ¬¡æ•°ï¼ˆ1-basedï¼‰\n            context: ä¸Šä¸‹æ–‡\n            original_prompt: åŸå§‹ prompt\n            original_model: åŸå§‹æ¨¡å‹\n        \"\"\"\n        if not context:\n            return\n        \n        # ç­–ç•¥1: å¢åŠ è¶…æ—¶æ—¶é—´ï¼ˆæ‰€æœ‰é‡è¯•éƒ½åº”ç”¨ï¼‰\n        self.current_timeout = min(\n            self.current_timeout * self.config.timeout_multiplier,\n            self.config.max_timeout\n        )\n        context['timeout'] = self.current_timeout\n        logger.info(f\"ğŸ“ˆ å¢åŠ è¶…æ—¶æ—¶é—´åˆ° {self.current_timeout} ç§’\")\n        \n        # ç­–ç•¥2: ç®€åŒ– promptï¼ˆç¬¬3æ¬¡åŠä»¥åï¼‰\n        if attempt >= 3 and self.config.enable_prompt_simplification and original_prompt:\n            simplified_prompt = self._simplify_prompt(original_prompt)\n            context['prompt'] = simplified_prompt\n            logger.info(f\"âœ‚ï¸ ç®€åŒ– promptï¼ˆä» {len(original_prompt)} å­—ç¬¦åˆ° {len(simplified_prompt)} å­—ç¬¦ï¼‰\")\n        \n        # ç­–ç•¥3: ä½¿ç”¨å¤‡ç”¨æ¨¡å‹ï¼ˆç¬¬4æ¬¡ï¼‰\n        if attempt >= 4 and self.config.enable_fallback_model and original_model:\n            fallback_model = self._get_fallback_model(original_model)\n            if fallback_model:\n                context['model'] = fallback_model\n                logger.info(f\"ğŸ”„ åˆ‡æ¢åˆ°å¤‡ç”¨æ¨¡å‹: {fallback_model}\")\n    "
},
{
"path": "daoyoucode/agents/core/timeout_recovery.py",
"start": 160,
"end": 192,
"text": "    def _simplify_prompt(self, prompt: str) -> str:\n        \"\"\"\n        ç®€åŒ– prompt\n        \n        ç­–ç•¥ï¼š\n        1. ç§»é™¤ç¤ºä¾‹ï¼ˆå¦‚æœæœ‰ï¼‰\n        2. ä¿ç•™æ ¸å¿ƒæŒ‡ä»¤\n        3. ç§»é™¤è¯¦ç»†è¯´æ˜\n        \n        Args:\n            prompt: åŸå§‹ prompt\n        \n        Returns:\n            ç®€åŒ–åçš„ prompt\n        \"\"\"\n        # ç®€å•ç­–ç•¥ï¼šä¿ç•™å‰30%å’Œå30%ï¼Œç§»é™¤ä¸­é—´éƒ¨åˆ†\n        lines = prompt.split('\\n')\n        total_lines = len(lines)\n        \n        if total_lines <= 50:\n            # prompt ä¸é•¿ï¼Œä¸éœ€è¦ç®€åŒ–\n            return prompt\n        \n        keep_lines = int(total_lines * 0.3)\n        \n        simplified_lines = (\n            lines[:keep_lines] +\n            [\"\\n[... ä¸ºäº†åŠ å¿«å“åº”ï¼Œéƒ¨åˆ†è¯¦ç»†è¯´æ˜å·²çœç•¥ ...]\\n\"] +\n            lines[-keep_lines:]\n        )\n        \n        return '\\n'.join(simplified_lines)\n    "
},
{
"path": "daoyoucode/agents/core/timeout_recovery.py",
"start": 193,
"end": 219,
"text": "    def _get_fallback_model(self, original_model: str) -> Optional[str]:\n        \"\"\"\n        è·å–å¤‡ç”¨æ¨¡å‹\n        \n        ç­–ç•¥ï¼š\n        - qwen-max â†’ qwen-plus\n        - qwen-plus â†’ qwen-turbo\n        - gpt-4 â†’ gpt-3.5-turbo\n        - deepseek-coder â†’ deepseek-chat\n        \n        Args:\n            original_model: åŸå§‹æ¨¡å‹\n        \n        Returns:\n            å¤‡ç”¨æ¨¡å‹ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› None\n        \"\"\"\n        fallback_map = {\n            'qwen-max': 'qwen-plus',\n            'qwen-plus': 'qwen-turbo',\n            'gpt-4': 'gpt-3.5-turbo',\n            'gpt-4-turbo': 'gpt-3.5-turbo',\n            'deepseek-coder': 'deepseek-chat',\n            'claude-opus': 'claude-sonnet',\n        }\n        \n        return fallback_map.get(original_model)\n    "
},
{
"path": "daoyoucode/agents/core/timeout_recovery.py",
"start": 220,
"end": 225,
"text": "    def reset(self):\n        \"\"\"é‡ç½®çŠ¶æ€\"\"\"\n        self.retry_count = 0\n        self.current_timeout = self.config.initial_timeout\n\n"
},
{
"path": "daoyoucode/agents/core/timeout_recovery.py",
"start": 226,
"end": 245,
"text": "def create_timeout_recovery_wrapper(\n    config: Optional[TimeoutRecoveryConfig] = None\n) -> Callable:\n    \"\"\"\n    åˆ›å»ºè¶…æ—¶æ¢å¤è£…é¥°å™¨\n    \n    Args:\n        config: è¶…æ—¶æ¢å¤é…ç½®\n    \n    Returns:\n        è£…é¥°å™¨å‡½æ•°\n    \n    Example:\n        @create_timeout_recovery_wrapper()\n        async def call_llm(prompt: str):\n            # LLM è°ƒç”¨é€»è¾‘\n            pass\n    \"\"\"\n    strategy = TimeoutRecoveryStrategy(config)\n    "
},
{
"path": "daoyoucode/agents/core/timeout_recovery.py",
"start": 246,
"end": 256,
"text": "    def decorator(func: Callable) -> Callable:\n        async def wrapper(*args, **kwargs):\n            return await strategy.execute_with_timeout_recovery(\n                func, *args, **kwargs\n            )\n        return wrapper\n    \n    return decorator\n\n\n# ç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯"
},
{
"path": "daoyoucode/agents/core/timeout_recovery.py",
"start": 257,
"end": 285,
"text": "def get_user_friendly_timeout_message(retry_count: int) -> str:\n    \"\"\"\n    è·å–ç”¨æˆ·å‹å¥½çš„è¶…æ—¶é”™è¯¯æ¶ˆæ¯\n    \n    Args:\n        retry_count: é‡è¯•æ¬¡æ•°\n    \n    Returns:\n        ç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯\n    \"\"\"\n    messages = {\n        1: \"è¯·æ±‚è¶…æ—¶äº†ï¼Œæ­£åœ¨é‡è¯•...\",\n        2: \"è¯·æ±‚ä»ç„¶è¶…æ—¶ï¼Œå¢åŠ è¶…æ—¶æ—¶é—´åé‡è¯•...\",\n        3: \"è¯·æ±‚æŒç»­è¶…æ—¶ï¼Œç®€åŒ–é—®é¢˜åé‡è¯•...\",\n    }\n    \n    if retry_count <= 3:\n        return messages.get(retry_count, \"è¯·æ±‚è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯•...\")\n    \n    return (\n        \"å¾ˆæŠ±æ­‰ï¼Œå¤šæ¬¡é‡è¯•åä»ç„¶è¶…æ—¶ã€‚å¯èƒ½çš„åŸå› ï¼š\\n\"\n        \"1. ç½‘ç»œè¿æ¥ä¸ç¨³å®š\\n\"\n        \"2. é—®é¢˜è¿‡äºå¤æ‚\\n\"\n        \"3. LLM æœåŠ¡ç¹å¿™\\n\\n\"\n        \"å»ºè®®ï¼š\\n\"\n        \"- æ£€æŸ¥ç½‘ç»œè¿æ¥\\n\"\n        \"- ç®€åŒ–é—®é¢˜æˆ–åˆ†æ­¥éª¤æé—®\\n\"\n        \"- ç¨åé‡è¯•\"\n    )"
},
{
"path": "daoyoucode/agents/core/verification.py",
"start": 1,
"end": 17,
"text": "\"\"\"\nç‹¬ç«‹éªŒè¯æœºåˆ¶\n\nä¸ä¿¡ä»»å­Agentçš„è¾“å‡ºï¼Œé€šè¿‡ç‹¬ç«‹éªŒè¯ç¡®ä¿ç»“æœå¯é æ€§ã€‚\nçµæ„Ÿæ¥è‡ªdaoyouCodePilotçš„éªŒè¯æœºåˆ¶ã€‚\n\"\"\"\n\nimport asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nfrom enum import Enum\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/core/verification.py",
"start": 18,
"end": 26,
"text": "class VerificationLevel(Enum):\n    \"\"\"éªŒè¯çº§åˆ«\"\"\"\n    NONE = \"none\"           # ä¸éªŒè¯\n    BASIC = \"basic\"         # åŸºç¡€éªŒè¯ï¼ˆè¯­æ³•æ£€æŸ¥ï¼‰\n    STANDARD = \"standard\"   # æ ‡å‡†éªŒè¯ï¼ˆè¯­æ³•+æ„å»ºï¼‰\n    STRICT = \"strict\"       # ä¸¥æ ¼éªŒè¯ï¼ˆè¯­æ³•+æ„å»º+æµ‹è¯•ï¼‰\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/core/verification.py",
"start": 27,
"end": 38,
"text": "class VerificationResult:\n    \"\"\"éªŒè¯ç»“æœ\"\"\"\n    passed: bool                          # æ˜¯å¦é€šè¿‡\n    level: VerificationLevel              # éªŒè¯çº§åˆ«\n    diagnostics_passed: bool = True       # è¯Šæ–­æ˜¯å¦é€šè¿‡\n    build_passed: bool = True             # æ„å»ºæ˜¯å¦é€šè¿‡\n    tests_passed: bool = True             # æµ‹è¯•æ˜¯å¦é€šè¿‡\n    file_check_passed: bool = True        # æ–‡ä»¶æ£€æŸ¥æ˜¯å¦é€šè¿‡\n    errors: List[str] = None              # é”™è¯¯åˆ—è¡¨\n    warnings: List[str] = None            # è­¦å‘Šåˆ—è¡¨\n    details: Dict[str, Any] = None        # è¯¦ç»†ä¿¡æ¯\n    "
},
{
"path": "daoyoucode/agents/core/verification.py",
"start": 39,
"end": 47,
"text": "    def __post_init__(self):\n        if self.errors is None:\n            self.errors = []\n        if self.warnings is None:\n            self.warnings = []\n        if self.details is None:\n            self.details = {}\n\n"
},
{
"path": "daoyoucode/agents/core/verification.py",
"start": 48,
"end": 60,
"text": "class VerificationManager:\n    \"\"\"\n    éªŒè¯ç®¡ç†å™¨\n    \n    ä¸ä¿¡ä»»å­Agentçš„è¾“å‡ºï¼Œé€šè¿‡ç‹¬ç«‹éªŒè¯ç¡®ä¿ç»“æœå¯é æ€§ï¼š\n    1. è¿è¡ŒLSPè¯Šæ–­ï¼ˆè¯­æ³•ã€ç±»å‹æ£€æŸ¥ï¼‰\n    2. è¿è¡Œæ„å»ºå‘½ä»¤\n    3. è¿è¡Œæµ‹è¯•å¥—ä»¶\n    4. æ£€æŸ¥ä¿®æ”¹çš„æ–‡ä»¶\n    \"\"\"\n    \n    _instance = None\n    "
},
{
"path": "daoyoucode/agents/core/verification.py",
"start": 61,
"end": 67,
"text": "    def __new__(cls):\n        \"\"\"å•ä¾‹æ¨¡å¼\"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    "
},
{
"path": "daoyoucode/agents/core/verification.py",
"start": 68,
"end": 80,
"text": "    def __init__(self):\n        \"\"\"åˆå§‹åŒ–éªŒè¯ç®¡ç†å™¨\"\"\"\n        if self._initialized:\n            return\n        \n        self.project_root: Optional[Path] = None\n        self.build_command: Optional[str] = None\n        self.test_command: Optional[str] = None\n        self.timeout: int = 300  # 5åˆ†é’Ÿè¶…æ—¶\n        \n        self._initialized = True\n        logger.info(\"éªŒè¯ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ\")\n    "
},
{
"path": "daoyoucode/agents/core/verification.py",
"start": 81,
"end": 361,
"text": "    def configure(\n        self,\n        project_root: Path,\n        build_command: Optional[str] = None,\n        test_command: Optional[str] = None,\n        timeout: int = 300\n    ):\n        \"\"\"\n        é…ç½®éªŒè¯ç®¡ç†å™¨\n        \n        Args:\n            project_root: é¡¹ç›®æ ¹ç›®å½•\n            build_command: æ„å»ºå‘½ä»¤ï¼ˆå¦‚ \"npm run build\", \"python -m build\"ï¼‰\n            test_command: æµ‹è¯•å‘½ä»¤ï¼ˆå¦‚ \"npm test\", \"pytest\"ï¼‰\n            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰\n        \"\"\"\n        self.project_root = project_root\n        self.build_command = build_command\n        self.test_command = test_command\n        self.timeout = timeout\n        \n        logger.info(f\"éªŒè¯ç®¡ç†å™¨é…ç½®å®Œæˆ: root={project_root}, build={build_command}, test={test_command}\")\n    \n    async def verify(\n        self,\n        result: Dict[str, Any],\n        level: VerificationLevel = VerificationLevel.STANDARD,\n        modified_files: Optional[List[Path]] = None\n    ) -> VerificationResult:\n        \"\"\"\n        éªŒè¯æ‰§è¡Œç»“æœ\n        \n        Args:\n            result: æ‰§è¡Œç»“æœ\n            level: éªŒè¯çº§åˆ«\n            modified_files: ä¿®æ”¹çš„æ–‡ä»¶åˆ—è¡¨\n        \n        Returns:\n            éªŒè¯ç»“æœ\n        \"\"\"\n        if level == VerificationLevel.NONE:\n            return VerificationResult(\n                passed=True,\n                level=level,\n                details={'message': 'è·³è¿‡éªŒè¯'}\n            )\n        \n        logger.info(f\"å¼€å§‹éªŒè¯ï¼Œçº§åˆ«: {level.value}\")\n        \n        verification = VerificationResult(passed=True, level=level)\n        \n        # 1. è¿è¡Œè¯Šæ–­ï¼ˆæ‰€æœ‰çº§åˆ«éƒ½éœ€è¦ï¼‰\n        if level in [VerificationLevel.BASIC, VerificationLevel.STANDARD, VerificationLevel.STRICT]:\n            diagnostics_result = await self._run_diagnostics(modified_files)\n            verification.diagnostics_passed = diagnostics_result['passed']\n            if not diagnostics_result['passed']:\n                verification.passed = False\n                verification.errors.extend(diagnostics_result.get('errors', []))\n            verification.details['diagnostics'] = diagnostics_result\n        \n        # 2. è¿è¡Œæ„å»ºï¼ˆæ ‡å‡†å’Œä¸¥æ ¼çº§åˆ«ï¼‰\n        if level in [VerificationLevel.STANDARD, VerificationLevel.STRICT]:\n            if self.build_command:\n                build_result = await self._run_build()\n                verification.build_passed = build_result['passed']\n                if not build_result['passed']:\n                    verification.passed = False\n                    verification.errors.extend(build_result.get('errors', []))\n                verification.details['build'] = build_result\n            else:\n                verification.warnings.append(\"æœªé…ç½®æ„å»ºå‘½ä»¤ï¼Œè·³è¿‡æ„å»ºéªŒè¯\")\n        \n        # 3. è¿è¡Œæµ‹è¯•ï¼ˆä¸¥æ ¼çº§åˆ«ï¼‰\n        if level == VerificationLevel.STRICT:\n            if self.test_command:\n                test_result = await self._run_tests()\n                verification.tests_passed = test_result['passed']\n                if not test_result['passed']:\n                    verification.passed = False\n                    verification.errors.extend(test_result.get('errors', []))\n                verification.details['tests'] = test_result\n            else:\n                verification.warnings.append(\"æœªé…ç½®æµ‹è¯•å‘½ä»¤ï¼Œè·³è¿‡æµ‹è¯•éªŒè¯\")\n        \n        # 4. æ£€æŸ¥ä¿®æ”¹çš„æ–‡ä»¶\n        if modified_files:\n            file_check_result = await self._check_modified_files(modified_files)\n            verification.file_check_passed = file_check_result['passed']\n            if not file_check_result['passed']:\n                verification.passed = False\n                verification.errors.extend(file_check_result.get('errors', []))\n            verification.details['file_check'] = file_check_result\n        \n        logger.info(f\"éªŒè¯å®Œæˆ: passed={verification.passed}, errors={len(verification.errors)}\")\n        return verification\n    \n    async def _run_diagnostics(self, files: Optional[List[Path]] = None) -> Dict[str, Any]:\n        \"\"\"\n        è¿è¡ŒLSPè¯Šæ–­\n        \n        æ£€æŸ¥è¯­æ³•é”™è¯¯ã€ç±»å‹é”™è¯¯ç­‰\n        \"\"\"\n        try:\n            logger.info(\"è¿è¡ŒLSPè¯Šæ–­...\")\n            \n            # è¿™é‡Œåº”è¯¥è°ƒç”¨å®é™…çš„LSPè¯Šæ–­å·¥å…·\n            # ç¤ºä¾‹ï¼šä½¿ç”¨pylintã€mypyã€eslintç­‰\n            \n      "
},
{
"path": "daoyoucode/agents/core/verification.py",
"start": 362,
"end": 364,
"text": "def get_verification_manager() -> VerificationManager:\n    \"\"\"è·å–éªŒè¯ç®¡ç†å™¨å•ä¾‹\"\"\"\n    return VerificationManager()"
},
{
"path": "daoyoucode/agents/core/__init__.py",
"start": 1,
"end": 61,
"text": "\"\"\"\nAgentæ ¸å¿ƒæ¨¡å—\n\"\"\"\n\nfrom .agent import BaseAgent, AgentConfig, AgentResult, get_agent_registry, register_agent\nfrom .orchestrator import BaseOrchestrator, get_orchestrator_registry, register_orchestrator\nfrom .skill import SkillConfig, SkillLoader\nfrom .task import Task, TaskStatus, TaskManager, get_task_manager\nfrom .router import IntelligentRouter, TaskFeatures, RoutingDecision, get_intelligent_router\nfrom .context import Context, ContextManager, ContextSnapshot, ContextChange, get_context_manager\nfrom .planner import ExecutionPlanner, ExecutionPlan, ExecutionStep, get_execution_planner\nfrom .feedback import FeedbackLoop, Evaluation, FailureAnalysis, get_feedback_loop\n\n__all__ = [\n    # Agent\n    'BaseAgent',\n    'AgentConfig',\n    'AgentResult',\n    'get_agent_registry',\n    'register_agent',\n    \n    # Orchestrator\n    'BaseOrchestrator',\n    'get_orchestrator_registry',\n    'register_orchestrator',\n    \n    # Skill\n    'SkillConfig',\n    'SkillLoader',\n    \n    # Task\n    'Task',\n    'TaskStatus',\n    'TaskManager',\n    'get_task_manager',\n    \n    # Router\n    'IntelligentRouter',\n    'TaskFeatures',\n    'RoutingDecision',\n    'get_intelligent_router',\n    \n    # Context\n    'Context',\n    'ContextManager',\n    'ContextSnapshot',\n    'ContextChange',\n    'get_context_manager',\n    \n    # Planner\n    'ExecutionPlanner',\n    'ExecutionPlan',\n    'ExecutionStep',\n    'get_execution_planner',\n    \n    # Feedback\n    'FeedbackLoop',\n    'Evaluation',\n    'FailureAnalysis',\n    'get_feedback_loop',\n]"
},
{
"path": "daoyoucode/agents/hooks/logging.py",
"start": 1,
"end": 14,
"text": "\"\"\"\næ—¥å¿—Hook\n\nè®°å½•Skillæ‰§è¡Œçš„è¯¦ç»†æ—¥å¿—\n\"\"\"\n\nfrom ..core.hook import BaseHook, HookContext\nfrom typing import Dict, Any, Optional\nimport logging\nimport time\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/hooks/logging.py",
"start": 15,
"end": 17,
"text": "class LoggingHook(BaseHook):\n    \"\"\"æ—¥å¿—Hook\"\"\"\n    "
},
{
"path": "daoyoucode/agents/hooks/logging.py",
"start": 18,
"end": 70,
"text": "    def __init__(self):\n        super().__init__(\"logging\")\n        self._start_times: Dict[str, float] = {}\n    \n    async def on_before_execute(\n        self,\n        context: HookContext\n    ) -> HookContext:\n        \"\"\"æ‰§è¡Œå‰è®°å½•æ—¥å¿—\"\"\"\n        session_key = f\"{context.session_id}_{context.skill_name}\"\n        self._start_times[session_key] = time.time()\n        \n        self.logger.info(\n            f\"å¼€å§‹æ‰§è¡ŒSkill: {context.skill_name}, \"\n            f\"session: {context.session_id}, \"\n            f\"input: {context.user_input[:50]}...\"\n        )\n        \n        return context\n    \n    async def on_after_execute(\n        self,\n        context: HookContext,\n        result: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"æ‰§è¡Œåè®°å½•æ—¥å¿—\"\"\"\n        session_key = f\"{context.session_id}_{context.skill_name}\"\n        start_time = self._start_times.pop(session_key, None)\n        \n        if start_time:\n            duration = time.time() - start_time\n            self.logger.info(\n                f\"Skillæ‰§è¡Œå®Œæˆ: {context.skill_name}, \"\n                f\"è€—æ—¶: {duration:.2f}s, \"\n                f\"æˆåŠŸ: {result.get('success', False)}\"\n            )\n        \n        return result\n    \n    async def on_error(\n        self,\n        context: HookContext,\n        error: Exception\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"é”™è¯¯æ—¶è®°å½•æ—¥å¿—\"\"\"\n        self.logger.error(\n            f\"Skillæ‰§è¡Œå¤±è´¥: {context.skill_name}, \"\n            f\"é”™è¯¯: {error}\",\n            exc_info=True\n        )\n        \n        # ä¸å¤„ç†é”™è¯¯ï¼Œç»§ç»­æŠ›å‡º\n        return None"
},
{
"path": "daoyoucode/agents/hooks/metrics.py",
"start": 1,
"end": 11,
"text": "\"\"\"\næ€§èƒ½æŒ‡æ ‡Hook\n\næ”¶é›†å’Œè®°å½•æ€§èƒ½æŒ‡æ ‡\n\"\"\"\n\nfrom ..core.hook import BaseHook, HookContext\nfrom typing import Dict, Any, Optional\nimport time\n\n"
},
{
"path": "daoyoucode/agents/hooks/metrics.py",
"start": 12,
"end": 14,
"text": "class MetricsHook(BaseHook):\n    \"\"\"æ€§èƒ½æŒ‡æ ‡Hook\"\"\"\n    "
},
{
"path": "daoyoucode/agents/hooks/metrics.py",
"start": 15,
"end": 92,
"text": "    def __init__(self):\n        super().__init__(\"metrics\")\n        self._start_times: Dict[str, float] = {}\n        self._metrics: Dict[str, Dict[str, Any]] = {}\n    \n    async def on_before_execute(\n        self,\n        context: HookContext\n    ) -> HookContext:\n        \"\"\"è®°å½•å¼€å§‹æ—¶é—´\"\"\"\n        session_key = f\"{context.session_id}_{context.skill_name}\"\n        self._start_times[session_key] = time.time()\n        \n        # åœ¨ä¸Šä¸‹æ–‡ä¸­æ·»åŠ å¼€å§‹æ—¶é—´\n        context.metadata['start_time'] = self._start_times[session_key]\n        \n        return context\n    \n    async def on_after_execute(\n        self,\n        context: HookContext,\n        result: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"è®¡ç®—æ€§èƒ½æŒ‡æ ‡\"\"\"\n        session_key = f\"{context.session_id}_{context.skill_name}\"\n        start_time = self._start_times.pop(session_key, None)\n        \n        if start_time:\n            duration = time.time() - start_time\n            \n            # æ·»åŠ æ€§èƒ½æŒ‡æ ‡åˆ°ç»“æœ\n            if 'metrics' not in result:\n                result['metrics'] = {}\n            \n            result['metrics'].update({\n                'duration': duration,\n                'start_time': start_time,\n                'end_time': time.time(),\n            })\n            \n            # å¦‚æœæœ‰tokensä¿¡æ¯ï¼Œæ·»åŠ æˆæœ¬ä¼°ç®—\n            if 'tokens_used' in result:\n                tokens = result['tokens_used']\n                # ç®€å•çš„æˆæœ¬ä¼°ç®—ï¼ˆå®é™…åº”æ ¹æ®æ¨¡å‹å®šä»·ï¼‰\n                estimated_cost = self._estimate_cost(tokens)\n                result['metrics']['estimated_cost'] = estimated_cost\n            \n            # ä¿å­˜æŒ‡æ ‡\n            self._metrics[session_key] = result['metrics']\n            \n            self.logger.info(\n                f\"æ€§èƒ½æŒ‡æ ‡ - Skill: {context.skill_name}, \"\n                f\"è€—æ—¶: {duration:.2f}s, \"\n                f\"tokens: {result.get('tokens_used', 'N/A')}\"\n            )\n        \n        return result\n    \n    async def on_error(\n        self,\n        context: HookContext,\n        error: Exception\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"è®°å½•é”™è¯¯æŒ‡æ ‡\"\"\"\n        session_key = f\"{context.session_id}_{context.skill_name}\"\n        start_time = self._start_times.pop(session_key, None)\n        \n        if start_time:\n            duration = time.time() - start_time\n            \n            self._metrics[session_key] = {\n                'duration': duration,\n                'error': str(error),\n                'success': False,\n            }\n        \n        return None\n    "
},
{
"path": "daoyoucode/agents/hooks/metrics.py",
"start": 93,
"end": 107,
"text": "    def _estimate_cost(self, tokens: Dict[str, int]) -> float:\n        \"\"\"\n        ä¼°ç®—æˆæœ¬ï¼ˆç¾å…ƒï¼‰\n        \n        ç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…åº”æ ¹æ®å…·ä½“æ¨¡å‹å®šä»·\n        \"\"\"\n        # å‡è®¾å¹³å‡ä»·æ ¼ï¼šè¾“å…¥$0.01/1K tokensï¼Œè¾“å‡º$0.03/1K tokens\n        input_tokens = tokens.get('input', 0)\n        output_tokens = tokens.get('output', 0)\n        \n        input_cost = (input_tokens / 1000) * 0.01\n        output_cost = (output_tokens / 1000) * 0.03\n        \n        return input_cost + output_cost\n    "
},
{
"path": "daoyoucode/agents/hooks/metrics.py",
"start": 108,
"end": 111,
"text": "    def get_metrics(self, session_key: str) -> Optional[Dict[str, Any]]:\n        \"\"\"è·å–æŒ‡æ ‡\"\"\"\n        return self._metrics.get(session_key)\n    "
},
{
"path": "daoyoucode/agents/hooks/metrics.py",
"start": 112,
"end": 115,
"text": "    def get_all_metrics(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"è·å–æ‰€æœ‰æŒ‡æ ‡\"\"\"\n        return self._metrics.copy()\n    "
},
{
"path": "daoyoucode/agents/hooks/metrics.py",
"start": 116,
"end": 118,
"text": "    def clear_metrics(self):\n        \"\"\"æ¸…ç©ºæŒ‡æ ‡\"\"\"\n        self._metrics.clear()"
},
{
"path": "daoyoucode/agents/hooks/retry.py",
"start": 1,
"end": 11,
"text": "\"\"\"\né‡è¯•Hook\n\nè‡ªåŠ¨é‡è¯•å¤±è´¥çš„æ‰§è¡Œ\n\"\"\"\n\nfrom ..core.hook import BaseHook, HookContext\nfrom typing import Dict, Any, Optional\nimport asyncio\n\n"
},
{
"path": "daoyoucode/agents/hooks/retry.py",
"start": 12,
"end": 14,
"text": "class RetryHook(BaseHook):\n    \"\"\"é‡è¯•Hook\"\"\"\n    "
},
{
"path": "daoyoucode/agents/hooks/retry.py",
"start": 15,
"end": 110,
"text": "    def __init__(\n        self,\n        max_retries: int = 3,\n        retry_delay: float = 1.0,\n        exponential_backoff: bool = True\n    ):\n        super().__init__(\"retry\")\n        self.max_retries = max_retries\n        self.retry_delay = retry_delay\n        self.exponential_backoff = exponential_backoff\n        self._retry_counts: Dict[str, int] = {}\n    \n    async def on_before_execute(\n        self,\n        context: HookContext\n    ) -> HookContext:\n        \"\"\"è®°å½•é‡è¯•æ¬¡æ•°\"\"\"\n        session_key = f\"{context.session_id}_{context.skill_name}\"\n        \n        if session_key not in self._retry_counts:\n            self._retry_counts[session_key] = 0\n        \n        retry_count = self._retry_counts[session_key]\n        context.metadata['retry_count'] = retry_count\n        \n        if retry_count > 0:\n            self.logger.info(\n                f\"é‡è¯•æ‰§è¡Œ (ç¬¬{retry_count}æ¬¡): {context.skill_name}\"\n            )\n        \n        return context\n    \n    async def on_after_execute(\n        self,\n        context: HookContext,\n        result: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"æˆåŠŸåæ¸…é™¤é‡è¯•è®¡æ•°\"\"\"\n        session_key = f\"{context.session_id}_{context.skill_name}\"\n        \n        if result.get('success'):\n            # æˆåŠŸï¼Œæ¸…é™¤é‡è¯•è®¡æ•°\n            self._retry_counts.pop(session_key, None)\n        \n        # æ·»åŠ é‡è¯•ä¿¡æ¯åˆ°ç»“æœ\n        if 'retry_count' in context.metadata:\n            result['retry_count'] = context.metadata['retry_count']\n        \n        return result\n    \n    async def on_error(\n        self,\n        context: HookContext,\n        error: Exception\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"é”™è¯¯æ—¶å°è¯•é‡è¯•\"\"\"\n        session_key = f\"{context.session_id}_{context.skill_name}\"\n        retry_count = self._retry_counts.get(session_key, 0)\n        \n        if retry_count < self.max_retries:\n            # å¢åŠ é‡è¯•è®¡æ•°\n            self._retry_counts[session_key] = retry_count + 1\n            \n            # è®¡ç®—å»¶è¿Ÿæ—¶é—´\n            if self.exponential_backoff:\n                delay = self.retry_delay * (2 ** retry_count)\n            else:\n                delay = self.retry_delay\n            \n            self.logger.warning(\n                f\"æ‰§è¡Œå¤±è´¥ï¼Œå°†åœ¨{delay}ç§’åé‡è¯• \"\n                f\"(ç¬¬{retry_count + 1}/{self.max_retries}æ¬¡): {error}\"\n            )\n            \n            # ç­‰å¾…åé‡è¯•\n            await asyncio.sleep(delay)\n            \n            # è¿”å›Noneè¡¨ç¤ºéœ€è¦é‡è¯•ï¼ˆç”±executorå¤„ç†ï¼‰\n            return None\n        \n        else:\n            # è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°\n            self.logger.error(\n                f\"è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°({self.max_retries})ï¼Œæ”¾å¼ƒé‡è¯•: {error}\"\n            )\n            \n            # æ¸…é™¤é‡è¯•è®¡æ•°\n            self._retry_counts.pop(session_key, None)\n            \n            # è¿”å›é”™è¯¯ç»“æœ\n            return {\n                'success': False,\n                'content': '',\n                'error': f\"æ‰§è¡Œå¤±è´¥ï¼ˆå·²é‡è¯•{self.max_retries}æ¬¡ï¼‰: {error}\",\n                'retry_count': self.max_retries,\n            }"
},
{
"path": "daoyoucode/agents/hooks/validation.py",
"start": 1,
"end": 10,
"text": "\"\"\"\nè¾“å…¥éªŒè¯Hook\n\néªŒè¯ç”¨æˆ·è¾“å…¥çš„åˆæ³•æ€§\n\"\"\"\n\nfrom ..core.hook import BaseHook, HookContext\nfrom typing import Dict, Any, Optional\n\n"
},
{
"path": "daoyoucode/agents/hooks/validation.py",
"start": 11,
"end": 13,
"text": "class ValidationHook(BaseHook):\n    \"\"\"è¾“å…¥éªŒè¯Hook\"\"\"\n    "
},
{
"path": "daoyoucode/agents/hooks/validation.py",
"start": 14,
"end": 89,
"text": "    def __init__(\n        self,\n        min_length: int = 1,\n        max_length: int = 10000,\n        forbidden_words: Optional[list] = None\n    ):\n        super().__init__(\"validation\")\n        self.min_length = min_length\n        self.max_length = max_length\n        self.forbidden_words = forbidden_words or []\n    \n    async def on_before_execute(\n        self,\n        context: HookContext\n    ) -> HookContext:\n        \"\"\"éªŒè¯è¾“å…¥\"\"\"\n        user_input = context.user_input\n        \n        # æ£€æŸ¥é•¿åº¦\n        if len(user_input) < self.min_length:\n            raise ValueError(\n                f\"è¾“å…¥å¤ªçŸ­ï¼Œæœ€å°‘éœ€è¦{self.min_length}ä¸ªå­—ç¬¦\"\n            )\n        \n        if len(user_input) > self.max_length:\n            raise ValueError(\n                f\"è¾“å…¥å¤ªé•¿ï¼Œæœ€å¤šå…è®¸{self.max_length}ä¸ªå­—ç¬¦\"\n            )\n        \n        # æ£€æŸ¥ç©ºç™½\n        if not user_input.strip():\n            raise ValueError(\"è¾“å…¥ä¸èƒ½ä¸ºç©º\")\n        \n        # æ£€æŸ¥ç¦ç”¨è¯\n        for word in self.forbidden_words:\n            if word.lower() in user_input.lower():\n                raise ValueError(f\"è¾“å…¥åŒ…å«ç¦ç”¨è¯: {word}\")\n        \n        self.logger.debug(f\"è¾“å…¥éªŒè¯é€šè¿‡: {user_input[:50]}...\")\n        \n        return context\n    \n    async def on_after_execute(\n        self,\n        context: HookContext,\n        result: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"éªŒè¯è¾“å‡º\"\"\"\n        # æ£€æŸ¥ç»“æœæ ¼å¼\n        if not isinstance(result, dict):\n            self.logger.warning(\"ç»“æœä¸æ˜¯å­—å…¸æ ¼å¼\")\n        \n        if 'success' not in result:\n            self.logger.warning(\"ç»“æœç¼ºå°‘successå­—æ®µ\")\n        \n        if 'content' not in result:\n            self.logger.warning(\"ç»“æœç¼ºå°‘contentå­—æ®µ\")\n        \n        return result\n    \n    async def on_error(\n        self,\n        context: HookContext,\n        error: Exception\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"é”™è¯¯å¤„ç†\"\"\"\n        # å¦‚æœæ˜¯éªŒè¯é”™è¯¯ï¼Œè¿”å›å‹å¥½çš„é”™è¯¯ä¿¡æ¯\n        if isinstance(error, ValueError):\n            return {\n                'success': False,\n                'content': '',\n                'error': str(error),\n                'error_type': 'validation_error'\n            }\n        \n        return None"
},
{
"path": "daoyoucode/agents/hooks/__init__.py",
"start": 1,
"end": 20,
"text": "\"\"\"\nå†…ç½®Hooks\n\næä¾›å¸¸ç”¨çš„Hookå®ç°\n\"\"\"\n\nfrom .logging import LoggingHook\nfrom .metrics import MetricsHook\nfrom .validation import ValidationHook\nfrom .retry import RetryHook\n\n__all__ = [\n    'LoggingHook',\n    'MetricsHook',\n    'ValidationHook',\n    'RetryHook',\n]\n\n\n# ä¾¿æ·å‡½æ•°ï¼šåˆ›å»ºé»˜è®¤Hooké›†åˆ"
},
{
"path": "daoyoucode/agents/hooks/__init__.py",
"start": 21,
"end": 29,
"text": "def create_default_hooks():\n    \"\"\"åˆ›å»ºé»˜è®¤çš„Hooké›†åˆ\"\"\"\n    return [\n        LoggingHook(),\n        MetricsHook(),\n        ValidationHook(),\n    ]\n\n"
},
{
"path": "daoyoucode/agents/hooks/__init__.py",
"start": 30,
"end": 41,
"text": "def create_production_hooks():\n    \"\"\"åˆ›å»ºç”Ÿäº§ç¯å¢ƒçš„Hooké›†åˆ\"\"\"\n    return [\n        LoggingHook(),\n        MetricsHook(),\n        ValidationHook(\n            min_length=1,\n            max_length=5000,\n            forbidden_words=['test', 'debug']  # ç¤ºä¾‹\n        ),\n        RetryHook(max_retries=3),\n    ]"
},
{
"path": "daoyoucode/agents/llm/base.py",
"start": 1,
"end": 11,
"text": "\"\"\"\nLLMæ¨¡å—åŸºç¡€æ¥å£å®šä¹‰\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import Optional, Dict, Any, AsyncIterator\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/llm/base.py",
"start": 12,
"end": 22,
"text": "class LLMRequest:\n    \"\"\"LLMè¯·æ±‚\"\"\"\n    prompt: str\n    model: str\n    temperature: float = 0.7\n    max_tokens: Optional[int] = None\n    stream: bool = False\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/llm/base.py",
"start": 23,
"end": 33,
"text": "class LLMResponse:\n    \"\"\"LLMå“åº”\"\"\"\n    content: str\n    model: str\n    tokens_used: int\n    cost: float\n    latency: float  # å“åº”æ—¶é—´ï¼ˆç§’ï¼‰\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    timestamp: datetime = field(default_factory=datetime.now)\n\n"
},
{
"path": "daoyoucode/agents/llm/base.py",
"start": 34,
"end": 59,
"text": "class BaseLLMClient(ABC):\n    \"\"\"LLMå®¢æˆ·ç«¯åŸºç±»\"\"\"\n    \n    @abstractmethod\n    async def chat(self, request: LLMRequest) -> LLMResponse:\n        \"\"\"åŒæ­¥å¯¹è¯\"\"\"\n        pass\n    \n    @abstractmethod\n    async def stream_chat(self, request: LLMRequest) -> AsyncIterator[str]:\n        \"\"\"æµå¼å¯¹è¯\"\"\"\n        pass\n    \n    async def health_check(self) -> bool:\n        \"\"\"å¥åº·æ£€æŸ¥\"\"\"\n        try:\n            # å‘é€ç®€å•æµ‹è¯•è¯·æ±‚\n            request = LLMRequest(\n                prompt=\"test\",\n                model=self.model,\n                max_tokens=1\n            )\n            await self.chat(request)\n            return True\n        except Exception:\n            return False"
},
{
"path": "daoyoucode/agents/llm/client_manager.py",
"start": 1,
"end": 15,
"text": "\"\"\"\nLLMå®¢æˆ·ç«¯ç®¡ç†å™¨ï¼ˆç®€åŒ–ç‰ˆï¼‰\nä½¿ç”¨ httpx å†…ç½®è¿æ¥æ± ï¼Œä¸éœ€è¦é¢å¤–çš„è¿æ¥æ± å±‚\næ”¯æŒå¤šAPI Keyè½®è¯¢\n\"\"\"\n\nimport httpx\nimport logging\nfrom typing import Dict, Optional, List\nfrom .clients.unified import UnifiedLLMClient\nfrom .exceptions import LLMError\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/llm/client_manager.py",
"start": 16,
"end": 28,
"text": "class LLMClientManager:\n    \"\"\"\n    LLMå®¢æˆ·ç«¯ç®¡ç†å™¨\n    \n    æ ¸å¿ƒè®¾è®¡ï¼š\n    1. å…¨å±€å…±äº« httpx.AsyncClientï¼ˆå†…ç½®è¿æ¥æ± ï¼‰\n    2. æŒ‰æä¾›å•†ç¼“å­˜é…ç½®\n    3. è½»é‡çº§å®¢æˆ·ç«¯å¯¹è±¡åˆ›å»º\n    4. æ”¯æŒå¤šAPI Keyè½®è¯¢ï¼ˆRound-robinï¼‰\n    \"\"\"\n    \n    _instance = None\n    "
},
{
"path": "daoyoucode/agents/llm/client_manager.py",
"start": 29,
"end": 34,
"text": "    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    "
},
{
"path": "daoyoucode/agents/llm/client_manager.py",
"start": 35,
"end": 63,
"text": "    def __init__(self):\n        if self._initialized:\n            return\n        \n        # å…¨å±€å…±äº«çš„ HTTP å®¢æˆ·ç«¯ï¼ˆå†…ç½®è¿æ¥æ± ï¼‰\n        self.http_client = httpx.AsyncClient(\n            limits=httpx.Limits(\n                max_connections=100,           # æœ€å¤§è¿æ¥æ•°\n                max_keepalive_connections=20   # ä¿æŒæ´»è·ƒçš„è¿æ¥æ•°\n            ),\n            timeout=httpx.Timeout(1800.0)  # ğŸ†• 30 åˆ†é’Ÿï¼ˆæ”¯æŒå¤§è§„æ¨¡æ–‡ä»¶è¯»å†™å’Œå¤æ‚ä»»åŠ¡ï¼‰\n        )\n        \n        # æä¾›å•†é…ç½®ç¼“å­˜\n        self.provider_configs: Dict[str, Dict] = {}\n        \n        # API Keyè½®è¯¢è®¡æ•°å™¨ï¼ˆæ¯ä¸ªæä¾›å•†ç‹¬ç«‹è®¡æ•°ï¼‰\n        self.key_counters: Dict[str, int] = {}\n        \n        # ç»Ÿè®¡ä¿¡æ¯\n        self.stats = {\n            'total_requests': 0,\n            'total_tokens': 0,\n            'total_cost': 0.0,\n        }\n        \n        self._initialized = True\n        logger.info(\"LLMå®¢æˆ·ç«¯ç®¡ç†å™¨å·²åˆå§‹åŒ–ï¼ˆæ”¯æŒAPI Keyè½®è¯¢ï¼‰\")\n    "
},
{
"path": "daoyoucode/agents/llm/client_manager.py",
"start": 64,
"end": 100,
"text": "    def configure_provider(\n        self,\n        provider: str,\n        api_key: Optional[str] = None,\n        api_keys: Optional[List[str]] = None,\n        base_url: str = \"\",\n        models: Optional[list] = None\n    ):\n        \"\"\"\n        é…ç½®æä¾›å•†\n        \n        Args:\n            provider: æä¾›å•†åç§°ï¼ˆqwen, deepseek, openaiç­‰ï¼‰\n            api_key: å•ä¸ªAPIå¯†é’¥ï¼ˆä¸api_keysäºŒé€‰ä¸€ï¼‰\n            api_keys: å¤šä¸ªAPIå¯†é’¥åˆ—è¡¨ï¼ˆè½®è¯¢ä½¿ç”¨ï¼‰\n            base_url: APIç«¯ç‚¹\n            models: æ”¯æŒçš„æ¨¡å‹åˆ—è¡¨\n        \"\"\"\n        # å¤„ç†API Keyï¼ˆæ”¯æŒå•ä¸ªæˆ–å¤šä¸ªï¼‰\n        if api_keys:\n            keys = api_keys\n        elif api_key:\n            keys = [api_key]\n        else:\n            raise LLMError(f\"æä¾›å•† {provider} å¿…é¡»é…ç½® api_key æˆ– api_keys\")\n        \n        self.provider_configs[provider] = {\n            'api_keys': keys,  # ç»Ÿä¸€å­˜å‚¨ä¸ºåˆ—è¡¨\n            'base_url': base_url,\n            'models': models or []\n        }\n        \n        # åˆå§‹åŒ–è½®è¯¢è®¡æ•°å™¨\n        self.key_counters[provider] = 0\n        \n        logger.info(f\"å·²é…ç½®æä¾›å•†: {provider}, API Keyæ•°é‡: {len(keys)}\")\n    "
},
{
"path": "daoyoucode/agents/llm/client_manager.py",
"start": 101,
"end": 128,
"text": "    def _get_next_api_key(self, provider: str) -> str:\n        \"\"\"\n        è·å–ä¸‹ä¸€ä¸ªAPI Keyï¼ˆRound-robinè½®è¯¢ï¼‰\n        \n        Args:\n            provider: æä¾›å•†åç§°\n        \n        Returns:\n            API Key\n        \"\"\"\n        config = self.provider_configs[provider]\n        keys = config['api_keys']\n        \n        # å¦‚æœåªæœ‰ä¸€ä¸ªkeyï¼Œç›´æ¥è¿”å›\n        if len(keys) == 1:\n            return keys[0]\n        \n        # è½®è¯¢ï¼šè·å–å½“å‰è®¡æ•°å™¨å¯¹åº”çš„keyï¼Œç„¶åé€’å¢è®¡æ•°å™¨\n        current_index = self.key_counters[provider] % len(keys)\n        self.key_counters[provider] += 1\n        \n        selected_key = keys[current_index]\n        \n        # æ—¥å¿—æ˜¾ç¤ºä½¿ç”¨çš„æ˜¯ç¬¬å‡ ä¸ªkeyï¼ˆé¿å…æ³„éœ²å®Œæ•´keyï¼‰\n        logger.debug(f\"æä¾›å•† {provider}: ä½¿ç”¨API Key #{current_index + 1}/{len(keys)} ({selected_key[:10]}...)\")\n        \n        return selected_key\n    "
},
{
"path": "daoyoucode/agents/llm/client_manager.py",
"start": 129,
"end": 160,
"text": "    def get_client(self, model: str, provider: Optional[str] = None) -> UnifiedLLMClient:\n        \"\"\"\n        è·å–å®¢æˆ·ç«¯ï¼ˆè½»é‡çº§å¯¹è±¡ï¼‰\n        \n        Args:\n            model: æ¨¡å‹åç§°\n            provider: æä¾›å•†åç§°ï¼ˆå¯é€‰ï¼Œè‡ªåŠ¨æ¨æ–­ï¼‰\n        \n        Returns:\n            UnifiedLLMClientå®ä¾‹\n        \"\"\"\n        # è‡ªåŠ¨æ¨æ–­æä¾›å•†\n        if provider is None:\n            provider = self._infer_provider(model)\n        \n        # è·å–é…ç½®\n        if provider not in self.provider_configs:\n            raise LLMError(f\"æœªé…ç½®æä¾›å•†: {provider}\")\n        \n        config = self.provider_configs[provider]\n        \n        # è·å–ä¸‹ä¸€ä¸ªAPI Keyï¼ˆè½®è¯¢ï¼‰\n        api_key = self._get_next_api_key(provider)\n        \n        # åˆ›å»ºè½»é‡çº§å®¢æˆ·ç«¯ï¼ˆå…±äº«HTTPå®¢æˆ·ç«¯ï¼‰\n        return UnifiedLLMClient(\n            http_client=self.http_client,  # å…±äº«è¿æ¥æ± \n            api_key=api_key,\n            base_url=config['base_url'],\n            model=model\n        )\n    "
},
{
"path": "daoyoucode/agents/llm/client_manager.py",
"start": 161,
"end": 175,
"text": "    def _infer_provider(self, model: str) -> str:\n        \"\"\"æ ¹æ®æ¨¡å‹åç§°æ¨æ–­æä¾›å•†\"\"\"\n        if model.startswith('qwen'):\n            return 'qwen'\n        elif model.startswith('deepseek'):\n            return 'deepseek'\n        elif model.startswith('gpt'):\n            return 'openai'\n        elif model.startswith('claude'):\n            return 'anthropic'\n        elif model.startswith('gemini'):\n            return 'google'\n        else:\n            raise LLMError(f\"æ— æ³•æ¨æ–­æ¨¡å‹ {model} çš„æä¾›å•†\")\n    "
},
{
"path": "daoyoucode/agents/llm/client_manager.py",
"start": 176,
"end": 181,
"text": "    def record_usage(self, tokens: int, cost: float):\n        \"\"\"è®°å½•ä½¿ç”¨ç»Ÿè®¡\"\"\"\n        self.stats['total_requests'] += 1\n        self.stats['total_tokens'] += tokens\n        self.stats['total_cost'] += cost\n    "
},
{
"path": "daoyoucode/agents/llm/client_manager.py",
"start": 182,
"end": 203,
"text": "    def get_stats(self) -> Dict:\n        \"\"\"è·å–ç»Ÿè®¡ä¿¡æ¯\"\"\"\n        stats = {**self.stats}\n        \n        # å°è¯•è·å–HTTPè¿æ¥æ± ç»Ÿè®¡ï¼ˆå¯é€‰ï¼‰\n        try:\n            if hasattr(self.http_client, '_limits'):\n                stats['http_pool_stats'] = {\n                    'max_connections': self.http_client._limits.max_connections,\n                    'max_keepalive': self.http_client._limits.max_keepalive_connections,\n                }\n        except Exception:\n            pass\n        \n        return stats\n    \n    async def close(self):\n        \"\"\"å…³é—­ç®¡ç†å™¨\"\"\"\n        await self.http_client.aclose()\n        logger.info(f\"LLMå®¢æˆ·ç«¯ç®¡ç†å™¨å·²å…³é—­ã€‚ç»Ÿè®¡: {self.stats}\")\n\n"
},
{
"path": "daoyoucode/agents/llm/client_manager.py",
"start": 204,
"end": 206,
"text": "def get_client_manager() -> LLMClientManager:\n    \"\"\"è·å–å®¢æˆ·ç«¯ç®¡ç†å™¨å•ä¾‹\"\"\"\n    return LLMClientManager()"
},
{
"path": "daoyoucode/agents/llm/config_loader.py",
"start": 1,
"end": 13,
"text": "\"\"\"\nLLMé…ç½®åŠ è½½å™¨\nä»é…ç½®æ–‡ä»¶åŠ è½½APIå¯†é’¥å’Œæä¾›å•†é…ç½®\n\"\"\"\n\nimport yaml\nimport os\nfrom pathlib import Path\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/llm/config_loader.py",
"start": 14,
"end": 46,
"text": "def load_llm_config(config_path: str = None) -> dict:\n    \"\"\"\n    åŠ è½½LLMé…ç½®\n    \n    Args:\n        config_path: é…ç½®æ–‡ä»¶è·¯å¾„ï¼Œé»˜è®¤ä¸º backend/config/llm_config.yaml\n    \n    Returns:\n        é…ç½®å­—å…¸\n    \"\"\"\n    if config_path is None:\n        # é»˜è®¤é…ç½®è·¯å¾„\n        backend_dir = Path(__file__).parent.parent.parent.parent\n        config_path = backend_dir / \"config\" / \"llm_config.yaml\"\n    \n    config_path = Path(config_path)\n    \n    if not config_path.exists():\n        logger.warning(f\"é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_path}\")\n        return {}\n    \n    try:\n        with open(config_path, 'r', encoding='utf-8') as f:\n            config = yaml.safe_load(f)\n        \n        logger.info(f\"å·²åŠ è½½LLMé…ç½®: {config_path}\")\n        return config\n    \n    except Exception as e:\n        logger.error(f\"åŠ è½½é…ç½®å¤±è´¥: {e}\")\n        return {}\n\n"
},
{
"path": "daoyoucode/agents/llm/config_loader.py",
"start": 47,
"end": 124,
"text": "def configure_from_file(client_manager, config_path: str = None):\n    \"\"\"\n    ä»é…ç½®æ–‡ä»¶é…ç½®å®¢æˆ·ç«¯ç®¡ç†å™¨\n    \n    Args:\n        client_manager: LLMClientManagerå®ä¾‹\n        config_path: é…ç½®æ–‡ä»¶è·¯å¾„\n    \"\"\"\n    config = load_llm_config(config_path)\n    \n    if not config:\n        logger.warning(\"æœªåŠ è½½ä»»ä½•é…ç½®\")\n        return\n    \n    providers = config.get('providers', {})\n    configured_count = 0\n    \n    for provider_name, provider_config in providers.items():\n        # æ£€æŸ¥æ˜¯å¦å¯ç”¨\n        if not provider_config.get('enabled', False):\n            logger.debug(f\"æä¾›å•† {provider_name} æœªå¯ç”¨\")\n            continue\n        \n        # æ£€æŸ¥APIå¯†é’¥ï¼ˆæ”¯æŒå•ä¸ªæˆ–å¤šä¸ªï¼Œæ”¯æŒå¤šç§æ ¼å¼ï¼‰\n        api_key = provider_config.get('api_key')\n        api_keys = provider_config.get('api_keys')\n        \n        # å¤„ç†api_keyå­—æ®µï¼ˆå¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–åˆ—è¡¨ï¼‰\n        if api_key:\n            if isinstance(api_key, list):\n                # api_keyæ˜¯åˆ—è¡¨ï¼Œè½¬æ¢ä¸ºapi_keys\n                api_keys = api_key\n                api_key = None\n            elif isinstance(api_key, str):\n                # api_keyæ˜¯å­—ç¬¦ä¸²ï¼Œä¿æŒä¸å˜\n                pass\n        \n        # éªŒè¯è‡³å°‘æœ‰ä¸€ä¸ªkeyé…ç½®\n        if not api_key and not api_keys:\n            logger.warning(f\"æä¾›å•† {provider_name} çš„APIå¯†é’¥æœªé…ç½®\")\n            continue\n        \n        # éªŒè¯keyä¸æ˜¯å ä½ç¬¦\n        if api_key and isinstance(api_key, str) and api_key.startswith('your-'):\n            logger.warning(f\"æä¾›å•† {provider_name} çš„APIå¯†é’¥æœªé…ç½®ï¼ˆå ä½ç¬¦ï¼‰\")\n            continue\n        \n        if api_keys:\n            # è¿‡æ»¤æ‰å ä½ç¬¦\n            api_keys = [k for k in api_keys if not k.startswith('your-')]\n            if not api_keys:\n                logger.warning(f\"æä¾›å•† {provider_name} çš„æ‰€æœ‰APIå¯†é’¥éƒ½æ˜¯å ä½ç¬¦\")\n                continue\n        \n        # é…ç½®æä¾›å•†\n        try:\n            client_manager.configure_provider(\n                provider=provider_name,\n                api_key=api_key,\n                api_keys=api_keys,\n                base_url=provider_config.get('base_url'),\n                models=provider_config.get('models', [])\n            )\n            configured_count += 1\n            \n            # æ˜¾ç¤ºé…ç½®çš„keyæ•°é‡\n            key_count = len(api_keys) if api_keys else 1\n            logger.info(f\"âœ“ å·²é…ç½®æä¾›å•†: {provider_name} ({key_count} ä¸ªAPI Key)\")\n        \n        except Exception as e:\n            logger.error(f\"é…ç½®æä¾›å•† {provider_name} å¤±è´¥: {e}\")\n    \n    if configured_count == 0:\n        logger.warning(\"æœªé…ç½®ä»»ä½•LLMæä¾›å•†ï¼Œè¯·æ£€æŸ¥é…ç½®æ–‡ä»¶\")\n    else:\n        logger.info(f\"æˆåŠŸé…ç½® {configured_count} ä¸ªLLMæä¾›å•†\")\n\n"
},
{
"path": "daoyoucode/agents/llm/config_loader.py",
"start": 125,
"end": 180,
"text": "def configure_from_env(client_manager):\n    \"\"\"\n    ä»ç¯å¢ƒå˜é‡é…ç½®å®¢æˆ·ç«¯ç®¡ç†å™¨\n    \n    æ”¯æŒçš„ç¯å¢ƒå˜é‡:\n    - QWEN_API_KEY\n    - DEEPSEEK_API_KEY\n    - OPENAI_API_KEY\n    - ANTHROPIC_API_KEY\n    \"\"\"\n    env_configs = {\n        'qwen': {\n            'env_var': 'QWEN_API_KEY',\n            'base_url': 'https://dashscope.aliyuncs.com/compatible-mode/v1',\n            'models': ['qwen-max', 'qwen-plus', 'qwen-coder-plus']\n        },\n        'deepseek': {\n            'env_var': 'DEEPSEEK_API_KEY',\n            'base_url': 'https://api.deepseek.com/v1',\n            'models': ['deepseek-chat', 'deepseek-coder']\n        },\n        'openai': {\n            'env_var': 'OPENAI_API_KEY',\n            'base_url': 'https://api.openai.com/v1',\n            'models': ['gpt-4', 'gpt-3.5-turbo']\n        },\n        'anthropic': {\n            'env_var': 'ANTHROPIC_API_KEY',\n            'base_url': 'https://api.anthropic.com/v1',\n            'models': ['claude-3-opus', 'claude-3-sonnet']\n        }\n    }\n    \n    configured_count = 0\n    \n    for provider_name, config in env_configs.items():\n        api_key = os.getenv(config['env_var'])\n        \n        if api_key:\n            try:\n                client_manager.configure_provider(\n                    provider=provider_name,\n                    api_key=api_key,\n                    base_url=config['base_url'],\n                    models=config['models']\n                )\n                configured_count += 1\n                logger.info(f\"âœ“ ä»ç¯å¢ƒå˜é‡é…ç½®æä¾›å•†: {provider_name}\")\n            \n            except Exception as e:\n                logger.error(f\"é…ç½®æä¾›å•† {provider_name} å¤±è´¥: {e}\")\n    \n    if configured_count > 0:\n        logger.info(f\"ä»ç¯å¢ƒå˜é‡æˆåŠŸé…ç½® {configured_count} ä¸ªLLMæä¾›å•†\")\n\n"
},
{
"path": "daoyoucode/agents/llm/config_loader.py",
"start": 181,
"end": 203,
"text": "def auto_configure(client_manager, config_path: str = None):\n    \"\"\"\n    è‡ªåŠ¨é…ç½®ï¼šå…ˆå°è¯•é…ç½®æ–‡ä»¶ï¼Œå†å°è¯•ç¯å¢ƒå˜é‡\n    \n    Args:\n        client_manager: LLMClientManagerå®ä¾‹\n        config_path: é…ç½®æ–‡ä»¶è·¯å¾„\n    \"\"\"\n    # 1. å°è¯•ä»é…ç½®æ–‡ä»¶åŠ è½½\n    configure_from_file(client_manager, config_path)\n    \n    # 2. å¦‚æœæ²¡æœ‰é…ç½®ä»»ä½•æä¾›å•†ï¼Œå°è¯•ä»ç¯å¢ƒå˜é‡åŠ è½½\n    if not client_manager.provider_configs:\n        logger.info(\"é…ç½®æ–‡ä»¶æœªé…ç½®æä¾›å•†ï¼Œå°è¯•ä»ç¯å¢ƒå˜é‡åŠ è½½...\")\n        configure_from_env(client_manager)\n    \n    # 3. æœ€ç»ˆæ£€æŸ¥\n    if not client_manager.provider_configs:\n        logger.warning(\"âš  æœªé…ç½®ä»»ä½•LLMæä¾›å•†\")\n        logger.warning(\"è¯·é…ç½® backend/config/llm_config.yaml æˆ–è®¾ç½®ç¯å¢ƒå˜é‡\")\n    else:\n        providers = list(client_manager.provider_configs.keys())\n        logger.info(f\"âœ“ LLMé…ç½®å®Œæˆï¼Œå¯ç”¨æä¾›å•†: {', '.join(providers)}\")"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 1,
"end": 5,
"text": "\"\"\"\nLLMæ¨¡å—å¼‚å¸¸å®šä¹‰\n\"\"\"\n\n"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 6,
"end": 10,
"text": "class LLMError(Exception):\n    \"\"\"LLMåŸºç¡€å¼‚å¸¸\"\"\"\n    pass\n\n"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 11,
"end": 15,
"text": "class LLMConnectionError(LLMError):\n    \"\"\"è¿æ¥é”™è¯¯\"\"\"\n    pass\n\n"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 16,
"end": 20,
"text": "class LLMTimeoutError(LLMError):\n    \"\"\"è¶…æ—¶é”™è¯¯\"\"\"\n    pass\n\n"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 21,
"end": 25,
"text": "class LLMRateLimitError(LLMError):\n    \"\"\"é™æµé”™è¯¯\"\"\"\n    pass\n\n"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 26,
"end": 30,
"text": "class LLMAuthenticationError(LLMError):\n    \"\"\"è®¤è¯é”™è¯¯\"\"\"\n    pass\n\n"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 31,
"end": 35,
"text": "class LLMInvalidRequestError(LLMError):\n    \"\"\"æ— æ•ˆè¯·æ±‚é”™è¯¯\"\"\"\n    pass\n\n"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 36,
"end": 40,
"text": "class LLMModelNotFoundError(LLMError):\n    \"\"\"æ¨¡å‹ä¸å­˜åœ¨é”™è¯¯\"\"\"\n    pass\n\n"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 41,
"end": 45,
"text": "class CircuitBreakerOpenError(LLMError):\n    \"\"\"ç†”æ–­å™¨æ‰“å¼€é”™è¯¯\"\"\"\n    pass\n\n"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 46,
"end": 50,
"text": "class FallbackExhaustedError(LLMError):\n    \"\"\"é™çº§é“¾è€—å°½é”™è¯¯\"\"\"\n    pass\n\n"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 51,
"end": 55,
"text": "class SkillNotFoundError(LLMError):\n    \"\"\"Skillæœªæ‰¾åˆ°\"\"\"\n    pass\n\n"
},
{
"path": "daoyoucode/agents/llm/exceptions.py",
"start": 56,
"end": 58,
"text": "class SkillExecutionError(LLMError):\n    \"\"\"Skillæ‰§è¡Œé”™è¯¯\"\"\"\n    pass"
},
{
"path": "daoyoucode/agents/llm/__init__.py",
"start": 1,
"end": 45,
"text": "\"\"\"\nLLMæ¨¡å— - ç»Ÿä¸€çš„å¤§è¯­è¨€æ¨¡å‹è°ƒç”¨æ¥å£\n\"\"\"\n\nfrom .base import LLMRequest, LLMResponse, BaseLLMClient\nfrom .exceptions import (\n    LLMError,\n    LLMConnectionError,\n    LLMTimeoutError,\n    LLMRateLimitError,\n    LLMAuthenticationError,\n    LLMInvalidRequestError,\n    LLMModelNotFoundError,\n    SkillNotFoundError,\n    SkillExecutionError\n)\nfrom .client_manager import LLMClientManager, get_client_manager\nfrom .clients.unified import UnifiedLLMClient\n\n__all__ = [\n    # åŸºç¡€ç±»\n    'LLMRequest',\n    'LLMResponse',\n    'BaseLLMClient',\n    \n    # å¼‚å¸¸\n    'LLMError',\n    'LLMConnectionError',\n    'LLMTimeoutError',\n    'LLMRateLimitError',\n    'LLMAuthenticationError',\n    'LLMInvalidRequestError',\n    'LLMModelNotFoundError',\n    'SkillNotFoundError',\n    'SkillExecutionError',\n    \n    # å®¢æˆ·ç«¯ç®¡ç†\n    'LLMClientManager',\n    'get_client_manager',\n    \n    # å®¢æˆ·ç«¯\n    'UnifiedLLMClient',\n]\n\n__version__ = \"0.1.0\""
},
{
"path": "daoyoucode/agents/llm/clients/unified.py",
"start": 1,
"end": 16,
"text": "\"\"\"\nç»Ÿä¸€LLMå®¢æˆ·ç«¯ï¼ˆOpenAIå…¼å®¹ï¼‰\n\"\"\"\n\nimport httpx\nimport json\nimport time\nfrom typing import AsyncIterator, Optional\nimport logging\n\nfrom ..base import BaseLLMClient, LLMRequest, LLMResponse\nfrom ..exceptions import LLMConnectionError, LLMTimeoutError\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/llm/clients/unified.py",
"start": 17,
"end": 33,
"text": "class UnifiedLLMClient(BaseLLMClient):\n    \"\"\"ç»Ÿä¸€LLMå®¢æˆ·ç«¯ï¼ˆOpenAIå…¼å®¹æ ¼å¼ï¼‰\"\"\"\n    \n    # æ¨¡å‹å®šä»·ï¼ˆæ¯1000 tokensï¼Œå•ä½ï¼šå…ƒï¼‰\n    PRICING = {\n        # é€šä¹‰åƒé—®\n        \"qwen-max\": {\"input\": 0.02, \"output\": 0.06},\n        \"qwen-plus\": {\"input\": 0.004, \"output\": 0.012},\n        \"qwen-turbo\": {\"input\": 0.002, \"output\": 0.006},\n        \"qwen-coder-plus\": {\"input\": 0.004, \"output\": 0.012},\n        # DeepSeek\n        \"deepseek-chat\": {\"input\": 0.001, \"output\": 0.002},\n        \"deepseek-coder\": {\"input\": 0.001, \"output\": 0.002},\n        # é»˜è®¤ä»·æ ¼\n        \"default\": {\"input\": 0.01, \"output\": 0.03},\n    }\n    "
},
{
"path": "daoyoucode/agents/llm/clients/unified.py",
"start": 34,
"end": 213,
"text": "    def __init__(\n        self,\n        http_client: httpx.AsyncClient,\n        api_key: str,\n        base_url: str,\n        model: str\n    ):\n        \"\"\"\n        åˆå§‹åŒ–å®¢æˆ·ç«¯\n        \n        Args:\n            http_client: å…±äº«çš„HTTPå®¢æˆ·ç«¯ï¼ˆå¸¦è¿æ¥æ± ï¼‰\n            api_key: APIå¯†é’¥\n            base_url: APIç«¯ç‚¹\n            model: æ¨¡å‹åç§°\n        \"\"\"\n        self.http_client = http_client\n        self.api_key = api_key\n        self.base_url = base_url.rstrip('/')\n        self.model = model\n    \n    async def chat(self, request: LLMRequest) -> LLMResponse:\n        \"\"\"åŒæ­¥å¯¹è¯\"\"\"\n        start_time = time.time()\n        \n        # æ”¯æŒå¤šè½®å¯¹è¯ï¼šå¦‚æœrequestä¸­æœ‰messagesï¼Œä½¿ç”¨å®ƒï¼›å¦åˆ™æ„å»ºå•è½®æ¶ˆæ¯\n        if hasattr(request, 'messages') and request.messages:\n            messages = request.messages\n        else:\n            messages = [{\"role\": \"user\", \"content\": request.prompt}]\n        \n        try:\n            payload = {\n                \"model\": request.model,\n                \"messages\": messages,\n                \"temperature\": request.temperature,\n                \"max_tokens\": request.max_tokens,\n            }\n            \n            # æ·»åŠ Function Callingæ”¯æŒ\n            if hasattr(request, 'functions') and request.functions:\n                payload[\"functions\"] = request.functions\n                if hasattr(request, 'function_call'):\n                    payload[\"function_call\"] = request.function_call\n            \n            # è¯¦ç»†è¯·æ±‚æ—¥å¿—ï¼šé»˜è®¤ logger.debugï¼Œè®¾ç½® DEBUG_LLM=1 æ—¶ç”¨ info é¿å…ç”Ÿäº§åˆ·å±ï¼ˆè§ä¼˜åŒ–å»ºè®® 3.5ï¼‰\n            import os\n            _log = logger.info if os.getenv('DEBUG_LLM') == '1' else logger.debug\n            _log(\"=\" * 60)\n            _log(\"ğŸ” LLMè¯·æ±‚è°ƒè¯•ä¿¡æ¯\")\n            _log(f\"æ¨¡å‹: {request.model}\")\n            _log(f\"API Key: {self.api_key[:15]}...{self.api_key[-4:]}\")\n            _log(f\"æ¶ˆæ¯æ•°é‡: {len(messages)}\")\n            _log(f\"Functionsæ•°é‡: {len(payload.get('functions', []))}\")\n            for i, msg in enumerate(messages[:3]):\n                content = str(msg.get('content', ''))[:200]\n                _log(f\"æ¶ˆæ¯ {i+1} ({msg.get('role')}): {content}...\")\n            if len(messages) > 3:\n                _log(f\"... è¿˜æœ‰ {len(messages) - 3} æ¡æ¶ˆæ¯\")\n            if payload.get('functions'):\n                _log(\"Functions:\")\n                for i, func in enumerate(payload['functions'][:3]):\n                    _log(f\"  {i+1}. {func.get('name')}\")\n                if len(payload['functions']) > 3:\n                    _log(f\"  ... è¿˜æœ‰ {len(payload['functions']) - 3} ä¸ªå‡½æ•°\")\n            payload_size = len(json.dumps(payload, ensure_ascii=False))\n            _log(f\"Payloadå¤§å°: {payload_size} å­—èŠ‚ ({payload_size/1024:.2f} KB)\")\n            if os.getenv('DEBUG_LLM_REQUEST') == '1':\n                debug_file = f\"debug_llm_request_{int(time.time())}.json\"\n                with open(debug_file, 'w', encoding='utf-8') as f:\n                    json.dump(payload, f, ensure_ascii=False, indent=2)\n                _log(f\"ğŸ’¾ å®Œæ•´è¯·æ±‚å·²ä¿å­˜åˆ°: {debug_file}\")\n            _log(\"=\" * 60)\n            \n            response = await self.http_client.post(\n                f\"{self.base_url}/chat/completions\",\n                headers=self._get_headers(),\n                json=payload,\n                timeout=1800.0  # ğŸ†• 30 åˆ†é’Ÿï¼ˆæ”¯æŒå¤§è§„æ¨¡æ–‡ä»¶è¯»å†™å’Œå¤æ‚ä»»åŠ¡ï¼‰\n            )\n            response.raise_for_status()\n            data = response.json()\n            \n            latency = time.time() - start_time\n            \n            # æ£€æŸ¥æ˜¯å¦æœ‰function_call\n            message = data[\"choices\"][0][\"message\"]\n            function_call = message.get(\"function_call\")\n            \n            return LLMResponse(\n                content=message.get(\"content\", \"\"),\n                model=request.model,\n                tokens_used=data[\"usage\"][\"total_tokens\"],\n                cost=self._calculate_cost(data[\"usage\"], request.model),\n                latency=latency,\n                metadata={\n                    \"prompt_tokens\": data[\"usage\"][\"prompt_tokens\"],\n                    \"completion_tokens\": data[\"usage\"][\"completion_tokens\"],\n                    \"function_call\": "
},
{
"path": "daoyoucode/agents/llm/clients/unified.py",
"start": 214,
"end": 220,
"text": "    def _get_headers(self) -> dict:\n        \"\"\"è·å–è¯·æ±‚å¤´\"\"\"\n        return {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\",\n        }\n    "
},
{
"path": "daoyoucode/agents/llm/clients/unified.py",
"start": 221,
"end": 235,
"text": "    def _calculate_cost(self, usage: dict, model: str) -> float:\n        \"\"\"è®¡ç®—æˆæœ¬\"\"\"\n        input_tokens = usage.get(\"prompt_tokens\", 0)\n        output_tokens = usage.get(\"completion_tokens\", 0)\n        \n        # è·å–å®šä»·\n        pricing = self.PRICING.get(model, self.PRICING[\"default\"])\n        \n        # è®¡ç®—æˆæœ¬ï¼ˆå…ƒï¼‰\n        cost = (\n            input_tokens * pricing[\"input\"] +\n            output_tokens * pricing[\"output\"]\n        ) / 1000\n        \n        return cost"
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 1,
"end": 16,
"text": "\"\"\"\nç†”æ–­å™¨ï¼ˆCircuit Breakerï¼‰\né˜²æ­¢çº§è”æ•…éšœï¼Œè‡ªåŠ¨æ•…éšœæ¢å¤\n\"\"\"\n\nimport asyncio\nimport time\nfrom typing import Dict, Callable, Any, Optional\nfrom enum import Enum\nimport logging\n\nfrom ..exceptions import CircuitBreakerOpenError\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 17,
"end": 23,
"text": "class CircuitState(Enum):\n    \"\"\"ç†”æ–­å™¨çŠ¶æ€\"\"\"\n    CLOSED = \"closed\"        # å…³é—­ï¼ˆæ­£å¸¸ï¼‰\n    OPEN = \"open\"            # æ‰“å¼€ï¼ˆç†”æ–­ï¼‰\n    HALF_OPEN = \"half_open\"  # åŠå¼€ï¼ˆå°è¯•æ¢å¤ï¼‰\n\n"
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 24,
"end": 36,
"text": "class CircuitBreaker:\n    \"\"\"\n    ç†”æ–­å™¨\n    \n    å·¥ä½œåŸç†ï¼š\n    1. CLOSED: æ­£å¸¸çŠ¶æ€ï¼Œè¯·æ±‚æ­£å¸¸é€šè¿‡\n    2. å¤±è´¥æ¬¡æ•°è¾¾åˆ°é˜ˆå€¼ -> OPEN\n    3. OPEN: ç†”æ–­çŠ¶æ€ï¼Œç›´æ¥æ‹’ç»è¯·æ±‚\n    4. è¶…è¿‡æ¢å¤æ—¶é—´ -> HALF_OPEN\n    5. HALF_OPEN: å°è¯•æ¢å¤ï¼Œå…è®¸å°‘é‡è¯·æ±‚\n    6. æˆåŠŸ -> CLOSEDï¼Œå¤±è´¥ -> OPEN\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 37,
"end": 158,
"text": "    def __init__(\n        self,\n        failure_threshold: int = 5,      # å¤±è´¥é˜ˆå€¼\n        success_threshold: int = 2,      # æˆåŠŸé˜ˆå€¼ï¼ˆåŠå¼€çŠ¶æ€ï¼‰\n        timeout: int = 60,               # æ¢å¤è¶…æ—¶ï¼ˆç§’ï¼‰\n        half_open_max_calls: int = 3     # åŠå¼€çŠ¶æ€æœ€å¤§è°ƒç”¨æ•°\n    ):\n        \"\"\"\n        åˆå§‹åŒ–ç†”æ–­å™¨\n        \n        Args:\n            failure_threshold: å¤±è´¥é˜ˆå€¼ï¼ˆè¿ç»­å¤±è´¥å¤šå°‘æ¬¡åæ‰“å¼€ç†”æ–­å™¨ï¼‰\n            success_threshold: æˆåŠŸé˜ˆå€¼ï¼ˆåŠå¼€çŠ¶æ€æˆåŠŸå¤šå°‘æ¬¡åå…³é—­ç†”æ–­å™¨ï¼‰\n            timeout: æ¢å¤è¶…æ—¶ï¼ˆç†”æ–­åå¤šä¹…å°è¯•æ¢å¤ï¼‰\n            half_open_max_calls: åŠå¼€çŠ¶æ€æœ€å¤§è°ƒç”¨æ•°\n        \"\"\"\n        self.failure_threshold = failure_threshold\n        self.success_threshold = success_threshold\n        self.timeout = timeout\n        self.half_open_max_calls = half_open_max_calls\n        \n        # çŠ¶æ€\n        self.state = CircuitState.CLOSED\n        self.failure_count = 0\n        self.success_count = 0\n        self.last_failure_time: Optional[float] = None\n        self.half_open_calls = 0\n        \n        # ç»Ÿè®¡\n        self.stats = {\n            'total_calls': 0,\n            'successful_calls': 0,\n            'failed_calls': 0,\n            'rejected_calls': 0,\n            'state_changes': []\n        }\n        \n        self._lock = asyncio.Lock()\n    \n    async def call(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        é€šè¿‡ç†”æ–­å™¨è°ƒç”¨å‡½æ•°\n        \n        Args:\n            func: è¦è°ƒç”¨çš„å‡½æ•°\n            *args, **kwargs: å‡½æ•°å‚æ•°\n        \n        Returns:\n            å‡½æ•°è¿”å›å€¼\n        \n        Raises:\n            CircuitBreakerOpenError: ç†”æ–­å™¨æ‰“å¼€\n            Exception: å‡½æ•°æ‰§è¡Œå¼‚å¸¸\n        \"\"\"\n        async with self._lock:\n            self.stats['total_calls'] += 1\n            \n            # æ£€æŸ¥çŠ¶æ€\n            if self.state == CircuitState.OPEN:\n                # æ£€æŸ¥æ˜¯å¦å¯ä»¥å°è¯•æ¢å¤\n                if self._should_attempt_reset():\n                    self._transition_to_half_open()\n                else:\n                    self.stats['rejected_calls'] += 1\n                    raise CircuitBreakerOpenError(\n                        f\"ç†”æ–­å™¨æ‰“å¼€: å¤±è´¥{self.failure_count}æ¬¡ï¼Œ\"\n                        f\"å°†åœ¨{self._get_remaining_timeout():.1f}ç§’åå°è¯•æ¢å¤\"\n                    )\n            \n            # åŠå¼€çŠ¶æ€æ£€æŸ¥è°ƒç”¨æ¬¡æ•°\n            if self.state == CircuitState.HALF_OPEN:\n                if self.half_open_calls >= self.half_open_max_calls:\n                    self.stats['rejected_calls'] += 1\n                    raise CircuitBreakerOpenError(\n                        \"ç†”æ–­å™¨åŠå¼€çŠ¶æ€: å·²è¾¾åˆ°æœ€å¤§è°ƒç”¨æ¬¡æ•°\"\n                    )\n                self.half_open_calls += 1\n        \n        # æ‰§è¡Œå‡½æ•°\n        try:\n            result = await func(*args, **kwargs) if asyncio.iscoroutinefunction(func) else func(*args, **kwargs)\n            await self._on_success()\n            return result\n        \n        except Exception as e:\n            await self._on_failure(e)\n            raise\n    \n    async def _on_success(self):\n        \"\"\"å¤„ç†æˆåŠŸ\"\"\"\n        async with self._lock:\n            self.stats['successful_calls'] += 1\n            \n            if self.state == CircuitState.HALF_OPEN:\n                self.success_count += 1\n                \n                # è¾¾åˆ°æˆåŠŸé˜ˆå€¼ï¼Œå…³é—­ç†”æ–­å™¨\n                if self.success_count >= self.success_threshold:\n                    self._transition_to_closed()\n            \n            elif self.state == CircuitState.CLOSED:\n                # é‡ç½®å¤±è´¥è®¡æ•°\n                self.failure_count = 0\n    \n    async def _on_failure(self, error: Exception):\n        \"\"\"å¤„ç†å¤±è´¥\"\"\"\n        async with self._lock:\n            self.stats['failed_calls'] += 1\n            self.failure_count += 1\n            self.last_failure_time = time.time()\n            \n            logger.warning(f\"ç†”æ–­å™¨æ£€æµ‹åˆ°å¤±è´¥: {error}\")\n            \n            if self.state == CircuitState.HALF_OPEN:\n                # åŠå¼€çŠ¶æ€å¤±è´¥ï¼Œç«‹å³æ‰“å¼€ç†”æ–­å™¨\n                self._transition_to_open()\n            \n            elif self.state == CircuitState.CLOSED:\n                # è¾¾åˆ°å¤±è´¥é˜ˆå€¼ï¼Œæ‰“å¼€ç†”æ–­å™¨\n                if self.failure_count >= self.failure_threshold:\n                    self._transition_to_open()\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 159,
"end": 166,
"text": "    def _should_attempt_reset(self) -> bool:\n        \"\"\"æ˜¯å¦åº”è¯¥å°è¯•æ¢å¤\"\"\"\n        if self.last_failure_time is None:\n            return False\n        \n        elapsed = time.time() - self.last_failure_time\n        return elapsed >= self.timeout\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 167,
"end": 174,
"text": "    def _get_remaining_timeout(self) -> float:\n        \"\"\"è·å–å‰©ä½™æ¢å¤æ—¶é—´\"\"\"\n        if self.last_failure_time is None:\n            return 0\n        \n        elapsed = time.time() - self.last_failure_time\n        return max(0, self.timeout - elapsed)\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 175,
"end": 193,
"text": "    def _transition_to_open(self):\n        \"\"\"è½¬æ¢åˆ°æ‰“å¼€çŠ¶æ€\"\"\"\n        old_state = self.state\n        self.state = CircuitState.OPEN\n        self.success_count = 0\n        self.half_open_calls = 0\n        \n        self.stats['state_changes'].append({\n            'from': old_state.value,\n            'to': CircuitState.OPEN.value,\n            'time': time.time(),\n            'failure_count': self.failure_count\n        })\n        \n        logger.error(\n            f\"ç†”æ–­å™¨æ‰“å¼€: å¤±è´¥{self.failure_count}æ¬¡ï¼Œ\"\n            f\"å°†åœ¨{self.timeout}ç§’åå°è¯•æ¢å¤\"\n        )\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 194,
"end": 208,
"text": "    def _transition_to_half_open(self):\n        \"\"\"è½¬æ¢åˆ°åŠå¼€çŠ¶æ€\"\"\"\n        old_state = self.state\n        self.state = CircuitState.HALF_OPEN\n        self.success_count = 0\n        self.half_open_calls = 0\n        \n        self.stats['state_changes'].append({\n            'from': old_state.value,\n            'to': CircuitState.HALF_OPEN.value,\n            'time': time.time()\n        })\n        \n        logger.info(\"ç†”æ–­å™¨è¿›å…¥åŠå¼€çŠ¶æ€ï¼Œå°è¯•æ¢å¤\")\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 209,
"end": 224,
"text": "    def _transition_to_closed(self):\n        \"\"\"è½¬æ¢åˆ°å…³é—­çŠ¶æ€\"\"\"\n        old_state = self.state\n        self.state = CircuitState.CLOSED\n        self.failure_count = 0\n        self.success_count = 0\n        self.half_open_calls = 0\n        \n        self.stats['state_changes'].append({\n            'from': old_state.value,\n            'to': CircuitState.CLOSED.value,\n            'time': time.time()\n        })\n        \n        logger.info(\"ç†”æ–­å™¨å…³é—­ï¼Œæ¢å¤æ­£å¸¸\")\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 225,
"end": 228,
"text": "    def get_state(self) -> CircuitState:\n        \"\"\"è·å–å½“å‰çŠ¶æ€\"\"\"\n        return self.state\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 229,
"end": 238,
"text": "    def get_stats(self) -> Dict:\n        \"\"\"è·å–ç»Ÿè®¡ä¿¡æ¯\"\"\"\n        return {\n            **self.stats,\n            'current_state': self.state.value,\n            'failure_count': self.failure_count,\n            'success_count': self.success_count,\n            'remaining_timeout': self._get_remaining_timeout() if self.state == CircuitState.OPEN else 0\n        }\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 239,
"end": 247,
"text": "    def reset(self):\n        \"\"\"æ‰‹åŠ¨é‡ç½®ç†”æ–­å™¨\"\"\"\n        self.state = CircuitState.CLOSED\n        self.failure_count = 0\n        self.success_count = 0\n        self.half_open_calls = 0\n        logger.info(\"ç†”æ–­å™¨å·²æ‰‹åŠ¨é‡ç½®\")\n\n"
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 248,
"end": 250,
"text": "class CircuitBreakerManager:\n    \"\"\"ç†”æ–­å™¨ç®¡ç†å™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 251,
"end": 264,
"text": "    def __init__(self):\n        # æŒ‰æ¨¡å‹ç®¡ç†ç†”æ–­å™¨\n        self.breakers: Dict[str, CircuitBreaker] = {}\n        \n        # é»˜è®¤é…ç½®\n        self.default_config = {\n            'failure_threshold': 5,\n            'success_threshold': 2,\n            'timeout': 60,\n            'half_open_max_calls': 3\n        }\n        \n        logger.info(\"ç†”æ–­å™¨ç®¡ç†å™¨å·²åˆå§‹åŒ–\")\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 265,
"end": 272,
"text": "    def get_breaker(self, model: str) -> CircuitBreaker:\n        \"\"\"è·å–æ¨¡å‹çš„ç†”æ–­å™¨\"\"\"\n        if model not in self.breakers:\n            self.breakers[model] = CircuitBreaker(**self.default_config)\n            logger.info(f\"ä¸ºæ¨¡å‹ {model} åˆ›å»ºç†”æ–­å™¨\")\n        \n        return self.breakers[model]\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 273,
"end": 294,
"text": "    def configure(\n        self,\n        model: str,\n        failure_threshold: int = 5,\n        success_threshold: int = 2,\n        timeout: int = 60,\n        half_open_max_calls: int = 3\n    ):\n        \"\"\"é…ç½®æ¨¡å‹çš„ç†”æ–­å™¨\"\"\"\n        self.breakers[model] = CircuitBreaker(\n            failure_threshold=failure_threshold,\n            success_threshold=success_threshold,\n            timeout=timeout,\n            half_open_max_calls=half_open_max_calls\n        )\n        logger.info(f\"æ¨¡å‹ {model} ç†”æ–­å™¨é…ç½®å®Œæˆ\")\n    \n    async def call(self, model: str, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"é€šè¿‡ç†”æ–­å™¨è°ƒç”¨å‡½æ•°\"\"\"\n        breaker = self.get_breaker(model)\n        return await breaker.call(func, *args, **kwargs)\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 295,
"end": 305,
"text": "    def get_stats(self, model: Optional[str] = None) -> Dict:\n        \"\"\"è·å–ç»Ÿè®¡ä¿¡æ¯\"\"\"\n        if model:\n            breaker = self.breakers.get(model)\n            return breaker.get_stats() if breaker else {}\n        \n        return {\n            model: breaker.get_stats()\n            for model, breaker in self.breakers.items()\n        }\n    "
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 306,
"end": 315,
"text": "    def reset(self, model: Optional[str] = None):\n        \"\"\"é‡ç½®ç†”æ–­å™¨\"\"\"\n        if model:\n            if model in self.breakers:\n                self.breakers[model].reset()\n        else:\n            for breaker in self.breakers.values():\n                breaker.reset()\n\n"
},
{
"path": "daoyoucode/agents/llm/utils/circuit_breaker.py",
"start": 316,
"end": 320,
"text": "def get_circuit_breaker_manager() -> CircuitBreakerManager:\n    \"\"\"è·å–ç†”æ–­å™¨ç®¡ç†å™¨å•ä¾‹\"\"\"\n    if not hasattr(get_circuit_breaker_manager, '_instance'):\n        get_circuit_breaker_manager._instance = CircuitBreakerManager()\n    return get_circuit_breaker_manager._instance"
},
{
"path": "daoyoucode/agents/llm/utils/fallback.py",
"start": 1,
"end": 13,
"text": "\"\"\"\né™çº§ç­–ç•¥ï¼ˆFallback Strategyï¼‰\nå½“ä¸»æ¨¡å‹å¤±è´¥æ—¶ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°å¤‡ç”¨æ¨¡å‹\n\"\"\"\n\nimport logging\nfrom typing import Dict, List, Callable, Any, Optional\n\nfrom ..exceptions import FallbackExhaustedError, CircuitBreakerOpenError\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/llm/utils/fallback.py",
"start": 14,
"end": 20,
"text": "class FallbackStrategy:\n    \"\"\"\n    é™çº§ç­–ç•¥\n    \n    å®šä¹‰æ¨¡å‹é™çº§é“¾ï¼Œå½“ä¸»æ¨¡å‹å¤±è´¥æ—¶è‡ªåŠ¨åˆ‡æ¢åˆ°å¤‡ç”¨æ¨¡å‹\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/llm/utils/fallback.py",
"start": 21,
"end": 49,
"text": "    def __init__(self):\n        # æ¨¡å‹é™çº§é“¾é…ç½®\n        self.fallback_chains: Dict[str, List[str]] = {\n            # é«˜ç«¯æ¨¡å‹é™çº§é“¾\n            'gpt-5.2': ['gpt-4o', 'claude-opus-4-5', 'qwen-max'],\n            'claude-opus-4-5': ['claude-sonnet-4-5', 'qwen-max'],\n            'gemini-3-pro': ['gemini-3-flash', 'qwen-plus'],\n            \n            # ä¸­ç«¯æ¨¡å‹é™çº§é“¾\n            'qwen-max': ['qwen-plus', 'qwen-turbo'],\n            'qwen-plus': ['qwen-turbo', 'deepseek-chat'],\n            'deepseek-chat': ['qwen-turbo'],\n            \n            # ä»£ç ä¸“ç”¨æ¨¡å‹é™çº§é“¾\n            'qwen-coder-plus': ['deepseek-coder', 'qwen-plus'],\n            'deepseek-coder': ['qwen-coder-plus', 'qwen-plus'],\n        }\n        \n        # ç»Ÿè®¡ä¿¡æ¯\n        self.stats = {\n            'total_attempts': 0,\n            'fallback_used': 0,\n            'fallback_success': 0,\n            'fallback_failed': 0,\n            'by_model': {}\n        }\n        \n        logger.info(\"é™çº§ç­–ç•¥å·²åˆå§‹åŒ–\")\n    "
},
{
"path": "daoyoucode/agents/llm/utils/fallback.py",
"start": 50,
"end": 60,
"text": "    def configure_fallback_chain(self, model: str, fallback_models: List[str]):\n        \"\"\"\n        é…ç½®æ¨¡å‹çš„é™çº§é“¾\n        \n        Args:\n            model: ä¸»æ¨¡å‹\n            fallback_models: é™çº§æ¨¡å‹åˆ—è¡¨ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰\n        \"\"\"\n        self.fallback_chains[model] = fallback_models\n        logger.info(f\"æ¨¡å‹ {model} é™çº§é“¾: {' -> '.join(fallback_models)}\")\n    "
},
{
"path": "daoyoucode/agents/llm/utils/fallback.py",
"start": 61,
"end": 163,
"text": "    def get_fallback_chain(self, model: str) -> List[str]:\n        \"\"\"\n        è·å–æ¨¡å‹çš„é™çº§é“¾\n        \n        Args:\n            model: æ¨¡å‹åç§°\n        \n        Returns:\n            é™çº§é“¾ï¼ˆåŒ…å«ä¸»æ¨¡å‹ï¼‰\n        \"\"\"\n        chain = [model]\n        if model in self.fallback_chains:\n            chain.extend(self.fallback_chains[model])\n        return chain\n    \n    async def execute_with_fallback(\n        self,\n        model: str,\n        func: Callable,\n        *args,\n        **kwargs\n    ) -> tuple[Any, str]:\n        \"\"\"\n        æ‰§è¡Œå‡½æ•°ï¼Œå¤±è´¥æ—¶è‡ªåŠ¨é™çº§\n        \n        Args:\n            model: ä¸»æ¨¡å‹\n            func: è¦æ‰§è¡Œçš„å‡½æ•°\n            *args, **kwargs: å‡½æ•°å‚æ•°\n        \n        Returns:\n            (ç»“æœ, å®é™…ä½¿ç”¨çš„æ¨¡å‹)\n        \n        Raises:\n            FallbackExhaustedError: æ‰€æœ‰é™çº§æ¨¡å‹éƒ½å¤±è´¥\n        \"\"\"\n        self.stats['total_attempts'] += 1\n        \n        # è·å–é™çº§é“¾\n        fallback_chain = self.get_fallback_chain(model)\n        \n        last_error = None\n        used_fallback = False\n        \n        for idx, fallback_model in enumerate(fallback_chain):\n            try:\n                if idx > 0:\n                    used_fallback = True\n                    self.stats['fallback_used'] += 1\n                    logger.warning(\n                        f\"é™çº§: {model} -> {fallback_model} \"\n                        f\"(ç¬¬{idx}æ¬¡é™çº§)\"\n                    )\n                \n                # æ‰§è¡Œå‡½æ•°ï¼ˆä¼ å…¥å½“å‰æ¨¡å‹ï¼‰\n                result = await func(fallback_model, *args, **kwargs)\n                \n                # æˆåŠŸ\n                if used_fallback:\n                    self.stats['fallback_success'] += 1\n                    logger.info(f\"é™çº§æˆåŠŸ: ä½¿ç”¨ {fallback_model}\")\n                \n                # æ›´æ–°ç»Ÿè®¡\n                if model not in self.stats['by_model']:\n                    self.stats['by_model'][model] = {\n                        'attempts': 0,\n                        'fallback_used': 0,\n                        'fallback_success': 0\n                    }\n                \n                self.stats['by_model'][model]['attempts'] += 1\n                if used_fallback:\n                    self.stats['by_model'][model]['fallback_used'] += 1\n                    self.stats['by_model'][model]['fallback_success'] += 1\n                \n                return result, fallback_model\n            \n            except CircuitBreakerOpenError as e:\n                # ç†”æ–­å™¨æ‰“å¼€ï¼Œç›´æ¥è·³è¿‡\n                last_error = e\n                logger.warning(f\"æ¨¡å‹ {fallback_model} ç†”æ–­å™¨æ‰“å¼€ï¼Œè·³è¿‡\")\n                continue\n            \n            except Exception as e:\n                # å…¶ä»–é”™è¯¯ï¼Œè®°å½•å¹¶ç»§ç»­\n                last_error = e\n                logger.error(\n                    f\"æ¨¡å‹ {fallback_model} æ‰§è¡Œå¤±è´¥: {e}\",\n                    exc_info=True\n                )\n                continue\n        \n        # æ‰€æœ‰é™çº§éƒ½å¤±è´¥\n        self.stats['fallback_failed'] += 1\n        \n        if model in self.stats['by_model']:\n            self.stats['by_model'][model]['fallback_used'] += 1\n        \n        raise FallbackExhaustedError(\n            f\"æ‰€æœ‰é™çº§æ¨¡å‹éƒ½å¤±è´¥: {' -> '.join(fallback_chain)}\\n\"\n            f\"æœ€åé”™è¯¯: {last_error}\"\n        )\n    "
},
{
"path": "daoyoucode/agents/llm/utils/fallback.py",
"start": 164,
"end": 182,
"text": "    def get_stats(self, model: Optional[str] = None) -> Dict:\n        \"\"\"è·å–ç»Ÿè®¡ä¿¡æ¯\"\"\"\n        if model:\n            return self.stats['by_model'].get(model, {})\n        \n        return {\n            'summary': {\n                'total_attempts': self.stats['total_attempts'],\n                'fallback_used': self.stats['fallback_used'],\n                'fallback_success': self.stats['fallback_success'],\n                'fallback_failed': self.stats['fallback_failed'],\n                'fallback_success_rate': (\n                    self.stats['fallback_success'] / self.stats['fallback_used']\n                    if self.stats['fallback_used'] > 0 else 0\n                )\n            },\n            'by_model': self.stats['by_model']\n        }\n    "
},
{
"path": "daoyoucode/agents/llm/utils/fallback.py",
"start": 183,
"end": 194,
"text": "    def get_fallback_info(self, model: str) -> Dict:\n        \"\"\"è·å–æ¨¡å‹çš„é™çº§ä¿¡æ¯\"\"\"\n        chain = self.get_fallback_chain(model)\n        \n        return {\n            'model': model,\n            'has_fallback': len(chain) > 1,\n            'fallback_chain': chain,\n            'fallback_count': len(chain) - 1\n        }\n\n"
},
{
"path": "daoyoucode/agents/llm/utils/fallback.py",
"start": 195,
"end": 199,
"text": "def get_fallback_strategy() -> FallbackStrategy:\n    \"\"\"è·å–é™çº§ç­–ç•¥å•ä¾‹\"\"\"\n    if not hasattr(get_fallback_strategy, '_instance'):\n        get_fallback_strategy._instance = FallbackStrategy()\n    return get_fallback_strategy._instance"
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 1,
"end": 16,
"text": "\"\"\"\né™æµå™¨ï¼ˆRate Limiterï¼‰\né˜²æ­¢è¯·æ±‚è¿‡è½½ï¼Œä¿æŠ¤LLMæœåŠ¡\n\"\"\"\n\nimport asyncio\nimport time\nfrom typing import Dict, Optional\nfrom collections import deque\nimport logging\n\nfrom ..exceptions import LLMRateLimitError\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 17,
"end": 19,
"text": "class TokenBucket:\n    \"\"\"ä»¤ç‰Œæ¡¶ç®—æ³•å®ç°\"\"\"\n    "
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 20,
"end": 70,
"text": "    def __init__(self, capacity: int, refill_rate: float):\n        \"\"\"\n        åˆå§‹åŒ–ä»¤ç‰Œæ¡¶\n        \n        Args:\n            capacity: æ¡¶å®¹é‡ï¼ˆæœ€å¤§ä»¤ç‰Œæ•°ï¼‰\n            refill_rate: å¡«å……é€Ÿç‡ï¼ˆä»¤ç‰Œ/ç§’ï¼‰\n        \"\"\"\n        self.capacity = capacity\n        self.refill_rate = refill_rate\n        self.tokens = capacity\n        self.last_refill = time.time()\n        self._lock = asyncio.Lock()\n    \n    async def acquire(self, tokens: int = 1, timeout: Optional[float] = None) -> bool:\n        \"\"\"\n        è·å–ä»¤ç‰Œ\n        \n        Args:\n            tokens: éœ€è¦çš„ä»¤ç‰Œæ•°\n            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼ŒNoneè¡¨ç¤ºæ— é™ç­‰å¾…\n        \n        Returns:\n            æ˜¯å¦æˆåŠŸè·å–ä»¤ç‰Œ\n        \n        Raises:\n            LLMRateLimitError: è¶…æ—¶æœªè·å–åˆ°ä»¤ç‰Œ\n        \"\"\"\n        start_time = time.time()\n        \n        while True:\n            async with self._lock:\n                # å¡«å……ä»¤ç‰Œ\n                self._refill()\n                \n                # æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„ä»¤ç‰Œ\n                if self.tokens >= tokens:\n                    self.tokens -= tokens\n                    return True\n            \n            # æ£€æŸ¥è¶…æ—¶\n            if timeout is not None:\n                elapsed = time.time() - start_time\n                if elapsed >= timeout:\n                    raise LLMRateLimitError(\n                        f\"è·å–ä»¤ç‰Œè¶…æ—¶: éœ€è¦{tokens}ä¸ªä»¤ç‰Œï¼Œå½“å‰{self.tokens:.2f}ä¸ª\"\n                    )\n            \n            # ç­‰å¾…ä¸€å°æ®µæ—¶é—´å†é‡è¯•\n            await asyncio.sleep(0.1)\n    "
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 71,
"end": 82,
"text": "    def _refill(self):\n        \"\"\"å¡«å……ä»¤ç‰Œ\"\"\"\n        now = time.time()\n        elapsed = now - self.last_refill\n        \n        # è®¡ç®—åº”è¯¥å¡«å……çš„ä»¤ç‰Œæ•°\n        tokens_to_add = elapsed * self.refill_rate\n        \n        if tokens_to_add > 0:\n            self.tokens = min(self.capacity, self.tokens + tokens_to_add)\n            self.last_refill = now\n    "
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 83,
"end": 87,
"text": "    def get_available_tokens(self) -> float:\n        \"\"\"è·å–å½“å‰å¯ç”¨ä»¤ç‰Œæ•°\"\"\"\n        return self.tokens\n\n"
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 88,
"end": 90,
"text": "class SlidingWindowCounter:\n    \"\"\"æ»‘åŠ¨çª—å£è®¡æ•°å™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 91,
"end": 140,
"text": "    def __init__(self, window_size: int, max_requests: int):\n        \"\"\"\n        åˆå§‹åŒ–æ»‘åŠ¨çª—å£\n        \n        Args:\n            window_size: çª—å£å¤§å°ï¼ˆç§’ï¼‰\n            max_requests: çª—å£å†…æœ€å¤§è¯·æ±‚æ•°\n        \"\"\"\n        self.window_size = window_size\n        self.max_requests = max_requests\n        self.requests = deque()\n        self._lock = asyncio.Lock()\n    \n    async def acquire(self, timeout: Optional[float] = None) -> bool:\n        \"\"\"\n        å°è¯•è·å–è®¸å¯\n        \n        Args:\n            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰\n        \n        Returns:\n            æ˜¯å¦æˆåŠŸè·å–è®¸å¯\n        \n        Raises:\n            LLMRateLimitError: è¶…æ—¶æœªè·å–åˆ°è®¸å¯\n        \"\"\"\n        start_time = time.time()\n        \n        while True:\n            async with self._lock:\n                # æ¸…ç†è¿‡æœŸè¯·æ±‚\n                self._cleanup()\n                \n                # æ£€æŸ¥æ˜¯å¦å¯ä»¥é€šè¿‡\n                if len(self.requests) < self.max_requests:\n                    self.requests.append(time.time())\n                    return True\n            \n            # æ£€æŸ¥è¶…æ—¶\n            if timeout is not None:\n                elapsed = time.time() - start_time\n                if elapsed >= timeout:\n                    raise LLMRateLimitError(\n                        f\"é™æµè¶…æ—¶: çª—å£å†…å·²æœ‰{len(self.requests)}ä¸ªè¯·æ±‚ï¼Œ\"\n                        f\"æœ€å¤§{self.max_requests}ä¸ª\"\n                    )\n            \n            # ç­‰å¾…ä¸€å°æ®µæ—¶é—´å†é‡è¯•\n            await asyncio.sleep(0.1)\n    "
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 141,
"end": 148,
"text": "    def _cleanup(self):\n        \"\"\"æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•\"\"\"\n        now = time.time()\n        cutoff = now - self.window_size\n        \n        while self.requests and self.requests[0] < cutoff:\n            self.requests.popleft()\n    "
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 149,
"end": 153,
"text": "    def get_current_count(self) -> int:\n        \"\"\"è·å–å½“å‰çª—å£å†…çš„è¯·æ±‚æ•°\"\"\"\n        return len(self.requests)\n\n"
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 154,
"end": 163,
"text": "class RateLimiter:\n    \"\"\"\n    é™æµå™¨\n    \n    æ”¯æŒå¤šç§é™æµç­–ç•¥ï¼š\n    1. æŒ‰ç”¨æˆ·é™æµ\n    2. æŒ‰æ¨¡å‹é™æµ\n    3. å…¨å±€é™æµ\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 164,
"end": 186,
"text": "    def __init__(self):\n        # ç”¨æˆ·é™æµå™¨ï¼ˆæ¯ä¸ªç”¨æˆ·ç‹¬ç«‹çš„ä»¤ç‰Œæ¡¶ï¼‰\n        self.user_limiters: Dict[int, TokenBucket] = {}\n        \n        # æ¨¡å‹é™æµå™¨ï¼ˆæ¯ä¸ªæ¨¡å‹ç‹¬ç«‹çš„æ»‘åŠ¨çª—å£ï¼‰\n        self.model_limiters: Dict[str, SlidingWindowCounter] = {}\n        \n        # å…¨å±€é™æµå™¨\n        self.global_limiter: Optional[TokenBucket] = None\n        \n        # é»˜è®¤é…ç½®\n        self.default_user_config = {\n            'capacity': 10,      # 10ä¸ªä»¤ç‰Œ\n            'refill_rate': 1.0   # æ¯ç§’1ä¸ªä»¤ç‰Œ\n        }\n        \n        self.default_model_config = {\n            'window_size': 60,    # 60ç§’çª—å£\n            'max_requests': 100   # æœ€å¤š100ä¸ªè¯·æ±‚\n        }\n        \n        logger.info(\"é™æµå™¨å·²åˆå§‹åŒ–\")\n    "
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 187,
"end": 194,
"text": "    def configure_user_limit(self, capacity: int, refill_rate: float):\n        \"\"\"é…ç½®ç”¨æˆ·é™æµ\"\"\"\n        self.default_user_config = {\n            'capacity': capacity,\n            'refill_rate': refill_rate\n        }\n        logger.info(f\"ç”¨æˆ·é™æµé…ç½®: å®¹é‡={capacity}, é€Ÿç‡={refill_rate}/s\")\n    "
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 195,
"end": 202,
"text": "    def configure_model_limit(self, model: str, window_size: int, max_requests: int):\n        \"\"\"é…ç½®æ¨¡å‹é™æµ\"\"\"\n        self.model_limiters[model] = SlidingWindowCounter(\n            window_size=window_size,\n            max_requests=max_requests\n        )\n        logger.info(f\"æ¨¡å‹ {model} é™æµé…ç½®: {max_requests}æ¬¡/{window_size}ç§’\")\n    "
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 203,
"end": 245,
"text": "    def configure_global_limit(self, capacity: int, refill_rate: float):\n        \"\"\"é…ç½®å…¨å±€é™æµ\"\"\"\n        self.global_limiter = TokenBucket(\n            capacity=capacity,\n            refill_rate=refill_rate\n        )\n        logger.info(f\"å…¨å±€é™æµé…ç½®: å®¹é‡={capacity}, é€Ÿç‡={refill_rate}/s\")\n    \n    async def acquire(\n        self,\n        user_id: Optional[int] = None,\n        model: Optional[str] = None,\n        timeout: float = 30.0\n    ):\n        \"\"\"\n        è·å–è®¸å¯ï¼ˆé€šè¿‡æ‰€æœ‰é™æµæ£€æŸ¥ï¼‰\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n            model: æ¨¡å‹åç§°\n            timeout: è¶…æ—¶æ—¶é—´\n        \n        Raises:\n            LLMRateLimitError: é™æµå¤±è´¥\n        \"\"\"\n        # 1. å…¨å±€é™æµ\n        if self.global_limiter:\n            await self.global_limiter.acquire(tokens=1, timeout=timeout)\n        \n        # 2. ç”¨æˆ·é™æµ\n        if user_id is not None:\n            if user_id not in self.user_limiters:\n                self.user_limiters[user_id] = TokenBucket(\n                    capacity=self.default_user_config['capacity'],\n                    refill_rate=self.default_user_config['refill_rate']\n                )\n            \n            await self.user_limiters[user_id].acquire(tokens=1, timeout=timeout)\n        \n        # 3. æ¨¡å‹é™æµ\n        if model is not None and model in self.model_limiters:\n            await self.model_limiters[model].acquire(timeout=timeout)\n    "
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 246,
"end": 278,
"text": "    def get_stats(self) -> Dict:\n        \"\"\"è·å–é™æµç»Ÿè®¡\"\"\"\n        stats = {\n            'user_count': len(self.user_limiters),\n            'model_count': len(self.model_limiters),\n            'users': {},\n            'models': {}\n        }\n        \n        # ç”¨æˆ·ç»Ÿè®¡\n        for user_id, limiter in self.user_limiters.items():\n            stats['users'][user_id] = {\n                'available_tokens': limiter.get_available_tokens(),\n                'capacity': limiter.capacity\n            }\n        \n        # æ¨¡å‹ç»Ÿè®¡\n        for model, limiter in self.model_limiters.items():\n            stats['models'][model] = {\n                'current_count': limiter.get_current_count(),\n                'max_requests': limiter.max_requests\n            }\n        \n        # å…¨å±€ç»Ÿè®¡\n        if self.global_limiter:\n            stats['global'] = {\n                'available_tokens': self.global_limiter.get_available_tokens(),\n                'capacity': self.global_limiter.capacity\n            }\n        \n        return stats\n\n"
},
{
"path": "daoyoucode/agents/llm/utils/rate_limiter.py",
"start": 279,
"end": 283,
"text": "def get_rate_limiter() -> RateLimiter:\n    \"\"\"è·å–é™æµå™¨å•ä¾‹\"\"\"\n    if not hasattr(get_rate_limiter, '_instance'):\n        get_rate_limiter._instance = RateLimiter()\n    return get_rate_limiter._instance"
},
{
"path": "daoyoucode/agents/llm/utils/__init__.py",
"start": 1,
"end": 23,
"text": "\"\"\"\nLLMå·¥å…·æ¨¡å—\n\"\"\"\n\nfrom .rate_limiter import RateLimiter, get_rate_limiter\nfrom .circuit_breaker import (\n    CircuitBreaker,\n    CircuitBreakerManager,\n    CircuitState,\n    get_circuit_breaker_manager\n)\nfrom .fallback import FallbackStrategy, get_fallback_strategy\n\n__all__ = [\n    'RateLimiter',\n    'get_rate_limiter',\n    'CircuitBreaker',\n    'CircuitBreakerManager',\n    'CircuitState',\n    'get_circuit_breaker_manager',\n    'FallbackStrategy',\n    'get_fallback_strategy',\n]"
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 1,
"end": 21,
"text": "\"\"\"\nBM25ç®—æ³• - ç”¨äºè¯é¢˜ç›¸ä¼¼åº¦è®¡ç®—\n\næ ¸å¿ƒä¼˜åŒ–ï¼š\n1. æ—¶é—´è¡°å‡æƒé‡ï¼ˆè¶Šè¿‘çš„æ¶ˆæ¯æƒé‡è¶Šé«˜ï¼‰\n2. åŠ¨æ€é˜ˆå€¼ï¼ˆæ ¹æ®å†å²é•¿åº¦è°ƒæ•´ï¼‰\n3. å¤šç²’åº¦åŒ¹é…ï¼ˆè¯çº§ + bigramï¼‰\n\nä¾èµ–ï¼š\n- rank-bm25ï¼ˆå¯é€‰ï¼Œå¦‚æœå®‰è£…åˆ™ä½¿ç”¨ï¼Œå¦åˆ™é™çº§åˆ°ç®€å•å®ç°ï¼‰\n- jiebaï¼ˆå¯é€‰ï¼Œå¦‚æœå®‰è£…åˆ™ä½¿ç”¨ï¼Œå¦åˆ™é™çº§åˆ°ç®€å•åˆ†è¯ï¼‰\n\"\"\"\n\nfrom typing import List, Dict, Tuple, Optional, Set\nfrom datetime import datetime\nimport math\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 22,
"end": 32,
"text": "class BM25Matcher:\n    \"\"\"\n    BM25åŒ¹é…å™¨\n    \n    ç”¨äºè®¡ç®—æ–‡æœ¬ç›¸ä¼¼åº¦ï¼Œæ”¯æŒï¼š\n    1. æ—¶é—´è¡°å‡ï¼šè¶Šè¿‘çš„æ¶ˆæ¯æƒé‡è¶Šé«˜\n    2. åŠ¨æ€é˜ˆå€¼ï¼šæ ¹æ®å†å²é•¿åº¦è‡ªé€‚åº”è°ƒæ•´\n    3. å¤šç²’åº¦ï¼šè¯çº§ + bigramåŒ¹é…\n    4. é™çº§ç­–ç•¥ï¼šrank-bm25ä¸å¯ç”¨æ—¶ä½¿ç”¨ç®€å•å®ç°\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 33,
"end": 69,
"text": "    def __init__(\n        self,\n        base_threshold: float = 0.35,  # æé«˜åŸºç¡€é˜ˆå€¼ï¼Œä½¿è¯é¢˜åˆ‡æ¢æ›´æ•æ„Ÿ\n        time_decay_halflife: float = 120.0,  # 2åˆ†é’ŸåŠè¡°æœŸ\n        use_rank_bm25: bool = True  # æ˜¯å¦å°è¯•ä½¿ç”¨rank-bm25åº“\n    ):\n        self.base_threshold = base_threshold\n        self.time_decay_halflife = time_decay_halflife\n        self.stopwords = self._load_stopwords()\n        \n        # å°è¯•å¯¼å…¥rank-bm25\n        self.rank_bm25_available = False\n        if use_rank_bm25:\n            try:\n                from rank_bm25 import BM25Okapi\n                self.BM25Okapi = BM25Okapi\n                self.rank_bm25_available = True\n                logger.info(\"BM25Matcher: ä½¿ç”¨rank-bm25åº“ï¼ˆæ›´å‡†ç¡®ï¼‰\")\n            except ImportError:\n                logger.info(\"BM25Matcher: rank-bm25æœªå®‰è£…ï¼Œä½¿ç”¨ç®€åŒ–å®ç°\")\n        \n        # å°è¯•å¯¼å…¥jieba\n        self.jieba_available = False\n        try:\n            import jieba\n            import jieba.posseg as pseg\n            \n            # é™é»˜åŠ è½½jiebaï¼ˆé¿å…è¾“å‡ºæ—¥å¿—ï¼‰\n            jieba.setLogLevel(20)  # è®¾ç½®ä¸ºINFOçº§åˆ«ï¼Œé¿å…DEBUGè¾“å‡º\n            \n            self.jieba = jieba\n            self.pseg = pseg\n            self.jieba_available = True\n            logger.info(\"BM25Matcher: ä½¿ç”¨jiebaåˆ†è¯ï¼ˆæ›´å‡†ç¡®ï¼‰\")\n        except ImportError:\n            logger.info(\"BM25Matcher: jiebaæœªå®‰è£…ï¼Œä½¿ç”¨ç®€å•åˆ†è¯\")\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 70,
"end": 131,
"text": "    def calculate_similarity(\n        self,\n        current_text: str,\n        history_texts: List[str],\n        history_timestamps: Optional[List[datetime]] = None,\n        current_time: Optional[datetime] = None\n    ) -> Tuple[float, float]:\n        \"\"\"\n        è®¡ç®—å½“å‰æ–‡æœ¬ä¸å†å²æ–‡æœ¬çš„ç›¸ä¼¼åº¦\n        \n        Args:\n            current_text: å½“å‰æ–‡æœ¬\n            history_texts: å†å²æ–‡æœ¬åˆ—è¡¨\n            history_timestamps: å†å²æ–‡æœ¬çš„æ—¶é—´æˆ³ï¼ˆå¯é€‰ï¼‰\n            current_time: å½“å‰æ—¶é—´ï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            (å¹³å‡åŠ æƒç›¸ä¼¼åº¦, æœ€å¤§ç›¸ä¼¼åº¦)\n        \"\"\"\n        if not history_texts:\n            return 0.0, 0.0\n        \n        if current_time is None:\n            current_time = datetime.now()\n        \n        # åˆ†è¯\n        current_tokens = self._tokenize(current_text)\n        \n        if not current_tokens:\n            return 0.0, 0.0\n        \n        # æå–å…³é”®å®ä½“ï¼ˆå¦‚\"çŒ«\"ã€\"ç‹—\"ç­‰æ ¸å¿ƒåè¯ï¼‰\n        current_entities = self._extract_key_entities(current_text)\n        \n        # å¦‚æœä½¿ç”¨rank-bm25\n        if self.rank_bm25_available:\n            avg_sim, max_sim = self._calculate_with_rank_bm25(\n                current_tokens,\n                history_texts,\n                history_timestamps,\n                current_time\n            )\n            \n            # åº”ç”¨å®ä½“æƒ©ç½šï¼šå¦‚æœå…³é”®å®ä½“å®Œå…¨ä¸åŒï¼Œé™ä½ç›¸ä¼¼åº¦\n            if current_entities:\n                entity_penalty = self._calculate_entity_penalty(\n                    current_entities,\n                    history_texts\n                )\n                avg_sim *= entity_penalty\n                max_sim *= entity_penalty\n            \n            return avg_sim, max_sim\n        else:\n            # é™çº§åˆ°ç®€å•å®ç°\n            return self._calculate_simple(\n                current_tokens,\n                history_texts,\n                history_timestamps,\n                current_time\n            )\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 132,
"end": 195,
"text": "    def _calculate_with_rank_bm25(\n        self,\n        current_tokens: List[str],\n        history_texts: List[str],\n        history_timestamps: Optional[List[datetime]],\n        current_time: datetime\n    ) -> Tuple[float, float]:\n        \"\"\"ä½¿ç”¨rank-bm25åº“è®¡ç®—ç›¸ä¼¼åº¦\"\"\"\n        # åˆ†è¯å†å²æ–‡æœ¬\n        corpus_tokens = [self._tokenize(text) for text in history_texts]\n        \n        # è¿‡æ»¤ç©ºæ–‡æ¡£\n        valid_indices = [i for i, tokens in enumerate(corpus_tokens) if tokens]\n        if not valid_indices:\n            return 0.0, 0.0\n        \n        corpus_tokens = [corpus_tokens[i] for i in valid_indices]\n        \n        # è®¡ç®—æ—¶é—´æƒé‡\n        time_weights = []\n        if history_timestamps:\n            for i in valid_indices:\n                if i < len(history_timestamps):\n                    time_diff = (current_time - history_timestamps[i]).total_seconds()\n                    weight = self._calculate_time_decay(time_diff)\n                else:\n                    weight = 1.0\n                time_weights.append(weight)\n        else:\n            time_weights = [1.0] * len(corpus_tokens)\n        \n        # BM25è®¡ç®—\n        bm25 = self.BM25Okapi(corpus_tokens)\n        bm25_scores = bm25.get_scores(current_tokens)\n        \n        # æ‰¾åˆ°æœ€å¤§å’Œæœ€å°åˆ†æ•°ç”¨äºå½’ä¸€åŒ–\n        min_score = float(bm25_scores.min()) if len(bm25_scores) > 0 else 0\n        max_bm25_score = float(bm25_scores.max()) if len(bm25_scores) > 0 else 0\n        score_range = max_bm25_score - min_score\n        \n        # ç»¼åˆåˆ†æ•°ï¼šBM25 Ã— æ—¶é—´æƒé‡\n        max_score = 0.0\n        total_weighted_score = 0.0\n        total_weight = 0.0\n        \n        for i, bm25_score in enumerate(bm25_scores):\n            # å½’ä¸€åŒ–BM25åˆ†æ•°åˆ°[0, 1]\n            if score_range > 0:\n                normalized_bm25 = (bm25_score - min_score) / score_range\n            else:\n                normalized_bm25 = 0.5  # æ‰€æœ‰åˆ†æ•°ç›¸åŒï¼Œç»™ä¸ªä¸­é—´å€¼\n            \n            # åŠ æƒ\n            weighted_score = normalized_bm25 * time_weights[i]\n            total_weighted_score += weighted_score\n            total_weight += time_weights[i]\n            \n            if normalized_bm25 > max_score:\n                max_score = normalized_bm25\n        \n        avg_score = total_weighted_score / total_weight if total_weight > 0 else 0\n        \n        return avg_score, max_score\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 196,
"end": 240,
"text": "    def _calculate_simple(\n        self,\n        current_tokens: List[str],\n        history_texts: List[str],\n        history_timestamps: Optional[List[datetime]],\n        current_time: datetime\n    ) -> Tuple[float, float]:\n        \"\"\"ç®€å•å®ç°ï¼ˆJaccardç›¸ä¼¼åº¦ + æ—¶é—´è¡°å‡ï¼‰\"\"\"\n        current_set = set(current_tokens)\n        \n        max_similarity = 0.0\n        total_weighted_similarity = 0.0\n        total_weight = 0.0\n        \n        for i, text in enumerate(history_texts):\n            tokens = self._tokenize(text)\n            if not tokens:\n                continue\n            \n            token_set = set(tokens)\n            \n            # Jaccardç›¸ä¼¼åº¦\n            overlap = len(current_set & token_set)\n            union = len(current_set | token_set)\n            similarity = overlap / union if union > 0 else 0\n            \n            # æ—¶é—´æƒé‡\n            if history_timestamps and i < len(history_timestamps):\n                time_diff = (current_time - history_timestamps[i]).total_seconds()\n                time_weight = self._calculate_time_decay(time_diff)\n            else:\n                time_weight = 1.0\n            \n            # åŠ æƒç›¸ä¼¼åº¦\n            weighted_similarity = similarity * time_weight\n            total_weighted_similarity += weighted_similarity\n            total_weight += time_weight\n            \n            if similarity > max_similarity:\n                max_similarity = similarity\n        \n        avg_similarity = total_weighted_similarity / total_weight if total_weight > 0 else 0\n        \n        return avg_similarity, max_similarity\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 241,
"end": 254,
"text": "    def _calculate_time_decay(self, time_diff_seconds: float) -> float:\n        \"\"\"\n        è®¡ç®—æ—¶é—´è¡°å‡æƒé‡ï¼ˆæŒ‡æ•°è¡°å‡ï¼‰\n        \n        å…¬å¼ï¼šweight = 0.5 ^ (time_diff / halflife)\n        \n        ç¤ºä¾‹ï¼š\n        - 0ç§’ï¼šæƒé‡ 1.0\n        - 2åˆ†é’Ÿï¼ˆ120ç§’ï¼‰ï¼šæƒé‡ 0.5\n        - 4åˆ†é’Ÿï¼šæƒé‡ 0.25\n        - 8åˆ†é’Ÿï¼šæƒé‡ 0.125\n        \"\"\"\n        return 0.5 ** (time_diff_seconds / self.time_decay_halflife)\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 255,
"end": 274,
"text": "    def calculate_dynamic_threshold(self, history_length: int) -> float:\n        \"\"\"\n        åŠ¨æ€é˜ˆå€¼ï¼ˆæ ¹æ®å†å²é•¿åº¦è°ƒæ•´ï¼‰\n        \n        é€»è¾‘ï¼š\n        - å†å²è¶Šé•¿ï¼Œè¶Šå®¹æ˜“æ··æ·†ï¼Œé˜ˆå€¼åº”è¯¥è¶Šé«˜\n        - å†å²å¾ˆçŸ­ï¼Œé˜ˆå€¼å¯ä»¥ä½ä¸€äº›\n        \n        å…¬å¼ï¼šthreshold = base + log(history_length) * 0.02\n        \"\"\"\n        if history_length <= 1:\n            return self.base_threshold * 0.8  # åªæœ‰1æ¡å†å²ï¼Œé™ä½é˜ˆå€¼\n        \n        # å¯¹æ•°å¢é•¿ï¼ˆé¿å…é˜ˆå€¼è¿‡é«˜ï¼‰\n        adjustment = math.log(history_length) * 0.02\n        dynamic = self.base_threshold + adjustment\n        \n        # é™åˆ¶èŒƒå›´ï¼š[0.2, 0.4]\n        return max(0.2, min(0.4, dynamic))\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 275,
"end": 288,
"text": "    def _tokenize(self, text: str) -> List[str]:\n        \"\"\"\n        åˆ†è¯ï¼ˆå¤šç²’åº¦ï¼‰\n        \n        ä¼˜åŒ–ï¼š\n        1. ä½¿ç”¨jiebaåˆ†è¯ï¼ˆè¯çº§ï¼‰\n        2. æå–bigramï¼ˆçŸ­è¯­çº§ï¼‰\n        3. è¿‡æ»¤åœç”¨è¯\n        \"\"\"\n        if self.jieba_available:\n            return self._tokenize_with_jieba(text)\n        else:\n            return self._tokenize_simple(text)\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 289,
"end": 312,
"text": "    def _tokenize_with_jieba(self, text: str) -> List[str]:\n        \"\"\"ä½¿ç”¨jiebaåˆ†è¯\"\"\"\n        # ä½¿ç”¨jiebaåˆ†è¯\n        words = self.jieba.lcut(text)\n        \n        # è¿‡æ»¤åœç”¨è¯\n        # æ³¨æ„ï¼šä¿ç•™å•å­—åè¯ï¼ˆå¦‚\"çŒ«\"ã€\"ç‹—\"ï¼‰ï¼Œä½†è¿‡æ»¤å…¶ä»–å•å­—\n        tokens = []\n        for w in words:\n            if w in self.stopwords:\n                continue\n            if len(w) > 1:\n                tokens.append(w)\n            elif len(w) == 1 and '\\u4e00' <= w <= '\\u9fa5':\n                # å•å­—ä¸­æ–‡ï¼Œå¯èƒ½æ˜¯é‡è¦åè¯ï¼Œä¿ç•™\n                tokens.append(w)\n        \n        # æå–bigramï¼ˆ2-gramï¼‰\n        if len(tokens) >= 2:\n            bigrams = [f\"{tokens[i]}_{tokens[i+1]}\" for i in range(len(tokens)-1)]\n            tokens.extend(bigrams)\n        \n        return tokens\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 313,
"end": 339,
"text": "    def _tokenize_simple(self, text: str) -> List[str]:\n        \"\"\"ç®€å•åˆ†è¯ï¼ˆæ»‘åŠ¨çª—å£ï¼‰\"\"\"\n        import re\n        # æå–æ‰€æœ‰ä¸­æ–‡å­—ç¬¦\n        chinese_chars = re.findall(r'[\\u4e00-\\u9fa5]', text)\n        \n        if not chinese_chars:\n            return []\n        \n        tokens = []\n        \n        # æå–æ‰€æœ‰2-3å­—çš„è¿ç»­ç»„åˆ\n        for i in range(len(chinese_chars)):\n            # 2å­—è¯\n            if i + 1 < len(chinese_chars):\n                word2 = ''.join(chinese_chars[i:i+2])\n                if word2 not in self.stopwords:\n                    tokens.append(word2)\n            \n            # 3å­—è¯\n            if i + 2 < len(chinese_chars):\n                word3 = ''.join(chinese_chars[i:i+3])\n                if word3 not in self.stopwords:\n                    tokens.append(word3)\n        \n        return tokens\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 340,
"end": 354,
"text": "    def _load_stopwords(self) -> Set[str]:\n        \"\"\"åŠ è½½åœç”¨è¯\"\"\"\n        return {\n            # åŸºç¡€åœç”¨è¯\n            'çš„', 'äº†', 'æ˜¯', 'åœ¨', 'æˆ‘', 'æœ‰', 'å’Œ', 'å°±', 'ä¸', 'äºº',\n            'éƒ½', 'ä¸€', 'ä¸ª', 'ä¸Š', 'ä¹Ÿ', 'å¾ˆ', 'åˆ°', 'è¯´', 'è¦', 'å»',\n            'ä½ ', 'ä¼š', 'ç€', 'æ²¡æœ‰', 'çœ‹', 'å¥½', 'è‡ªå·±', 'è¿™',\n            # å¯¹è¯åœç”¨è¯\n            'å—', 'å‘¢', 'å•Š', 'å“¦', 'å—¯', 'å“ˆ', 'å‘€', 'å§',\n            # æ—¶é—´åœç”¨è¯\n            'ä»Šå¤©', 'æ˜å¤©', 'æ˜¨å¤©', 'ç°åœ¨', 'åˆšæ‰',\n            # å…¶ä»–\n            'ä»€ä¹ˆ', 'æ€ä¹ˆ', 'å¯ä»¥', 'éœ€è¦',\n        }\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 355,
"end": 407,
"text": "    def _extract_key_entities(self, text: str) -> Set[str]:\n        \"\"\"\n        æå–å…³é”®å®ä½“ï¼ˆæ ¸å¿ƒåè¯ï¼‰\n        \n        å…³é”®å®ä½“æ˜¯æŒ‡é‚£äº›èƒ½å¤Ÿæ˜ç¡®åŒºåˆ†è¯é¢˜çš„æ ¸å¿ƒè¯ï¼Œå¦‚ï¼š\n        - åŠ¨ç‰©åç§°ï¼šçŒ«ã€ç‹—ã€é¸Ÿã€é±¼\n        - äººç‰©ï¼šå¦ˆå¦ˆã€çˆ¸çˆ¸ã€è€å¸ˆ\n        - åœ°ç‚¹ï¼šå­¦æ ¡ã€åŒ»é™¢ã€å…¬å›­\n        \n        ç­–ç•¥ï¼š\n        1. ä½¿ç”¨jiebaè¯æ€§æ ‡æ³¨ï¼Œæå–åè¯(n)\n        2. ä¼˜å…ˆä¿ç•™å•å­—åè¯ï¼ˆå¦‚\"çŒ«\"ã€\"ç‹—\"ï¼‰\n        3. è¿‡æ»¤é€šç”¨è¯ï¼ˆå¦‚\"é—®é¢˜\"ã€\"æƒ…å†µ\"ï¼‰\n        \"\"\"\n        entities = set()\n        \n        if self.jieba_available:\n            try:\n                # ä½¿ç”¨è¯æ€§æ ‡æ³¨\n                words = self.pseg.cut(text)\n                \n                # é€šç”¨è¯åˆ—è¡¨ï¼ˆä¸ä½œä¸ºå…³é”®å®ä½“ï¼‰\n                generic_nouns = {'é—®é¢˜', 'æƒ…å†µ', 'äº‹æƒ…', 'ä¸œè¥¿', 'æ–¹é¢', 'æ—¶å€™', 'åœ°æ–¹', 'åŠæ³•', 'æ–¹æ³•'}\n                \n                for word, flag in words:\n                    # åªä¿ç•™åè¯\n                    if flag.startswith('n'):\n                        # å•å­—åè¯ï¼ˆå¦‚\"çŒ«\"ã€\"ç‹—\"ï¼‰ä¼˜å…ˆ\n                        if len(word) == 1 and '\\u4e00' <= word <= '\\u9fa5':\n                            entities.add(word)\n                        # 2-3å­—åè¯ï¼Œæ’é™¤é€šç”¨è¯\n                        elif len(word) <= 3 and word not in generic_nouns:\n                            entities.add(word)\n                \n                logger.debug(f\"æå–å…³é”®å®ä½“: {entities}\")\n                return entities\n            \n            except Exception as e:\n                logger.debug(f\"å®ä½“æå–å¤±è´¥: {e}\")\n        \n        # é™çº§ï¼šæå–å•å­—ä¸­æ–‡ï¼ˆå¯èƒ½æ˜¯å…³é”®å®ä½“ï¼‰\n        import re\n        chinese_chars = re.findall(r'[\\u4e00-\\u9fa5]', text)\n        \n        # å¸¸è§åŠ¨ç‰©ã€äººç‰©ç­‰å…³é”®è¯\n        key_entities = {'çŒ«', 'ç‹—', 'é¸Ÿ', 'é±¼', 'å…”', 'é¼ ', 'ç‰›', 'ç¾Š', 'é©¬', 'çŒª'}\n        \n        for char in chinese_chars:\n            if char in key_entities:\n                entities.add(char)\n        \n        return entities\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 408,
"end": 455,
"text": "    def _calculate_entity_penalty(\n        self,\n        current_entities: Set[str],\n        history_texts: List[str]\n    ) -> float:\n        \"\"\"\n        è®¡ç®—å®ä½“æƒ©ç½šç³»æ•°\n        \n        å¦‚æœå½“å‰æ¶ˆæ¯çš„å…³é”®å®ä½“ä¸å†å²æ¶ˆæ¯å®Œå…¨ä¸åŒï¼Œåº”è¯¥é™ä½ç›¸ä¼¼åº¦ã€‚\n        \n        ç­–ç•¥ï¼š\n        - å¦‚æœæœ‰ä»»ä½•å®ä½“é‡å ï¼Œä¸æƒ©ç½šï¼ˆè¿”å›1.0ï¼‰\n        - å¦‚æœå®ä½“å®Œå…¨ä¸åŒï¼Œæƒ©ç½šï¼ˆè¿”å›0.3-0.7ï¼‰\n        \n        Args:\n            current_entities: å½“å‰æ¶ˆæ¯çš„å…³é”®å®ä½“\n            history_texts: å†å²æ–‡æœ¬åˆ—è¡¨\n        \n        Returns:\n            æƒ©ç½šç³»æ•°ï¼ˆ0.3-1.0ï¼‰\n        \"\"\"\n        if not current_entities:\n            return 1.0  # æ²¡æœ‰å…³é”®å®ä½“ï¼Œä¸æƒ©ç½š\n        \n        # æå–å†å²æ–‡æœ¬çš„æ‰€æœ‰å®ä½“\n        history_entities = set()\n        for text in history_texts:\n            history_entities.update(self._extract_key_entities(text))\n        \n        if not history_entities:\n            return 1.0  # å†å²æ²¡æœ‰å…³é”®å®ä½“ï¼Œä¸æƒ©ç½š\n        \n        # è®¡ç®—å®ä½“é‡å \n        overlap = len(current_entities & history_entities)\n        \n        if overlap > 0:\n            # æœ‰å®ä½“é‡å ï¼Œä¸æƒ©ç½š\n            return 1.0\n        else:\n            # å®ä½“å®Œå…¨ä¸åŒï¼Œåº”ç”¨æƒ©ç½š\n            # æƒ©ç½šåŠ›åº¦ï¼š0.3ï¼ˆå¼ºæƒ©ç½šï¼Œç›¸ä¼¼åº¦é™ä½70%ï¼‰\n            penalty = 0.3\n            logger.debug(\n                f\"å®ä½“å®Œå…¨ä¸åŒï¼Œåº”ç”¨æƒ©ç½š: current={current_entities}, \"\n                f\"history={history_entities}, penalty={penalty}\"\n            )\n            return penalty\n    "
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 456,
"end": 469,
"text": "    def get_stats(self) -> Dict:\n        \"\"\"è·å–ç»Ÿè®¡ä¿¡æ¯\"\"\"\n        return {\n            'base_threshold': self.base_threshold,\n            'time_decay_halflife': self.time_decay_halflife,\n            'rank_bm25_available': self.rank_bm25_available,\n            'jieba_available': self.jieba_available,\n        }\n\n\n# å•ä¾‹\n_bm25_matcher = None\n\n"
},
{
"path": "daoyoucode/agents/memory/bm25_matcher.py",
"start": 470,
"end": 477,
"text": "def get_bm25_matcher() -> BM25Matcher:\n    \"\"\"è·å–BM25åŒ¹é…å™¨å•ä¾‹\"\"\"\n    global _bm25_matcher\n    \n    if _bm25_matcher is None:\n        _bm25_matcher = BM25Matcher()\n    \n    return _bm25_matcher"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 1,
"end": 24,
"text": "\"\"\"\nä»£ç åº“å‘é‡ç´¢å¼•ï¼ˆCursor åŒçº§æŒ‰é—®æ£€ç´¢ï¼‰\n\nå¯¹ä»“åº“åš chunk â†’ embed â†’ å­˜å‚¨ï¼Œæ”¯æŒæŒ‰ query æ£€ç´¢ top-k ç›¸å…³ä»£ç å—ã€‚\nä¾èµ–ï¼šsentence-transformers å¯é€‰ï¼›æœªå®‰è£…æ—¶é€€åŒ–ä¸ºå…³é”®è¯åŒ¹é…ã€‚\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import List, Dict, Any, Optional, Tuple\nimport logging\nimport json\nimport hashlib\nimport re\n\nlogger = logging.getLogger(__name__)\n\n# å•ä¾‹ï¼šæŒ‰ repo è·¯å¾„ç¼“å­˜ç´¢å¼•\n_index_cache: Dict[str, \"CodebaseIndex\"] = {}\n# é»˜è®¤ chunk æœ€å¤§è¡Œæ•°\nDEFAULT_CHUNK_LINES = 55\n# ç´¢å¼•ç›®å½•å\nINDEX_DIR = \".daoyoucode/codebase_index\"\n\n"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 25,
"end": 32,
"text": "def _repo_key(repo_path: Path) -> str:\n    try:\n        abs_path = repo_path.resolve()\n        return hashlib.sha256(str(abs_path).encode()).hexdigest()[:16]\n    except Exception:\n        return \"default\"\n\n"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 33,
"end": 38,
"text": "def _get_index_dir(repo_path: Path) -> Path:\n    key = _repo_key(repo_path)\n    base = repo_path if repo_path.is_dir() else repo_path.parent\n    return base / INDEX_DIR / key\n\n"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 39,
"end": 51,
"text": "def _should_ignore(path: Path, repo_path: Path) -> bool:\n    rel = path.relative_to(repo_path) if repo_path in path.parents or path == repo_path else path\n    parts = str(rel).replace(\"\\\\\", \"/\").split(\"/\")\n    ignore = {\n        \".git\", \"node_modules\", \"__pycache__\", \".venv\", \"venv\", \"dist\", \"build\",\n        \".daoyoucode\", \".cursor\", \".idea\", \"*.pyc\", \".pytest_cache\", \"vendor\"\n    }\n    for p in parts:\n        if p in ignore or p.startswith(\".\") and len(p) > 1:\n            return True\n    return False\n\n"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 52,
"end": 81,
"text": "def _chunk_file(content: str, path: Path, max_lines: int = DEFAULT_CHUNK_LINES) -> List[Dict[str, Any]]:\n    \"\"\"æŒ‰è¡Œæˆ– def/class è¾¹ç•Œåˆ‡åˆ†ä¸ºå—ï¼ˆPython æŒ‰ def/classï¼Œå…¶å®ƒæŒ‰è¡Œï¼‰\"\"\"\n    lines = content.splitlines()\n    if not lines:\n        return []\n    ext = path.suffix.lower()\n    chunks = []\n    if ext == \".py\":\n        # Python: æŒ‰ def/class è¾¹ç•Œ\n        current_start = 0\n        for i, line in enumerate(lines):\n            stripped = line.strip()\n            if (stripped.startswith(\"def \") or stripped.startswith(\"class \")) and i > current_start:\n                block = \"\\n\".join(lines[current_start:i])\n                if block.strip():\n                    chunks.append({\"start\": current_start + 1, \"end\": i, \"text\": block})\n                current_start = i\n        if current_start < len(lines):\n            block = \"\\n\".join(lines[current_start:])\n            if block.strip():\n                chunks.append({\"start\": current_start + 1, \"end\": len(lines), \"text\": block})\n    else:\n        for start in range(0, len(lines), max_lines):\n            end = min(start + max_lines, len(lines))\n            block = \"\\n\".join(lines[start:end])\n            if block.strip():\n                chunks.append({\"start\": start + 1, \"end\": end, \"text\": block})\n    return chunks\n\n"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 82,
"end": 84,
"text": "class CodebaseIndex:\n    \"\"\"ä»£ç åº“å‘é‡ç´¢å¼•ï¼šchunk + embed + æ£€ç´¢\"\"\"\n"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 85,
"end": 93,
"text": "    def __init__(self, repo_path: Path):\n        self.repo_path = Path(repo_path).resolve()\n        if not self.repo_path.is_dir():\n            self.repo_path = self.repo_path.parent\n        self.index_dir = _get_index_dir(self.repo_path)\n        self.chunks: List[Dict[str, Any]] = []  # [{path, start, end, text}, ...]\n        self.embeddings: Optional[Any] = None   # np.ndarray (n, dim) or None\n        self._retriever = None\n"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 94,
"end": 101,
"text": "    def _get_retriever(self):\n        if self._retriever is None:\n            from .vector_retriever import get_vector_retriever\n            r = get_vector_retriever()\n            r.enable()\n            self._retriever = r\n        return self._retriever\n"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 102,
"end": 179,
"text": "    def build_index(\n        self,\n        max_file_size: int = 200_000,\n        extensions: Optional[Tuple[str, ...]] = None,\n        force: bool = False\n    ) -> int:\n        \"\"\"æ‰«æä»“åº“ã€åˆ†å—ã€ç¼–ç å¹¶æŒä¹…åŒ–ã€‚è¿”å› chunk æ•°é‡ã€‚\"\"\"\n        if extensions is None:\n            extensions = (\".py\", \".js\", \".ts\", \".tsx\", \".jsx\", \".md\", \".yaml\", \".yml\", \".json\")\n        self.index_dir.mkdir(parents=True, exist_ok=True)\n        meta_file = self.index_dir / \"meta.json\"\n        npy_file = self.index_dir / \"embeddings.npy\"\n\n        if not force and meta_file.exists():\n            try:\n                with open(meta_file, \"r\", encoding=\"utf-8\") as f:\n                    data = json.load(f)\n                self.chunks = data.get(\"chunks\", [])\n                if npy_file.exists():\n                    import numpy as np\n                    self.embeddings = np.load(npy_file)\n                logger.info(f\"å·²åŠ è½½ä»£ç åº“ç´¢å¼•: {len(self.chunks)} å—\")\n                return len(self.chunks)\n            except Exception as e:\n                logger.warning(f\"åŠ è½½ç´¢å¼•å¤±è´¥ï¼Œé‡å»º: {e}\")\n\n        self.chunks = []\n        for path in self.repo_path.rglob(\"*\"):\n            if not path.is_file():\n                continue\n            if _should_ignore(path, self.repo_path):\n                continue\n            if path.suffix.lower() not in extensions:\n                continue\n            try:\n                content = path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n            except Exception as e:\n                logger.debug(f\"è·³è¿‡ {path}: {e}\")\n                continue\n            if len(content) > max_file_size:\n                continue\n            rel_path = path.relative_to(self.repo_path)\n            rel_str = str(rel_path).replace(\"\\\\\", \"/\")\n            for c in _chunk_file(content, path):\n                self.chunks.append({\n                    \"path\": rel_str,\n                    \"start\": c[\"start\"],\n                    \"end\": c[\"end\"],\n                    \"text\": c[\"text\"][:4000]\n                })\n\n        if not self.chunks:\n            logger.warning(\"ä»£ç åº“ç´¢å¼•æ—  chunk\")\n            self._save_meta()\n            return 0\n\n        retriever = self._get_retriever()\n        if not getattr(retriever, \"enabled\", False) or not retriever.model:\n            logger.warning(\"embedding æœªå¯ç”¨ï¼Œä»…ä¿å­˜ chunk å…ƒæ•°æ®ï¼Œæ£€ç´¢å°†ä½¿ç”¨å…³é”®è¯å›é€€\")\n            self._save_meta()\n            return len(self.chunks)\n\n        import numpy as np\n        dim = getattr(retriever.model, \"get_sentence_embedding_dimension\", lambda: 384)()\n        vecs = []\n        for c in self.chunks:\n            text = c.get(\"text\", \"\")[:2000]\n            emb = retriever.encode(text)\n            if emb is not None:\n                vecs.append(emb)\n            else:\n                vecs.append(np.zeros(dim, dtype=np.float32))\n        self.embeddings = np.array(vecs, dtype=np.float32)\n        self._save_meta()\n        np.save(npy_file, self.embeddings)\n        logger.info(f\"ä»£ç åº“ç´¢å¼•å·²æ„å»º: {len(self.chunks)} å—, å‘é‡ç»´åº¦ {self.embeddings.shape[1]}\")\n        return len(self.chunks)\n"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 180,
"end": 185,
"text": "    def _save_meta(self):\n        self.index_dir.mkdir(parents=True, exist_ok=True)\n        meta_file = self.index_dir / \"meta.json\"\n        with open(meta_file, \"w\", encoding=\"utf-8\") as f:\n            json.dump({\"chunks\": self.chunks, \"repo\": str(self.repo_path)}, f, ensure_ascii=False, indent=0)\n"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 186,
"end": 220,
"text": "    def search(self, query: str, top_k: int = 10) -> List[Dict[str, Any]]:\n        \"\"\"æŒ‰ query æ£€ç´¢æœ€ç›¸å…³çš„ä»£ç å—ã€‚æ— å‘é‡æ—¶é€€åŒ–ä¸ºå…³é”®è¯åŒ¹é…ã€‚\"\"\"\n        if not self.chunks:\n            self.build_index()\n        if not self.chunks:\n            return []\n\n        retriever = self._get_retriever()\n        if retriever.enabled and self.embeddings is not None:\n            import numpy as np\n            q = retriever.encode(query)\n            if q is not None:\n                q_norm = q / np.linalg.norm(q)\n                emb_norm = self.embeddings / np.linalg.norm(self.embeddings, axis=1, keepdims=True)\n                scores = np.dot(emb_norm, q_norm)\n                top_idx = np.argsort(scores)[::-1][:top_k]\n                return [\n                    {**self.chunks[i], \"score\": float(scores[i])}\n                    for i in top_idx if scores[i] > 1e-6\n                ]\n\n        # å…³é”®è¯å›é€€\n        words = re.findall(r\"\\w+\", query.lower())\n        if not words:\n            return self.chunks[:top_k]\n        scored = []\n        for c in self.chunks:\n            text = (c.get(\"text\") or \"\").lower()\n            score = sum(1 for w in words if w in text)\n            if score > 0:\n                scored.append((score, c))\n        scored.sort(key=lambda x: -x[0])\n        return [{**c, \"score\": float(s)} for s, c in scored[:top_k]]\n\n    @classmethod"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 221,
"end": 227,
"text": "    def get_index(cls, repo_path: Path) -> \"CodebaseIndex\":\n        key = _repo_key(Path(repo_path).resolve())\n        if key not in _index_cache:\n            _index_cache[key] = cls(repo_path)\n        return _index_cache[key]\n\n"
},
{
"path": "daoyoucode/agents/memory/codebase_index.py",
"start": 228,
"end": 231,
"text": "def search_codebase(repo_path: Path, query: str, top_k: int = 10) -> List[Dict[str, Any]]:\n    \"\"\"ä¾¿æ·å‡½æ•°ï¼šè·å–æˆ–æ„å»ºç´¢å¼•å¹¶æ£€ç´¢ã€‚\"\"\"\n    idx = CodebaseIndex.get_index(repo_path)\n    return idx.search(query, top_k=top_k)"
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 1,
"end": 54,
"text": "\"\"\"\nå¯¹è¯æ ‘ï¼ˆConversation Treeï¼‰\n\næ ¸å¿ƒåŠŸèƒ½ï¼š\n1. ç»´æŠ¤å¯¹è¯çš„æ ‘å½¢ç»“æ„ï¼ˆåˆ†æ”¯ã€è¯é¢˜åˆ‡æ¢ï¼‰\n2. æ”¯æŒå¤šåˆ†æ”¯å¯¹è¯ï¼ˆç”¨æˆ·å¯ä»¥åœ¨ä¸åŒè¯é¢˜é—´åˆ‡æ¢ï¼‰\n3. æ™ºèƒ½è¯†åˆ«è¯é¢˜åˆ‡æ¢å’Œåˆ†æ”¯åˆ›å»º\n4. æä¾›åŸºäºæ ‘ç»“æ„çš„ä¸Šä¸‹æ–‡æ£€ç´¢\n\nè®¾è®¡åŸåˆ™ï¼š\n- è½»é‡çº§ï¼šé€šè¿‡å…ƒæ•°æ®æ ‡è®°ï¼Œä¸æ”¹å˜æ ¸å¿ƒæ•°æ®ç»“æ„\n- å¯æ‰©å±•ï¼šæ”¯æŒå¤šç§æ£€ç´¢ç­–ç•¥ï¼ˆæ ‘ç»“æ„ã€å…³é”®è¯ã€å‘é‡ï¼‰\n- å¯é€‰ï¼šä¸å¼ºåˆ¶ä¾èµ–ï¼Œå¯ä»¥ç¦ç”¨\n- é€šç”¨ï¼šå¯ä»¥è¢«å…¶ä»–Agentå¤ç”¨\n\næ•°æ®ç»“æ„ï¼š\n```\nconversation = {\n    'user': 'ç”¨æˆ·æ¶ˆæ¯',\n    'ai': 'AIå“åº”',\n    'timestamp': '2026-02-15T12:00:00',\n    'metadata': {\n        'conversation_id': 'conv-1',      # å¯¹è¯ID\n        'parent_id': None,                # çˆ¶å¯¹è¯ID\n        'branch_id': 'branch-1',          # åˆ†æ”¯ID\n        'topic': 'çŒ«-è‚ èƒƒé—®é¢˜',           # è¯é¢˜æ ‡ç­¾\n        'depth': 0,                       # æ ‘æ·±åº¦\n        'is_branch_start': False          # æ˜¯å¦ä¸ºåˆ†æ”¯èµ·ç‚¹\n    }\n}\n```\n\næ ‘ç»“æ„ç¤ºä¾‹ï¼š\n```\nRoot\nâ”œâ”€ Branch-1: çŒ«-è‚ èƒƒé—®é¢˜\nâ”‚  â”œâ”€ Conv-1: æˆ‘çš„çŒ«ä¸åƒé¥­\nâ”‚  â”œâ”€ Conv-2: å¯èƒ½æ˜¯ä»€ä¹ˆåŸå› ï¼Ÿ\nâ”‚  â””â”€ Conv-3: éœ€è¦å»åŒ»é™¢å—ï¼Ÿ\nâ”‚\nâ””â”€ Branch-2: ç‹—-çš®è‚¤é—®é¢˜\n   â”œâ”€ Conv-4: é‚£ç‹—å‘¢ï¼Ÿï¼ˆè¯é¢˜åˆ‡æ¢ï¼‰\n   â””â”€ Conv-5: ç‹—çš„çš®è‚¤æœ‰çº¢ç‚¹\n```\n\"\"\"\n\nfrom typing import Dict, List, Optional, Any, Tuple, Set\nfrom datetime import datetime\nimport logging\nimport uuid\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 55,
"end": 61,
"text": "class ConversationNode:\n    \"\"\"\n    å¯¹è¯èŠ‚ç‚¹\n    \n    è¡¨ç¤ºæ ‘ä¸­çš„ä¸€ä¸ªå¯¹è¯\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 62,
"end": 84,
"text": "    def __init__(\n        self,\n        conversation_id: str,\n        user_message: str,\n        ai_response: str,\n        parent_id: Optional[str] = None,\n        branch_id: Optional[str] = None,\n        topic: Optional[str] = None,\n        timestamp: Optional[str] = None\n    ):\n        self.conversation_id = conversation_id\n        self.user_message = user_message\n        self.ai_response = ai_response\n        self.parent_id = parent_id\n        self.branch_id = branch_id or self._generate_branch_id()\n        self.topic = topic\n        self.timestamp = timestamp or datetime.now().isoformat()\n        \n        # æ ‘ç»“æ„\n        self.children: List[str] = []  # å­èŠ‚ç‚¹IDåˆ—è¡¨\n        self.depth = 0\n        self.is_branch_start = False\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 85,
"end": 88,
"text": "    def _generate_branch_id(self) -> str:\n        \"\"\"ç”Ÿæˆåˆ†æ”¯ID\"\"\"\n        return f\"branch-{uuid.uuid4().hex[:8]}\"\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 89,
"end": 105,
"text": "    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"è½¬æ¢ä¸ºå­—å…¸\"\"\"\n        return {\n            'user': self.user_message,\n            'ai': self.ai_response,\n            'timestamp': self.timestamp,\n            'metadata': {\n                'conversation_id': self.conversation_id,\n                'parent_id': self.parent_id,\n                'branch_id': self.branch_id,\n                'topic': self.topic,\n                'depth': self.depth,\n                'is_branch_start': self.is_branch_start\n            }\n        }\n    \n    @classmethod"
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 106,
"end": 125,
"text": "    def from_dict(cls, data: Dict[str, Any]) -> 'ConversationNode':\n        \"\"\"ä»å­—å…¸åˆ›å»ºèŠ‚ç‚¹\"\"\"\n        metadata = data.get('metadata', {})\n        \n        node = cls(\n            conversation_id=metadata.get('conversation_id', f\"conv-{uuid.uuid4().hex[:8]}\"),\n            user_message=data.get('user', ''),\n            ai_response=data.get('ai', ''),\n            parent_id=metadata.get('parent_id'),\n            branch_id=metadata.get('branch_id'),\n            topic=metadata.get('topic'),\n            timestamp=data.get('timestamp')\n        )\n        \n        node.depth = metadata.get('depth', 0)\n        node.is_branch_start = metadata.get('is_branch_start', False)\n        \n        return node\n\n"
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 126,
"end": 136,
"text": "class ConversationTree:\n    \"\"\"\n    å¯¹è¯æ ‘ç®¡ç†å™¨\n    \n    èŒè´£ï¼š\n    1. ç»´æŠ¤å¯¹è¯çš„æ ‘å½¢ç»“æ„\n    2. è¯†åˆ«è¯é¢˜åˆ‡æ¢å’Œåˆ†æ”¯åˆ›å»º\n    3. æä¾›åŸºäºæ ‘ç»“æ„çš„æ£€ç´¢\n    4. æ”¯æŒå¤šç§æ£€ç´¢ç­–ç•¥\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 137,
"end": 163,
"text": "    def __init__(self, enabled: bool = True):\n        \"\"\"\n        åˆå§‹åŒ–å¯¹è¯æ ‘\n        \n        Args:\n            enabled: æ˜¯å¦å¯ç”¨æ ‘ç»“æ„ï¼ˆå¯é€‰ï¼‰\n        \"\"\"\n        self.enabled = enabled\n        \n        # èŠ‚ç‚¹å­˜å‚¨ï¼šconversation_id -> ConversationNode\n        self._nodes: Dict[str, ConversationNode] = {}\n        \n        # åˆ†æ”¯å­˜å‚¨ï¼šbranch_id -> [conversation_ids]\n        self._branches: Dict[str, List[str]] = {}\n        \n        # å½“å‰æ´»è·ƒåˆ†æ”¯\n        self._current_branch_id: Optional[str] = None\n        \n        # è¯é¢˜å…³é”®è¯ç¼“å­˜ï¼ˆç”¨äºå¿«é€Ÿè¯é¢˜è¯†åˆ«ï¼‰\n        self._topic_keywords: Dict[str, Set[str]] = {}\n        \n        # BM25åŒ¹é…å™¨ï¼ˆç”¨äºè¯é¢˜ç›¸ä¼¼åº¦è®¡ç®—ï¼‰\n        from .bm25_matcher import get_bm25_matcher\n        self._bm25_matcher = get_bm25_matcher()\n        \n        logger.info(f\"å¯¹è¯æ ‘å·²åˆå§‹åŒ–ï¼ˆå¯ç”¨: {enabled}ï¼‰\")\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 164,
"end": 265,
"text": "    def add_conversation(\n        self,\n        user_message: str,\n        ai_response: str,\n        conversation_id: Optional[str] = None,\n        detect_topic_switch: bool = True\n    ) -> ConversationNode:\n        \"\"\"\n        æ·»åŠ å¯¹è¯åˆ°æ ‘ä¸­\n        \n        Args:\n            user_message: ç”¨æˆ·æ¶ˆæ¯\n            ai_response: AIå“åº”\n            conversation_id: å¯¹è¯IDï¼ˆå¯é€‰ï¼Œè‡ªåŠ¨ç”Ÿæˆï¼‰\n            detect_topic_switch: æ˜¯å¦æ£€æµ‹è¯é¢˜åˆ‡æ¢\n        \n        Returns:\n            åˆ›å»ºçš„å¯¹è¯èŠ‚ç‚¹\n        \"\"\"\n        if not self.enabled:\n            # æ ‘ç»“æ„æœªå¯ç”¨ï¼Œåˆ›å»ºç®€å•èŠ‚ç‚¹\n            node = ConversationNode(\n                conversation_id=conversation_id or f\"conv-{uuid.uuid4().hex[:8]}\",\n                user_message=user_message,\n                ai_response=ai_response\n            )\n            return node\n        \n        # ç”Ÿæˆå¯¹è¯ID\n        if conversation_id is None:\n            conversation_id = f\"conv-{uuid.uuid4().hex[:8]}\"\n        \n        # æ£€æµ‹è¯é¢˜åˆ‡æ¢\n        is_topic_switch = False\n        new_topic = None\n        parent_id = None\n        branch_id = self._current_branch_id\n        \n        if detect_topic_switch and self._nodes:\n            is_topic_switch, new_topic = self._detect_topic_switch(user_message)\n            \n            if is_topic_switch:\n                # è¯é¢˜åˆ‡æ¢ï¼Œåˆ›å»ºæ–°åˆ†æ”¯\n                branch_id = f\"branch-{uuid.uuid4().hex[:8]}\"\n                parent_id = None  # æ–°åˆ†æ”¯æ²¡æœ‰çˆ¶èŠ‚ç‚¹\n                logger.info(f\"ğŸŒ¿ æ£€æµ‹åˆ°è¯é¢˜åˆ‡æ¢: {new_topic}\")\n            else:\n                # åŒä¸€è¯é¢˜ï¼Œç»§ç»­å½“å‰åˆ†æ”¯\n                parent_id = self._get_last_conversation_id()\n                # æ›´æ–°å½“å‰åˆ†æ”¯çš„è¯é¢˜å…³é”®è¯\n                if self._current_branch_id:\n                    self._update_topic_keywords(self._current_branch_id, user_message)\n        else:\n            # ç¬¬ä¸€ä¸ªå¯¹è¯ï¼Œåˆ›å»ºæ ¹åˆ†æ”¯\n            branch_id = f\"branch-{uuid.uuid4().hex[:8]}\"\n            parent_id = None\n        \n        # åˆ›å»ºèŠ‚ç‚¹\n        node = ConversationNode(\n            conversation_id=conversation_id,\n            user_message=user_message,\n            ai_response=ai_response,\n            parent_id=parent_id,\n            branch_id=branch_id,\n            topic=new_topic\n        )\n        \n        # è®¾ç½®æ·±åº¦\n        if parent_id and parent_id in self._nodes:\n            node.depth = self._nodes[parent_id].depth + 1\n        else:\n            node.depth = 0\n        \n        # æ ‡è®°åˆ†æ”¯èµ·ç‚¹\n        node.is_branch_start = is_topic_switch or (not self._nodes)\n        \n        # æ·»åŠ åˆ°å­˜å‚¨\n        self._nodes[conversation_id] = node\n        \n        # æ›´æ–°åˆ†æ”¯\n        if branch_id not in self._branches:\n            self._branches[branch_id] = []\n        self._branches[branch_id].append(conversation_id)\n        \n        # æ›´æ–°çˆ¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹åˆ—è¡¨\n        if parent_id and parent_id in self._nodes:\n            self._nodes[parent_id].children.append(conversation_id)\n        \n        # æ›´æ–°å½“å‰åˆ†æ”¯\n        self._current_branch_id = branch_id\n        \n        # æ›´æ–°è¯é¢˜å…³é”®è¯ç¼“å­˜\n        if branch_id:\n            self._update_topic_keywords(branch_id, user_message)\n        \n        logger.debug(\n            f\"æ·»åŠ å¯¹è¯: id={conversation_id}, branch={branch_id}, \"\n            f\"depth={node.depth}, topic_switch={is_topic_switch}\"\n        )\n        \n        return node\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 266,
"end": 339,
"text": "    def _detect_topic_switch(self, current_message: str) -> Tuple[bool, Optional[str]]:\n        \"\"\"\n        æ£€æµ‹è¯é¢˜åˆ‡æ¢ï¼ˆä½¿ç”¨BM25ç®—æ³•ï¼‰\n        \n        ç­–ç•¥ï¼š\n        1. ä½¿ç”¨BM25ç®—æ³•è®¡ç®—ä¸å½“å‰åˆ†æ”¯æ‰€æœ‰æ¶ˆæ¯çš„ç›¸ä¼¼åº¦\n        2. åº”ç”¨æ—¶é—´è¡°å‡æƒé‡ï¼ˆè¶Šè¿‘çš„æ¶ˆæ¯æƒé‡è¶Šé«˜ï¼‰\n        3. åŠ¨æ€é˜ˆå€¼ï¼ˆæ ¹æ®åˆ†æ”¯å¯¹è¯æ•°é‡è°ƒæ•´ï¼‰\n        4. å¦‚æœç›¸ä¼¼åº¦ä½ï¼Œåˆ¤æ–­ä¸ºè¯é¢˜åˆ‡æ¢\n        \n        Args:\n            current_message: å½“å‰æ¶ˆæ¯\n        \n        Returns:\n            (æ˜¯å¦åˆ‡æ¢, æ–°è¯é¢˜)\n        \"\"\"\n        if not self._current_branch_id:\n            return False, None\n        \n        # è·å–å½“å‰åˆ†æ”¯çš„æ‰€æœ‰å¯¹è¯\n        branch_conversations = self._branches.get(self._current_branch_id, [])\n        \n        if not branch_conversations:\n            # å½“å‰åˆ†æ”¯æ²¡æœ‰å¯¹è¯ï¼Œä¸åˆ¤æ–­ä¸ºåˆ‡æ¢\n            return False, None\n        \n        # æ”¶é›†å†å²æ–‡æœ¬å’Œæ—¶é—´æˆ³\n        history_texts = []\n        history_timestamps = []\n        \n        for conv_id in branch_conversations:\n            if conv_id in self._nodes:\n                node = self._nodes[conv_id]\n                history_texts.append(node.user_message)\n                try:\n                    history_timestamps.append(datetime.fromisoformat(node.timestamp))\n                except:\n                    history_timestamps.append(datetime.now())\n        \n        if not history_texts:\n            return False, None\n        \n        # ä½¿ç”¨BM25è®¡ç®—ç›¸ä¼¼åº¦\n        avg_similarity, max_similarity = self._bm25_matcher.calculate_similarity(\n            current_text=current_message,\n            history_texts=history_texts,\n            history_timestamps=history_timestamps,\n            current_time=datetime.now()\n        )\n        \n        # åŠ¨æ€é˜ˆå€¼\n        threshold = self._bm25_matcher.calculate_dynamic_threshold(len(branch_conversations))\n        \n        logger.debug(\n            f\"è¯é¢˜æ£€æµ‹: avg_sim={avg_similarity:.2f}, max_sim={max_similarity:.2f}, \"\n            f\"threshold={threshold:.2f}, convs={len(branch_conversations)}\"\n        )\n        \n        # åˆ¤æ–­æ˜¯å¦åˆ‡æ¢ï¼ˆä½¿ç”¨å¹³å‡åŠ æƒç›¸ä¼¼åº¦ï¼‰\n        if avg_similarity < threshold:\n            # ç”Ÿæˆæ–°è¯é¢˜æ ‡ç­¾ï¼ˆä½¿ç”¨å‰3ä¸ªå…³é”®è¯ï¼‰\n            keywords = self._extract_keywords(current_message)\n            new_topic = \"-\".join(list(keywords)[:3]) if keywords else \"new-topic\"\n            \n            logger.debug(\n                f\"è¯é¢˜åˆ‡æ¢: avg_sim={avg_similarity:.2f} < {threshold}\"\n            )\n            return True, new_topic\n        \n        logger.debug(\n            f\"è¯é¢˜å»¶ç»­: avg_sim={avg_similarity:.2f} >= {threshold}\"\n        )\n        return False, None\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 340,
"end": 411,
"text": "    def _extract_keywords(self, text: str) -> Set[str]:\n        \"\"\"\n        æå–å…³é”®è¯ï¼ˆå¤šç²’åº¦ï¼‰\n        \n        ç­–ç•¥ï¼š\n        1. ä¼˜å…ˆä½¿ç”¨jiebaåˆ†è¯ + bigram\n        2. é™çº§åˆ°æ»‘åŠ¨çª—å£\n        \n        Args:\n            text: æ–‡æœ¬\n        \n        Returns:\n            å…³é”®è¯é›†åˆ\n        \"\"\"\n        try:\n            # å°è¯•ä½¿ç”¨jiebaï¼ˆæ›´å‡†ç¡®ï¼‰\n            import jieba.posseg as pseg\n            \n            words = pseg.cut(text)\n            # åªä¿ç•™åè¯(n)ã€åŠ¨è¯(v)ã€å½¢å®¹è¯(a)\n            # æ³¨æ„ï¼šä¿ç•™å•å­—åè¯ï¼ˆå¦‚\"çŒ«\"ã€\"ç‹—\"ï¼‰ï¼Œä½†è¿‡æ»¤å•å­—åŠ¨è¯å’Œå½¢å®¹è¯\n            tokens = [\n                w for w, flag in words \n                if (flag.startswith('n') or flag.startswith('v') or flag.startswith('a'))\n                and (len(w) > 1 or flag.startswith('n'))  # åè¯å¯ä»¥æ˜¯å•å­—\n            ]\n            \n            if tokens:\n                keywords = set(tokens)\n                \n                # æ·»åŠ bigramï¼ˆ2-gramï¼‰æé«˜å‡†ç¡®æ€§\n                if len(tokens) >= 2:\n                    bigrams = {f\"{tokens[i]}_{tokens[i+1]}\" for i in range(len(tokens)-1)}\n                    keywords.update(bigrams)\n                \n                logger.debug(f\"jiebaåˆ†è¯: {keywords}\")\n                return keywords\n        \n        except ImportError:\n            logger.debug(\"jiebaæœªå®‰è£…ï¼Œä½¿ç”¨ç®€å•åˆ†è¯\")\n        except Exception as e:\n            logger.debug(f\"jiebaåˆ†è¯å¤±è´¥: {e}\")\n        \n        # é™çº§åˆ°æ»‘åŠ¨çª—å£\n        import re\n        # æå–æ‰€æœ‰ä¸­æ–‡å­—ç¬¦\n        chinese_chars = re.findall(r'[\\u4e00-\\u9fa5]', text)\n        \n        if not chinese_chars:\n            return set()\n        \n        stopwords = {'çš„', 'äº†', 'æ˜¯', 'åœ¨', 'æˆ‘', 'æœ‰', 'å’Œ', 'å°±', 'ä¸', 'äºº', 'éƒ½', 'ä¸€', 'ä¸ª', 'ä¹ˆ', 'å—', 'å‘¢', 'å•Š', 'è¿™', 'é‚£', 'ä»€ä¹ˆ', 'æ€ä¹ˆ', 'å¯ä»¥', 'éœ€è¦', 'å»'}\n        \n        keywords = set()\n        \n        # æå–æ‰€æœ‰2-3å­—çš„è¿ç»­ç»„åˆï¼ˆæ»‘åŠ¨çª—å£ï¼‰\n        for i in range(len(chinese_chars)):\n            # 2å­—è¯\n            if i + 1 < len(chinese_chars):\n                word2 = ''.join(chinese_chars[i:i+2])\n                if word2 not in stopwords:\n                    keywords.add(word2)\n            \n            # 3å­—è¯\n            if i + 2 < len(chinese_chars):\n                word3 = ''.join(chinese_chars[i:i+3])\n                if word3 not in stopwords:\n                    keywords.add(word3)\n        \n        logger.debug(f\"ç®€å•åˆ†è¯(æ»‘åŠ¨çª—å£): {keywords}\")\n        return keywords\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 412,
"end": 426,
"text": "    def _update_topic_keywords(self, branch_id: str, message: str):\n        \"\"\"\n        æ›´æ–°åˆ†æ”¯çš„è¯é¢˜å…³é”®è¯\n        \n        Args:\n            branch_id: åˆ†æ”¯ID\n            message: æ¶ˆæ¯\n        \"\"\"\n        keywords = self._extract_keywords(message)\n        \n        if branch_id not in self._topic_keywords:\n            self._topic_keywords[branch_id] = set()\n        \n        self._topic_keywords[branch_id].update(keywords)\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 427,
"end": 434,
"text": "    def _get_last_conversation_id(self) -> Optional[str]:\n        \"\"\"è·å–æœ€åä¸€ä¸ªå¯¹è¯çš„ID\"\"\"\n        if not self._current_branch_id or self._current_branch_id not in self._branches:\n            return None\n        \n        branch_conversations = self._branches[self._current_branch_id]\n        return branch_conversations[-1] if branch_conversations else None\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 435,
"end": 467,
"text": "    def get_branch_conversations(\n        self,\n        branch_id: Optional[str] = None,\n        limit: Optional[int] = None\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        è·å–åˆ†æ”¯çš„æ‰€æœ‰å¯¹è¯\n        \n        Args:\n            branch_id: åˆ†æ”¯IDï¼ˆNoneè¡¨ç¤ºå½“å‰åˆ†æ”¯ï¼‰\n            limit: æœ€å¤šè¿”å›å¤šå°‘ä¸ªï¼ˆNoneè¡¨ç¤ºå…¨éƒ¨ï¼‰\n        \n        Returns:\n            å¯¹è¯åˆ—è¡¨\n        \"\"\"\n        if branch_id is None:\n            branch_id = self._current_branch_id\n        \n        if not branch_id or branch_id not in self._branches:\n            return []\n        \n        conversation_ids = self._branches[branch_id]\n        \n        if limit:\n            conversation_ids = conversation_ids[-limit:]\n        \n        conversations = []\n        for conv_id in conversation_ids:\n            if conv_id in self._nodes:\n                conversations.append(self._nodes[conv_id].to_dict())\n        \n        return conversations\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 468,
"end": 519,
"text": "    def get_relevant_conversations(\n        self,\n        current_message: str,\n        limit: int = 5,\n        strategy: str = 'auto'\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        è·å–ç›¸å…³å¯¹è¯ï¼ˆæ™ºèƒ½æ£€ç´¢ï¼‰\n        \n        ç­–ç•¥ï¼š\n        - 'current_branch': åªè¿”å›å½“å‰åˆ†æ”¯çš„å¯¹è¯\n        - 'keyword': åŸºäºå…³é”®è¯åŒ¹é…\n        - 'tree': åŸºäºæ ‘ç»“æ„ï¼ˆå½“å‰åˆ†æ”¯ + ç›¸å…³åˆ†æ”¯ï¼‰\n        - 'auto': è‡ªåŠ¨é€‰æ‹©ï¼ˆæ¨èï¼‰\n        \n        Args:\n            current_message: å½“å‰æ¶ˆæ¯\n            limit: æœ€å¤šè¿”å›å¤šå°‘ä¸ª\n            strategy: æ£€ç´¢ç­–ç•¥\n        \n        Returns:\n            ç›¸å…³å¯¹è¯åˆ—è¡¨\n        \"\"\"\n        if not self.enabled or not self._nodes:\n            return []\n        \n        # è‡ªåŠ¨é€‰æ‹©ç­–ç•¥\n        if strategy == 'auto':\n            if len(self._branches) == 1:\n                # åªæœ‰ä¸€ä¸ªåˆ†æ”¯ï¼Œä½¿ç”¨current_branch\n                strategy = 'current_branch'\n            elif len(self._branches) <= 3:\n                # åˆ†æ”¯è¾ƒå°‘ï¼Œä½¿ç”¨tree\n                strategy = 'tree'\n            else:\n                # åˆ†æ”¯è¾ƒå¤šï¼Œä½¿ç”¨keyword\n                strategy = 'keyword'\n        \n        # æ‰§è¡Œæ£€ç´¢\n        if strategy == 'current_branch':\n            return self._get_current_branch_conversations(limit)\n        \n        elif strategy == 'keyword':\n            return self._get_keyword_matched_conversations(current_message, limit)\n        \n        elif strategy == 'tree':\n            return self._get_tree_based_conversations(current_message, limit)\n        \n        else:\n            logger.warning(f\"æœªçŸ¥çš„æ£€ç´¢ç­–ç•¥: {strategy}ï¼Œä½¿ç”¨current_branch\")\n            return self._get_current_branch_conversations(limit)\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 520,
"end": 523,
"text": "    def _get_current_branch_conversations(self, limit: int) -> List[Dict[str, Any]]:\n        \"\"\"è·å–å½“å‰åˆ†æ”¯çš„å¯¹è¯\"\"\"\n        return self.get_branch_conversations(limit=limit)\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 524,
"end": 572,
"text": "    def _get_keyword_matched_conversations(\n        self,\n        current_message: str,\n        limit: int\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        åŸºäºå…³é”®è¯åŒ¹é…çš„æ£€ç´¢\n        \n        ç­–ç•¥ï¼š\n        1. æå–å½“å‰æ¶ˆæ¯çš„å…³é”®è¯\n        2. åœ¨æ‰€æœ‰å¯¹è¯ä¸­æŸ¥æ‰¾åŒ…å«ç›¸åŒå…³é”®è¯çš„å¯¹è¯\n        3. æŒ‰ç›¸å…³æ€§æ’åº\n        4. å§‹ç»ˆåŒ…å«æœ€è¿‘2è½®ï¼ˆä¿è¯è¿è´¯æ€§ï¼‰\n        \"\"\"\n        keywords = self._extract_keywords(current_message)\n        \n        if not keywords:\n            return self._get_current_branch_conversations(limit)\n        \n        # è®¡ç®—æ¯ä¸ªå¯¹è¯çš„ç›¸å…³æ€§åˆ†æ•°\n        scored_conversations = []\n        \n        for conv_id, node in self._nodes.items():\n            msg_keywords = self._extract_keywords(node.user_message)\n            overlap = len(keywords & msg_keywords)\n            \n            if overlap > 0:\n                score = overlap / len(keywords)\n                scored_conversations.append((conv_id, score))\n        \n        # æŒ‰åˆ†æ•°æ’åº\n        scored_conversations.sort(key=lambda x: x[1], reverse=True)\n        \n        # æå–top N-2ä¸ª\n        top_ids = {conv_id for conv_id, _ in scored_conversations[:limit-2]}\n        \n        # åŠ ä¸Šæœ€è¿‘2ä¸ªï¼ˆä¿è¯è¿è´¯æ€§ï¼‰\n        all_ids = list(self._nodes.keys())\n        recent_ids = set(all_ids[-2:]) if len(all_ids) >= 2 else set(all_ids)\n        \n        # åˆå¹¶å¹¶æ’åºï¼ˆæŒ‰æ—¶é—´ï¼‰\n        final_ids = sorted(top_ids | recent_ids, key=lambda x: self._nodes[x].timestamp)\n        \n        # é™åˆ¶æ•°é‡\n        if len(final_ids) > limit:\n            final_ids = final_ids[-limit:]\n        \n        return [self._nodes[conv_id].to_dict() for conv_id in final_ids]\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 573,
"end": 630,
"text": "    def _get_tree_based_conversations(\n        self,\n        current_message: str,\n        limit: int\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        åŸºäºæ ‘ç»“æ„çš„æ£€ç´¢\n        \n        ç­–ç•¥ï¼š\n        1. ä¼˜å…ˆè¿”å›å½“å‰åˆ†æ”¯çš„å¯¹è¯\n        2. å¦‚æœå½“å‰åˆ†æ”¯å¯¹è¯ä¸è¶³ï¼ŒæŸ¥æ‰¾ç›¸å…³åˆ†æ”¯\n        3. ç›¸å…³åˆ†æ”¯ï¼šè¯é¢˜å…³é”®è¯é‡å åº¦é«˜çš„åˆ†æ”¯\n        \"\"\"\n        # 1. è·å–å½“å‰åˆ†æ”¯çš„å¯¹è¯\n        current_branch_convs = self.get_branch_conversations(limit=limit)\n        \n        if len(current_branch_convs) >= limit:\n            return current_branch_convs[-limit:]\n        \n        # 2. éœ€è¦ä»å…¶ä»–åˆ†æ”¯è¡¥å……\n        needed = limit - len(current_branch_convs)\n        \n        # æå–å½“å‰æ¶ˆæ¯çš„å…³é”®è¯\n        keywords = self._extract_keywords(current_message)\n        \n        if not keywords:\n            return current_branch_convs\n        \n        # 3. æŸ¥æ‰¾ç›¸å…³åˆ†æ”¯\n        scored_branches = []\n        \n        for branch_id, branch_keywords in self._topic_keywords.items():\n            if branch_id == self._current_branch_id:\n                continue\n            \n            overlap = len(keywords & branch_keywords)\n            if overlap > 0:\n                score = overlap / len(keywords)\n                scored_branches.append((branch_id, score))\n        \n        # æŒ‰åˆ†æ•°æ’åº\n        scored_branches.sort(key=lambda x: x[1], reverse=True)\n        \n        # 4. ä»ç›¸å…³åˆ†æ”¯ä¸­æå–å¯¹è¯\n        additional_convs = []\n        \n        for branch_id, _ in scored_branches:\n            if len(additional_convs) >= needed:\n                break\n            \n            branch_convs = self.get_branch_conversations(branch_id, limit=needed)\n            additional_convs.extend(branch_convs)\n        \n        # 5. åˆå¹¶å¹¶é™åˆ¶æ•°é‡\n        all_convs = current_branch_convs + additional_convs[:needed]\n        \n        return all_convs[-limit:]\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 631,
"end": 644,
"text": "    def get_tree_stats(self) -> Dict[str, Any]:\n        \"\"\"è·å–æ ‘çš„ç»Ÿè®¡ä¿¡æ¯\"\"\"\n        return {\n            'enabled': self.enabled,\n            'total_conversations': len(self._nodes),\n            'total_branches': len(self._branches),\n            'current_branch_id': self._current_branch_id,\n            'max_depth': max((node.depth for node in self._nodes.values()), default=0),\n            'branches': {\n                branch_id: len(conv_ids)\n                for branch_id, conv_ids in self._branches.items()\n            }\n        }\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 645,
"end": 658,
"text": "    def visualize(self, format: str = 'ascii', **kwargs) -> str:\n        \"\"\"\n        å¯è§†åŒ–å¯¹è¯æ ‘\n        \n        Args:\n            format: æ ¼å¼ï¼ˆmermaid/ascii/json/htmlï¼‰\n            **kwargs: å…¶ä»–å‚æ•°\n        \n        Returns:\n            å¯è§†åŒ–å­—ç¬¦ä¸²\n        \"\"\"\n        from .tree_visualizer import visualize_tree\n        return visualize_tree(self, format=format, **kwargs)\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 659,
"end": 670,
"text": "    def export_visualization(self, filepath: str, format: str = 'auto'):\n        \"\"\"\n        å¯¼å‡ºå¯è§†åŒ–åˆ°æ–‡ä»¶\n        \n        Args:\n            filepath: æ–‡ä»¶è·¯å¾„\n            format: æ ¼å¼ï¼ˆauto/mermaid/ascii/json/htmlï¼‰\n        \"\"\"\n        from .tree_visualizer import TreeVisualizer\n        visualizer = TreeVisualizer(self)\n        visualizer.export_to_file(filepath, format=format)\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 671,
"end": 705,
"text": "    def load_from_history(self, history: List[Dict[str, Any]]):\n        \"\"\"\n        ä»å†å²å¯¹è¯ä¸­é‡å»ºæ ‘ç»“æ„\n        \n        Args:\n            history: å¯¹è¯å†å²åˆ—è¡¨\n        \"\"\"\n        if not self.enabled:\n            return\n        \n        for item in history:\n            metadata = item.get('metadata', {})\n            \n            # å¦‚æœå·²æœ‰æ ‘ç»“æ„å…ƒæ•°æ®ï¼Œç›´æ¥åŠ è½½\n            if 'conversation_id' in metadata:\n                node = ConversationNode.from_dict(item)\n                self._nodes[node.conversation_id] = node\n                \n                # æ›´æ–°åˆ†æ”¯\n                if node.branch_id not in self._branches:\n                    self._branches[node.branch_id] = []\n                self._branches[node.branch_id].append(node.conversation_id)\n                \n                # æ›´æ–°å½“å‰åˆ†æ”¯\n                self._current_branch_id = node.branch_id\n            else:\n                # æ²¡æœ‰å…ƒæ•°æ®ï¼Œé‡æ–°æ„å»º\n                self.add_conversation(\n                    user_message=item.get('user', ''),\n                    ai_response=item.get('ai', ''),\n                    detect_topic_switch=True\n                )\n        \n        logger.info(f\"ä»å†å²é‡å»ºæ ‘ç»“æ„: {len(self._nodes)}ä¸ªå¯¹è¯, {len(self._branches)}ä¸ªåˆ†æ”¯\")\n    "
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 706,
"end": 728,
"text": "    def export_to_history(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        å¯¼å‡ºä¸ºå†å²å¯¹è¯æ ¼å¼\n        \n        Returns:\n            å¯¹è¯å†å²åˆ—è¡¨ï¼ˆåŒ…å«æ ‘ç»“æ„å…ƒæ•°æ®ï¼‰\n        \"\"\"\n        if not self.enabled:\n            return []\n        \n        # æŒ‰æ—¶é—´æ’åº\n        sorted_nodes = sorted(\n            self._nodes.values(),\n            key=lambda x: x.timestamp\n        )\n        \n        return [node.to_dict() for node in sorted_nodes]\n\n\n# å•ä¾‹\n_conversation_tree = None\n\n"
},
{
"path": "daoyoucode/agents/memory/conversation_tree.py",
"start": 729,
"end": 736,
"text": "def get_conversation_tree(enabled: bool = True) -> ConversationTree:\n    \"\"\"è·å–å¯¹è¯æ ‘å•ä¾‹\"\"\"\n    global _conversation_tree\n    \n    if _conversation_tree is None:\n        _conversation_tree = ConversationTree(enabled=enabled)\n    \n    return _conversation_tree"
},
{
"path": "daoyoucode/agents/memory/detector.py",
"start": 1,
"end": 17,
"text": "\"\"\"\nè¿½é—®åˆ¤æ–­å™¨\nåˆ¤æ–­ç”¨æˆ·æ¶ˆæ¯æ˜¯å¦ä¸ºè¿½é—®ï¼ˆä¸Šä¸‹æ–‡å…³è”ï¼‰\n\nä¸‰å±‚ç€‘å¸ƒå¼ç®—æ³•ï¼š\n1. å¿«é€Ÿè§„åˆ™ï¼ˆ<1msï¼‰- æ˜æ˜¾çš„è¿½é—®/æ–°è¯é¢˜æ ‡å¿—\n2. å…³é”®è¯åŒ¹é…ï¼ˆ<5msï¼‰- è¯é¢˜ç›¸å…³æ€§\n3. è¯­ä¹‰ç›¸ä¼¼åº¦ï¼ˆå¯é€‰ï¼‰- æ·±åº¦è¯­ä¹‰ç†è§£\n\"\"\"\n\nimport re\nfrom typing import List, Dict, Tuple, Set\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/memory/detector.py",
"start": 18,
"end": 24,
"text": "class FollowupDetector:\n    \"\"\"\n    è¿½é—®åˆ¤æ–­å™¨\n    \n    æ ¸å¿ƒæ€æƒ³ï¼šåˆ¤æ–­æ˜¯å¦åœ¨è®¨è®ºåŒä¸€ä¸ªè¯é¢˜ï¼ˆä¸Šä¸‹æ–‡å…³è”ï¼‰\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/detector.py",
"start": 25,
"end": 93,
"text": "    def __init__(self):\n        # æ˜æ˜¾çš„è¿½é—®æ ‡å¿—è¯\n        self.followup_indicators = {\n            'ç»§ç»­', 'è¿˜æœ‰', 'é‚£', 'è¿™', 'å®ƒ', 'ä»–', 'å¥¹',\n            'å‘¢', 'å—', 'ä¹ˆ', 'å•Š', 'å“¦', 'å—¯',\n            'å†', 'åˆ', 'ä¹Ÿ', 'è¿˜', 'æ›´', 'å¦å¤–',\n            'è¯¦ç»†', 'å…·ä½“', 'æ€ä¹ˆ', 'ä¸ºä»€ä¹ˆ', 'å¦‚ä½•',\n            'åˆšæ‰', 'åˆšåˆš', 'ä¹‹å‰', 'ä¸Šé¢', 'å‰é¢'\n        }\n        \n        # æ–°è¯é¢˜æ ‡å¿—è¯\n        self.new_topic_indicators = {\n            'æ¢ä¸ª', 'å¦ä¸€ä¸ª', 'åˆ«çš„', 'å…¶ä»–',\n            'æ–°çš„', 'é‡æ–°', 'ä»å¤´', 'å¼€å§‹',\n            'ä¸æ˜¯', 'ä¸å¯¹', 'ç®—äº†', 'ä¸ç”¨'\n        }\n        \n        # åœç”¨è¯\n        self.stopwords = {\n            'çš„', 'äº†', 'æ˜¯', 'åœ¨', 'æˆ‘', 'æœ‰', 'å’Œ', 'å°±',\n            'ä¸', 'äºº', 'éƒ½', 'ä¸€', 'ä¸ª', 'ä¸Š', 'æ¥', 'åˆ°',\n            'è¯´', 'è¦', 'å»', 'ä½ ', 'ä¼š', 'ç€', 'æ²¡', 'çœ‹'\n        }\n    \n    async def is_followup(\n        self,\n        current_message: str,\n        history: List[Dict],\n        skill_name: str = None\n    ) -> Tuple[bool, float, str]:\n        \"\"\"\n        åˆ¤æ–­æ˜¯å¦ä¸ºè¿½é—®\n        \n        Args:\n            current_message: å½“å‰æ¶ˆæ¯\n            history: å¯¹è¯å†å²\n            skill_name: å½“å‰Skillåç§°\n        \n        Returns:\n            (is_followup, confidence, reason)\n        \"\"\"\n        if not history:\n            return False, 0.0, \"no_history\"\n        \n        # å±‚1: å¿«é€Ÿè§„åˆ™åˆ¤æ–­\n        is_followup, confidence, reason = self._rule_based_check(\n            current_message,\n            history\n        )\n        \n        if confidence >= 0.9:  # é«˜ç½®ä¿¡åº¦ï¼Œç›´æ¥è¿”å›\n            return is_followup, confidence, reason\n        \n        # å±‚2: å…³é”®è¯åŒ¹é…\n        keyword_followup, keyword_confidence, keyword_reason = \\\n            self._keyword_based_check(current_message, history)\n        \n        # ç»¼åˆåˆ¤æ–­\n        if confidence >= 0.7 or keyword_confidence >= 0.6:\n            # ä»»ä¸€æ–¹æ³•é«˜ç½®ä¿¡åº¦\n            final_followup = is_followup or keyword_followup\n            final_confidence = max(confidence, keyword_confidence)\n            final_reason = reason if confidence > keyword_confidence else keyword_reason\n            \n            return final_followup, final_confidence, final_reason\n        \n        # ä½ç½®ä¿¡åº¦ï¼Œåˆ¤æ–­ä¸ºæ–°è¯é¢˜\n        return False, max(confidence, keyword_confidence), \"low_confidence\"\n    "
},
{
"path": "daoyoucode/agents/memory/detector.py",
"start": 94,
"end": 128,
"text": "    def _rule_based_check(\n        self,\n        current_message: str,\n        history: List[Dict]\n    ) -> Tuple[bool, float, str]:\n        \"\"\"\n        è§„åˆ™åˆ¤æ–­ï¼ˆå¿«é€Ÿï¼‰\n        \n        Returns:\n            (is_followup, confidence, reason)\n        \"\"\"\n        # 1. æ£€æŸ¥è¿½é—®æ ‡å¿—è¯\n        for indicator in self.followup_indicators:\n            if indicator in current_message:\n                return True, 0.95, f\"followup_indicator:{indicator}\"\n        \n        # 2. æ£€æŸ¥æ–°è¯é¢˜æ ‡å¿—è¯\n        for indicator in self.new_topic_indicators:\n            if indicator in current_message:\n                return False, 0.95, f\"new_topic_indicator:{indicator}\"\n        \n        # 3. æ£€æŸ¥æ¶ˆæ¯é•¿åº¦ï¼ˆå¾ˆçŸ­çš„æ¶ˆæ¯é€šå¸¸æ˜¯è¿½é—®ï¼‰\n        if len(current_message) <= 5:\n            # æ£€æŸ¥æ˜¯å¦æ˜¯ç®€å•å›åº”\n            simple_responses = {'å¥½', 'å—¯', 'æ˜¯', 'å¯¹', 'è¡Œ', 'å¯ä»¥', 'è°¢è°¢', 'å¥½çš„', 'æ˜ç™½'}\n            if current_message.strip() in simple_responses:\n                return True, 0.9, \"simple_response\"\n        \n        # 4. æ£€æŸ¥ç–‘é—®è¯ï¼ˆå¯èƒ½æ˜¯è¿½é—®ï¼‰\n        question_words = ['ä»€ä¹ˆ', 'æ€ä¹ˆ', 'ä¸ºä»€ä¹ˆ', 'å¦‚ä½•', 'å“ª', 'è°', 'å¤šå°‘']\n        if any(qw in current_message for qw in question_words):\n            return True, 0.6, \"question_word\"\n        \n        return False, 0.3, \"no_rule_match\"\n    "
},
{
"path": "daoyoucode/agents/memory/detector.py",
"start": 129,
"end": 172,
"text": "    def _keyword_based_check(\n        self,\n        current_message: str,\n        history: List[Dict]\n    ) -> Tuple[bool, float, str]:\n        \"\"\"\n        å…³é”®è¯åŒ¹é…åˆ¤æ–­\n        \n        Returns:\n            (is_followup, confidence, reason)\n        \"\"\"\n        # æå–å½“å‰æ¶ˆæ¯çš„å…³é”®è¯\n        current_keywords = self._extract_keywords(current_message)\n        \n        if not current_keywords:\n            return False, 0.0, \"no_keywords\"\n        \n        # æ£€æŸ¥æœ€è¿‘3è½®å¯¹è¯çš„å…³é”®è¯é‡å \n        max_overlap = 0\n        max_overlap_round = 0\n        \n        for idx, item in enumerate(history[-3:], 1):\n            user_msg = item.get('user', '')\n            if not user_msg:\n                continue\n            \n            # æå–å†å²æ¶ˆæ¯çš„å…³é”®è¯\n            history_keywords = self._extract_keywords(user_msg)\n            \n            # è®¡ç®—é‡å åº¦\n            overlap = len(current_keywords & history_keywords)\n            \n            if overlap > max_overlap:\n                max_overlap = overlap\n                max_overlap_round = idx\n        \n        # è®¡ç®—ç½®ä¿¡åº¦\n        if max_overlap > 0:\n            confidence = min(0.9, max_overlap / len(current_keywords))\n            reason = f\"keyword_overlap:{max_overlap}/{len(current_keywords)}_round{max_overlap_round}\"\n            return True, confidence, reason\n        \n        return False, 0.0, \"no_keyword_overlap\"\n    "
},
{
"path": "daoyoucode/agents/memory/detector.py",
"start": 173,
"end": 192,
"text": "    def _extract_keywords(self, text: str) -> Set[str]:\n        \"\"\"\n        æå–å…³é”®è¯ï¼ˆç®€å•åˆ†è¯ï¼‰\n        \n        Args:\n            text: æ–‡æœ¬\n        \n        Returns:\n            å…³é”®è¯é›†åˆ\n        \"\"\"\n        # ä½¿ç”¨æ­£åˆ™æå–ä¸­æ–‡è¯ï¼ˆ2ä¸ªå­—ä»¥ä¸Šï¼‰\n        words = re.findall(r'[\\u4e00-\\u9fa5]{2,}', text)\n        \n        # è¿‡æ»¤åœç”¨è¯\n        keywords = {\n            w for w in words\n            if w not in self.stopwords\n        }\n        \n        return keywords"
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 1,
"end": 62,
"text": "\"\"\"\nMemoryåŠ è½½ç­–ç•¥é…ç½®\n\næ”¯æŒä»é…ç½®æ–‡ä»¶åŠ è½½ç­–ç•¥ï¼Œå®ç°çµæ´»é…ç½®\n\"\"\"\n\nimport yaml\nimport json\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\n# é»˜è®¤ç­–ç•¥é…ç½®\nDEFAULT_STRATEGIES = {\n    # æ–°å¯¹è¯ï¼šä¸åŠ è½½\n    'new_conversation': {\n        'load_history': False,\n        'load_summary': False,\n        'load_profile': False,\n        'cost': 0,\n        'description': 'æ–°å¯¹è¯ï¼Œä¸åŠ è½½ä»»ä½•è®°å¿†'\n    },\n    # ç®€å•è¿½é—®ï¼ˆ2è½®å†…ï¼‰\n    'simple_followup': {\n        'load_history': True,\n        'history_limit': 2,\n        'load_summary': False,\n        'load_profile': False,\n        'cost': 1,\n        'description': 'ç®€å•è¿½é—®ï¼ŒåŠ è½½æœ€è¿‘2è½®'\n    },\n    # ä¸­ç­‰è¿½é—®ï¼ˆ3-5è½®ï¼‰\n    'medium_followup': {\n        'load_history': True,\n        'history_limit': 3,\n        'load_summary': False,\n        'cost': 2,\n        'description': 'ä¸­ç­‰è¿½é—®ï¼ŒåŠ è½½æœ€è¿‘3è½®'\n    },\n    # å¤æ‚è¿½é—®ï¼ˆ>5è½®ï¼‰\n    'complex_followup': {\n        'load_history': True,\n        'history_limit': 2,  # åªåŠ è½½æœ€è¿‘2è½®\n        'load_summary': True,  # åŠ è½½æ‘˜è¦ä»£æ›¿æ—©æœŸå¯¹è¯\n        'cost': 3,\n        'description': 'å¤æ‚è¿½é—®ï¼ŒåŠ è½½æ‘˜è¦+æœ€è¿‘2è½®'\n    },\n    # è·¨sessionï¼ˆéœ€è¦å‘é‡æ£€ç´¢ï¼‰\n    'cross_session': {\n        'load_history': True,\n        'history_limit': 3,\n        'load_summary': True,\n        'use_vector_search': True,  # ä½¿ç”¨å‘é‡æ£€ç´¢\n        'cost': 5,\n        'description': 'è·¨sessionï¼Œä½¿ç”¨å‘é‡æ£€ç´¢'\n    }\n}\n\n"
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 63,
"end": 74,
"text": "class LoadStrategyConfig:\n    \"\"\"\n    åŠ è½½ç­–ç•¥é…ç½®ç®¡ç†å™¨\n    \n    åŠŸèƒ½ï¼š\n    1. ä»é…ç½®æ–‡ä»¶åŠ è½½ç­–ç•¥\n    2. æ”¯æŒYAMLå’ŒJSONæ ¼å¼\n    3. æä¾›é»˜è®¤ç­–ç•¥\n    4. éªŒè¯é…ç½®æœ‰æ•ˆæ€§\n    5. æ”¯æŒçƒ­é‡è½½\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 75,
"end": 90,
"text": "    def __init__(self, config_path: Optional[str] = None):\n        \"\"\"\n        åˆå§‹åŒ–é…ç½®ç®¡ç†å™¨\n        \n        Args:\n            config_path: é…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰\n        \"\"\"\n        self.config_path = config_path\n        self.strategies = DEFAULT_STRATEGIES.copy()\n        \n        # å¦‚æœæä¾›äº†é…ç½®æ–‡ä»¶ï¼ŒåŠ è½½å®ƒ\n        if config_path:\n            self.load_from_file(config_path)\n        else:\n            logger.info(\"ä½¿ç”¨é»˜è®¤åŠ è½½ç­–ç•¥é…ç½®\")\n    "
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 91,
"end": 135,
"text": "    def load_from_file(self, config_path: str) -> bool:\n        \"\"\"\n        ä»æ–‡ä»¶åŠ è½½é…ç½®\n        \n        Args:\n            config_path: é…ç½®æ–‡ä»¶è·¯å¾„\n        \n        Returns:\n            æ˜¯å¦åŠ è½½æˆåŠŸ\n        \"\"\"\n        try:\n            path = Path(config_path)\n            \n            if not path.exists():\n                logger.warning(f\"é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_path}ï¼Œä½¿ç”¨é»˜è®¤é…ç½®\")\n                return False\n            \n            # æ ¹æ®æ–‡ä»¶æ‰©å±•åé€‰æ‹©è§£æå™¨\n            if path.suffix in ['.yaml', '.yml']:\n                with open(path, 'r', encoding='utf-8') as f:\n                    config = yaml.safe_load(f)\n            elif path.suffix == '.json':\n                with open(path, 'r', encoding='utf-8') as f:\n                    config = json.load(f)\n            else:\n                logger.error(f\"ä¸æ”¯æŒçš„é…ç½®æ–‡ä»¶æ ¼å¼: {path.suffix}\")\n                return False\n            \n            # éªŒè¯é…ç½®\n            if not self._validate_config(config):\n                logger.error(\"é…ç½®éªŒè¯å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®\")\n                return False\n            \n            # åˆå¹¶é…ç½®ï¼ˆç”¨æˆ·é…ç½®è¦†ç›–é»˜è®¤é…ç½®ï¼‰\n            self.strategies.update(config.get('strategies', {}))\n            \n            logger.info(f\"âœ… åŠ è½½ç­–ç•¥é…ç½®: {config_path}\")\n            logger.info(f\"   ç­–ç•¥æ•°é‡: {len(self.strategies)}\")\n            \n            return True\n        \n        except Exception as e:\n            logger.error(f\"åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥: {e}\", exc_info=True)\n            return False\n    "
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 136,
"end": 171,
"text": "    def _validate_config(self, config: Dict[str, Any]) -> bool:\n        \"\"\"\n        éªŒè¯é…ç½®æœ‰æ•ˆæ€§\n        \n        Args:\n            config: é…ç½®å­—å…¸\n        \n        Returns:\n            æ˜¯å¦æœ‰æ•ˆ\n        \"\"\"\n        if not isinstance(config, dict):\n            logger.error(\"é…ç½®å¿…é¡»æ˜¯å­—å…¸\")\n            return False\n        \n        if 'strategies' not in config:\n            logger.error(\"é…ç½®ç¼ºå°‘ 'strategies' å­—æ®µ\")\n            return False\n        \n        strategies = config['strategies']\n        if not isinstance(strategies, dict):\n            logger.error(\"'strategies' å¿…é¡»æ˜¯å­—å…¸\")\n            return False\n        \n        # éªŒè¯æ¯ä¸ªç­–ç•¥\n        for name, strategy in strategies.items():\n            if not isinstance(strategy, dict):\n                logger.error(f\"ç­–ç•¥ '{name}' å¿…é¡»æ˜¯å­—å…¸\")\n                return False\n            \n            # æ£€æŸ¥å¿…éœ€å­—æ®µ\n            if 'cost' not in strategy:\n                logger.warning(f\"ç­–ç•¥ '{name}' ç¼ºå°‘ 'cost' å­—æ®µï¼Œä½¿ç”¨é»˜è®¤å€¼0\")\n                strategy['cost'] = 0\n        \n        return True\n    "
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 172,
"end": 183,
"text": "    def get_strategy(self, name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        è·å–ç­–ç•¥é…ç½®\n        \n        Args:\n            name: ç­–ç•¥åç§°\n        \n        Returns:\n            ç­–ç•¥é…ç½®å­—å…¸\n        \"\"\"\n        return self.strategies.get(name)\n    "
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 184,
"end": 187,
"text": "    def get_all_strategies(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"è·å–æ‰€æœ‰ç­–ç•¥\"\"\"\n        return self.strategies.copy()\n    "
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 188,
"end": 198,
"text": "    def add_strategy(self, name: str, config: Dict[str, Any]):\n        \"\"\"\n        æ·»åŠ æˆ–æ›´æ–°ç­–ç•¥\n        \n        Args:\n            name: ç­–ç•¥åç§°\n            config: ç­–ç•¥é…ç½®\n        \"\"\"\n        self.strategies[name] = config\n        logger.info(f\"æ·»åŠ /æ›´æ–°ç­–ç•¥: {name}\")\n    "
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 199,
"end": 214,
"text": "    def remove_strategy(self, name: str) -> bool:\n        \"\"\"\n        åˆ é™¤ç­–ç•¥\n        \n        Args:\n            name: ç­–ç•¥åç§°\n        \n        Returns:\n            æ˜¯å¦åˆ é™¤æˆåŠŸ\n        \"\"\"\n        if name in self.strategies:\n            del self.strategies[name]\n            logger.info(f\"åˆ é™¤ç­–ç•¥: {name}\")\n            return True\n        return False\n    "
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 215,
"end": 256,
"text": "    def save_to_file(self, config_path: Optional[str] = None) -> bool:\n        \"\"\"\n        ä¿å­˜é…ç½®åˆ°æ–‡ä»¶\n        \n        Args:\n            config_path: é…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä½¿ç”¨åˆå§‹åŒ–æ—¶çš„è·¯å¾„ï¼‰\n        \n        Returns:\n            æ˜¯å¦ä¿å­˜æˆåŠŸ\n        \"\"\"\n        path = config_path or self.config_path\n        \n        if not path:\n            logger.error(\"æœªæŒ‡å®šé…ç½®æ–‡ä»¶è·¯å¾„\")\n            return False\n        \n        try:\n            path = Path(path)\n            path.parent.mkdir(parents=True, exist_ok=True)\n            \n            config = {\n                'strategies': self.strategies\n            }\n            \n            # æ ¹æ®æ–‡ä»¶æ‰©å±•åé€‰æ‹©æ ¼å¼\n            if path.suffix in ['.yaml', '.yml']:\n                with open(path, 'w', encoding='utf-8') as f:\n                    yaml.dump(config, f, allow_unicode=True, default_flow_style=False)\n            elif path.suffix == '.json':\n                with open(path, 'w', encoding='utf-8') as f:\n                    json.dump(config, f, ensure_ascii=False, indent=2)\n            else:\n                logger.error(f\"ä¸æ”¯æŒçš„é…ç½®æ–‡ä»¶æ ¼å¼: {path.suffix}\")\n                return False\n            \n            logger.info(f\"âœ… ä¿å­˜ç­–ç•¥é…ç½®: {path}\")\n            return True\n        \n        except Exception as e:\n            logger.error(f\"ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥: {e}\", exc_info=True)\n            return False\n    "
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 257,
"end": 292,
"text": "    def export_default_config(self, output_path: str) -> bool:\n        \"\"\"\n        å¯¼å‡ºé»˜è®¤é…ç½®åˆ°æ–‡ä»¶ï¼ˆç”¨äºç”Ÿæˆæ¨¡æ¿ï¼‰\n        \n        Args:\n            output_path: è¾“å‡ºæ–‡ä»¶è·¯å¾„\n        \n        Returns:\n            æ˜¯å¦å¯¼å‡ºæˆåŠŸ\n        \"\"\"\n        try:\n            path = Path(output_path)\n            path.parent.mkdir(parents=True, exist_ok=True)\n            \n            config = {\n                'strategies': DEFAULT_STRATEGIES\n            }\n            \n            # æ ¹æ®æ–‡ä»¶æ‰©å±•åé€‰æ‹©æ ¼å¼\n            if path.suffix in ['.yaml', '.yml']:\n                with open(path, 'w', encoding='utf-8') as f:\n                    yaml.dump(config, f, allow_unicode=True, default_flow_style=False)\n            elif path.suffix == '.json':\n                with open(path, 'w', encoding='utf-8') as f:\n                    json.dump(config, f, ensure_ascii=False, indent=2)\n            else:\n                logger.error(f\"ä¸æ”¯æŒçš„é…ç½®æ–‡ä»¶æ ¼å¼: {path.suffix}\")\n                return False\n            \n            logger.info(f\"âœ… å¯¼å‡ºé»˜è®¤é…ç½®: {output_path}\")\n            return True\n        \n        except Exception as e:\n            logger.error(f\"å¯¼å‡ºé»˜è®¤é…ç½®å¤±è´¥: {e}\", exc_info=True)\n            return False\n    "
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 293,
"end": 306,
"text": "    def reload(self) -> bool:\n        \"\"\"\n        é‡æ–°åŠ è½½é…ç½®ï¼ˆçƒ­é‡è½½ï¼‰\n        \n        Returns:\n            æ˜¯å¦é‡è½½æˆåŠŸ\n        \"\"\"\n        if not self.config_path:\n            logger.warning(\"æœªæŒ‡å®šé…ç½®æ–‡ä»¶è·¯å¾„ï¼Œæ— æ³•é‡è½½\")\n            return False\n        \n        logger.info(\"é‡æ–°åŠ è½½é…ç½®...\")\n        return self.load_from_file(self.config_path)\n    "
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 307,
"end": 320,
"text": "    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"è·å–é…ç½®ç»Ÿè®¡ä¿¡æ¯\"\"\"\n        return {\n            'total_strategies': len(self.strategies),\n            'strategy_names': list(self.strategies.keys()),\n            'config_path': self.config_path,\n            'using_default': self.config_path is None\n        }\n\n\n# å…¨å±€é…ç½®å®ä¾‹\n_config_instance: Optional[LoadStrategyConfig] = None\n\n"
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 321,
"end": 338,
"text": "def get_load_strategy_config(config_path: Optional[str] = None) -> LoadStrategyConfig:\n    \"\"\"\n    è·å–åŠ è½½ç­–ç•¥é…ç½®å®ä¾‹ï¼ˆå•ä¾‹ï¼‰\n    \n    Args:\n        config_path: é…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼Œä»…é¦–æ¬¡è°ƒç”¨æ—¶æœ‰æ•ˆï¼‰\n    \n    Returns:\n        LoadStrategyConfigå®ä¾‹\n    \"\"\"\n    global _config_instance\n    \n    if _config_instance is None:\n        _config_instance = LoadStrategyConfig(config_path)\n    \n    return _config_instance\n\n"
},
{
"path": "daoyoucode/agents/memory/load_strategy_config.py",
"start": 339,
"end": 347,
"text": "def set_load_strategy_config(config: LoadStrategyConfig):\n    \"\"\"\n    è®¾ç½®å…¨å±€é…ç½®å®ä¾‹\n    \n    Args:\n        config: LoadStrategyConfigå®ä¾‹\n    \"\"\"\n    global _config_instance\n    _config_instance = config"
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 1,
"end": 22,
"text": "\"\"\"\né•¿æœŸè®°å¿†ç®¡ç†å™¨\n\nåŠŸèƒ½ï¼š\n1. å¯¹è¯æ‘˜è¦ï¼ˆæ¯Nè½®è‡ªåŠ¨ç”Ÿæˆï¼‰\n2. å…³é”®ä¿¡æ¯æå–ï¼ˆç—‡çŠ¶ã€è¯Šæ–­ã€å»ºè®®ç­‰ï¼‰\n3. ç”¨æˆ·ç”»åƒï¼ˆåå¥½ã€å†å²é—®é¢˜ç­‰ï¼‰\n\nå­˜å‚¨å±‚æ¬¡ï¼š\n- çŸ­æœŸè®°å¿†ï¼šæœ€è¿‘10è½®å¯¹è¯ï¼ˆå†…å­˜ï¼Œ1å°æ—¶ï¼‰\n- ä¸­æœŸè®°å¿†ï¼šå¯¹è¯æ‘˜è¦ï¼ˆå†…å­˜ï¼Œ1å¤©ï¼‰\n- é•¿æœŸè®°å¿†ï¼šç”¨æˆ·ç”»åƒï¼ˆå†…å­˜ï¼Œ30å¤©ï¼‰\n\"\"\"\n\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nimport json\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 23,
"end": 34,
"text": "class LongTermMemory:\n    \"\"\"\n    é•¿æœŸè®°å¿†ç®¡ç†å™¨\n    \n    è®¾è®¡åŸåˆ™ï¼š\n    1. åˆ†å±‚å­˜å‚¨ï¼šçŸ­æœŸã€ä¸­æœŸã€é•¿æœŸ\n    2. è‡ªåŠ¨æ‘˜è¦ï¼šæ¯5è½®å¯¹è¯ç”Ÿæˆæ‘˜è¦\n    3. å…³é”®æå–ï¼šç»“æ„åŒ–ä¿¡æ¯æå–\n    4. ç”¨æˆ·ç”»åƒï¼šåå¥½ã€å†å²é—®é¢˜\n    5. ç¼“å­˜å±‚ï¼šå‡å°‘æ–‡ä»¶I/O\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 35,
"end": 126,
"text": "    def __init__(self, storage=None):\n        \"\"\"\n        åˆå§‹åŒ–é•¿æœŸè®°å¿†ç®¡ç†å™¨\n        \n        Args:\n            storage: MemoryStorageå®ä¾‹ï¼ˆç”¨äºå­˜å‚¨ï¼‰\n        \"\"\"\n        self.storage = storage\n        self.summary_interval = 5  # æ¯Nè½®ç”Ÿæˆä¸€æ¬¡æ‘˜è¦ï¼ˆå¯é…ç½®ï¼‰\n        self.summary_min_messages = 3  # æœ€å°‘éœ€è¦Nè½®æ‰ç”Ÿæˆæ‘˜è¦\n        \n        # ç¼“å­˜å±‚\n        from ..core.cache import get_profile_cache, get_summary_cache\n        self.profile_cache = get_profile_cache()\n        self.summary_cache = get_summary_cache()\n        \n        logger.info(\"é•¿æœŸè®°å¿†ç®¡ç†å™¨å·²åˆå§‹åŒ–ï¼ˆå¸¦ç¼“å­˜ï¼‰\")\n    \n    async def generate_summary(\n        self,\n        session_id: str,\n        history: List[Dict],\n        llm_client\n    ) -> str:\n        \"\"\"\n        ç”Ÿæˆå¯¹è¯æ‘˜è¦\n        \n        Args:\n            session_id: ä¼šè¯ID\n            history: å¯¹è¯å†å²\n            llm_client: LLMå®¢æˆ·ç«¯ï¼ˆç”¨äºç”Ÿæˆæ‘˜è¦ï¼‰\n        \n        Returns:\n            æ‘˜è¦æ–‡æœ¬\n        \"\"\"\n        if not history:\n            return \"\"\n        \n        # æ„å»ºæ‘˜è¦prompt\n        conversation = []\n        for item in history:\n            user_msg = item.get('user', '')\n            ai_resp = item.get('ai', '')\n            \n            conversation.append(f\"ç”¨æˆ·: {user_msg}\")\n            conversation.append(f\"AI: {ai_resp}\")\n        \n        conversation_text = \"\\n\".join(conversation)\n        \n        summary_prompt = f\"\"\"è¯·å¯¹ä»¥ä¸‹å¯¹è¯è¿›è¡Œç®€æ´çš„æ‘˜è¦ï¼Œæå–å…³é”®ä¿¡æ¯ï¼š\n\n{conversation_text}\n\nè¦æ±‚ï¼š\n1. æå–ä¸»è¦è®¨è®ºçš„è¯é¢˜\n2. æå–å…³é”®é—®é¢˜å’Œç­”æ¡ˆ\n3. æå–å·²ç»™å‡ºçš„å»ºè®®\n4. æ§åˆ¶åœ¨200å­—ä»¥å†…\n\næ‘˜è¦æ ¼å¼ï¼š\nã€ä¸»è¦è¯é¢˜ã€‘...\nã€å…³é”®é—®é¢˜ã€‘...\nã€å·²ç»™å»ºè®®ã€‘...\n\"\"\"\n        \n        try:\n            # è°ƒç”¨LLMç”Ÿæˆæ‘˜è¦\n            from ..llm.base import LLMRequest\n            request = LLMRequest(\n                prompt=summary_prompt,\n                model=llm_client.model,\n                temperature=0.3,\n                max_tokens=300\n            )\n            response = await llm_client.chat(request)\n            \n            summary = response.content.strip()\n            \n            # ä¿å­˜æ‘˜è¦åˆ°å­˜å‚¨\n            if self.storage:\n                self.storage.save_summary(session_id, summary)\n            \n            # ç¼“å­˜æ‘˜è¦ï¼ˆTTL: 30åˆ†é’Ÿï¼‰\n            self.summary_cache.set(session_id, summary, ttl=1800)\n            \n            logger.info(f\"âœ… ç”Ÿæˆå¯¹è¯æ‘˜è¦: session={session_id}, length={len(summary)}\")\n            return summary\n        \n        except Exception as e:\n            logger.error(f\"âŒ ç”Ÿæˆæ‘˜è¦å¤±è´¥: {e}\", exc_info=True)\n            return \"\"\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 127,
"end": 224,
"text": "    def get_summary(self, session_id: str) -> Optional[str]:\n        \"\"\"\n        è·å–ä¼šè¯æ‘˜è¦ï¼ˆå¸¦ç¼“å­˜ï¼‰\n        \n        Args:\n            session_id: ä¼šè¯ID\n        \n        Returns:\n            æ‘˜è¦æ–‡æœ¬\n        \"\"\"\n        # å°è¯•ä»ç¼“å­˜è·å–\n        cached = self.summary_cache.get(session_id)\n        if cached is not None:\n            logger.debug(f\"æ‘˜è¦ç¼“å­˜å‘½ä¸­: {session_id}\")\n            return cached\n        \n        # ä»å­˜å‚¨è·å–\n        if not self.storage:\n            return None\n        \n        summary = self.storage.get_summary(session_id)\n        \n        # ç¼“å­˜ç»“æœï¼ˆTTL: 30åˆ†é’Ÿï¼‰\n        if summary:\n            self.summary_cache.set(session_id, summary, ttl=1800)\n        \n        return summary\n    \n    async def extract_key_info(\n        self,\n        session_id: str,\n        history: List[Dict],\n        llm_client\n    ) -> Dict[str, Any]:\n        \"\"\"\n        æå–å…³é”®ä¿¡æ¯ï¼ˆç»“æ„åŒ–ï¼‰\n        \n        Returns:\n            {\n                \"main_topics\": [\"è¯é¢˜1\", \"è¯é¢˜2\"],\n                \"key_questions\": [\"é—®é¢˜1\", \"é—®é¢˜2\"],\n                \"suggestions\": [\"å»ºè®®1\", \"å»ºè®®2\"],\n                \"decisions\": [\"å†³ç­–1\", \"å†³ç­–2\"]\n            }\n        \"\"\"\n        if not history:\n            return {}\n        \n        # æ„å»ºæå–prompt\n        conversation = []\n        for item in history[-5:]:  # åªçœ‹æœ€è¿‘5è½®\n            user_msg = item.get('user', '')\n            ai_resp = item.get('ai', '')\n            \n            conversation.append(f\"ç”¨æˆ·: {user_msg}\")\n            conversation.append(f\"AI: {ai_resp}\")\n        \n        conversation_text = \"\\n\".join(conversation)\n        \n        extract_prompt = f\"\"\"ä»ä»¥ä¸‹å¯¹è¯ä¸­æå–å…³é”®ä¿¡æ¯ï¼Œä»¥JSONæ ¼å¼è¿”å›ï¼š\n\n{conversation_text}\n\nè¯·æå–ï¼š\n1. main_topics: ä¸»è¦è®¨è®ºçš„è¯é¢˜åˆ—è¡¨\n2. key_questions: å…³é”®é—®é¢˜åˆ—è¡¨\n3. suggestions: å·²ç»™å‡ºçš„å»ºè®®åˆ—è¡¨\n4. decisions: åšå‡ºçš„å†³ç­–åˆ—è¡¨\n\nè¿”å›JSONæ ¼å¼ï¼Œå¦‚æœæŸé¡¹ä¿¡æ¯æ²¡æœ‰åˆ™ä¸ºç©ºåˆ—è¡¨ã€‚\n\"\"\"\n        \n        try:\n            # è°ƒç”¨LLMæå–å…³é”®ä¿¡æ¯\n            response = await llm_client.chat(\n                messages=[{\"role\": \"user\", \"content\": extract_prompt}],\n                temperature=0.1,\n                max_tokens=500\n            )\n            \n            # è§£æJSON\n            import re\n            json_match = re.search(r'\\{.*\\}', response.content, re.DOTALL)\n            if json_match:\n                key_info = json.loads(json_match.group())\n                \n                # ä¿å­˜åˆ°å­˜å‚¨\n                if self.storage:\n                    self.storage.save_key_info(session_id, key_info)\n                \n                logger.info(f\"âœ… æå–å…³é”®ä¿¡æ¯: session={session_id}\")\n                return key_info\n            \n        except Exception as e:\n            logger.error(f\"âŒ æå–å…³é”®ä¿¡æ¯å¤±è´¥: {e}\", exc_info=True)\n        \n        return {}\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 225,
"end": 325,
"text": "    def get_key_info(self, session_id: str) -> Optional[Dict]:\n        \"\"\"è·å–å…³é”®ä¿¡æ¯\"\"\"\n        if not self.storage:\n            return None\n        \n        return self.storage.get_key_info(session_id)\n    \n    async def build_user_profile(\n        self,\n        user_id: str,\n        all_sessions: List[str] = None,\n        llm_client = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        æ„å»ºç”¨æˆ·ç”»åƒï¼ˆè·¨sessionï¼‰\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n            all_sessions: è¯¥ç”¨æˆ·çš„æ‰€æœ‰sessionåˆ—è¡¨ï¼ˆå¯é€‰ï¼Œè‡ªåŠ¨æ”¶é›†ï¼‰\n            llm_client: LLMå®¢æˆ·ç«¯ï¼ˆå¯é€‰ï¼Œç”¨äºæ™ºèƒ½åˆ†æï¼‰\n        \n        Returns:\n            {\n                \"user_id\": \"user_123\",\n                \"common_topics\": [\"è¯é¢˜1\", \"è¯é¢˜2\"],\n                \"skill_level\": \"intermediate\",\n                \"preferred_style\": \"functional\",\n                \"activity_pattern\": \"evening\",\n                \"total_conversations\": 10,\n                \"total_sessions\": 5,\n                \"last_updated\": \"2026-02-15T12:00:00\"\n            }\n        \"\"\"\n        # 1. æ”¶é›†æ‰€æœ‰ä¼šè¯æ•°æ®\n        if all_sessions is None:\n            all_sessions = self._collect_user_sessions(user_id)\n        \n        # 2. åŸºç¡€ç»Ÿè®¡\n        profile = {\n            \"user_id\": user_id,\n            \"total_sessions\": len(all_sessions),\n            \"total_conversations\": 0,\n            \"last_updated\": datetime.now().isoformat()\n        }\n        \n        # 3. èšåˆæ‰€æœ‰sessionçš„æ•°æ®\n        all_conversations = []\n        all_key_info = []\n        \n        for session_id in all_sessions:\n            # è·å–å¯¹è¯å†å²\n            history = self.storage.get_conversation_history(session_id) if self.storage else []\n            all_conversations.extend(history)\n            profile['total_conversations'] += len(history)\n            \n            # è·å–å…³é”®ä¿¡æ¯\n            key_info = self.get_key_info(session_id)\n            if key_info:\n                all_key_info.append(key_info)\n        \n        # 4. æå–å¸¸è§è¯é¢˜\n        profile['common_topics'] = self._extract_common_topics(all_conversations, all_key_info)\n        \n        # 5. åˆ†ææŠ€èƒ½æ°´å¹³\n        profile['skill_level'] = self._analyze_skill_level(all_conversations)\n        \n        # 6. åˆ†æåå¥½é£æ ¼\n        profile['preferred_style'] = self._analyze_preferred_style(all_conversations)\n        \n        # 7. åˆ†ææ´»åŠ¨æ¨¡å¼\n        profile['activity_pattern'] = self._analyze_activity_pattern(all_conversations)\n        \n        # 8. æå–æœ€è¿‘é¡¹ç›®\n        profile['recent_projects'] = self._extract_recent_projects(all_conversations)\n        \n        # 9. å¦‚æœæœ‰LLMï¼Œè¿›è¡Œæ·±åº¦åˆ†æ\n        if llm_client and all_conversations:\n            try:\n                deep_analysis = await self._deep_analyze_with_llm(\n                    user_id, all_conversations, llm_client\n                )\n                profile.update(deep_analysis)\n            except Exception as e:\n                logger.warning(f\"LLMæ·±åº¦åˆ†æå¤±è´¥: {e}\")\n        \n        # 10. ä¿å­˜åˆ°å­˜å‚¨\n        if self.storage:\n            self.storage.save_user_profile(user_id, profile)\n        \n        # ç¼“å­˜ç”»åƒï¼ˆTTL: 1å°æ—¶ï¼‰\n        self.profile_cache.set(user_id, profile, ttl=3600)\n        \n        logger.info(\n            f\"âœ… æ„å»ºç”¨æˆ·ç”»åƒ: user_id={user_id}, \"\n            f\"sessions={len(all_sessions)}, \"\n            f\"conversations={profile['total_conversations']}, \"\n            f\"topics={len(profile['common_topics'])}\"\n        )\n        \n        return profile\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 326,
"end": 340,
"text": "    def _collect_user_sessions(self, user_id: str) -> List[str]:\n        \"\"\"\n        æ”¶é›†ç”¨æˆ·çš„æ‰€æœ‰ä¼šè¯ID\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n        \n        Returns:\n            ä¼šè¯IDåˆ—è¡¨\n        \"\"\"\n        if not self.storage:\n            return []\n        \n        return self.storage.get_user_sessions(user_id)\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 341,
"end": 373,
"text": "    def _extract_common_topics(\n        self,\n        conversations: List[Dict],\n        key_info_list: List[Dict]\n    ) -> List[str]:\n        \"\"\"æå–å¸¸è§è¯é¢˜\"\"\"\n        from collections import Counter\n        \n        all_topics = []\n        \n        # ä»å…³é”®ä¿¡æ¯ä¸­æå–\n        for info in key_info_list:\n            topics = info.get('main_topics', [])\n            all_topics.extend(topics)\n        \n        # ä»å¯¹è¯ä¸­æå–å…³é”®è¯\n        keywords = [\n            'python', 'javascript', 'java', 'go', 'rust',\n            'testing', 'refactoring', 'performance', 'debugging',\n            'api', 'database', 'frontend', 'backend',\n            'docker', 'kubernetes', 'ci/cd'\n        ]\n        \n        for conv in conversations:\n            user_msg = conv.get('user', '').lower()\n            for keyword in keywords:\n                if keyword in user_msg:\n                    all_topics.append(keyword)\n        \n        # ç»Ÿè®¡é¢‘ç‡ï¼Œè¿”å›å‰5ä¸ª\n        topic_counter = Counter(all_topics)\n        return [t for t, _ in topic_counter.most_common(5)]\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 374,
"end": 402,
"text": "    def _analyze_skill_level(self, conversations: List[Dict]) -> str:\n        \"\"\"åˆ†ææŠ€èƒ½æ°´å¹³\"\"\"\n        if not conversations:\n            return 'unknown'\n        \n        # ç®€å•å¯å‘å¼è§„åˆ™\n        total = len(conversations)\n        \n        # ç»Ÿè®¡å¤æ‚é—®é¢˜çš„æ¯”ä¾‹\n        complex_indicators = [\n            'architecture', 'design pattern', 'optimization',\n            'performance', 'scalability', 'concurrency'\n        ]\n        \n        complex_count = 0\n        for conv in conversations:\n            user_msg = conv.get('user', '').lower()\n            if any(indicator in user_msg for indicator in complex_indicators):\n                complex_count += 1\n        \n        complex_ratio = complex_count / total if total > 0 else 0\n        \n        if complex_ratio > 0.3:\n            return 'advanced'\n        elif complex_ratio > 0.1:\n            return 'intermediate'\n        else:\n            return 'beginner'\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 403,
"end": 426,
"text": "    def _analyze_preferred_style(self, conversations: List[Dict]) -> str:\n        \"\"\"åˆ†æåå¥½é£æ ¼\"\"\"\n        if not conversations:\n            return 'unknown'\n        \n        # ç»Ÿè®¡é£æ ¼å…³é”®è¯\n        style_keywords = {\n            'functional': ['functional', 'lambda', 'map', 'filter', 'reduce'],\n            'oop': ['class', 'object', 'inheritance', 'polymorphism'],\n            'procedural': ['function', 'procedure', 'step by step']\n        }\n        \n        style_counts = {style: 0 for style in style_keywords}\n        \n        for conv in conversations:\n            user_msg = conv.get('user', '').lower()\n            for style, keywords in style_keywords.items():\n                if any(kw in user_msg for kw in keywords):\n                    style_counts[style] += 1\n        \n        # è¿”å›æœ€å¸¸è§çš„é£æ ¼\n        max_style = max(style_counts, key=style_counts.get)\n        return max_style if style_counts[max_style] > 0 else 'unknown'\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 427,
"end": 460,
"text": "    def _analyze_activity_pattern(self, conversations: List[Dict]) -> str:\n        \"\"\"åˆ†ææ´»åŠ¨æ¨¡å¼\"\"\"\n        if not conversations:\n            return 'unknown'\n        \n        # ç»Ÿè®¡æ—¶é—´æˆ³ï¼ˆå¦‚æœæœ‰ï¼‰\n        from collections import Counter\n        \n        hours = []\n        for conv in conversations:\n            timestamp = conv.get('timestamp')\n            if timestamp:\n                try:\n                    dt = datetime.fromisoformat(timestamp)\n                    hours.append(dt.hour)\n                except:\n                    pass\n        \n        if not hours:\n            return 'unknown'\n        \n        # åˆ†ææ—¶æ®µ\n        hour_counter = Counter(hours)\n        avg_hour = sum(hours) / len(hours)\n        \n        if 6 <= avg_hour < 12:\n            return 'morning'\n        elif 12 <= avg_hour < 18:\n            return 'afternoon'\n        elif 18 <= avg_hour < 24:\n            return 'evening'\n        else:\n            return 'night'\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 461,
"end": 587,
"text": "    def _extract_recent_projects(self, conversations: List[Dict]) -> List[str]:\n        \"\"\"æå–æœ€è¿‘é¡¹ç›®\"\"\"\n        projects = []\n        \n        # æŸ¥æ‰¾é¡¹ç›®ç›¸å…³çš„å…³é”®è¯\n        project_indicators = ['project', 'é¡¹ç›®', 'working on', 'åœ¨åš']\n        \n        for conv in conversations[-20:]:  # åªçœ‹æœ€è¿‘20è½®\n            user_msg = conv.get('user', '')\n            \n            # ç®€å•æå–ï¼ˆå®é™…åº”è¯¥ç”¨NERï¼‰\n            if any(indicator in user_msg.lower() for indicator in project_indicators):\n                # æå–é¡¹ç›®åç§°ï¼ˆç®€åŒ–å®ç°ï¼‰\n                words = user_msg.split()\n                for i, word in enumerate(words):\n                    if word.lower() in project_indicators and i + 1 < len(words):\n                        project_name = words[i + 1].strip(',.!?')\n                        if project_name and len(project_name) > 2:\n                            projects.append(project_name)\n        \n        # å»é‡å¹¶è¿”å›æœ€è¿‘3ä¸ª\n        seen = set()\n        unique_projects = []\n        for p in reversed(projects):\n            if p not in seen:\n                seen.add(p)\n                unique_projects.append(p)\n        \n        return unique_projects[:3]\n    \n    async def _deep_analyze_with_llm(\n        self,\n        user_id: str,\n        conversations: List[Dict],\n        llm_client\n    ) -> Dict[str, Any]:\n        \"\"\"ä½¿ç”¨LLMè¿›è¡Œæ·±åº¦åˆ†æ\"\"\"\n        # é‡‡æ ·å¯¹è¯ï¼ˆé¿å…tokenè¿‡å¤šï¼‰\n        sample_size = min(20, len(conversations))\n        sampled = conversations[-sample_size:]\n        \n        # æ„å»ºåˆ†æprompt\n        conv_text = \"\\n\".join([\n            f\"User: {c.get('user', '')}\\nAI: {c.get('ai', '')[:100]}...\"\n            for c in sampled\n        ])\n        \n        prompt = f\"\"\"åˆ†æä»¥ä¸‹å¯¹è¯è®°å½•ï¼Œæå–ç”¨æˆ·ç”»åƒã€‚åªè¾“å‡ºä¸€ä¸ª JSON å¯¹è±¡ï¼Œä¸è¦ä»»ä½•è§£é‡Šã€ä¸è¦ markdown ä»£ç å—ã€ä¸è¦å…¶ä»–æ–‡å­—ã€‚\n\nå¯¹è¯è®°å½•ï¼š\n{conv_text}\n\nå¿…é¡»åªè¾“å‡ºå¦‚ä¸‹æ ¼å¼çš„å•ä¸€ JSONï¼ˆä¸è¦æ¢è¡Œå¤–çš„å†…å®¹ï¼‰ï¼š\n{{\"interests\": [], \"learning_goals\": [], \"pain_points\": [], \"communication_style\": \"ç®€æ´\"}}\n\"\"\"\n        \n        try:\n            from ..llm.base import LLMRequest\n            \n            request = LLMRequest(\n                prompt=prompt,\n                model=llm_client.model,\n                temperature=0.3\n            )\n            \n            response = await llm_client.chat(request)\n            \n            # æ£€æŸ¥å“åº”æ˜¯å¦ä¸ºç©º\n            if not response.content or not response.content.strip():\n                logger.warning(\"LLMè¿”å›ç©ºå“åº”ï¼Œè·³è¿‡æ·±åº¦åˆ†æ\")\n                return {}\n            \n            # è§£æJSONå“åº”ï¼ˆLLM å¸¸è¿”å›è¯´æ˜+JSONï¼Œéœ€ç¨³å¥æå–ï¼‰\n            import json\n            \n            content = response.content.strip()\n            # å»æ‰ ```json ... ``` åŒ…è£¹\n            if '```json' in content:\n                start = content.find('```json') + 7\n                end = content.find('```', start)\n                content = content[start:end].strip() if end > start else content\n            elif content.startswith('```'):\n                content = content[3:]\n                if content.endswith('```'):\n                    content = content[:-3]\n                content = content.strip()\n            # ä»ç¬¬ä¸€ä¸ª { å¼€å§‹æ‰¾å®Œæ•´ JSON å¯¹è±¡ï¼ˆå…¼å®¹å‰é¢æœ‰è¯´æ˜æ–‡å­—ï¼‰\n            first_brace = content.find('{')\n            if first_brace >= 0:\n                brace_count = 0\n                json_end = -1\n                for i in range(first_brace, len(content)):\n                    if content[i] == '{':\n                        brace_count += 1\n                    elif content[i] == '}':\n                        brace_count -= 1\n                        if brace_count == 0:\n                            json_end = i + 1\n                            break\n                if json_end > first_brace:\n                    content = content[first_brace:json_end]\n            if not content.strip().startswith('{'):\n                logger.warning(\"LLMæ·±åº¦åˆ†ææœªè¿”å›æœ‰æ•ˆJSONï¼Œè·³è¿‡\")\n                return {}\n            \n            analysis = json.loads(content)\n            \n            return {\n                'interests': analysis.get('interests', []),\n                'learning_goals': analysis.get('learning_goals', []),\n                'pain_points': analysis.get('pain_points', []),\n                'communication_st"
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 588,
"end": 615,
"text": "    def should_update_profile(\n        self,\n        user_id: str,\n        current_conversation_count: int\n    ) -> bool:\n        \"\"\"\n        åˆ¤æ–­æ˜¯å¦åº”è¯¥æ›´æ–°ç”¨æˆ·ç”»åƒ\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n            current_conversation_count: å½“å‰å¯¹è¯æ€»æ•°\n        \n        Returns:\n            æ˜¯å¦åº”è¯¥æ›´æ–°\n        \"\"\"\n        # è·å–ç°æœ‰ç”»åƒ\n        profile = self.get_user_profile(user_id)\n        \n        if not profile:\n            # æ²¡æœ‰ç”»åƒï¼Œä¸”å¯¹è¯æ•°>=10ï¼Œåˆ›å»ºç”»åƒ\n            return current_conversation_count >= 10\n        \n        # æœ‰ç”»åƒï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°\n        last_count = profile.get('total_conversations', 0)\n        \n        # æ¯å¢åŠ 20è½®å¯¹è¯ï¼Œæ›´æ–°ä¸€æ¬¡\n        return current_conversation_count - last_count >= 20\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 616,
"end": 643,
"text": "    def get_user_profile(self, user_id: str) -> Optional[Dict]:\n        \"\"\"\n        è·å–ç”¨æˆ·ç”»åƒï¼ˆå¸¦ç¼“å­˜ï¼‰\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n        \n        Returns:\n            ç”¨æˆ·ç”»åƒå­—å…¸\n        \"\"\"\n        # å°è¯•ä»ç¼“å­˜è·å–\n        cached = self.profile_cache.get(user_id)\n        if cached is not None:\n            logger.debug(f\"ç”»åƒç¼“å­˜å‘½ä¸­: {user_id}\")\n            return cached\n        \n        # ä»å­˜å‚¨è·å–\n        if not self.storage:\n            return None\n        \n        profile = self.storage.get_user_profile(user_id)\n        \n        # ç¼“å­˜ç»“æœï¼ˆTTL: 1å°æ—¶ï¼‰\n        if profile:\n            self.profile_cache.set(user_id, profile, ttl=3600)\n        \n        return profile\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 644,
"end": 680,
"text": "    def should_generate_summary(\n        self,\n        session_id: str,\n        current_round: int\n    ) -> bool:\n        \"\"\"\n        åˆ¤æ–­æ˜¯å¦åº”è¯¥ç”Ÿæˆæ‘˜è¦ï¼ˆæ™ºèƒ½è§¦å‘ï¼‰\n        \n        ç­–ç•¥ï¼š\n        1. è‡³å°‘Nè½®å¯¹è¯ï¼ˆé¿å…å¤ªæ—©ç”Ÿæˆï¼‰\n        2. æ¯Nè½®ç”Ÿæˆä¸€æ¬¡\n        3. å¦‚æœå·²æœ‰æ‘˜è¦ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°\n        \n        Args:\n            session_id: ä¼šè¯ID\n            current_round: å½“å‰è½®æ•°\n        \n        Returns:\n            æ˜¯å¦åº”è¯¥ç”Ÿæˆæ‘˜è¦\n        \"\"\"\n        # 1. è‡³å°‘éœ€è¦æœ€å°‘è½®æ•°\n        if current_round < self.summary_min_messages:\n            return False\n        \n        # 2. æ¯Nè½®ç”Ÿæˆä¸€æ¬¡\n        if current_round % self.summary_interval == 0:\n            return True\n        \n        # 3. æ£€æŸ¥æ˜¯å¦å·²æœ‰æ‘˜è¦\n        existing_summary = self.get_summary(session_id)\n        \n        # å¦‚æœæ²¡æœ‰æ‘˜è¦ï¼Œä¸”è½®æ•°>=æœ€å°‘è½®æ•°ï¼Œç”Ÿæˆä¸€æ¬¡\n        if not existing_summary and current_round >= self.summary_min_messages:\n            return True\n        \n        return False\n    "
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 681,
"end": 731,
"text": "    def get_context_with_memory(\n        self,\n        session_id: str,\n        user_id: str,\n        recent_history: List[Dict],\n        current_message: str\n    ) -> str:\n        \"\"\"\n        è·å–å®Œæ•´ä¸Šä¸‹æ–‡ï¼ˆçŸ­æœŸ + ä¸­æœŸ + é•¿æœŸï¼‰\n        \n        Args:\n            session_id: ä¼šè¯ID\n            user_id: ç”¨æˆ·ID\n            recent_history: æœ€è¿‘çš„å¯¹è¯å†å²\n            current_message: å½“å‰æ¶ˆæ¯\n        \n        Returns:\n            æ ¼å¼åŒ–çš„ä¸Šä¸‹æ–‡æ–‡æœ¬\n        \"\"\"\n        context_parts = []\n        \n        # 1. é•¿æœŸè®°å¿†ï¼šç”¨æˆ·ç”»åƒ\n        profile = self.get_user_profile(user_id)\n        if profile and profile.get('common_topics'):\n            topics = \", \".join(profile['common_topics'][:3])\n            context_parts.append(f\"ã€ç”¨æˆ·ç”»åƒã€‘å¸¸è®¨è®ºçš„è¯é¢˜ï¼š{topics}\")\n        \n        # 2. ä¸­æœŸè®°å¿†ï¼šå¯¹è¯æ‘˜è¦\n        summary = self.get_summary(session_id)\n        if summary:\n            context_parts.append(f\"ã€å¯¹è¯æ‘˜è¦ã€‘\\n{summary}\")\n        \n        # 3. çŸ­æœŸè®°å¿†ï¼šæœ€è¿‘å¯¹è¯\n        if recent_history:\n            recent_lines = []\n            for idx, item in enumerate(recent_history[-3:], 1):\n                user_msg = item.get('user', '')\n                ai_text = item.get('ai', '')[:200]\n                \n                recent_lines.append(f\"[ç¬¬{idx}è½®]\")\n                recent_lines.append(f\"ç”¨æˆ·: {user_msg}\")\n                recent_lines.append(f\"AI: {ai_text}\")\n            \n            context_parts.append(f\"ã€æœ€è¿‘å¯¹è¯ã€‘\\n\" + \"\\n\".join(recent_lines))\n        \n        return \"\\n\\n\".join(context_parts)\n\n\n# å•ä¾‹\n_long_term_memory = None\n"
},
{
"path": "daoyoucode/agents/memory/long_term_memory.py",
"start": 732,
"end": 737,
"text": "def get_long_term_memory(storage=None) -> LongTermMemory:\n    \"\"\"è·å–é•¿æœŸè®°å¿†ç®¡ç†å™¨å•ä¾‹\"\"\"\n    global _long_term_memory\n    if _long_term_memory is None:\n        _long_term_memory = LongTermMemory(storage)\n    return _long_term_memory"
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 1,
"end": 16,
"text": "\"\"\"\nç»Ÿä¸€çš„è®°å¿†ç®¡ç†å™¨\næ•´åˆæ‰€æœ‰è®°å¿†åŠŸèƒ½\n\"\"\"\n\nfrom typing import Dict, List, Optional, Any\nimport logging\n\nfrom .storage import MemoryStorage\nfrom .detector import FollowupDetector\nfrom .shared import SharedMemoryInterface\nfrom ..core.cache import get_profile_cache, get_summary_cache, get_history_cache, get_preference_cache\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 17,
"end": 29,
"text": "class MemoryManager:\n    \"\"\"\n    ç»Ÿä¸€çš„è®°å¿†ç®¡ç†å™¨\n    \n    èŒè´£ï¼š\n    1. ç®¡ç†å¯¹è¯å†å²ï¼ˆLLMå±‚ï¼‰\n    2. ç®¡ç†ç”¨æˆ·åå¥½ï¼ˆAgentå±‚ï¼‰\n    3. ç®¡ç†ä»»åŠ¡å†å²ï¼ˆAgentå±‚ï¼‰\n    4. åˆ¤æ–­è¿½é—®\n    5. æä¾›å¤šæ™ºèƒ½ä½“å…±äº«æ¥å£\n    6. ç¼“å­˜å±‚ï¼ˆå‡å°‘æ–‡ä»¶I/Oï¼‰\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 30,
"end": 65,
"text": "    def __init__(self, enable_tree: bool = True):\n        \"\"\"\n        åˆå§‹åŒ–è®°å¿†ç®¡ç†å™¨\n        \n        Args:\n            enable_tree: æ˜¯å¦å¯ç”¨å¯¹è¯æ ‘ï¼ˆé»˜è®¤å¯ç”¨ï¼‰\n        \"\"\"\n        self.storage = MemoryStorage()\n        self.detector = FollowupDetector()\n        \n        # ========== ç¼“å­˜å±‚ ==========\n        self.profile_cache = get_profile_cache()\n        self.summary_cache = get_summary_cache()\n        self.history_cache = get_history_cache()\n        self.preference_cache = get_preference_cache()\n        \n        # ========== æ–°å¢ï¼šé•¿æœŸè®°å¿†å’Œæ™ºèƒ½åŠ è½½ ==========\n        from .long_term_memory import LongTermMemory\n        from .smart_loader import SmartLoader\n        \n        self.long_term_memory = LongTermMemory(storage=self.storage)\n        self.smart_loader = SmartLoader(enable_tree=enable_tree)\n        \n        # ========== å¯¹è¯æ ‘ï¼ˆå¯é€‰ï¼‰==========\n        self.enable_tree = enable_tree\n        self._conversation_tree = None\n        \n        if enable_tree:\n            from .conversation_tree import get_conversation_tree\n            self._conversation_tree = get_conversation_tree(enabled=True)\n            logger.info(\"è®°å¿†ç®¡ç†å™¨å·²åˆå§‹åŒ–ï¼ˆå¢å¼ºç‰ˆ + å¯¹è¯æ ‘ + ç¼“å­˜å±‚ï¼‰\")\n        else:\n            logger.info(\"è®°å¿†ç®¡ç†å™¨å·²åˆå§‹åŒ–ï¼ˆå¢å¼ºç‰ˆ + ç¼“å­˜å±‚ï¼‰\")\n    \n    # ========== LLMå±‚è®°å¿†ï¼ˆå¯¹è¯å†å²ï¼‰==========\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 66,
"end": 111,
"text": "    def add_conversation(\n        self,\n        session_id: str,\n        user_message: str,\n        ai_response: str,\n        metadata: Optional[Dict] = None,\n        user_id: Optional[str] = None\n    ):\n        \"\"\"\n        æ·»åŠ å¯¹è¯\n        \n        Args:\n            session_id: ä¼šè¯ID\n            user_message: ç”¨æˆ·æ¶ˆæ¯\n            ai_response: AIå“åº”\n            metadata: å…ƒæ•°æ®\n            user_id: ç”¨æˆ·IDï¼ˆå¯é€‰ï¼Œç”¨äºç»´æŠ¤æ˜ å°„ï¼‰\n        \"\"\"\n        # å¦‚æœå¯ç”¨äº†å¯¹è¯æ ‘ï¼Œå…ˆæ·»åŠ åˆ°æ ‘ä¸­\n        if self.enable_tree and self._conversation_tree:\n            node = self._conversation_tree.add_conversation(\n                user_message=user_message,\n                ai_response=ai_response,\n                detect_topic_switch=True\n            )\n            \n            # ä½¿ç”¨æ ‘èŠ‚ç‚¹çš„å…ƒæ•°æ®\n            if metadata is None:\n                metadata = {}\n            metadata.update(node.to_dict()['metadata'])\n        \n        # æ·»åŠ åˆ°å­˜å‚¨\n        self.storage.add_conversation(\n            session_id,\n            user_message,\n            ai_response,\n            metadata,\n            user_id=user_id\n        )\n        \n        # æ¸…é™¤å†å²ç¼“å­˜ï¼ˆå› ä¸ºæ•°æ®å·²æ›´æ–°ï¼‰\n        # æ¸…é™¤æ‰€æœ‰ç›¸å…³çš„ç¼“å­˜é”®\n        for limit in [None, 1, 2, 3, 5, 10]:\n            cache_key = f\"{session_id}:{limit or 'all'}\"\n            self.history_cache.delete(cache_key)\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 112,
"end": 154,
"text": "    def get_conversation_history(\n        self,\n        session_id: str,\n        limit: Optional[int] = None\n    ) -> List[Dict]:\n        \"\"\"\n        è·å–å¯¹è¯å†å²ï¼ˆå¸¦ç¼“å­˜ï¼‰\n        \n        Args:\n            session_id: ä¼šè¯ID\n            limit: é™åˆ¶æ•°é‡\n        \n        Returns:\n            å¯¹è¯å†å²åˆ—è¡¨\n        \"\"\"\n        # æ„å»ºç¼“å­˜é”®\n        cache_key = f\"{session_id}:{limit or 'all'}\"\n        \n        # å°è¯•ä»ç¼“å­˜è·å–\n        cached = self.history_cache.get(cache_key)\n        if cached is not None:\n            logger.debug(f\"å†å²ç¼“å­˜å‘½ä¸­: {session_id}\")\n            return cached\n        \n        # ä»å­˜å‚¨è·å–\n        history = self.storage.get_conversation_history(session_id, limit)\n        \n        # ç¼“å­˜ç»“æœï¼ˆTTL: 5åˆ†é’Ÿï¼‰\n        self.history_cache.set(cache_key, history, ttl=300)\n        \n        return history\n    \n    async def is_followup(\n        self,\n        session_id: str,\n        current_message: str\n    ) -> tuple[bool, float, str]:\n        \"\"\"åˆ¤æ–­æ˜¯å¦ä¸ºè¿½é—®\"\"\"\n        history = self.get_conversation_history(session_id)\n        return await self.detector.is_followup(current_message, history)\n    \n    # ========== Agentå±‚è®°å¿†ï¼ˆç”¨æˆ·åå¥½ï¼‰==========\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 155,
"end": 173,
"text": "    def remember_preference(\n        self,\n        user_id: str,\n        key: str,\n        value: Any\n    ):\n        \"\"\"\n        è®°ä½ç”¨æˆ·åå¥½\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n            key: åå¥½é”®\n            value: åå¥½å€¼\n        \"\"\"\n        self.storage.add_preference(user_id, key, value)\n        \n        # æ¸…é™¤åå¥½ç¼“å­˜ï¼ˆå› ä¸ºæ•°æ®å·²æ›´æ–°ï¼‰\n        self.preference_cache.delete(user_id)\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 174,
"end": 202,
"text": "    def get_preferences(\n        self,\n        user_id: str\n    ) -> Dict[str, Any]:\n        \"\"\"\n        è·å–ç”¨æˆ·åå¥½ï¼ˆå¸¦ç¼“å­˜ï¼‰\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n        \n        Returns:\n            ç”¨æˆ·åå¥½å­—å…¸\n        \"\"\"\n        # å°è¯•ä»ç¼“å­˜è·å–\n        cached = self.preference_cache.get(user_id)\n        if cached is not None:\n            logger.debug(f\"åå¥½ç¼“å­˜å‘½ä¸­: {user_id}\")\n            return cached\n        \n        # ä»å­˜å‚¨è·å–\n        prefs = self.storage.get_preferences(user_id)\n        \n        # ç¼“å­˜ç»“æœï¼ˆTTL: 1å°æ—¶ï¼‰\n        self.preference_cache.set(user_id, prefs, ttl=3600)\n        \n        return prefs\n    \n    # ========== Agentå±‚è®°å¿†ï¼ˆä»»åŠ¡å†å²ï¼‰==========\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 203,
"end": 210,
"text": "    def add_task(\n        self,\n        user_id: str,\n        task: Dict[str, Any]\n    ):\n        \"\"\"æ·»åŠ ä»»åŠ¡åˆ°å†å²\"\"\"\n        self.storage.add_task(user_id, task)\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 211,
"end": 220,
"text": "    def get_task_history(\n        self,\n        user_id: str,\n        limit: int = 10\n    ) -> List[Dict]:\n        \"\"\"è·å–ä»»åŠ¡å†å²\"\"\"\n        return self.storage.get_task_history(user_id, limit)\n    \n    # ========== å¤šæ™ºèƒ½ä½“å…±äº«æ¥å£ ==========\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 221,
"end": 237,
"text": "    def get_shared_context(\n        self,\n        session_id: str,\n        agent_names: List[str]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        è·å–å¤šæ™ºèƒ½ä½“å…±äº«ä¸Šä¸‹æ–‡\n        \n        Args:\n            session_id: ä¼šè¯ID\n            agent_names: å‚ä¸çš„Agentåç§°åˆ—è¡¨\n        \n        Returns:\n            å…±äº«ä¸Šä¸‹æ–‡å­—å…¸\n        \"\"\"\n        return self.storage.get_shared_context(session_id, agent_names)\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 238,
"end": 260,
"text": "    def update_shared_context(\n        self,\n        session_id: str,\n        agent_name: str,\n        key: str,\n        value: Any\n    ):\n        \"\"\"\n        æ›´æ–°å…±äº«ä¸Šä¸‹æ–‡\n        \n        Args:\n            session_id: ä¼šè¯ID\n            agent_name: Agentåç§°\n            key: é”®\n            value: å€¼\n        \"\"\"\n        self.storage.update_shared_context(\n            session_id,\n            agent_name,\n            key,\n            value\n        )\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 261,
"end": 270,
"text": "    def create_shared_memory(\n        self,\n        session_id: str,\n        agent_names: List[str]\n    ) -> SharedMemoryInterface:\n        \"\"\"åˆ›å»ºå…±äº«è®°å¿†æ¥å£\"\"\"\n        return SharedMemoryInterface(self, session_id, agent_names)\n    \n    # ========== ç”¨æˆ·ä¼šè¯æ˜ å°„ ==========\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 271,
"end": 282,
"text": "    def get_user_sessions(self, user_id: str) -> List[str]:\n        \"\"\"\n        è·å–ç”¨æˆ·çš„æ‰€æœ‰ä¼šè¯ID\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n        \n        Returns:\n            ä¼šè¯IDåˆ—è¡¨\n        \"\"\"\n        return self.storage.get_user_sessions(user_id)\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 283,
"end": 345,
"text": "    def get_session_user(self, session_id: str) -> Optional[str]:\n        \"\"\"\n        è·å–ä¼šè¯å¯¹åº”çš„ç”¨æˆ·ID\n        \n        Args:\n            session_id: ä¼šè¯ID\n        \n        Returns:\n            ç”¨æˆ·ID\n        \"\"\"\n        return self.storage.get_session_user(session_id)\n    \n    # ========== æ–°å¢ï¼šæ™ºèƒ½åŠ è½½æ¥å£ ==========\n    \n    async def load_context_smart(\n        self,\n        session_id: str,\n        user_id: str,\n        user_input: str,\n        is_followup: bool = False,\n        confidence: float = 0.0\n    ) -> Dict[str, Any]:\n        \"\"\"\n        æ™ºèƒ½åŠ è½½ä¸Šä¸‹æ–‡ï¼ˆæ ¸å¿ƒæ–¹æ³•ï¼‰\n        \n        Args:\n            session_id: ä¼šè¯ID\n            user_id: ç”¨æˆ·ID\n            user_input: ç”¨æˆ·è¾“å…¥\n            is_followup: æ˜¯å¦ä¸ºè¿½é—®\n            confidence: è¿½é—®ç½®ä¿¡åº¦\n        \n        Returns:\n            åŠ è½½çš„ä¸Šä¸‹æ–‡æ•°æ®\n        \"\"\"\n        # è·å–å†å²æ•°é‡\n        history = self.get_conversation_history(session_id)\n        history_count = len(history)\n        \n        # æ£€æŸ¥æ˜¯å¦æœ‰æ‘˜è¦\n        has_summary = self.long_term_memory.get_summary(session_id) is not None\n        \n        # å†³å®šåŠ è½½ç­–ç•¥\n        strategy, config = await self.smart_loader.decide_load_strategy(\n            is_followup=is_followup,\n            confidence=confidence,\n            history_count=history_count,\n            has_summary=has_summary,\n            current_message=user_input\n        )\n        \n        # åŠ è½½ä¸Šä¸‹æ–‡\n        context = await self.smart_loader.load_context(\n            strategy_name=strategy,\n            strategy_config=config,\n            memory_manager=self,\n            session_id=session_id,\n            user_id=user_id,\n            current_message=user_input\n        )\n        \n        return context\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 346,
"end": 364,
"text": "    def format_context_for_prompt(\n        self,\n        context: Dict[str, Any],\n        current_message: str\n    ) -> str:\n        \"\"\"\n        æ ¼å¼åŒ–ä¸Šä¸‹æ–‡ä¸ºLLM prompt\n        \n        Args:\n            context: åŠ è½½çš„ä¸Šä¸‹æ–‡\n            current_message: å½“å‰æ¶ˆæ¯\n        \n        Returns:\n            æ ¼å¼åŒ–çš„promptæ–‡æœ¬\n        \"\"\"\n        return self.smart_loader.format_context_for_prompt(context, current_message)\n    \n    # ========== å·¥å…·æ–¹æ³• ==========\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 365,
"end": 368,
"text": "    def clear_session(self, session_id: str):\n        \"\"\"æ¸…é™¤ä¼šè¯\"\"\"\n        self.storage.clear_session(session_id)\n    "
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 369,
"end": 383,
"text": "    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"è·å–ç»Ÿè®¡ä¿¡æ¯\"\"\"\n        stats = self.storage.get_stats()\n        \n        # æ·»åŠ å¯¹è¯æ ‘ç»Ÿè®¡\n        if self.enable_tree and self._conversation_tree:\n            stats['tree'] = self._conversation_tree.get_tree_stats()\n        \n        return stats\n\n\n# å•ä¾‹æ¨¡å¼\n_memory_manager_instance = None\n\n"
},
{
"path": "daoyoucode/agents/memory/manager.py",
"start": 384,
"end": 392,
"text": "def get_memory_manager() -> MemoryManager:\n    \"\"\"è·å–è®°å¿†ç®¡ç†å™¨å•ä¾‹\"\"\"\n    global _memory_manager_instance\n    \n    if _memory_manager_instance is None:\n        _memory_manager_instance = MemoryManager()\n        logger.info(\"è®°å¿†ç®¡ç†å™¨å•ä¾‹å·²åˆ›å»º\")\n    \n    return _memory_manager_instance"
},
{
"path": "daoyoucode/agents/memory/shared.py",
"start": 1,
"end": 11,
"text": "\"\"\"\nå¤šæ™ºèƒ½ä½“å…±äº«æ¥å£\næä¾›ä¾¿æ·çš„å¤šæ™ºèƒ½ä½“è®°å¿†è®¿é—®æ–¹æ³•\n\"\"\"\n\nfrom typing import Dict, List, Any, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from .manager import MemoryManager\n\n"
},
{
"path": "daoyoucode/agents/memory/shared.py",
"start": 12,
"end": 18,
"text": "class SharedMemoryInterface:\n    \"\"\"\n    å¤šæ™ºèƒ½ä½“å…±äº«è®°å¿†æ¥å£\n    \n    ç”¨äºå¤šæ™ºèƒ½ä½“åä½œæ—¶çš„è®°å¿†å…±äº«\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/shared.py",
"start": 19,
"end": 23,
"text": "    def __init__(self, memory: 'MemoryManager', session_id: str, agent_names: List[str]):\n        self.memory = memory\n        self.session_id = session_id\n        self.agent_names = agent_names\n    "
},
{
"path": "daoyoucode/agents/memory/shared.py",
"start": 24,
"end": 30,
"text": "    def get_context(self) -> Dict[str, Any]:\n        \"\"\"è·å–å…±äº«ä¸Šä¸‹æ–‡\"\"\"\n        return self.memory.get_shared_context(\n            self.session_id,\n            self.agent_names\n        )\n    "
},
{
"path": "daoyoucode/agents/memory/shared.py",
"start": 31,
"end": 39,
"text": "    def set_shared(self, key: str, value: Any):\n        \"\"\"è®¾ç½®å…±äº«æ•°æ®ï¼ˆæ‰€æœ‰Agentå¯è§ï¼‰\"\"\"\n        self.memory.update_shared_context(\n            self.session_id,\n            'shared',\n            key,\n            value\n        )\n    "
},
{
"path": "daoyoucode/agents/memory/shared.py",
"start": 40,
"end": 51,
"text": "    def set_agent_data(self, agent_name: str, key: str, value: Any):\n        \"\"\"è®¾ç½®Agentç§æœ‰æ•°æ®\"\"\"\n        if agent_name not in self.agent_names:\n            raise ValueError(f\"Agent {agent_name} not in session\")\n        \n        self.memory.update_shared_context(\n            self.session_id,\n            agent_name,\n            key,\n            value\n        )\n    "
},
{
"path": "daoyoucode/agents/memory/shared.py",
"start": 52,
"end": 56,
"text": "    def get_shared(self, key: str, default=None) -> Any:\n        \"\"\"è·å–å…±äº«æ•°æ®\"\"\"\n        ctx = self.get_context()\n        return ctx.get('shared', {}).get(key, default)\n    "
},
{
"path": "daoyoucode/agents/memory/shared.py",
"start": 57,
"end": 60,
"text": "    def get_agent_data(self, agent_name: str, key: str, default=None) -> Any:\n        \"\"\"è·å–Agentç§æœ‰æ•°æ®\"\"\"\n        ctx = self.get_context()\n        return ctx.get(agent_name, {}).get(key, default)"
},
{
"path": "daoyoucode/agents/memory/smart_loader.py",
"start": 1,
"end": 28,
"text": "\"\"\"\næ™ºèƒ½è®°å¿†åŠ è½½å™¨\n\næ ¸å¿ƒæ€æƒ³ï¼š\n1. æŒ‰éœ€åŠ è½½ - åªåœ¨éœ€è¦æ—¶åŠ è½½\n2. åˆ†å±‚åŠ è½½ - æ ¹æ®å¯¹è¯æ·±åº¦é€‰æ‹©ç­–ç•¥\n3. æˆæœ¬ä¼˜åŒ– - é¿å…æ¯æ¬¡éƒ½åŠ è½½æ‰€æœ‰è®°å¿†\n4. æ ‘ç»“æ„ - æ”¯æŒåŸºäºå¯¹è¯æ ‘çš„æ™ºèƒ½æ£€ç´¢\n5. å¯é…ç½® - æ”¯æŒä»é…ç½®æ–‡ä»¶åŠ è½½ç­–ç•¥\n\nåŠ è½½ç­–ç•¥ï¼š\n- æ–°å¯¹è¯ï¼šä¸åŠ è½½ä»»ä½•è®°å¿†ï¼ˆæˆæœ¬0ï¼‰\n- ç®€å•è¿½é—®ï¼šåªåŠ è½½æœ€è¿‘2è½®ï¼ˆæˆæœ¬ä½ï¼‰\n- å¤æ‚è¿½é—®ï¼šåŠ è½½ç›¸å…³åˆ†æ”¯ + æ‘˜è¦ï¼ˆæˆæœ¬ä¸­ï¼‰\n- è·¨sessionï¼šåŠ è½½ç”¨æˆ·ç”»åƒï¼ˆæˆæœ¬é«˜ï¼Œä½†å¿…è¦ï¼‰\n\næ ‘ç»“æ„æ”¯æŒï¼š\n- è‡ªåŠ¨æ£€æµ‹è¯é¢˜åˆ‡æ¢\n- ç»´æŠ¤å¤šåˆ†æ”¯å¯¹è¯\n- æ™ºèƒ½æ£€ç´¢ç›¸å…³åˆ†æ”¯\n\"\"\"\n\nfrom typing import Dict, List, Optional, Any, Tuple, Set\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/memory/smart_loader.py",
"start": 29,
"end": 40,
"text": "class SmartLoader:\n    \"\"\"\n    æ™ºèƒ½è®°å¿†åŠ è½½å™¨\n    \n    èŒè´£ï¼š\n    1. æ ¹æ®å¯¹è¯æ·±åº¦å†³å®šåŠ è½½ç­–ç•¥\n    2. æœ€å°åŒ–LLM prompté•¿åº¦\n    3. é™ä½æˆæœ¬\n    4. æ”¯æŒåŸºäºæ ‘ç»“æ„çš„æ™ºèƒ½æ£€ç´¢\n    5. æ”¯æŒç­–ç•¥é…ç½®åŒ–\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/smart_loader.py",
"start": 41,
"end": 344,
"text": "    def __init__(self, enable_tree: bool = True, config_path: Optional[str] = None):\n        \"\"\"\n        åˆå§‹åŒ–æ™ºèƒ½åŠ è½½å™¨\n        \n        Args:\n            enable_tree: æ˜¯å¦å¯ç”¨å¯¹è¯æ ‘ï¼ˆé»˜è®¤å¯ç”¨ï¼‰\n            config_path: ç­–ç•¥é…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰\n        \"\"\"\n        self.enable_tree = enable_tree\n        \n        # å¯¹è¯æ ‘ï¼ˆå¯é€‰ï¼‰\n        self._conversation_tree = None\n        if enable_tree:\n            from .conversation_tree import get_conversation_tree\n            self._conversation_tree = get_conversation_tree(enabled=True)\n            logger.info(\"å¯¹è¯æ ‘å·²å¯ç”¨\")\n        \n        # åŠ è½½ç­–ç•¥é…ç½®\n        from .load_strategy_config import get_load_strategy_config\n        self.strategy_config = get_load_strategy_config(config_path)\n        self.config = self.strategy_config.get_all_strategies()\n        \n        logger.info(\n            f\"æ™ºèƒ½åŠ è½½å™¨å·²åˆå§‹åŒ–: \"\n            f\"ç­–ç•¥æ•°={len(self.config)}, \"\n            f\"é…ç½®æ–‡ä»¶={'æ˜¯' if config_path else 'å¦ï¼ˆä½¿ç”¨é»˜è®¤ï¼‰'}\"\n        )\n        \n        # ç»Ÿè®¡\n        self.stats = {\n            'total_loads': 0,\n            'new_conversation': 0,\n            'simple_followup': 0,\n            'medium_followup': 0,\n            'complex_followup': 0,\n            'cross_session': 0,\n            'total_cost': 0\n        }\n    \n    async def decide_load_strategy(\n        self,\n        is_followup: bool,\n        confidence: float,\n        history_count: int,\n        has_summary: bool = False,\n        is_new_user: bool = False,\n        current_message: str = \"\"\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"\n        å†³å®šåŠ è½½ç­–ç•¥\n        \n        Args:\n            is_followup: æ˜¯å¦ä¸ºè¿½é—®\n            confidence: è¿½é—®ç½®ä¿¡åº¦\n            history_count: å†å²å¯¹è¯æ•°é‡\n            has_summary: æ˜¯å¦æœ‰æ‘˜è¦\n            is_new_user: æ˜¯å¦ä¸ºæ–°ç”¨æˆ·\n            current_message: å½“å‰æ¶ˆæ¯\n        \n        Returns:\n            (ç­–ç•¥åç§°, ç­–ç•¥é…ç½®)\n        \"\"\"\n        self.stats['total_loads'] += 1\n        \n        # 1. æ–°å¯¹è¯ï¼šä½†å¦‚æœæœ‰å†å²ï¼Œå°è¯•æ™ºèƒ½ç­›é€‰\n        if not is_followup:\n            if history_count > 0:\n                # æœ‰å†å²è®°å½•ï¼Œä½¿ç”¨ç®€å•è¿½é—®ç­–ç•¥\n                self.stats['simple_followup'] += 1\n                strategy = 'simple_followup'\n                cost = self.config[strategy]['cost']\n                self.stats['total_cost'] += cost\n                logger.info(\n                    f\"ğŸ“Š åˆ¤æ–­ä¸ºæ–°è¯é¢˜ä½†æœ‰å†å²ï¼Œå°è¯•ç­›é€‰: \"\n                    f\"ç­–ç•¥={strategy}, æˆæœ¬={cost}\"\n                )\n                return strategy, self.config[strategy]\n            else:\n                # çœŸçš„æ²¡æœ‰å†å²ï¼Œä¸åŠ è½½\n                self.stats['new_conversation'] += 1\n                strategy = 'new_conversation'\n                logger.debug(f\"ğŸ“Š åŠ è½½ç­–ç•¥: {strategy} (æˆæœ¬: 0)\")\n                return strategy, self.config[strategy]\n        \n        # 2. ç®€å•è¿½é—®ï¼ˆå†å²å°‘äº3è½®ï¼‰\n        if history_count <= 2:\n            self.stats['simple_followup'] += 1\n            strategy = 'simple_followup'\n            cost = self.config[strategy]['cost']\n            self.stats['total_cost'] += cost\n            logger.debug(f\"ğŸ“Š åŠ è½½ç­–ç•¥: {strategy} (æˆæœ¬: {cost})\")\n            return strategy, self.config[strategy]\n        \n        # 3. ä¸­ç­‰è¿½é—®ï¼ˆ3-5è½®ï¼‰\n        if history_count <= 5:\n            self.stats['medium_followup'] += 1\n            strategy = 'medium_followup'\n            cost = self.config[strategy]['cost']\n            self.stats['total_cost'] += cost\n            logger.debug(f\"ğŸ“Š åŠ è½½ç­–ç•¥: {strategy} (æˆæœ¬: {cost})\")\n            return strategy, self.config[strategy]\n        \n        # 4. å¤æ‚è¿½é—®ï¼ˆ>5è½®ï¼Œæœ‰æ‘˜è¦ï¼‰\n        if has_summary:\n            self.stats['complex_followup'] += 1\n            strategy = 'complex_followup'\n            cost = self.config[strategy]['cost']\n            self.stats['total_cost'] += cost\n            logger.debug(f\"ğŸ“Š åŠ è½½ç­–ç•¥: {strategy} (æˆæœ¬: {cost}, ä½¿ç”¨æ‘˜è¦)\")\n            return strategy, self.config[strategy]\n        \n        # 5. å¤æ‚è¿½é—®ï¼ˆ>5è½®ï¼Œæ— æ‘˜è¦ï¼‰- é™çº§ä¸ºä¸­ç­‰ç­–ç•¥\n        self.stats['medium_followup'] += 1\n        strategy = 'medium_followup'\n        cost = self.config[strategy]['cost']\n        self.stats['total_cost'] += cost\n        logger.debug(f\"ğŸ“Š åŠ è½½ç­–ç•¥: {strategy} (æˆæœ¬: {cost}, æ— æ‘˜è¦é™çº§)\")\n        return strategy, self.config["
},
{
"path": "daoyoucode/agents/memory/smart_loader.py",
"start": 345,
"end": 388,
"text": "    def _extract_keywords(self, text: str) -> Set[str]:\n        \"\"\"\n        æå–å…³é”®è¯\n        \n        ç­–ç•¥ï¼š\n        1. ä¼˜å…ˆä½¿ç”¨jiebaåˆ†è¯ï¼ˆå¦‚æœå¯ç”¨ï¼‰\n        2. é™çº§åˆ°ç®€å•åˆ†è¯\n        \n        Args:\n            text: æ–‡æœ¬\n        \n        Returns:\n            å…³é”®è¯é›†åˆ\n        \"\"\"\n        try:\n            # å°è¯•ä½¿ç”¨jiebaï¼ˆæ›´å‡†ç¡®ï¼‰\n            import jieba.posseg as pseg\n            \n            words = pseg.cut(text)\n            # åªä¿ç•™åè¯(n)ã€åŠ¨è¯(v)ã€å½¢å®¹è¯(a)\n            keywords = {\n                w for w, flag in words \n                if (flag.startswith('n') or flag.startswith('v') or flag.startswith('a'))\n                and len(w) > 1\n            }\n            \n            if keywords:\n                logger.debug(f\"  ğŸ“ jiebaåˆ†è¯: {keywords}\")\n                return keywords\n        \n        except ImportError:\n            pass\n        except Exception as e:\n            logger.debug(f\"  âš ï¸ jiebaåˆ†è¯å¤±è´¥: {e}\")\n        \n        # é™çº§åˆ°ç®€å•åˆ†è¯\n        import re\n        words = re.findall(r'[\\u4e00-\\u9fa5]+', text)\n        stopwords = {'çš„', 'äº†', 'æ˜¯', 'åœ¨', 'æˆ‘', 'æœ‰', 'å’Œ', 'å°±', 'ä¸', 'äºº', 'éƒ½', 'ä¸€', 'ä¸ª', 'ä¹ˆ', 'å—', 'å‘¢', 'å•Š'}\n        keywords = {w for w in words if w not in stopwords and len(w) > 1}\n        \n        logger.debug(f\"  ğŸ“ ç®€å•åˆ†è¯: {keywords}\")\n        return keywords\n    "
},
{
"path": "daoyoucode/agents/memory/smart_loader.py",
"start": 389,
"end": 441,
"text": "    def format_context_for_prompt(\n        self,\n        context: Dict[str, Any],\n        current_message: str\n    ) -> str:\n        \"\"\"\n        æ ¼å¼åŒ–ä¸Šä¸‹æ–‡ä¸ºLLM prompt\n        \n        Args:\n            context: åŠ è½½çš„ä¸Šä¸‹æ–‡\n            current_message: å½“å‰æ¶ˆæ¯\n        \n        Returns:\n            æ ¼å¼åŒ–çš„promptæ–‡æœ¬\n        \"\"\"\n        parts = []\n        \n        # 1. ç”¨æˆ·ç”»åƒï¼ˆå¦‚æœæœ‰ï¼‰\n        if context.get('profile'):\n            profile = context['profile']\n            topics = profile.get('common_topics', [])\n            if topics:\n                topics_str = \", \".join(topics[:3])\n                parts.append(f\"ã€ç”¨æˆ·ç”»åƒã€‘å¸¸è®¨è®ºçš„è¯é¢˜ï¼š{topics_str}\")\n        \n        # 2. å¯¹è¯æ‘˜è¦ï¼ˆå¦‚æœæœ‰ï¼‰\n        if context.get('summary'):\n            parts.append(f\"ã€å¯¹è¯æ‘˜è¦ã€‘\\n{context['summary']}\")\n        \n        # 3. æœ€è¿‘å¯¹è¯\n        history = context.get('history', [])\n        if history:\n            history_lines = []\n            for idx, item in enumerate(history, 1):\n                user_msg = item.get('user', '')\n                ai_text = item.get('ai', '')[:300]  # é™åˆ¶é•¿åº¦\n                \n                history_lines.append(f\"[ç¬¬{idx}è½®]\")\n                history_lines.append(f\"ç”¨æˆ·: {user_msg}\")\n                history_lines.append(f\"AI: {ai_text}\")\n                history_lines.append(\"\")\n            \n            parts.append(f\"ã€æœ€è¿‘å¯¹è¯ï¼ˆå…±{len(history)}è½®ï¼‰ã€‘\\n\" + \"\\n\".join(history_lines))\n        \n        # 4. å½“å‰é—®é¢˜\n        parts.append(f\"ã€å½“å‰é—®é¢˜ã€‘\\n{current_message}\")\n        \n        # ç»„åˆ\n        if len(parts) > 1:  # æœ‰ä¸Šä¸‹æ–‡\n            return \"\\n\\n\".join(parts)\n        else:  # æ— ä¸Šä¸‹æ–‡\n            return f\"ç”¨æˆ·é—®é¢˜ï¼š{current_message}\"\n    "
},
{
"path": "daoyoucode/agents/memory/smart_loader.py",
"start": 442,
"end": 463,
"text": "    def reload_config(self, config_path: Optional[str] = None) -> bool:\n        \"\"\"\n        é‡æ–°åŠ è½½é…ç½®ï¼ˆçƒ­é‡è½½ï¼‰\n        \n        Args:\n            config_path: é…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            æ˜¯å¦é‡è½½æˆåŠŸ\n        \"\"\"\n        if config_path:\n            from .load_strategy_config import LoadStrategyConfig\n            self.strategy_config = LoadStrategyConfig(config_path)\n        else:\n            success = self.strategy_config.reload()\n            if not success:\n                return False\n        \n        self.config = self.strategy_config.get_all_strategies()\n        logger.info(f\"âœ… ç­–ç•¥é…ç½®å·²é‡è½½: {len(self.config)} ä¸ªç­–ç•¥\")\n        return True\n    "
},
{
"path": "daoyoucode/agents/memory/smart_loader.py",
"start": 464,
"end": 475,
"text": "    def get_strategy_info(self, strategy_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        è·å–ç­–ç•¥ä¿¡æ¯\n        \n        Args:\n            strategy_name: ç­–ç•¥åç§°\n        \n        Returns:\n            ç­–ç•¥é…ç½®å­—å…¸\n        \"\"\"\n        return self.config.get(strategy_name)\n    "
},
{
"path": "daoyoucode/agents/memory/smart_loader.py",
"start": 476,
"end": 479,
"text": "    def list_strategies(self) -> List[str]:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰å¯ç”¨ç­–ç•¥\"\"\"\n        return list(self.config.keys())\n    "
},
{
"path": "daoyoucode/agents/memory/smart_loader.py",
"start": 480,
"end": 492,
"text": "    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"è·å–ç»Ÿè®¡ä¿¡æ¯\"\"\"\n        avg_cost = (\n            self.stats['total_cost'] / self.stats['total_loads']\n            if self.stats['total_loads'] > 0\n            else 0\n        )\n        \n        return {\n            **self.stats,\n            'average_cost': round(avg_cost, 2)\n        }\n    "
},
{
"path": "daoyoucode/agents/memory/smart_loader.py",
"start": 493,
"end": 508,
"text": "    def reset_stats(self):\n        \"\"\"é‡ç½®ç»Ÿè®¡\"\"\"\n        self.stats = {\n            'total_loads': 0,\n            'new_conversation': 0,\n            'simple_followup': 0,\n            'medium_followup': 0,\n            'complex_followup': 0,\n            'cross_session': 0,\n            'total_cost': 0\n        }\n\n\n# å•ä¾‹\n_smart_loader = None\n"
},
{
"path": "daoyoucode/agents/memory/smart_loader.py",
"start": 509,
"end": 514,
"text": "def get_smart_loader() -> SmartLoader:\n    \"\"\"è·å–æ™ºèƒ½åŠ è½½å™¨å•ä¾‹\"\"\"\n    global _smart_loader\n    if _smart_loader is None:\n        _smart_loader = SmartLoader()\n    return _smart_loader"
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 1,
"end": 22,
"text": "\"\"\"\nè®°å¿†å­˜å‚¨\nè´Ÿè´£å®é™…çš„æ•°æ®å­˜å‚¨å’Œæ£€ç´¢\n\næ”¯æŒæŒä¹…åŒ–ï¼š\n- å¯¹è¯å†å²ï¼šå†…å­˜å­˜å‚¨ï¼ˆä¸´æ—¶ï¼‰\n- ç”¨æˆ·åå¥½ï¼šæŒä¹…åŒ–å­˜å‚¨ï¼ˆJSONï¼‰\n- ä»»åŠ¡å†å²ï¼šæŒä¹…åŒ–å­˜å‚¨ï¼ˆJSONï¼‰\n- æ‘˜è¦ï¼šæŒä¹…åŒ–å­˜å‚¨ï¼ˆJSONï¼‰\n- ç”¨æˆ·ç”»åƒï¼šæŒä¹…åŒ–å­˜å‚¨ï¼ˆJSONï¼‰\n\"\"\"\n\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nfrom collections import defaultdict\nfrom pathlib import Path\nimport json\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 23,
"end": 33,
"text": "class MemoryStorage:\n    \"\"\"\n    è®°å¿†å­˜å‚¨\n    \n    å­˜å‚¨ç»“æ„ï¼š\n    1. å¯¹è¯å†å²ï¼šæŒ‰session_idå­˜å‚¨\n    2. ç”¨æˆ·åå¥½ï¼šæŒ‰user_idå­˜å‚¨\n    3. ä»»åŠ¡å†å²ï¼šæŒ‰user_idå­˜å‚¨\n    4. å…±äº«ä¸Šä¸‹æ–‡ï¼šæŒ‰session_idå­˜å‚¨ï¼ˆå¤šæ™ºèƒ½ä½“ï¼‰\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 34,
"end": 97,
"text": "    def __init__(\n        self,\n        max_conversations: int = 10,\n        max_tasks: int = 100,\n        max_sessions: int = 1000,\n        storage_dir: Optional[str] = None\n    ):\n        # å¯¹è¯å†å²ï¼ˆå†…å­˜å­˜å‚¨ï¼Œä¸´æ—¶ï¼‰\n        self._conversations: Dict[str, List[Dict]] = {}\n        \n        # ç”¨æˆ·åå¥½ï¼ˆæŒä¹…åŒ–ï¼‰\n        self._preferences: Dict[str, Dict[str, Any]] = {}\n        \n        # ä»»åŠ¡å†å²ï¼ˆæŒä¹…åŒ–ï¼‰\n        self._tasks: Dict[str, List[Dict]] = {}\n        \n        # å…±äº«ä¸Šä¸‹æ–‡ï¼ˆå†…å­˜å­˜å‚¨ï¼Œä¸´æ—¶ï¼‰\n        self._shared_contexts: Dict[str, Dict[str, Any]] = {}\n        \n        # ========== æ–°å¢ï¼šé•¿æœŸè®°å¿†å­˜å‚¨ï¼ˆæŒä¹…åŒ–ï¼‰==========\n        # å¯¹è¯æ‘˜è¦\n        self._summaries: Dict[str, str] = {}\n        \n        # å…³é”®ä¿¡æ¯\n        self._key_info: Dict[str, Dict[str, Any]] = {}\n        \n        # ç”¨æˆ·ç”»åƒ\n        self._user_profiles: Dict[str, Dict[str, Any]] = {}\n        \n        # ========== æ–°å¢ï¼šç”¨æˆ·ä¼šè¯æ˜ å°„ï¼ˆæŒä¹…åŒ–ï¼‰==========\n        # user_id -> [session_id1, session_id2, ...]\n        self._user_sessions: Dict[str, List[str]] = defaultdict(list)\n        \n        # session_id -> user_id\n        self._session_users: Dict[str, str] = {}\n        \n        # é…ç½®\n        self.max_conversations = max_conversations\n        self.max_tasks = max_tasks\n        self.max_sessions = max_sessions\n        \n        # ========== æŒä¹…åŒ–é…ç½® ==========\n        if storage_dir is None:\n            # é»˜è®¤å­˜å‚¨åœ¨ç”¨æˆ·ç›®å½•ä¸‹\n            storage_dir = str(Path.home() / '.daoyoucode' / 'memory')\n        \n        self.storage_dir = Path(storage_dir)\n        self.storage_dir.mkdir(parents=True, exist_ok=True)\n        \n        # æŒä¹…åŒ–æ–‡ä»¶è·¯å¾„\n        self._preferences_file = self.storage_dir / 'preferences.json'\n        self._tasks_file = self.storage_dir / 'tasks.json'\n        self._summaries_file = self.storage_dir / 'summaries.json'\n        self._key_info_file = self.storage_dir / 'key_info.json'\n        self._profiles_file = self.storage_dir / 'profiles.json'\n        self._user_sessions_file = self.storage_dir / 'user_sessions.json'\n        \n        # åŠ è½½æŒä¹…åŒ–æ•°æ®\n        self._load_persistent_data()\n        \n        logger.info(f\"è®°å¿†å­˜å‚¨å·²åˆå§‹åŒ–ï¼ˆæŒä¹…åŒ–ç›®å½•: {self.storage_dir}ï¼‰\")\n    \n    # ========== å¯¹è¯å†å² ==========\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 98,
"end": 134,
"text": "    def add_conversation(\n        self,\n        session_id: str,\n        user_message: str,\n        ai_response: str,\n        metadata: Optional[Dict] = None,\n        user_id: Optional[str] = None\n    ):\n        \"\"\"\n        æ·»åŠ å¯¹è¯\n        \n        Args:\n            session_id: ä¼šè¯ID\n            user_message: ç”¨æˆ·æ¶ˆæ¯\n            ai_response: AIå“åº”\n            metadata: å…ƒæ•°æ®\n            user_id: ç”¨æˆ·IDï¼ˆå¯é€‰ï¼Œç”¨äºç»´æŠ¤user_idåˆ°session_idçš„æ˜ å°„ï¼‰\n        \"\"\"\n        if session_id not in self._conversations:\n            self._conversations[session_id] = []\n        \n        self._conversations[session_id].append({\n            'user': user_message,\n            'ai': ai_response,\n            'timestamp': datetime.now().isoformat(),\n            'metadata': metadata or {}\n        })\n        \n        # ä¿æŒæœ€è¿‘Nè½®\n        if len(self._conversations[session_id]) > self.max_conversations:\n            self._conversations[session_id] = \\\n                self._conversations[session_id][-self.max_conversations:]\n        \n        # ç»´æŠ¤user_idåˆ°session_idçš„æ˜ å°„\n        if user_id:\n            self._register_session(user_id, session_id)\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 135,
"end": 149,
"text": "    def get_conversation_history(\n        self,\n        session_id: str,\n        limit: Optional[int] = None\n    ) -> List[Dict]:\n        \"\"\"è·å–å¯¹è¯å†å²\"\"\"\n        history = self._conversations.get(session_id, [])\n        \n        if limit is None:\n            return history\n        \n        return history[-limit:]\n    \n    # ========== ç”¨æˆ·åå¥½ ==========\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 150,
"end": 168,
"text": "    def add_preference(\n        self,\n        user_id: str,\n        key: str,\n        value: Any\n    ):\n        \"\"\"æ·»åŠ ç”¨æˆ·åå¥½\"\"\"\n        if user_id not in self._preferences:\n            self._preferences[user_id] = {}\n        \n        self._preferences[user_id][key] = {\n            'value': value,\n            'timestamp': datetime.now().isoformat(),\n            'count': self._preferences[user_id].get(key, {}).get('count', 0) + 1\n        }\n        \n        # æŒä¹…åŒ–\n        self._save_preferences()\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 169,
"end": 180,
"text": "    def get_preferences(self, user_id: str) -> Dict[str, Any]:\n        \"\"\"è·å–ç”¨æˆ·åå¥½\"\"\"\n        prefs = self._preferences.get(user_id, {})\n        \n        # åªè¿”å›value\n        return {\n            key: data['value']\n            for key, data in prefs.items()\n        }\n    \n    # ========== ä»»åŠ¡å†å² ==========\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 181,
"end": 201,
"text": "    def add_task(\n        self,\n        user_id: str,\n        task: Dict[str, Any]\n    ):\n        \"\"\"æ·»åŠ ä»»åŠ¡\"\"\"\n        if user_id not in self._tasks:\n            self._tasks[user_id] = []\n        \n        self._tasks[user_id].append({\n            **task,\n            'timestamp': datetime.now().isoformat()\n        })\n        \n        # ä¿æŒæœ€è¿‘Nä¸ªä»»åŠ¡\n        if len(self._tasks[user_id]) > self.max_tasks:\n            self._tasks[user_id] = self._tasks[user_id][-self.max_tasks:]\n        \n        # æŒä¹…åŒ–\n        self._save_tasks()\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 202,
"end": 212,
"text": "    def get_task_history(\n        self,\n        user_id: str,\n        limit: int = 10\n    ) -> List[Dict]:\n        \"\"\"è·å–ä»»åŠ¡å†å²\"\"\"\n        tasks = self._tasks.get(user_id, [])\n        return tasks[-limit:]\n    \n    # ========== å¤šæ™ºèƒ½ä½“å…±äº«ä¸Šä¸‹æ–‡ ==========\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 213,
"end": 245,
"text": "    def get_shared_context(\n        self,\n        session_id: str,\n        agent_names: List[str]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        è·å–å¤šæ™ºèƒ½ä½“å…±äº«ä¸Šä¸‹æ–‡\n        \n        è¿”å›æ ¼å¼ï¼š\n        {\n            'agent1': {'key1': 'value1', ...},\n            'agent2': {'key2': 'value2', ...},\n            'shared': {'shared_key': 'shared_value', ...}\n        }\n        \"\"\"\n        if session_id not in self._shared_contexts:\n            self._shared_contexts[session_id] = {\n                'shared': {},  # æ‰€æœ‰Agentå…±äº«çš„æ•°æ®\n                'agents': defaultdict(dict)  # æ¯ä¸ªAgentçš„ç§æœ‰æ•°æ®\n            }\n        \n        ctx = self._shared_contexts[session_id]\n        \n        # æ„å»ºè¿”å›ç»“æœ\n        result = {\n            'shared': ctx['shared'].copy()\n        }\n        \n        for agent_name in agent_names:\n            result[agent_name] = ctx['agents'][agent_name].copy()\n        \n        return result\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 246,
"end": 268,
"text": "    def update_shared_context(\n        self,\n        session_id: str,\n        agent_name: str,\n        key: str,\n        value: Any\n    ):\n        \"\"\"æ›´æ–°å…±äº«ä¸Šä¸‹æ–‡\"\"\"\n        if session_id not in self._shared_contexts:\n            self._shared_contexts[session_id] = {\n                'shared': {},\n                'agents': defaultdict(dict)\n            }\n        \n        # å¦‚æœagent_nameæ˜¯'shared'ï¼Œæ›´æ–°å…±äº«æ•°æ®\n        if agent_name == 'shared':\n            self._shared_contexts[session_id]['shared'][key] = value\n        else:\n            # å¦åˆ™æ›´æ–°Agentç§æœ‰æ•°æ®\n            self._shared_contexts[session_id]['agents'][agent_name][key] = value\n    \n    # ========== å·¥å…·æ–¹æ³• ==========\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 269,
"end": 278,
"text": "    def clear_session(self, session_id: str):\n        \"\"\"æ¸…é™¤ä¼šè¯\"\"\"\n        if session_id in self._conversations:\n            del self._conversations[session_id]\n        \n        if session_id in self._shared_contexts:\n            del self._shared_contexts[session_id]\n    \n    # ========== æ‘˜è¦ç®¡ç† ==========\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 279,
"end": 284,
"text": "    def save_summary(self, session_id: str, summary: str):\n        \"\"\"ä¿å­˜å¯¹è¯æ‘˜è¦\"\"\"\n        self._summaries[session_id] = summary\n        # æŒä¹…åŒ–\n        self._save_summaries()\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 285,
"end": 290,
"text": "    def get_summary(self, session_id: str) -> Optional[str]:\n        \"\"\"è·å–å¯¹è¯æ‘˜è¦\"\"\"\n        return self._summaries.get(session_id)\n    \n    # ========== å…³é”®ä¿¡æ¯ç®¡ç† ==========\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 291,
"end": 296,
"text": "    def save_key_info(self, session_id: str, key_info: Dict[str, Any]):\n        \"\"\"ä¿å­˜å…³é”®ä¿¡æ¯\"\"\"\n        self._key_info[session_id] = key_info\n        # æŒä¹…åŒ–\n        self._save_key_info()\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 297,
"end": 302,
"text": "    def get_key_info(self, session_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"è·å–å…³é”®ä¿¡æ¯\"\"\"\n        return self._key_info.get(session_id)\n    \n    # ========== ç”¨æˆ·ç”»åƒç®¡ç† ==========\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 303,
"end": 308,
"text": "    def save_user_profile(self, user_id: str, profile: Dict[str, Any]):\n        \"\"\"ä¿å­˜ç”¨æˆ·ç”»åƒ\"\"\"\n        self._user_profiles[user_id] = profile\n        # æŒä¹…åŒ–\n        self._save_profiles()\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 309,
"end": 314,
"text": "    def get_user_profile(self, user_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"è·å–ç”¨æˆ·ç”»åƒ\"\"\"\n        return self._user_profiles.get(user_id)\n    \n    # ========== ç”¨æˆ·ä¼šè¯æ˜ å°„ ==========\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 315,
"end": 332,
"text": "    def _register_session(self, user_id: str, session_id: str):\n        \"\"\"\n        æ³¨å†Œç”¨æˆ·ä¼šè¯æ˜ å°„\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n            session_id: ä¼šè¯ID\n        \"\"\"\n        # æ·»åŠ åˆ°user_id -> sessionsæ˜ å°„\n        if session_id not in self._user_sessions[user_id]:\n            self._user_sessions[user_id].append(session_id)\n        \n        # æ·»åŠ åˆ°session_id -> user_idæ˜ å°„\n        self._session_users[session_id] = user_id\n        \n        # æŒä¹…åŒ–\n        self._save_user_sessions()\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 333,
"end": 344,
"text": "    def get_user_sessions(self, user_id: str) -> List[str]:\n        \"\"\"\n        è·å–ç”¨æˆ·çš„æ‰€æœ‰ä¼šè¯ID\n        \n        Args:\n            user_id: ç”¨æˆ·ID\n        \n        Returns:\n            ä¼šè¯IDåˆ—è¡¨\n        \"\"\"\n        return self._user_sessions.get(user_id, [])\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 345,
"end": 358,
"text": "    def get_session_user(self, session_id: str) -> Optional[str]:\n        \"\"\"\n        è·å–ä¼šè¯å¯¹åº”çš„ç”¨æˆ·ID\n        \n        Args:\n            session_id: ä¼šè¯ID\n        \n        Returns:\n            ç”¨æˆ·IDï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›None\n        \"\"\"\n        return self._session_users.get(session_id)\n    \n    # ========== å·¥å…·æ–¹æ³• ==========\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 359,
"end": 381,
"text": "    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"è·å–ç»Ÿè®¡ä¿¡æ¯\"\"\"\n        total_conversations = sum(\n            len(convs) for convs in self._conversations.values()\n        )\n        \n        total_tasks = sum(\n            len(tasks) for tasks in self._tasks.values()\n        )\n        \n        return {\n            'total_sessions': len(self._conversations),\n            'total_conversations': total_conversations,\n            'total_users': len(self._preferences),\n            'total_tasks': total_tasks,\n            'shared_contexts': len(self._shared_contexts),\n            'summaries': len(self._summaries),\n            'key_info': len(self._key_info),\n            'user_profiles': len(self._user_profiles)\n        }\n    \n    # ========== æŒä¹…åŒ–æ–¹æ³• ==========\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 382,
"end": 426,
"text": "    def _load_persistent_data(self):\n        \"\"\"åŠ è½½æŒä¹…åŒ–æ•°æ®\"\"\"\n        try:\n            # åŠ è½½ç”¨æˆ·åå¥½\n            if self._preferences_file.exists():\n                with open(self._preferences_file, 'r', encoding='utf-8') as f:\n                    self._preferences = json.load(f)\n                logger.info(f\"åŠ è½½äº† {len(self._preferences)} ä¸ªç”¨æˆ·çš„åå¥½\")\n            \n            # åŠ è½½ä»»åŠ¡å†å²\n            if self._tasks_file.exists():\n                with open(self._tasks_file, 'r', encoding='utf-8') as f:\n                    self._tasks = json.load(f)\n                total_tasks = sum(len(tasks) for tasks in self._tasks.values())\n                logger.info(f\"åŠ è½½äº† {total_tasks} ä¸ªä»»åŠ¡\")\n            \n            # åŠ è½½æ‘˜è¦\n            if self._summaries_file.exists():\n                with open(self._summaries_file, 'r', encoding='utf-8') as f:\n                    self._summaries = json.load(f)\n                logger.info(f\"åŠ è½½äº† {len(self._summaries)} ä¸ªæ‘˜è¦\")\n            \n            # åŠ è½½å…³é”®ä¿¡æ¯\n            if self._key_info_file.exists():\n                with open(self._key_info_file, 'r', encoding='utf-8') as f:\n                    self._key_info = json.load(f)\n                logger.info(f\"åŠ è½½äº† {len(self._key_info)} ä¸ªå…³é”®ä¿¡æ¯\")\n            \n            # åŠ è½½ç”¨æˆ·ç”»åƒ\n            if self._profiles_file.exists():\n                with open(self._profiles_file, 'r', encoding='utf-8') as f:\n                    self._user_profiles = json.load(f)\n                logger.info(f\"åŠ è½½äº† {len(self._user_profiles)} ä¸ªç”¨æˆ·ç”»åƒ\")\n            \n            # åŠ è½½ç”¨æˆ·ä¼šè¯æ˜ å°„\n            if self._user_sessions_file.exists():\n                with open(self._user_sessions_file, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    self._user_sessions = defaultdict(list, data.get('user_sessions', {}))\n                    self._session_users = data.get('session_users', {})\n                logger.info(f\"åŠ è½½äº† {len(self._user_sessions)} ä¸ªç”¨æˆ·çš„ä¼šè¯æ˜ å°„\")\n        \n        except Exception as e:\n            logger.warning(f\"åŠ è½½æŒä¹…åŒ–æ•°æ®å¤±è´¥: {e}\")\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 427,
"end": 434,
"text": "    def _save_preferences(self):\n        \"\"\"ä¿å­˜ç”¨æˆ·åå¥½\"\"\"\n        try:\n            with open(self._preferences_file, 'w', encoding='utf-8') as f:\n                json.dump(self._preferences, f, ensure_ascii=False, indent=2)\n        except Exception as e:\n            logger.error(f\"ä¿å­˜ç”¨æˆ·åå¥½å¤±è´¥: {e}\")\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 435,
"end": 442,
"text": "    def _save_tasks(self):\n        \"\"\"ä¿å­˜ä»»åŠ¡å†å²\"\"\"\n        try:\n            with open(self._tasks_file, 'w', encoding='utf-8') as f:\n                json.dump(self._tasks, f, ensure_ascii=False, indent=2)\n        except Exception as e:\n            logger.error(f\"ä¿å­˜ä»»åŠ¡å†å²å¤±è´¥: {e}\")\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 443,
"end": 450,
"text": "    def _save_summaries(self):\n        \"\"\"ä¿å­˜æ‘˜è¦\"\"\"\n        try:\n            with open(self._summaries_file, 'w', encoding='utf-8') as f:\n                json.dump(self._summaries, f, ensure_ascii=False, indent=2)\n        except Exception as e:\n            logger.error(f\"ä¿å­˜æ‘˜è¦å¤±è´¥: {e}\")\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 451,
"end": 458,
"text": "    def _save_key_info(self):\n        \"\"\"ä¿å­˜å…³é”®ä¿¡æ¯\"\"\"\n        try:\n            with open(self._key_info_file, 'w', encoding='utf-8') as f:\n                json.dump(self._key_info, f, ensure_ascii=False, indent=2)\n        except Exception as e:\n            logger.error(f\"ä¿å­˜å…³é”®ä¿¡æ¯å¤±è´¥: {e}\")\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 459,
"end": 466,
"text": "    def _save_profiles(self):\n        \"\"\"ä¿å­˜ç”¨æˆ·ç”»åƒ\"\"\"\n        try:\n            with open(self._profiles_file, 'w', encoding='utf-8') as f:\n                json.dump(self._user_profiles, f, ensure_ascii=False, indent=2)\n        except Exception as e:\n            logger.error(f\"ä¿å­˜ç”¨æˆ·ç”»åƒå¤±è´¥: {e}\")\n    "
},
{
"path": "daoyoucode/agents/memory/storage.py",
"start": 467,
"end": 477,
"text": "    def _save_user_sessions(self):\n        \"\"\"ä¿å­˜ç”¨æˆ·ä¼šè¯æ˜ å°„\"\"\"\n        try:\n            data = {\n                'user_sessions': dict(self._user_sessions),\n                'session_users': self._session_users\n            }\n            with open(self._user_sessions_file, 'w', encoding='utf-8') as f:\n                json.dump(data, f, ensure_ascii=False, indent=2)\n        except Exception as e:\n            logger.error(f\"ä¿å­˜ç”¨æˆ·ä¼šè¯æ˜ å°„å¤±è´¥: {e}\")"
},
{
"path": "daoyoucode/agents/memory/tree_visualizer.py",
"start": 1,
"end": 17,
"text": "\"\"\"\nå¯¹è¯æ ‘å¯è§†åŒ–\n\næ”¯æŒå¤šç§å¯è§†åŒ–æ ¼å¼ï¼š\n1. Mermaidå›¾ï¼ˆMarkdownå‹å¥½ï¼‰\n2. ASCIIæ ‘ï¼ˆç»ˆç«¯å‹å¥½ï¼‰\n3. JSONæ ‘ï¼ˆç¨‹åºå‹å¥½ï¼‰\n4. HTMLæ ‘ï¼ˆWebå‹å¥½ï¼‰\n\"\"\"\n\nfrom typing import Dict, List, Optional, Any\nimport json\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/memory/tree_visualizer.py",
"start": 18,
"end": 28,
"text": "class TreeVisualizer:\n    \"\"\"\n    å¯¹è¯æ ‘å¯è§†åŒ–å™¨\n    \n    åŠŸèƒ½ï¼š\n    1. ç”ŸæˆMermaidå›¾\n    2. ç”ŸæˆASCIIæ ‘\n    3. ç”ŸæˆJSONæ ‘\n    4. ç”ŸæˆHTMLæ ‘\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/tree_visualizer.py",
"start": 29,
"end": 37,
"text": "    def __init__(self, conversation_tree):\n        \"\"\"\n        åˆå§‹åŒ–å¯è§†åŒ–å™¨\n        \n        Args:\n            conversation_tree: ConversationTreeå®ä¾‹\n        \"\"\"\n        self.tree = conversation_tree\n    "
},
{
"path": "daoyoucode/agents/memory/tree_visualizer.py",
"start": 38,
"end": 100,
"text": "    def to_mermaid(self, max_depth: Optional[int] = None) -> str:\n        \"\"\"\n        ç”ŸæˆMermaidå›¾\n        \n        Args:\n            max_depth: æœ€å¤§æ·±åº¦ï¼ˆå¯é€‰ï¼‰\n        \n        Returns:\n            Mermaidå›¾ä»£ç \n        \"\"\"\n        lines = [\"graph TD\"]\n        \n        # è·å–æ‰€æœ‰èŠ‚ç‚¹\n        nodes = self.tree._nodes\n        \n        if not nodes:\n            return \"graph TD\\n    Empty[\\\"ç©ºæ ‘\\\"]\"\n        \n        # æ·»åŠ æ ¹èŠ‚ç‚¹\n        lines.append('    Root[\"ğŸŒ³ å¯¹è¯æ ‘\"]')\n        \n        # æŒ‰åˆ†æ”¯ç»„ç»‡èŠ‚ç‚¹\n        branches = {}\n        for node_id, node in nodes.items():\n            branch_id = node.branch_id\n            if branch_id not in branches:\n                branches[branch_id] = []\n            branches[branch_id].append((node_id, node))\n        \n        # ä¸ºæ¯ä¸ªåˆ†æ”¯ç”ŸæˆèŠ‚ç‚¹\n        for branch_id, branch_nodes in branches.items():\n            # æ’åºï¼ˆæŒ‰æ·±åº¦ï¼‰\n            branch_nodes.sort(key=lambda x: x[1].depth)\n            \n            # åˆ†æ”¯èµ·ç‚¹\n            first_node_id, first_node = branch_nodes[0]\n            topic = first_node.topic or \"æœªçŸ¥è¯é¢˜\"\n            \n            # æ·»åŠ åˆ†æ”¯èŠ‚ç‚¹\n            branch_label = f\"ğŸ“ {topic}\"\n            lines.append(f'    {branch_id}[\"{branch_label}\"]')\n            lines.append(f'    Root --> {branch_id}')\n            \n            # æ·»åŠ å¯¹è¯èŠ‚ç‚¹\n            prev_id = branch_id\n            for node_id, node in branch_nodes:\n                # æ£€æŸ¥æ·±åº¦é™åˆ¶\n                if max_depth and node.depth > max_depth:\n                    continue\n                \n                # èŠ‚ç‚¹æ ‡ç­¾ï¼ˆæˆªæ–­é•¿æ–‡æœ¬ï¼‰\n                user_msg = node.user_message[:30] + \"...\" if len(node.user_message) > 30 else node.user_message\n                label = f\"ğŸ’¬ {user_msg}\"\n                \n                # æ·»åŠ èŠ‚ç‚¹\n                safe_id = node_id.replace('-', '_')\n                lines.append(f'    {safe_id}[\"{label}\"]')\n                lines.append(f'    {prev_id} --> {safe_id}')\n                \n                prev_id = safe_id\n        \n        return \"\\n\".join(lines)\n    "
},
{
"path": "daoyoucode/agents/memory/tree_visualizer.py",
"start": 101,
"end": 169,
"text": "    def to_ascii(self, max_depth: Optional[int] = None, show_content: bool = False) -> str:\n        \"\"\"\n        ç”ŸæˆASCIIæ ‘\n        \n        Args:\n            max_depth: æœ€å¤§æ·±åº¦ï¼ˆå¯é€‰ï¼‰\n            show_content: æ˜¯å¦æ˜¾ç¤ºå¯¹è¯å†…å®¹\n        \n        Returns:\n            ASCIIæ ‘å­—ç¬¦ä¸²\n        \"\"\"\n        lines = [\"ğŸŒ³ å¯¹è¯æ ‘\"]\n        lines.append(\"=\" * 60)\n        \n        nodes = self.tree._nodes\n        \n        if not nodes:\n            lines.append(\"(ç©ºæ ‘)\")\n            return \"\\n\".join(lines)\n        \n        # æŒ‰åˆ†æ”¯ç»„ç»‡\n        branches = {}\n        for node_id, node in nodes.items():\n            branch_id = node.branch_id\n            if branch_id not in branches:\n                branches[branch_id] = []\n            branches[branch_id].append((node_id, node))\n        \n        # ä¸ºæ¯ä¸ªåˆ†æ”¯ç”Ÿæˆæ ‘\n        for idx, (branch_id, branch_nodes) in enumerate(branches.items(), 1):\n            # æ’åº\n            branch_nodes.sort(key=lambda x: x[1].depth)\n            \n            # åˆ†æ”¯ä¿¡æ¯\n            first_node = branch_nodes[0][1]\n            topic = first_node.topic or \"æœªçŸ¥è¯é¢˜\"\n            \n            # åˆ†æ”¯æ ‡é¢˜\n            is_last_branch = idx == len(branches)\n            branch_prefix = \"â””â”€\" if is_last_branch else \"â”œâ”€\"\n            lines.append(f\"{branch_prefix} ğŸ“ åˆ†æ”¯ {idx}: {topic} ({len(branch_nodes)}è½®)\")\n            \n            # å¯¹è¯èŠ‚ç‚¹\n            for j, (node_id, node) in enumerate(branch_nodes):\n                # æ£€æŸ¥æ·±åº¦é™åˆ¶\n                if max_depth and node.depth > max_depth:\n                    continue\n                \n                is_last_node = j == len(branch_nodes) - 1\n                node_prefix = \"   â””â”€\" if is_last_branch else \"â”‚  â””â”€\" if is_last_node else \"â”‚  â”œâ”€\"\n                \n                # èŠ‚ç‚¹ä¿¡æ¯\n                user_msg = node.user_message[:40] + \"...\" if len(node.user_message) > 40 else node.user_message\n                lines.append(f\"{node_prefix} ğŸ’¬ {user_msg}\")\n                \n                # æ˜¾ç¤ºå†…å®¹ï¼ˆå¯é€‰ï¼‰\n                if show_content:\n                    ai_msg = node.ai_response[:60] + \"...\" if len(node.ai_response) > 60 else node.ai_response\n                    content_prefix = \"      \" if is_last_branch else \"â”‚     \"\n                    lines.append(f\"{content_prefix}   â†³ {ai_msg}\")\n        \n        # ç»Ÿè®¡ä¿¡æ¯\n        lines.append(\"\")\n        lines.append(\"=\" * 60)\n        stats = self.tree.get_tree_stats()\n        lines.append(f\"ç»Ÿè®¡: {stats['total_conversations']}è½®å¯¹è¯, {stats['total_branches']}ä¸ªåˆ†æ”¯\")\n        \n        return \"\\n\".join(lines)\n    "
},
{
"path": "daoyoucode/agents/memory/tree_visualizer.py",
"start": 170,
"end": 214,
"text": "    def to_json(self, pretty: bool = True) -> str:\n        \"\"\"\n        ç”ŸæˆJSONæ ‘\n        \n        Args:\n            pretty: æ˜¯å¦æ ¼å¼åŒ–\n        \n        Returns:\n            JSONå­—ç¬¦ä¸²\n        \"\"\"\n        nodes = self.tree._nodes\n        \n        if not nodes:\n            return json.dumps({\"tree\": \"empty\"}, indent=2 if pretty else None)\n        \n        # æŒ‰åˆ†æ”¯ç»„ç»‡\n        branches = {}\n        for node_id, node in nodes.items():\n            branch_id = node.branch_id\n            if branch_id not in branches:\n                branches[branch_id] = {\n                    'branch_id': branch_id,\n                    'topic': node.topic,\n                    'conversations': []\n                }\n            \n            branches[branch_id]['conversations'].append({\n                'conversation_id': node.conversation_id,\n                'user_message': node.user_message,\n                'ai_response': node.ai_response,\n                'depth': node.depth,\n                'timestamp': node.timestamp\n            })\n        \n        # æ’åº\n        for branch in branches.values():\n            branch['conversations'].sort(key=lambda x: x['depth'])\n        \n        tree_data = {\n            'tree': list(branches.values()),\n            'stats': self.tree.get_tree_stats()\n        }\n        \n        return json.dumps(tree_data, ensure_ascii=False, indent=2 if pretty else None)\n    "
},
{
"path": "daoyoucode/agents/memory/tree_visualizer.py",
"start": 215,
"end": 371,
"text": "    def to_html(self, title: str = \"å¯¹è¯æ ‘\") -> str:\n        \"\"\"\n        ç”ŸæˆHTMLæ ‘\n        \n        Args:\n            title: æ ‡é¢˜\n        \n        Returns:\n            HTMLå­—ç¬¦ä¸²\n        \"\"\"\n        nodes = self.tree._nodes\n        \n        if not nodes:\n            return f\"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>{title}</title>\n    <style>\n        body {{ font-family: Arial, sans-serif; padding: 20px; }}\n        .empty {{ color: #999; }}\n    </style>\n</head>\n<body>\n    <h1>{title}</h1>\n    <p class=\"empty\">ç©ºæ ‘</p>\n</body>\n</html>\n\"\"\"\n        \n        # æŒ‰åˆ†æ”¯ç»„ç»‡\n        branches = {}\n        for node_id, node in nodes.items():\n            branch_id = node.branch_id\n            if branch_id not in branches:\n                branches[branch_id] = []\n            branches[branch_id].append((node_id, node))\n        \n        # ç”ŸæˆHTML\n        html_parts = [f\"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>{title}</title>\n    <style>\n        body {{\n            font-family: 'Segoe UI', Arial, sans-serif;\n            padding: 20px;\n            background: #f5f5f5;\n        }}\n        .container {{\n            max-width: 1200px;\n            margin: 0 auto;\n            background: white;\n            padding: 30px;\n            border-radius: 8px;\n            box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n        }}\n        h1 {{\n            color: #333;\n            border-bottom: 3px solid #4CAF50;\n            padding-bottom: 10px;\n        }}\n        .stats {{\n            background: #e8f5e9;\n            padding: 15px;\n            border-radius: 5px;\n            margin: 20px 0;\n        }}\n        .branch {{\n            margin: 20px 0;\n            padding: 15px;\n            border-left: 4px solid #2196F3;\n            background: #f9f9f9;\n        }}\n        .branch-title {{\n            font-size: 18px;\n            font-weight: bold;\n            color: #2196F3;\n            margin-bottom: 10px;\n        }}\n        .conversation {{\n            margin: 10px 0;\n            padding: 10px;\n            background: white;\n            border-radius: 5px;\n            border: 1px solid #ddd;\n        }}\n        .user-message {{\n            color: #1976D2;\n            font-weight: bold;\n            margin-bottom: 5px;\n        }}\n        .ai-response {{\n            color: #666;\n            padding-left: 20px;\n            border-left: 3px solid #4CAF50;\n        }}\n        .metadata {{\n            font-size: 12px;\n            color: #999;\n            margin-top: 5px;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>ğŸŒ³ {title}</h1>\n\"\"\"]\n        \n        # ç»Ÿè®¡ä¿¡æ¯\n        stats = self.tree.get_tree_stats()\n        html_parts.append(f\"\"\"\n        <div class=\"stats\">\n            <strong>ç»Ÿè®¡ä¿¡æ¯ï¼š</strong>\n            {stats['total_conversations']}è½®å¯¹è¯ | \n            {stats['total_branches']}ä¸ªåˆ†æ”¯ | \n            å½“å‰åˆ†æ”¯: {stats['current_branch_id']}\n        </div>\n\"\"\")\n        \n        # åˆ†æ”¯å’Œå¯¹è¯\n        for idx, (branch_id, branch_nodes) in enumerate(branches.items(), 1):\n            # æ’åº\n            branch_nodes.sort(key=lambda x: x[1].depth)\n            \n            # åˆ†æ”¯ä¿¡æ¯\n            first_node = branch_nodes[0][1]\n            topic = first_node.topic or \"æœªçŸ¥è¯é¢˜\"\n            \n            html_parts.append(f\"\"\"\n        <div class=\"branch\">\n            <div class=\"branch-title\">ğŸ“ åˆ†æ”¯ {idx}: {topic} ({len(branch_nodes)}è½®)</div>\n\"\"\")\n            \n            # å¯¹è¯èŠ‚ç‚¹\n            for node_id, node in branch_nodes:\n                html_parts.append(f\"\"\"\n            <div class=\"conversation\">\n                <div class=\"user-message\">ğŸ’¬ ç”¨æˆ·: {self._escape_html(node.user_message)}</div>\n                <div class=\"ai-response\">ğŸ¤– AI: {self._escape_html(node.ai_response[:200])}{'...' if len(node.ai_response) > 200 else ''}</div>\n                <div class=\"metadata\">æ·±åº¦: {node.depth} | æ—¶é—´: {node.timestamp}</div>\n            </div>\n\"\"\")\n            \n            html_parts.append(\"        </div>\")\n        \n        html_parts.append(\"\"\"\n"
},
{
"path": "daoyoucode/agents/memory/tree_visualizer.py",
"start": 372,
"end": 380,
"text": "    def _escape_html(self, text: str) -> str:\n        \"\"\"è½¬ä¹‰HTMLç‰¹æ®Šå­—ç¬¦\"\"\"\n        return (text\n                .replace('&', '&amp;')\n                .replace('<', '&lt;')\n                .replace('>', '&gt;')\n                .replace('\"', '&quot;')\n                .replace(\"'\", '&#39;'))\n    "
},
{
"path": "daoyoucode/agents/memory/tree_visualizer.py",
"start": 381,
"end": 426,
"text": "    def export_to_file(self, filepath: str, format: str = 'auto'):\n        \"\"\"\n        å¯¼å‡ºåˆ°æ–‡ä»¶\n        \n        Args:\n            filepath: æ–‡ä»¶è·¯å¾„\n            format: æ ¼å¼ï¼ˆauto/mermaid/ascii/json/htmlï¼‰\n        \"\"\"\n        from pathlib import Path\n        \n        path = Path(filepath)\n        \n        # è‡ªåŠ¨æ£€æµ‹æ ¼å¼\n        if format == 'auto':\n            suffix = path.suffix.lower()\n            if suffix == '.md':\n                format = 'mermaid'\n            elif suffix == '.txt':\n                format = 'ascii'\n            elif suffix == '.json':\n                format = 'json'\n            elif suffix == '.html':\n                format = 'html'\n            else:\n                format = 'ascii'\n        \n        # ç”Ÿæˆå†…å®¹\n        if format == 'mermaid':\n            content = f\"# å¯¹è¯æ ‘\\n\\n```mermaid\\n{self.to_mermaid()}\\n```\"\n        elif format == 'ascii':\n            content = self.to_ascii(show_content=True)\n        elif format == 'json':\n            content = self.to_json(pretty=True)\n        elif format == 'html':\n            content = self.to_html()\n        else:\n            raise ValueError(f\"ä¸æ”¯æŒçš„æ ¼å¼: {format}\")\n        \n        # å†™å…¥æ–‡ä»¶\n        path.parent.mkdir(parents=True, exist_ok=True)\n        with open(path, 'w', encoding='utf-8') as f:\n            f.write(content)\n        \n        logger.info(f\"âœ… å¯¹è¯æ ‘å·²å¯¼å‡º: {filepath} (æ ¼å¼: {format})\")\n\n"
},
{
"path": "daoyoucode/agents/memory/tree_visualizer.py",
"start": 427,
"end": 450,
"text": "def visualize_tree(conversation_tree, format: str = 'ascii', **kwargs) -> str:\n    \"\"\"\n    å¿«æ·å‡½æ•°ï¼šå¯è§†åŒ–å¯¹è¯æ ‘\n    \n    Args:\n        conversation_tree: ConversationTreeå®ä¾‹\n        format: æ ¼å¼ï¼ˆmermaid/ascii/json/htmlï¼‰\n        **kwargs: å…¶ä»–å‚æ•°\n    \n    Returns:\n        å¯è§†åŒ–å­—ç¬¦ä¸²\n    \"\"\"\n    visualizer = TreeVisualizer(conversation_tree)\n    \n    if format == 'mermaid':\n        return visualizer.to_mermaid(**kwargs)\n    elif format == 'ascii':\n        return visualizer.to_ascii(**kwargs)\n    elif format == 'json':\n        return visualizer.to_json(**kwargs)\n    elif format == 'html':\n        return visualizer.to_html(**kwargs)\n    else:\n        raise ValueError(f\"ä¸æ”¯æŒçš„æ ¼å¼: {format}\")"
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 1,
"end": 15,
"text": "\"\"\"\nç”¨æˆ·ç®¡ç†å™¨\n\nè´Ÿè´£ç”Ÿæˆå’Œç®¡ç†ç”¨æˆ·ID\n\"\"\"\n\nfrom pathlib import Path\nimport json\nimport uuid\nimport logging\nfrom typing import Optional\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 16,
"end": 25,
"text": "class UserManager:\n    \"\"\"\n    ç”¨æˆ·ç®¡ç†å™¨\n    \n    èŒè´£ï¼š\n    1. ç”Ÿæˆå’Œç®¡ç†ç”¨æˆ·ID\n    2. æŒä¹…åŒ–ç”¨æˆ·ä¿¡æ¯\n    3. æä¾›ç”¨æˆ·é…ç½®\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 26,
"end": 45,
"text": "    def __init__(self, config_dir: Optional[str] = None):\n        \"\"\"\n        åˆå§‹åŒ–ç”¨æˆ·ç®¡ç†å™¨\n        \n        Args:\n            config_dir: é…ç½®ç›®å½•ï¼Œé»˜è®¤ä¸º ~/.daoyoucode\n        \"\"\"\n        if config_dir is None:\n            config_dir = str(Path.home() / '.daoyoucode')\n        \n        self.config_dir = Path(config_dir)\n        self.config_dir.mkdir(parents=True, exist_ok=True)\n        \n        self.user_file = self.config_dir / 'user.json'\n        \n        # åŠ è½½æˆ–åˆ›å»ºç”¨æˆ·ä¿¡æ¯\n        self.user_info = self._load_or_create_user()\n        \n        logger.info(f\"ç”¨æˆ·ç®¡ç†å™¨å·²åˆå§‹åŒ–: user_id={self.user_info['user_id']}\")\n    "
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 46,
"end": 71,
"text": "    def _load_or_create_user(self) -> dict:\n        \"\"\"åŠ è½½æˆ–åˆ›å»ºç”¨æˆ·ä¿¡æ¯\"\"\"\n        if self.user_file.exists():\n            try:\n                with open(self.user_file, 'r', encoding='utf-8') as f:\n                    user_info = json.load(f)\n                logger.info(f\"åŠ è½½äº†ç°æœ‰ç”¨æˆ·: {user_info['user_id']}\")\n                return user_info\n            except Exception as e:\n                logger.warning(f\"åŠ è½½ç”¨æˆ·ä¿¡æ¯å¤±è´¥: {e}ï¼Œå°†åˆ›å»ºæ–°ç”¨æˆ·\")\n        \n        # åˆ›å»ºæ–°ç”¨æˆ·\n        user_info = {\n            'user_id': self._generate_user_id(),\n            'created_at': self._get_timestamp(),\n            'config': {\n                'language': 'zh-CN',\n                'theme': 'default'\n            }\n        }\n        \n        self._save_user_info(user_info)\n        logger.info(f\"åˆ›å»ºäº†æ–°ç”¨æˆ·: {user_info['user_id']}\")\n        \n        return user_info\n    "
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 72,
"end": 98,
"text": "    def _generate_user_id(self) -> str:\n        \"\"\"\n        ç”Ÿæˆç”¨æˆ·ID\n        \n        ç­–ç•¥ï¼š\n        1. ä½¿ç”¨æœºå™¨æ ‡è¯†ï¼ˆå¦‚æœå¯ç”¨ï¼‰\n        2. å¦åˆ™ä½¿ç”¨UUID\n        \n        Returns:\n            ç”¨æˆ·IDå­—ç¬¦ä¸²\n        \"\"\"\n        try:\n            # å°è¯•ä½¿ç”¨æœºå™¨æ ‡è¯†\n            import platform\n            machine_id = platform.node()  # ä¸»æœºå\n            \n            if machine_id:\n                # ä½¿ç”¨ä¸»æœºåçš„hashä½œä¸ºç”¨æˆ·ID\n                import hashlib\n                hash_obj = hashlib.md5(machine_id.encode())\n                return f\"user-{hash_obj.hexdigest()[:12]}\"\n        except:\n            pass\n        \n        # å›é€€åˆ°UUID\n        return f\"user-{uuid.uuid4().hex[:12]}\"\n    "
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 99,
"end": 103,
"text": "    def _get_timestamp(self) -> str:\n        \"\"\"è·å–å½“å‰æ—¶é—´æˆ³\"\"\"\n        from datetime import datetime\n        return datetime.now().isoformat()\n    "
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 104,
"end": 111,
"text": "    def _save_user_info(self, user_info: dict):\n        \"\"\"ä¿å­˜ç”¨æˆ·ä¿¡æ¯\"\"\"\n        try:\n            with open(self.user_file, 'w', encoding='utf-8') as f:\n                json.dump(user_info, f, ensure_ascii=False, indent=2)\n        except Exception as e:\n            logger.error(f\"ä¿å­˜ç”¨æˆ·ä¿¡æ¯å¤±è´¥: {e}\")\n    "
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 112,
"end": 120,
"text": "    def get_user_id(self) -> str:\n        \"\"\"\n        è·å–ç”¨æˆ·ID\n        \n        Returns:\n            ç”¨æˆ·IDå­—ç¬¦ä¸²\n        \"\"\"\n        return self.user_info['user_id']\n    "
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 121,
"end": 133,
"text": "    def get_user_config(self, key: str, default=None):\n        \"\"\"\n        è·å–ç”¨æˆ·é…ç½®\n        \n        Args:\n            key: é…ç½®é”®\n            default: é»˜è®¤å€¼\n        \n        Returns:\n            é…ç½®å€¼\n        \"\"\"\n        return self.user_info.get('config', {}).get(key, default)\n    "
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 134,
"end": 149,
"text": "    def set_user_config(self, key: str, value):\n        \"\"\"\n        è®¾ç½®ç”¨æˆ·é…ç½®\n        \n        Args:\n            key: é…ç½®é”®\n            value: é…ç½®å€¼\n        \"\"\"\n        if 'config' not in self.user_info:\n            self.user_info['config'] = {}\n        \n        self.user_info['config'][key] = value\n        self._save_user_info(self.user_info)\n        \n        logger.info(f\"æ›´æ–°äº†ç”¨æˆ·é…ç½®: {key}={value}\")\n    "
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 150,
"end": 168,
"text": "    def reset_user(self):\n        \"\"\"é‡ç½®ç”¨æˆ·ï¼ˆç”Ÿæˆæ–°çš„ç”¨æˆ·IDï¼‰\"\"\"\n        self.user_info = {\n            'user_id': self._generate_user_id(),\n            'created_at': self._get_timestamp(),\n            'config': {\n                'language': 'zh-CN',\n                'theme': 'default'\n            }\n        }\n        \n        self._save_user_info(self.user_info)\n        logger.info(f\"é‡ç½®äº†ç”¨æˆ·: {self.user_info['user_id']}\")\n\n\n# å•ä¾‹æ¨¡å¼\n_user_manager_instance = None\n\n"
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 169,
"end": 178,
"text": "def get_user_manager() -> UserManager:\n    \"\"\"è·å–ç”¨æˆ·ç®¡ç†å™¨å•ä¾‹\"\"\"\n    global _user_manager_instance\n    \n    if _user_manager_instance is None:\n        _user_manager_instance = UserManager()\n    \n    return _user_manager_instance\n\n"
},
{
"path": "daoyoucode/agents/memory/user_manager.py",
"start": 179,
"end": 186,
"text": "def get_current_user_id() -> str:\n    \"\"\"\n    è·å–å½“å‰ç”¨æˆ·IDï¼ˆä¾¿æ·å‡½æ•°ï¼‰\n    \n    Returns:\n        ç”¨æˆ·IDå­—ç¬¦ä¸²\n    \"\"\"\n    return get_user_manager().get_user_id()"
},
{
"path": "daoyoucode/agents/memory/vector_retriever.py",
"start": 1,
"end": 21,
"text": "\"\"\"\nå‘é‡æ£€ç´¢å™¨ï¼ˆå¯é€‰åŠŸèƒ½ï¼‰\n\nä½¿ç”¨embeddingè¿›è¡Œè¯­ä¹‰ç›¸ä¼¼åº¦åŒ¹é…ï¼Œæ¯”å…³é”®è¯åŒ¹é…æ›´ç²¾å‡†\n\nä¾èµ–ï¼š\n- sentence-transformersï¼ˆå¯é€‰ï¼Œéœ€è¦æ‰‹åŠ¨å®‰è£…ï¼‰\n- numpy\n\nå®‰è£…ï¼š\npip install sentence-transformers\n\nå¦‚æœä¸å®‰è£…ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨é™çº§åˆ°å…³é”®è¯åŒ¹é…ï¼Œä¸å½±å“åŠŸèƒ½ã€‚\n\"\"\"\n\nfrom typing import List, Dict, Tuple, Optional\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/memory/vector_retriever.py",
"start": 22,
"end": 41,
"text": "class VectorRetriever:\n    \"\"\"\n    å‘é‡æ£€ç´¢å™¨ï¼ˆå¯é€‰ï¼‰\n    \n    åŠŸèƒ½ï¼š\n    1. å°†æ–‡æœ¬è½¬æ¢ä¸ºå‘é‡ï¼ˆembeddingï¼‰\n    2. è®¡ç®—å‘é‡ç›¸ä¼¼åº¦ï¼ˆä½™å¼¦ç›¸ä¼¼åº¦ï¼‰\n    3. æ£€ç´¢æœ€ç›¸å…³çš„å†å²å¯¹è¯\n    \n    ä¼˜åŠ¿ï¼š\n    - è¯­ä¹‰åŒ¹é…ï¼šç†è§£\"çŒ«å’ª\"å’Œ\"å°çŒ«\"æ˜¯åŒä¸€ä¸ªæ„æ€\n    - æ›´å‡†ç¡®ï¼šæ¯”å…³é”®è¯åŒ¹é…å‡†ç¡®ç‡é«˜10-20%\n    - è·¨è¯­è¨€ï¼šæ”¯æŒå¤šè¯­è¨€ï¼ˆå¦‚æœä½¿ç”¨å¤šè¯­è¨€æ¨¡å‹ï¼‰\n    \n    æ³¨æ„ï¼š\n    - é»˜è®¤ç¦ç”¨ï¼ˆenabled=Falseï¼‰\n    - éœ€è¦æ‰‹åŠ¨å®‰è£… sentence-transformers\n    - å¦‚æœä¸å®‰è£…ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨é™çº§åˆ°å…³é”®è¯åŒ¹é…\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/memory/vector_retriever.py",
"start": 42,
"end": 61,
"text": "    def __init__(self, model_name: str = \"paraphrase-multilingual-MiniLM-L12-v2\"):\n        \"\"\"\n        åˆå§‹åŒ–å‘é‡æ£€ç´¢å™¨\n        \n        Args:\n            model_name: embeddingæ¨¡å‹åç§°\n                - paraphrase-multilingual-MiniLM-L12-v2: å¤šè¯­è¨€ï¼Œ384ç»´ï¼Œ50MB\n                - all-MiniLM-L6-v2: è‹±æ–‡ï¼Œ384ç»´ï¼Œ80MB\n                - text2vec-base-chinese: ä¸­æ–‡ï¼Œ768ç»´ï¼Œ400MB\n        \"\"\"\n        self.model_name = model_name\n        self.model = None\n        self.enabled = False\n        \n        # å°è¯•åŠ è½½æ¨¡å‹ï¼ˆé»˜è®¤ä¸åŠ è½½ï¼‰\n        # self._load_model()  # â† æ³¨é‡Šæ‰ï¼Œé»˜è®¤ç¦ç”¨\n        \n        logger.info(\"å‘é‡æ£€ç´¢å™¨å·²åˆå§‹åŒ–ï¼ˆé»˜è®¤ç¦ç”¨ï¼‰\")\n        logger.info(\"ğŸ’¡ è¦å¯ç”¨å‘é‡æ£€ç´¢ï¼Œè¯·å®‰è£…: pip install sentence-transformers\")\n    "
},
{
"path": "daoyoucode/agents/memory/vector_retriever.py",
"start": 62,
"end": 82,
"text": "    def _load_model(self):\n        \"\"\"åŠ è½½embeddingæ¨¡å‹\"\"\"\n        try:\n            from sentence_transformers import SentenceTransformer\n            \n            logger.info(f\"ğŸ”„ åŠ è½½embeddingæ¨¡å‹: {self.model_name}\")\n            self.model = SentenceTransformer(self.model_name)\n            self.enabled = True\n            logger.info(f\"âœ… å‘é‡æ£€ç´¢å·²å¯ç”¨: {self.model_name}\")\n        \n        except ImportError:\n            logger.info(\n                \"â„¹ï¸ sentence-transformersæœªå®‰è£…ï¼Œå‘é‡æ£€ç´¢ä¸å¯ç”¨\\n\"\n                \"ğŸ’¡ å®‰è£…: pip install sentence-transformers\"\n            )\n            self.enabled = False\n        \n        except Exception as e:\n            logger.warning(f\"âš ï¸ åŠ è½½embeddingæ¨¡å‹å¤±è´¥: {e}\")\n            self.enabled = False\n    "
},
{
"path": "daoyoucode/agents/memory/vector_retriever.py",
"start": 83,
"end": 87,
"text": "    def enable(self):\n        \"\"\"æ‰‹åŠ¨å¯ç”¨å‘é‡æ£€ç´¢\"\"\"\n        if not self.enabled:\n            self._load_model()\n    "
},
{
"path": "daoyoucode/agents/memory/vector_retriever.py",
"start": 88,
"end": 109,
"text": "    def encode(self, text: str) -> Optional['numpy.ndarray']:\n        \"\"\"\n        å°†æ–‡æœ¬è½¬æ¢ä¸ºå‘é‡\n        \n        Args:\n            text: æ–‡æœ¬\n        \n        Returns:\n            å‘é‡ï¼ˆnumpyæ•°ç»„ï¼‰ï¼Œå¦‚æœå¤±è´¥è¿”å›None\n        \"\"\"\n        if not self.enabled or not self.model:\n            return None\n        \n        try:\n            # è½¬æ¢ä¸ºå‘é‡\n            embedding = self.model.encode(text, convert_to_numpy=True)\n            return embedding\n        \n        except Exception as e:\n            logger.error(f\"âŒ æ–‡æœ¬ç¼–ç å¤±è´¥: {e}\")\n            return None\n    "
},
{
"path": "daoyoucode/agents/memory/vector_retriever.py",
"start": 110,
"end": 196,
"text": "    def cosine_similarity(self, vec1, vec2) -> float:\n        \"\"\"\n        è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦\n        \n        Args:\n            vec1: å‘é‡1\n            vec2: å‘é‡2\n        \n        Returns:\n            ç›¸ä¼¼åº¦åˆ†æ•°ï¼ˆ0-1ï¼‰\n        \"\"\"\n        try:\n            import numpy as np\n            \n            # å½’ä¸€åŒ–\n            vec1_norm = vec1 / np.linalg.norm(vec1)\n            vec2_norm = vec2 / np.linalg.norm(vec2)\n            \n            # ä½™å¼¦ç›¸ä¼¼åº¦\n            similarity = np.dot(vec1_norm, vec2_norm)\n            \n            return float(similarity)\n        except Exception as e:\n            logger.error(f\"âŒ è®¡ç®—ç›¸ä¼¼åº¦å¤±è´¥: {e}\")\n            return 0.0\n    \n    async def find_relevant_history(\n        self,\n        current_message: str,\n        full_history: List[Dict],\n        limit: int = 3,\n        threshold: float = 0.5\n    ) -> List[Tuple[int, float]]:\n        \"\"\"\n        ä½¿ç”¨å‘é‡æ£€ç´¢æŸ¥æ‰¾ç›¸å…³å†å²\n        \n        Args:\n            current_message: å½“å‰æ¶ˆæ¯\n            full_history: å®Œæ•´å†å²\n            limit: æœ€å¤šè¿”å›å¤šå°‘æ¡\n            threshold: ç›¸ä¼¼åº¦é˜ˆå€¼ï¼ˆ0-1ï¼‰\n        \n        Returns:\n            [(ç´¢å¼•, ç›¸ä¼¼åº¦åˆ†æ•°), ...]\n        \"\"\"\n        if not self.enabled:\n            logger.debug(\"å‘é‡æ£€ç´¢æœªå¯ç”¨ï¼Œè¿”å›ç©ºç»“æœ\")\n            return []\n        \n        try:\n            # 1. ç¼–ç å½“å‰æ¶ˆæ¯\n            current_embedding = self.encode(current_message)\n            if current_embedding is None:\n                return []\n            \n            # 2. ç¼–ç æ‰€æœ‰å†å²æ¶ˆæ¯å¹¶è®¡ç®—ç›¸ä¼¼åº¦\n            similarities = []\n            \n            for idx, item in enumerate(full_history):\n                user_msg = item.get('user', '')\n                if not user_msg:\n                    continue\n                \n                # ç¼–ç å†å²æ¶ˆæ¯\n                msg_embedding = self.encode(user_msg)\n                if msg_embedding is None:\n                    continue\n                \n                # è®¡ç®—ç›¸ä¼¼åº¦\n                similarity = self.cosine_similarity(current_embedding, msg_embedding)\n                \n                # åªä¿ç•™è¶…è¿‡é˜ˆå€¼çš„\n                if similarity >= threshold:\n                    similarities.append((idx, similarity))\n                    logger.debug(\n                        f\"  ğŸ¯ å‘é‡åŒ¹é…ç¬¬{idx+1}è½®: {user_msg[:30]}... \"\n                        f\"(ç›¸ä¼¼åº¦: {similarity:.3f})\"\n                    )\n            \n            # 3. æŒ‰ç›¸ä¼¼åº¦æ’åºï¼Œè¿”å›top N\n            similarities.sort(key=lambda x: x[1], reverse=True)\n            return similarities[:limit]\n        \n        except Exception as e:\n            logger.error(f\"âŒ å‘é‡æ£€ç´¢å¤±è´¥: {e}\", exc_info=True)\n            return []\n    "
},
{
"path": "daoyoucode/agents/memory/vector_retriever.py",
"start": 197,
"end": 215,
"text": "    def get_stats(self) -> Dict:\n        \"\"\"è·å–ç»Ÿè®¡ä¿¡æ¯\"\"\"\n        stats = {\n            'enabled': self.enabled,\n            'model_name': self.model_name if self.enabled else None,\n        }\n        \n        if self.enabled and self.model:\n            try:\n                stats['embedding_dim'] = self.model.get_sentence_embedding_dimension()\n            except:\n                pass\n        \n        return stats\n\n\n# å…¨å±€å•ä¾‹\n_vector_retriever = None\n"
},
{
"path": "daoyoucode/agents/memory/vector_retriever.py",
"start": 216,
"end": 221,
"text": "def get_vector_retriever(model_name: str = \"paraphrase-multilingual-MiniLM-L12-v2\") -> VectorRetriever:\n    \"\"\"è·å–å‘é‡æ£€ç´¢å™¨å•ä¾‹\"\"\"\n    global _vector_retriever\n    if _vector_retriever is None:\n        _vector_retriever = VectorRetriever(model_name)\n    return _vector_retriever"
},
{
"path": "daoyoucode/agents/memory/__init__.py",
"start": 1,
"end": 64,
"text": "\"\"\"\nè®°å¿†æ¨¡å—\nç‹¬ç«‹çš„è®°å¿†ç®¡ç†ç³»ç»Ÿ\n\næä¾›å®Œæ•´çš„è®°å¿†ç®¡ç†åŠŸèƒ½ï¼š\n1. LLMå±‚è®°å¿†ï¼šå¯¹è¯å†å²\n2. Agentå±‚è®°å¿†ï¼šç”¨æˆ·åå¥½ã€ä»»åŠ¡å†å²\n3. é•¿æœŸè®°å¿†ï¼šæ‘˜è¦ã€å…³é”®ä¿¡æ¯ã€ç”¨æˆ·ç”»åƒ\n4. æ™ºèƒ½åŠ è½½ï¼šæŒ‰éœ€åŠ è½½ï¼ŒèŠ‚çœtoken\n5. å¤šæ™ºèƒ½ä½“å…±äº«ï¼šè·¨Agentçš„è®°å¿†å…±äº«\n6. ç”¨æˆ·ç®¡ç†ï¼šç”¨æˆ·IDç”Ÿæˆå’Œç®¡ç†\n7. å¯¹è¯æ ‘ï¼šåˆ†æ”¯ç®¡ç†ã€è¯é¢˜åˆ‡æ¢\n\"\"\"\n\nfrom .manager import MemoryManager, get_memory_manager\nfrom .storage import MemoryStorage\nfrom .detector import FollowupDetector\nfrom .shared import SharedMemoryInterface\nfrom .long_term_memory import LongTermMemory, get_long_term_memory\nfrom .smart_loader import SmartLoader, get_smart_loader\nfrom .vector_retriever import VectorRetriever, get_vector_retriever\nfrom .user_manager import UserManager, get_user_manager, get_current_user_id\nfrom .conversation_tree import ConversationTree, get_conversation_tree\nfrom .bm25_matcher import BM25Matcher, get_bm25_matcher\n\n__all__ = [\n    # ä¸»è¦æ¥å£\n    'MemoryManager',\n    'get_memory_manager',\n    \n    # å­˜å‚¨\n    'MemoryStorage',\n    \n    # è¿½é—®åˆ¤æ–­\n    'FollowupDetector',\n    \n    # å¤šæ™ºèƒ½ä½“å…±äº«\n    'SharedMemoryInterface',\n    \n    # é•¿æœŸè®°å¿†\n    'LongTermMemory',\n    'get_long_term_memory',\n    \n    # æ™ºèƒ½åŠ è½½\n    'SmartLoader',\n    'get_smart_loader',\n    \n    # å‘é‡æ£€ç´¢ï¼ˆå¯é€‰ï¼‰\n    'VectorRetriever',\n    'get_vector_retriever',\n    \n    # ç”¨æˆ·ç®¡ç†\n    'UserManager',\n    'get_user_manager',\n    'get_current_user_id',\n    \n    # å¯¹è¯æ ‘\n    'ConversationTree',\n    'get_conversation_tree',\n    \n    # BM25åŒ¹é…\n    'BM25Matcher',\n    'get_bm25_matcher',\n]"
},
{
"path": "daoyoucode/agents/middleware/context.py",
"start": 1,
"end": 8,
"text": "\"\"\"\nä¸Šä¸‹æ–‡ç®¡ç†ä¸­é—´ä»¶\n\"\"\"\n\nfrom typing import Dict, Any\nfrom ..core.middleware import BaseMiddleware\n\n"
},
{
"path": "daoyoucode/agents/middleware/context.py",
"start": 9,
"end": 46,
"text": "class ContextMiddleware(BaseMiddleware):\n    \"\"\"ä¸Šä¸‹æ–‡ç®¡ç†ä¸­é—´ä»¶ï¼ˆä½¿ç”¨è®°å¿†ç³»ç»Ÿï¼‰\"\"\"\n    \n    async def process(\n        self,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"å¤„ç†ä¸Šä¸‹æ–‡ç®¡ç†\"\"\"\n        try:\n            # ä½¿ç”¨å·²æœ‰çš„è®°å¿†ç®¡ç†ç³»ç»Ÿ\n            from ..memory import get_memory_manager\n            \n            memory = get_memory_manager()\n            session_id = context.get('session_id')\n            \n            if not session_id:\n                self.logger.warning(\"æœªæä¾›session_id\")\n                return context\n            \n            # è·å–å†å²å¯¹è¯ï¼ˆæœ€è¿‘5è½®ï¼‰\n            history = memory.get_conversation_history(session_id, limit=5)\n            if history:\n                context['history'] = history\n                self.logger.info(f\"å·²åŠ è½½å†å²: {len(history)} è½®\")\n            \n            # å¦‚æœæ˜¯è¿½é—®ï¼Œå¯ä»¥åŠ è½½æ›´å¤šä¸Šä¸‹æ–‡\n            if context.get('is_followup'):\n                # åŠ è½½æ›´å¤šå†å²\n                extended_history = memory.get_conversation_history(session_id, limit=10)\n                context['extended_history'] = extended_history\n                self.logger.info(f\"è¿½é—®æ¨¡å¼ï¼šå·²åŠ è½½æ‰©å±•å†å²: {len(extended_history)} è½®\")\n        \n        except Exception as e:\n            self.logger.error(f\"ä¸Šä¸‹æ–‡ç®¡ç†å¤±è´¥: {e}\")\n            context['history'] = []\n        \n        return context"
},
{
"path": "daoyoucode/agents/middleware/followup.py",
"start": 1,
"end": 8,
"text": "\"\"\"\nè¿½é—®åˆ¤æ–­ä¸­é—´ä»¶\n\"\"\"\n\nfrom typing import Dict, Any\nfrom ..core.middleware import BaseMiddleware\n\n"
},
{
"path": "daoyoucode/agents/middleware/followup.py",
"start": 9,
"end": 43,
"text": "class FollowupMiddleware(BaseMiddleware):\n    \"\"\"è¿½é—®åˆ¤æ–­ä¸­é—´ä»¶\"\"\"\n    \n    async def process(\n        self,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"å¤„ç†è¿½é—®åˆ¤æ–­\"\"\"\n        try:\n            from ...llm.context import get_followup_detector\n            \n            detector = get_followup_detector()\n            history = context.get('history', [])\n            \n            is_followup, confidence, reason = await detector.is_followup(\n                user_input,\n                history\n            )\n            \n            context['is_followup'] = is_followup\n            context['followup_confidence'] = confidence\n            context['followup_reason'] = reason\n            \n            self.logger.info(\n                f\"è¿½é—®åˆ¤æ–­: is_followup={is_followup}, \"\n                f\"confidence={confidence:.2f}\"\n            )\n        \n        except Exception as e:\n            self.logger.error(f\"è¿½é—®åˆ¤æ–­å¤±è´¥: {e}\")\n            context['is_followup'] = False\n            context['followup_confidence'] = 0.0\n        \n        return context"
},
{
"path": "daoyoucode/agents/middleware/followup_advanced.py",
"start": 1,
"end": 17,
"text": "\"\"\"\né«˜çº§è¿½é—®æ£€æµ‹ä¸­é—´ä»¶\n\nç»“åˆå¤šç§æ–¹æ³•ï¼š\n1. è§„åˆ™æ£€æµ‹ï¼ˆå¿«é€Ÿï¼‰\n2. å…³é”®è¯åŒ¹é…ï¼ˆä¸­é€Ÿï¼‰\n3. LLMè¯­ä¹‰ç†è§£ï¼ˆæ…¢ä½†å‡†ç¡®ï¼‰\n4. ä¸Šä¸‹æ–‡åˆ†æï¼ˆè¯é¢˜è¿è´¯æ€§ï¼‰\n\"\"\"\n\nfrom ..core.middleware import BaseMiddleware\nfrom typing import Dict, Any, List, Tuple\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/middleware/followup_advanced.py",
"start": 18,
"end": 27,
"text": "class AdvancedFollowupMiddleware(BaseMiddleware):\n    \"\"\"\n    é«˜çº§è¿½é—®æ£€æµ‹ä¸­é—´ä»¶\n    \n    ç‰¹ç‚¹ï¼š\n    - å››å±‚æ£€æµ‹æœºåˆ¶\n    - è‡ªé€‚åº”ç­–ç•¥ï¼ˆæ ¹æ®åœºæ™¯é€‰æ‹©æ–¹æ³•ï¼‰\n    - é«˜å‡†ç¡®ç‡ï¼ˆ95%+ï¼‰\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/middleware/followup_advanced.py",
"start": 28,
"end": 188,
"text": "    def __init__(self):\n        super().__init__()\n        \n        # è¿½é—®æŒ‡ç¤ºè¯ï¼ˆæ‰©å±•ç‰ˆï¼‰\n        self.followup_indicators = {\n            # ä»£è¯\n            'å®ƒ', 'ä»–', 'å¥¹', 'è¿™', 'é‚£', 'è¿™ä¸ª', 'é‚£ä¸ª', 'è¿™äº›', 'é‚£äº›',\n            'æ­¤', 'è¯¥', 'å…¶', 'ä¹‹', 'æ‰€', 'å‰è€…', 'åè€…',\n            \n            # è¿æ¥è¯\n            'ç»§ç»­', 'è¿˜æœ‰', 'å†', 'åˆ', 'ä¹Ÿ', 'è¿˜', 'æ›´', 'å¦å¤–',\n            'æ¥ç€', 'ç„¶å', 'æ¥ä¸‹æ¥', 'ä¸‹ä¸€æ­¥',\n            \n            # è¿½é—®è¯\n            'å‘¢', 'å—', 'ä¹ˆ', 'å•Š', 'å“¦', 'å—¯', 'å“ˆ',\n            \n            # æ·±å…¥è¯\n            'è¯¦ç»†', 'å…·ä½“', 'æ·±å…¥', 'è¿›ä¸€æ­¥', 'æ›´å¤š',\n            'æ€ä¹ˆ', 'ä¸ºä»€ä¹ˆ', 'å¦‚ä½•', 'ä¸ºä½•',\n            \n            # æ—¶é—´è¯\n            'åˆšæ‰', 'åˆšåˆš', 'ä¹‹å‰', 'ä¸Šé¢', 'å‰é¢', 'åˆšè¯´',\n            'åˆšæåˆ°', 'åˆšè®²', 'åˆšé—®',\n            \n            # ç¡®è®¤è¯\n            'å¯¹', 'æ˜¯çš„', 'æ²¡é”™', 'æ­£æ˜¯', 'å°±æ˜¯',\n            \n            # è¡¥å……è¯\n            'è¡¥å……', 'è¿½åŠ ', 'é¢å¤–', 'é¡ºä¾¿'\n        }\n        \n        # æ–°è¯é¢˜æŒ‡ç¤ºè¯\n        self.new_topic_indicators = {\n            'æ¢ä¸ª', 'å¦ä¸€ä¸ª', 'åˆ«çš„', 'å…¶ä»–', 'æ¢',\n            'æ–°çš„', 'é‡æ–°', 'ä»å¤´', 'å¼€å§‹', 'æ”¹',\n            'ä¸æ˜¯', 'ä¸å¯¹', 'ç®—äº†', 'ä¸ç”¨', 'åœ',\n            'ä¸è¯´', 'ä¸èŠ', 'ä¸è°ˆ', 'ä¸é—®'\n        }\n        \n        # ç–‘é—®è¯\n        self.question_words = {\n            'ä»€ä¹ˆ', 'æ€ä¹ˆ', 'ä¸ºä»€ä¹ˆ', 'å¦‚ä½•', 'å“ª', 'è°',\n            'å¤šå°‘', 'å‡ ', 'ä½•æ—¶', 'ä½•åœ°', 'ä½•äºº', 'ä½•äº‹',\n            'ä¸ºå•¥', 'å’‹', 'å’‹æ ·', 'å’‹åŠ'\n        }\n        \n        # ç®€å•å›åº”\n        self.simple_responses = {\n            'å¥½', 'å—¯', 'æ˜¯', 'å¯¹', 'è¡Œ', 'å¯ä»¥', 'è°¢è°¢',\n            'å¥½çš„', 'æ˜ç™½', 'çŸ¥é“äº†', 'æ‡‚äº†', 'äº†è§£',\n            'ok', 'OK', 'yes', 'Yes'\n        }\n    \n    async def process(\n        self,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"å¤„ç†è¿½é—®æ£€æµ‹\"\"\"\n        \n        # è·å–å†å²å¯¹è¯\n        session_id = context.get('session_id')\n        if not session_id:\n            # æ²¡æœ‰ä¼šè¯IDï¼Œè‚¯å®šä¸æ˜¯è¿½é—®\n            context['is_followup'] = False\n            context['followup_confidence'] = 0.0\n            context['followup_reason'] = 'no_session'\n            return context\n        \n        # è·å–å†å²\n        history = context.get('conversation_history', [])\n        if not history:\n            # æ²¡æœ‰å†å²ï¼Œè‚¯å®šä¸æ˜¯è¿½é—®\n            context['is_followup'] = False\n            context['followup_confidence'] = 0.0\n            context['followup_reason'] = 'no_history'\n            return context\n        \n        # å››å±‚æ£€æµ‹\n        is_followup, confidence, reason = await self._detect_followup(\n            user_input,\n            history,\n            context\n        )\n        \n        # æ›´æ–°context\n        context['is_followup'] = is_followup\n        context['followup_confidence'] = confidence\n        context['followup_reason'] = reason\n        \n        self.logger.info(\n            f\"è¿½é—®æ£€æµ‹: is_followup={is_followup}, \"\n            f\"confidence={confidence:.2f}, reason={reason}\"\n        )\n        \n        return context\n    \n    async def _detect_followup(\n        self,\n        user_input: str,\n        history: List[Dict],\n        context: Dict[str, Any]\n    ) -> Tuple[bool, float, str]:\n        \"\"\"\n        å››å±‚æ£€æµ‹æœºåˆ¶\n        \n        Returns:\n            (is_followup, confidence, reason)\n        \"\"\"\n        \n        # ========== å±‚1: å¿«é€Ÿè§„åˆ™æ£€æµ‹ï¼ˆ<1msï¼‰==========\n        is_followup, confidence, reason = self._rule_based_detection(user_input)\n        \n        if confidence >= 0.95:\n            # æé«˜ç½®ä¿¡åº¦ï¼Œç›´æ¥è¿”å›\n            return is_followup, confidence, f\"rule:{reason}\"\n        \n        # ========== å±‚2: å…³é”®è¯åŒ¹é…ï¼ˆ<5msï¼‰==========\n        keyword_followup, keyword_conf, keyword_reason = \\\n            self._keyword_matching(user_input, history)\n        \n        # æ›´æ–°ç½®ä¿¡åº¦\n        if keyword_conf > confidence:\n            is_followup = keyword_followup\n            confidence = keyword_conf\n            reason = keyword_reason\n        \n        if confidence >= 0.85:\n            # é«˜ç½®ä¿¡åº¦ï¼Œç›´æ¥è¿”å›\n            return is_followup, confidence, f\"keyword:{reason}\"\n        \n        # ========== å±‚3: ä¸Šä¸‹æ–‡åˆ†æï¼ˆ<10msï¼‰==========\n        context_followup, context_conf, context_reason = \\\n            self._context_analysis(user_input, history)\n        \n        # æ›´æ–°ç½®ä¿¡åº¦\n        if context_conf > confidence:\n            is_followup "
},
{
"path": "daoyoucode/agents/middleware/followup_advanced.py",
"start": 189,
"end": 228,
"text": "    def _rule_based_detection(\n        self,\n        user_input: str\n    ) -> Tuple[bool, float, str]:\n        \"\"\"\n        è§„åˆ™æ£€æµ‹ï¼ˆå¿«é€Ÿï¼‰\n        \n        æ£€æŸ¥ï¼š\n        1. è¿½é—®æŒ‡ç¤ºè¯\n        2. æ–°è¯é¢˜æŒ‡ç¤ºè¯\n        3. ç®€å•å›åº”\n        4. æ¶ˆæ¯é•¿åº¦\n        \"\"\"\n        \n        # 1. æ£€æŸ¥è¿½é—®æŒ‡ç¤ºè¯\n        for indicator in self.followup_indicators:\n            if indicator in user_input:\n                return True, 0.95, f\"indicator:{indicator}\"\n        \n        # 2. æ£€æŸ¥æ–°è¯é¢˜æŒ‡ç¤ºè¯\n        for indicator in self.new_topic_indicators:\n            if indicator in user_input:\n                return False, 0.95, f\"new_topic:{indicator}\"\n        \n        # 3. æ£€æŸ¥ç®€å•å›åº”\n        if user_input.strip() in self.simple_responses:\n            return True, 0.9, \"simple_response\"\n        \n        # 4. æ£€æŸ¥æ¶ˆæ¯é•¿åº¦\n        if len(user_input) <= 5:\n            # å¾ˆçŸ­çš„æ¶ˆæ¯ï¼Œå¯èƒ½æ˜¯è¿½é—®\n            return True, 0.7, \"short_message\"\n        \n        # 5. æ£€æŸ¥ç–‘é—®è¯\n        for qw in self.question_words:\n            if qw in user_input:\n                return True, 0.6, f\"question:{qw}\"\n        \n        return False, 0.3, \"no_rule_match\"\n    "
},
{
"path": "daoyoucode/agents/middleware/followup_advanced.py",
"start": 229,
"end": 284,
"text": "    def _keyword_matching(\n        self,\n        user_input: str,\n        history: List[Dict]\n    ) -> Tuple[bool, float, str]:\n        \"\"\"\n        å…³é”®è¯åŒ¹é…\n        \n        æ£€æŸ¥ï¼š\n        1. å…³é”®è¯é‡å åº¦\n        2. å®ä½“å»¶ç»­æ€§\n        3. è¯é¢˜ä¸€è‡´æ€§\n        \"\"\"\n        \n        # æå–å½“å‰æ¶ˆæ¯çš„å…³é”®è¯\n        current_keywords = self._extract_keywords(user_input)\n        \n        if not current_keywords:\n            return False, 0.0, \"no_keywords\"\n        \n        # æ£€æŸ¥æœ€è¿‘3è½®å¯¹è¯\n        max_overlap = 0\n        max_overlap_ratio = 0.0\n        \n        for idx, item in enumerate(history[-3:], 1):\n            content = item.get('content', '') or item.get('user', '')\n            if not content:\n                continue\n            \n            # æå–å†å²å…³é”®è¯\n            history_keywords = self._extract_keywords(content)\n            \n            if not history_keywords:\n                continue\n            \n            # è®¡ç®—é‡å \n            overlap = len(current_keywords & history_keywords)\n            overlap_ratio = overlap / len(current_keywords)\n            \n            if overlap_ratio > max_overlap_ratio:\n                max_overlap = overlap\n                max_overlap_ratio = overlap_ratio\n        \n        # åˆ¤æ–­\n        if max_overlap_ratio >= 0.5:\n            # 50%ä»¥ä¸Šé‡å ï¼Œå¾ˆå¯èƒ½æ˜¯è¿½é—®\n            confidence = min(0.9, 0.5 + max_overlap_ratio * 0.4)\n            return True, confidence, f\"overlap:{max_overlap}/{len(current_keywords)}\"\n        \n        elif max_overlap_ratio >= 0.3:\n            # 30-50%é‡å ï¼Œå¯èƒ½æ˜¯è¿½é—®\n            confidence = 0.5 + max_overlap_ratio * 0.5\n            return True, confidence, f\"partial_overlap:{max_overlap}/{len(current_keywords)}\"\n        \n        return False, 0.2, \"low_overlap\"\n    "
},
{
"path": "daoyoucode/agents/middleware/followup_advanced.py",
"start": 285,
"end": 378,
"text": "    def _context_analysis(\n        self,\n        user_input: str,\n        history: List[Dict]\n    ) -> Tuple[bool, float, str]:\n        \"\"\"\n        ä¸Šä¸‹æ–‡åˆ†æ\n        \n        æ£€æŸ¥ï¼š\n        1. è¯é¢˜è¿è´¯æ€§\n        2. å®ä½“å¼•ç”¨\n        3. æ—¶é—´è¿ç»­æ€§\n        \"\"\"\n        \n        # 1. æ£€æŸ¥å®ä½“å¼•ç”¨\n        # å¦‚æœå½“å‰æ¶ˆæ¯å¾ˆçŸ­ï¼Œä½†å†å²ä¸­æœ‰å®ä½“ï¼Œå¯èƒ½æ˜¯å¼•ç”¨\n        if len(user_input) <= 10:\n            last_msg = history[-1].get('content', '') or history[-1].get('user', '')\n            \n            # æ£€æŸ¥å†å²ä¸­æ˜¯å¦æœ‰å®ä½“ï¼ˆåè¯ï¼‰\n            import re\n            entities = re.findall(r'[\\u4e00-\\u9fa5]{2,}(?:ç±»|å‡½æ•°|æ–¹æ³•|æ–‡ä»¶|æ¨¡å—)', last_msg)\n            \n            if entities:\n                # å†å²ä¸­æœ‰å®ä½“ï¼Œå½“å‰æ¶ˆæ¯å¾ˆçŸ­ï¼Œå¯èƒ½æ˜¯è¿½é—®\n                return True, 0.8, f\"entity_reference:{len(entities)}\"\n        \n        # 2. æ£€æŸ¥è¯é¢˜è¿è´¯æ€§\n        # å¦‚æœå½“å‰æ¶ˆæ¯å’Œæœ€è¿‘æ¶ˆæ¯çš„å¥å¼ç›¸ä¼¼ï¼Œå¯èƒ½æ˜¯è¿½é—®\n        if len(history) >= 2:\n            last_msg = history[-1].get('content', '') or history[-1].get('user', '')\n            \n            # æ£€æŸ¥å¥å¼ç›¸ä¼¼åº¦ï¼ˆç®€å•ç‰ˆæœ¬ï¼‰\n            if self._sentence_similarity(user_input, last_msg) > 0.6:\n                return True, 0.75, \"sentence_similarity\"\n        \n        return False, 0.3, \"no_context_match\"\n    \n    async def _llm_semantic_understanding(\n        self,\n        user_input: str,\n        history: List[Dict]\n    ) -> Tuple[bool, float, str]:\n        \"\"\"\n        LLMè¯­ä¹‰ç†è§£ï¼ˆæœ€å‡†ç¡®ä½†æœ€æ…¢ï¼‰\n        \n        ä½¿ç”¨è½»é‡çº§LLMåˆ¤æ–­æ˜¯å¦æ˜¯è¿½é—®\n        \"\"\"\n        \n        try:\n            from ...llm import get_client_manager\n            \n            # æ„å»ºåˆ¤æ–­Prompt\n            history_text = \"\\n\".join([\n                f\"ç”¨æˆ·: {item.get('content', '') or item.get('user', '')}\"\n                for item in history[-3:]\n            ])\n            \n            prompt = f\"\"\"åˆ¤æ–­ç”¨æˆ·çš„æ–°æ¶ˆæ¯æ˜¯å¦æ˜¯å¯¹ä¹‹å‰å¯¹è¯çš„è¿½é—®ã€‚\n\nå†å²å¯¹è¯ï¼š\n{history_text}\n\næ–°æ¶ˆæ¯ï¼š{user_input}\n\nè¯·å›ç­”ï¼š\n1. æ˜¯è¿½é—®ï¼ˆå¦‚æœæ–°æ¶ˆæ¯æ˜¯åœ¨è®¨è®ºåŒä¸€ä¸ªè¯é¢˜æˆ–å¼•ç”¨ä¹‹å‰çš„å†…å®¹ï¼‰\n2. ä¸æ˜¯è¿½é—®ï¼ˆå¦‚æœæ–°æ¶ˆæ¯æ˜¯ä¸€ä¸ªå…¨æ–°çš„è¯é¢˜ï¼‰\n\nåªå›ç­”\"æ˜¯\"æˆ–\"å¦\"ï¼Œä¸è¦è§£é‡Šã€‚\"\"\"\n            \n            # è°ƒç”¨LLM\n            client_manager = get_client_manager()\n            client = await client_manager.get_client(model=\"qwen-turbo\")  # ä½¿ç”¨å¿«é€Ÿæ¨¡å‹\n            \n            response = await client.chat(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                temperature=0.1,\n                max_tokens=10\n            )\n            \n            answer = response.get('content', '').strip()\n            \n            if 'æ˜¯' in answer and 'ä¸æ˜¯' not in answer:\n                return True, 0.95, \"llm_yes\"\n            elif 'å¦' in answer or 'ä¸æ˜¯' in answer:\n                return False, 0.95, \"llm_no\"\n            else:\n                return False, 0.5, \"llm_unclear\"\n        \n        except Exception as e:\n            self.logger.error(f\"LLMè¯­ä¹‰ç†è§£å¤±è´¥: {e}\")\n            return False, 0.3, \"llm_error\"\n    "
},
{
"path": "daoyoucode/agents/middleware/followup_advanced.py",
"start": 379,
"end": 398,
"text": "    def _extract_keywords(self, text: str) -> set:\n        \"\"\"æå–å…³é”®è¯\"\"\"\n        import re\n        \n        # æå–ä¸­æ–‡è¯ï¼ˆ2ä¸ªå­—ä»¥ä¸Šï¼‰\n        words = re.findall(r'[\\u4e00-\\u9fa5]{2,}', text)\n        \n        # åœç”¨è¯\n        stopwords = {\n            'çš„', 'äº†', 'æ˜¯', 'åœ¨', 'æˆ‘', 'æœ‰', 'å’Œ', 'å°±',\n            'ä¸', 'äºº', 'éƒ½', 'ä¸€', 'ä¸ª', 'ä¸Š', 'æ¥', 'åˆ°',\n            'è¯´', 'è¦', 'å»', 'ä½ ', 'ä¼š', 'ç€', 'æ²¡', 'çœ‹',\n            'èƒ½', 'è¿™æ ·', 'é‚£æ ·', 'æ€æ ·', 'ä»€ä¹ˆæ ·'\n        }\n        \n        # è¿‡æ»¤åœç”¨è¯\n        keywords = {w for w in words if w not in stopwords}\n        \n        return keywords\n    "
},
{
"path": "daoyoucode/agents/middleware/followup_advanced.py",
"start": 399,
"end": 414,
"text": "    def _sentence_similarity(self, sent1: str, sent2: str) -> float:\n        \"\"\"è®¡ç®—å¥å­ç›¸ä¼¼åº¦ï¼ˆç®€å•ç‰ˆæœ¬ï¼‰\"\"\"\n        \n        # æå–å…³é”®è¯\n        keywords1 = self._extract_keywords(sent1)\n        keywords2 = self._extract_keywords(sent2)\n        \n        if not keywords1 or not keywords2:\n            return 0.0\n        \n        # è®¡ç®—Jaccardç›¸ä¼¼åº¦\n        intersection = len(keywords1 & keywords2)\n        union = len(keywords1 | keywords2)\n        \n        return intersection / union if union > 0 else 0.0\n    "
},
{
"path": "daoyoucode/agents/middleware/followup_advanced.py",
"start": 415,
"end": 422,
"text": "    def _is_important_scenario(self, context: Dict[str, Any]) -> bool:\n        \"\"\"åˆ¤æ–­æ˜¯å¦æ˜¯é‡è¦åœºæ™¯ï¼ˆéœ€è¦é«˜å‡†ç¡®ç‡ï¼‰\"\"\"\n        \n        # å¦‚æœæ˜¯ä»£ç ç›¸å…³çš„Skillï¼Œéœ€è¦é«˜å‡†ç¡®ç‡\n        skill_name = context.get('skill_name', '')\n        important_skills = ['code-exploration', 'code-analysis', 'refactoring']\n        \n        return skill_name in important_skills"
},
{
"path": "daoyoucode/agents/orchestrators/conditional.py",
"start": 1,
"end": 13,
"text": "\"\"\"\næ¡ä»¶åˆ†æ”¯ç¼–æ’å™¨\n\næ ¹æ®æ¡ä»¶é€‰æ‹©ä¸åŒçš„æ‰§è¡Œè·¯å¾„\n\"\"\"\n\nfrom ..core.orchestrator import BaseOrchestrator\nfrom typing import Dict, Any\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/orchestrators/conditional.py",
"start": 14,
"end": 244,
"text": "class ConditionalOrchestrator(BaseOrchestrator):\n    \"\"\"\n    æ¡ä»¶åˆ†æ”¯ç¼–æ’å™¨\n    \n    æ ¹æ®æ¡ä»¶é€‰æ‹©æ‰§è¡Œif_pathæˆ–else_path\n    \"\"\"\n    \n    async def execute(\n        self,\n        skill,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        æ‰§è¡Œæ¡ä»¶åˆ†æ”¯\n        \n        æ”¯æŒä¸¤ç§æ¨¡å¼ï¼š\n        \n        1. ç®€å•æ¨¡å¼ï¼ˆäºŒé€‰ä¸€ï¼‰:\n        condition: ${context.language} == 'python'\n        if_path:\n          agent: python_expert\n        else_path:\n          agent: general_programmer\n        \n        2. å¤šè·¯åˆ†æ”¯æ¨¡å¼:\n        conditions:\n          - condition: ${context.language} == 'python'\n            path:\n              agent: python_expert\n          - condition: ${context.language} == 'javascript'\n            path:\n              agent: js_expert\n          - default: true\n            path:\n              agent: general_editor\n        \"\"\"\n        # åº”ç”¨ä¸­é—´ä»¶\n        if skill.middleware:\n            for middleware_name in skill.middleware:\n                context = await self._apply_middleware(\n                    middleware_name,\n                    user_input,\n                    context\n                )\n        \n        # ä¿å­˜Skillå¼•ç”¨ï¼Œä¾›è·¯å¾„ä½¿ç”¨\n        context['_current_skill'] = skill\n        \n        # æ£€æŸ¥æ˜¯å¤šè·¯åˆ†æ”¯è¿˜æ˜¯ç®€å•æ¨¡å¼\n        conditions = getattr(skill, 'conditions', None)\n        \n        if conditions:\n            # å¤šè·¯åˆ†æ”¯æ¨¡å¼\n            return await self._execute_multi_branch(conditions, user_input, context)\n        else:\n            # ç®€å•æ¨¡å¼ï¼ˆå‘åå…¼å®¹ï¼‰\n            return await self._execute_simple_branch(skill, user_input, context)\n    \n    async def _execute_simple_branch(\n        self,\n        skill,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"æ‰§è¡Œç®€å•çš„if/elseåˆ†æ”¯\"\"\"\n        # è·å–æ¡ä»¶\n        condition = getattr(skill, 'condition', None)\n        if not condition:\n            return {\n                'success': False,\n                'content': '',\n                'error': 'Skillæœªå®šä¹‰condition'\n            }\n        \n        # è¯„ä¼°æ¡ä»¶\n        condition_result = await self._evaluate_condition(condition, context)\n        \n        logger.info(f\"æ¡ä»¶è¯„ä¼°ç»“æœ: {condition_result}\")\n        \n        # é€‰æ‹©æ‰§è¡Œè·¯å¾„\n        if condition_result:\n            path = getattr(skill, 'if_path', None)\n            path_name = 'if_path'\n        else:\n            path = getattr(skill, 'else_path', None)\n            path_name = 'else_path'\n        \n        if not path:\n            return {\n                'success': False,\n                'content': '',\n                'error': f'Skillæœªå®šä¹‰{path_name}'\n            }\n        \n        # æ‰§è¡Œé€‰ä¸­çš„è·¯å¾„\n        result = await self._execute_path(path, user_input, context)\n        \n        result['metadata'] = result.get('metadata', {})\n        result['metadata'].update({\n            'orchestrator': 'conditional',\n            'mode': 'simple',\n            'condition': condition,\n            'condition_result': condition_result,\n            'path_executed': path_name\n        })\n        \n        return result\n    \n    async def _execute_multi_branch(\n        self,\n        conditions: list,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"æ‰§è¡Œå¤šè·¯åˆ†æ”¯\"\"\"\n        selected_path = None\n        selected_index = -1\n        matched_condition = None\n        \n        # éå†æ‰€æœ‰æ¡ä»¶ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…çš„\n        for i, branch in enumerate(conditions):\n            # æ£€æŸ¥æ˜¯å¦æ˜¯defaultåˆ†æ”¯\n            if branch.get('default'):\n                if selected_path is None:\n                    selected_path = branch.get('path')\n                    selected_index = i\n                    matched_condition = 'default'\n                continue\n            \n            # è¯„ä¼°æ¡ä»¶\n            condition = branch.get('condition')\n            if not condition:\n                logger.warning(f\"åˆ†æ”¯ {i} ç¼ºå°‘conditionï¼Œè·³è¿‡\")\n                continue\n            \n            condition_result = await self._evaluate_condition(condition, context)\n            \n            logger.info(f\"åˆ†æ”¯ {i} æ¡ä»¶è¯„ä¼°: {condition} â†’ {condition_result}\")\n          "
},
{
"path": "daoyoucode/agents/orchestrators/conditional.py",
"start": 245,
"end": 252,
"text": "    def _replace_variables(\n        self,\n        text: str,\n        context: Dict[str, Any]\n    ) -> str:\n        \"\"\"æ›¿æ¢å˜é‡ ${variable}\"\"\"\n        import re\n        "
},
{
"path": "daoyoucode/agents/orchestrators/conditional.py",
"start": 253,
"end": 264,
"text": "        def replace_var(match):\n            var_path = match.group(1)\n            value = self._get_nested_value(var_path, context)\n            if value is None:\n                return match.group(0)\n            # å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œæ·»åŠ å¼•å·\n            if isinstance(value, str):\n                return f'\"{value}\"'\n            return str(value)\n        \n        return re.sub(r'\\$\\{([^}]+)\\}', replace_var, text)\n    "
},
{
"path": "daoyoucode/agents/orchestrators/conditional.py",
"start": 265,
"end": 281,
"text": "    def _get_nested_value(\n        self,\n        path: str,\n        context: Dict[str, Any]\n    ) -> Any:\n        \"\"\"è·å–åµŒå¥—å€¼\"\"\"\n        keys = path.split('.')\n        value = context\n        \n        for key in keys:\n            if isinstance(value, dict):\n                value = value.get(key)\n            else:\n                return None\n        \n        return value\n    "
},
{
"path": "daoyoucode/agents/orchestrators/conditional.py",
"start": 282,
"end": 308,
"text": "    def _safe_eval(\n        self,\n        condition: str,\n        context: Dict[str, Any]\n    ) -> bool:\n        \"\"\"å®‰å…¨çš„æ¡ä»¶è¯„ä¼°\"\"\"\n        try:\n            # ç§»é™¤å±é™©å­—ç¬¦\n            if any(char in condition for char in ['__', 'import', 'exec', 'eval']):\n                return False\n            \n            # åˆ›å»ºå®‰å…¨çš„å‘½åç©ºé—´\n            safe_dict = {\n                'True': True,\n                'False': False,\n                'None': None,\n            }\n            \n            # æ·»åŠ contextåˆ°å‘½åç©ºé—´\n            safe_dict['context'] = context\n            \n            # è¯„ä¼°\n            return bool(eval(condition, {\"__builtins__\": {}}, safe_dict))\n        \n        except Exception as e:\n            logger.warning(f\"æ¡ä»¶è¯„ä¼°å¤±è´¥: {e}\")\n            return False"
},
{
"path": "daoyoucode/agents/orchestrators/multi_agent.py",
"start": 1,
"end": 12,
"text": "\"\"\"\nå¤šAgentç¼–æ’å™¨ï¼ˆå¢å¼ºç‰ˆï¼‰\n\næ”¯æŒå¤šç§åä½œæ¨¡å¼çš„çœŸæ­£å¤šAgentåä½œ\n\"\"\"\n\nfrom typing import Dict, Any, Optional, List\nimport asyncio\nimport json\nfrom ..core.orchestrator import BaseOrchestrator\n\n"
},
{
"path": "daoyoucode/agents/orchestrators/multi_agent.py",
"start": 13,
"end": 374,
"text": "class MultiAgentOrchestrator(BaseOrchestrator):\n    \"\"\"\n    å¤šAgentç¼–æ’å™¨ï¼ˆå¢å¼ºç‰ˆï¼‰\n    \n    æ”¯æŒ4ç§åä½œæ¨¡å¼ï¼š\n    1. sequential: é¡ºåºæ‰§è¡Œï¼ˆæ¯ä¸ªAgentå¤„ç†å‰ä¸€ä¸ªçš„è¾“å‡ºï¼‰\n    2. parallel: å¹¶è¡Œæ‰§è¡Œï¼ˆæ‰€æœ‰AgentåŒæ—¶å¤„ç†ï¼‰\n    3. debate: è¾©è®ºæ¨¡å¼ï¼ˆAgentä¹‹é—´è®¨è®ºï¼‰\n    4. main_with_helpers: ä¸»Agent + è¾…åŠ©Agentï¼ˆé»˜è®¤ï¼‰\n    \"\"\"\n    \n    async def execute(\n        self,\n        skill: 'SkillConfig',\n        user_input: str,\n        context: Optional[Dict[str, Any]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"æ‰§è¡ŒSkill\"\"\"\n        if context is None:\n            context = {}\n        \n        self.logger.info(f\"å¤šAgentæ‰§è¡ŒSkill: {skill.name}\")\n        \n        # 1. åº”ç”¨ä¸­é—´ä»¶\n        if skill.middleware:\n            for middleware_name in skill.middleware:\n                context = await self._apply_middleware(\n                    middleware_name,\n                    user_input,\n                    context\n                )\n        \n        # 2. åªä½¿ç”¨å·²æ³¨å†Œçš„å·¥å…·åï¼ˆé¿å… Skill é…ç½®é”™è¯¯å¯¼è‡´ä¸ç¨³å®šï¼‰\n        from ..tools import get_tool_registry\n        _tool_registry = get_tool_registry()\n        skill_tools_filtered = _tool_registry.filter_tool_names(skill.tools if skill.tools else None)\n        \n        # 3. è·å–Agentåˆ—è¡¨\n        agents = self._get_agents_from_skill(skill)\n        \n        if not agents:\n            return {\n                'success': False,\n                'content': '',\n                'error': 'No agents configured'\n            }\n        \n        # 4. ç¡®å®šåä½œæ¨¡å¼\n        mode = getattr(skill, 'collaboration_mode', 'main_with_helpers')\n        \n        self.logger.info(f\"åä½œæ¨¡å¼: {mode}, Agentæ•°é‡: {len(agents)}\")\n        \n        # ä¸ºå¤š Agent ä¼ é€’è¿‡æ»¤åçš„ toolsï¼ˆç”¨ä¸´æ—¶å±æ€§é¿å…æ”¹ SkillConfig ç»“æ„ï¼‰\n        skill._filtered_tools = skill_tools_filtered\n        \n        # 5. æ ¹æ®æ¨¡å¼æ‰§è¡Œ\n        if mode == 'sequential':\n            result = await self._execute_sequential(agents, user_input, context, skill)\n        elif mode == 'parallel':\n            result = await self._execute_parallel(agents, user_input, context, skill)\n        elif mode == 'debate':\n            result = await self._execute_debate(agents, user_input, context, skill)\n        else:\n            result = await self._execute_main_with_helpers(agents, user_input, context, skill)\n        \n        # 5. æ·»åŠ å…ƒæ•°æ®\n        result['metadata'] = result.get('metadata', {})\n        result['metadata'].update({\n            'skill': skill.name,\n            'orchestrator': 'multi_agent',\n            'collaboration_mode': mode,\n            'agents_count': len(agents),\n            'agents_used': [agent.name for agent in agents]\n        })\n        \n        return result\n    \n    async def _execute_sequential(\n        self,\n        agents: List,\n        user_input: str,\n        context: Dict[str, Any],\n        skill: 'SkillConfig'\n    ) -> Dict[str, Any]:\n        \"\"\"\n        é¡ºåºæ‰§è¡Œæ¨¡å¼\n        \n        æ¯ä¸ªAgentå¤„ç†å‰ä¸€ä¸ªAgentçš„è¾“å‡º\n        \"\"\"\n        self.logger.info(\"é¡ºåºæ‰§è¡Œæ¨¡å¼\")\n        \n        current_input = user_input\n        results = []\n        \n        for i, agent in enumerate(agents):\n            self.logger.info(f\"æ‰§è¡ŒAgent {i+1}/{len(agents)}: {agent.name}\")\n            \n            result = await agent.execute(\n                prompt_source={'use_agent_default': True},\n                user_input=current_input,\n                context=context,\n                llm_config=skill.llm,\n                tools=getattr(skill, '_filtered_tools', None) or skill.tools\n            )\n            \n            results.append({\n                'agent': agent.name,\n                'success': result.success,\n                'content': result.content,\n                'tokens_used': result.tokens_used\n            })\n            \n            # ä¸‹ä¸€ä¸ªAgentä½¿ç”¨å‰ä¸€ä¸ªçš„è¾“å‡º\n            if result.success and result.content:\n                current_input = result.content\n            else:\n                # å¦‚æœå¤±è´¥ï¼Œåœæ­¢æ‰§è¡Œ\n                self.logger.warning(f\"Agent {agent.name} æ‰§è¡Œå¤±è´¥ï¼Œåœæ­¢é¡ºåºæ‰§è¡Œ\")\n                break\n        \n        # èšåˆç»“æœ\n        final_content = results[-1]['content'] if results else \"\"\n        total_tokens = sum(r['tokens_used'] for r in results)\n "
},
{
"path": "daoyoucode/agents/orchestrators/multi_agent.py",
"start": 375,
"end": 453,
"text": "    def _build_debate_prompt(\n        self,\n        user_input: str,\n        agent_name: str,\n        debate_history: List,\n        round_num: int\n    ) -> str:\n        \"\"\"æ„å»ºè¾©è®ºPrompt\"\"\"\n        \n        prompt_parts = [\n            f\"ä½ æ˜¯ {agent_name}ï¼Œæ­£åœ¨å‚ä¸ä¸€ä¸ªå¤šAgentè¾©è®ºã€‚\",\n            f\"\",\n            f\"é—®é¢˜: {user_input}\",\n            f\"\",\n            f\"å½“å‰æ˜¯ç¬¬ {round_num + 1} è½®è¾©è®ºã€‚\"\n        ]\n        \n        # æ·»åŠ ä¹‹å‰çš„è¾©è®ºå†å²\n        if debate_history:\n            prompt_parts.append(\"\")\n            prompt_parts.append(\"ä¹‹å‰çš„è¾©è®º:\")\n            \n            for round_data in debate_history:\n                prompt_parts.append(f\"\\nç¬¬ {round_data['round']} è½®:\")\n                for opinion in round_data['opinions']:\n                    prompt_parts.append(f\"- {opinion['agent']}: {opinion['opinion'][:200]}...\")\n        \n        prompt_parts.append(\"\")\n        prompt_parts.append(\"è¯·æå‡ºä½ çš„è§‚ç‚¹ï¼ˆè€ƒè™‘å…¶ä»–Agentçš„æ„è§ï¼Œä½†ä¿æŒç‹¬ç«‹æ€è€ƒï¼‰:\")\n        \n        return \"\\n\".join(prompt_parts)\n    \n    async def _aggregate_parallel_results(\n        self,\n        results: List[Dict[str, Any]]\n    ) -> str:\n        \"\"\"èšåˆå¹¶è¡Œç»“æœ\"\"\"\n        \n        sections = []\n        \n        for result in results:\n            if result['success'] and result.get('content'):\n                sections.append(f\"[{result['agent']}]\\n{result['content']}\")\n        \n        if not sections:\n            return \"\"\n        \n        return \"\\n\\n---\\n\\n\".join(sections)\n    \n    async def _synthesize_debate(\n        self,\n        debate_history: List,\n        user_input: str\n    ) -> str:\n        \"\"\"ç»¼åˆè¾©è®ºç»“æœ\"\"\"\n        \n        # ç®€åŒ–ç‰ˆï¼šæå–æ‰€æœ‰è§‚ç‚¹\n        all_opinions = []\n        \n        for round_data in debate_history:\n            for opinion in round_data['opinions']:\n                if opinion.get('opinion'):\n                    all_opinions.append(f\"{opinion['agent']}: {opinion['opinion']}\")\n        \n        if not all_opinions:\n            return \"è¾©è®ºæœªäº§ç”Ÿæœ‰æ•ˆç»“è®º\"\n        \n        # ç»„åˆæˆæœ€ç»ˆç­”æ¡ˆ\n        synthesis = [\n            f\"ç»è¿‡ {len(debate_history)} è½®è¾©è®ºï¼Œå„Agentçš„è§‚ç‚¹å¦‚ä¸‹ï¼š\",\n            \"\",\n            *all_opinions,\n            \"\",\n            \"ç»¼åˆç»“è®ºï¼š\",\n            \"ï¼ˆå„Agentè§‚ç‚¹å·²åˆ—å‡ºï¼Œè¯·æ ¹æ®å®é™…æƒ…å†µç»¼åˆåˆ¤æ–­ï¼‰\"\n        ]\n        \n        return \"\\n\".join(synthesis)\n    "
},
{
"path": "daoyoucode/agents/orchestrators/multi_agent.py",
"start": 454,
"end": 466,
"text": "    def _get_agents_from_skill(self, skill: 'SkillConfig') -> List:\n        \"\"\"ä»Skillé…ç½®è·å–Agentåˆ—è¡¨\"\"\"\n        agents = []\n        \n        if skill.agents:\n            for agent_name in skill.agents:\n                agent = self._get_agent(agent_name)\n                agents.append(agent)\n        elif skill.agent:\n            agent = self._get_agent(skill.agent)\n            agents.append(agent)\n        \n        return agents"
},
{
"path": "daoyoucode/agents/orchestrators/parallel.py",
"start": 1,
"end": 15,
"text": "\"\"\"\nå¹¶è¡Œç¼–æ’å™¨ï¼ˆå¢å¼ºç‰ˆï¼‰\n\næ”¯æŒLLMæ™ºèƒ½ä»»åŠ¡æ‹†åˆ†å’Œç»“æœèšåˆ\n\"\"\"\n\nfrom ..core.orchestrator import BaseOrchestrator\nfrom typing import Dict, Any, List\nimport asyncio\nimport json\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/orchestrators/parallel.py",
"start": 16,
"end": 26,
"text": "class ParallelOrchestrator(BaseOrchestrator):\n    \"\"\"\n    å¹¶è¡Œç¼–æ’å™¨ï¼ˆå¢å¼ºç‰ˆï¼‰\n    \n    æ–°å¢åŠŸèƒ½ï¼š\n    - LLMæ™ºèƒ½ä»»åŠ¡æ‹†åˆ†\n    - ä¼˜å…ˆçº§è°ƒåº¦\n    - LLMæ™ºèƒ½ç»“æœèšåˆ\n    - æ‰¹é‡æ‰§è¡Œæ§åˆ¶\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/orchestrators/parallel.py",
"start": 27,
"end": 325,
"text": "    def __init__(self, timeout: float = 60.0, batch_size: int = 3):\n        super().__init__()\n        self.timeout = timeout\n        self.batch_size = batch_size\n    \n    async def execute(\n        self,\n        skill,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        å¹¶è¡Œæ‰§è¡Œ\n        \n        æ”¯æŒä¸¤ç§æ¨¡å¼ï¼š\n        1. é…ç½®æ¨¡å¼ï¼šä½¿ç”¨Skillé…ç½®çš„agents\n        2. æ™ºèƒ½æ¨¡å¼ï¼šä½¿ç”¨LLMè‡ªåŠ¨æ‹†åˆ†ä»»åŠ¡\n        \"\"\"\n        # åº”ç”¨ä¸­é—´ä»¶\n        if skill.middleware:\n            for middleware_name in skill.middleware:\n                context = await self._apply_middleware(\n                    middleware_name,\n                    user_input,\n                    context\n                )\n        \n        # ä¿å­˜Skillå¼•ç”¨\n        context['_current_skill'] = skill\n        \n        # è·å–ä»»åŠ¡åˆ—è¡¨\n        agents_config = getattr(skill, 'agents', None)\n        use_llm_split = getattr(skill, 'use_llm_split', False)\n        \n        if agents_config:\n            # é…ç½®æ¨¡å¼\n            logger.info(\"ä½¿ç”¨é…ç½®çš„agents\")\n            tasks = self._prepare_tasks(agents_config, user_input, context)\n        elif use_llm_split:\n            # æ™ºèƒ½æ¨¡å¼ï¼šä½¿ç”¨LLMæ‹†åˆ†\n            logger.info(\"ä½¿ç”¨LLMæ™ºèƒ½æ‹†åˆ†ä»»åŠ¡\")\n            tasks = await self._llm_analyze_and_split(user_input, context, skill)\n        else:\n            # ç®€å•æ¨¡å¼ï¼šåŸºäºå…³é”®è¯æ‹†åˆ†\n            logger.info(\"ä½¿ç”¨å…³é”®è¯æ‹†åˆ†ä»»åŠ¡\")\n            tasks = await self._analyze_and_split(user_input, context)\n        \n        if not tasks:\n            return {\n                'success': False,\n                'content': '',\n                'error': 'æ— æ³•ç”Ÿæˆä»»åŠ¡'\n            }\n        \n        # æŒ‰ä¼˜å…ˆçº§æ’åº\n        tasks.sort(key=lambda t: t.get('priority', 5), reverse=True)\n        \n        logger.info(f\"å¹¶è¡Œæ‰§è¡Œ {len(tasks)} ä¸ªä»»åŠ¡ï¼ˆæ‰¹é‡å¤§å°: {self.batch_size}ï¼‰\")\n        \n        # åˆ†æ‰¹æ‰§è¡Œ\n        all_results = await self._execute_in_batches(tasks, context)\n        \n        # æ™ºèƒ½èšåˆç»“æœ\n        use_llm_aggregate = getattr(skill, 'use_llm_aggregate', False)\n        \n        if use_llm_aggregate:\n            logger.info(\"ä½¿ç”¨LLMæ™ºèƒ½èšåˆç»“æœ\")\n            aggregated = await self._llm_smart_aggregate(all_results, user_input)\n        else:\n            logger.info(\"ä½¿ç”¨ç®€å•èšåˆ\")\n            aggregated = await self._smart_aggregate(all_results)\n        \n        # ç»Ÿè®¡\n        successful_results = [r for r in all_results if not isinstance(r, Exception) and r.get('success')]\n        failed_results = [r for r in all_results if isinstance(r, Exception) or not r.get('success')]\n        \n        return {\n            'success': len(successful_results) > 0,\n            'content': aggregated,\n            'parallel_results': all_results,\n            'metadata': {\n                'orchestrator': 'parallel',\n                'total_tasks': len(tasks),\n                'successful_tasks': len(successful_results),\n                'failed_tasks': len(failed_results),\n                'batch_size': self.batch_size,\n                'use_llm_split': use_llm_split,\n                'use_llm_aggregate': use_llm_aggregate\n            }\n        }\n    \n    async def _llm_analyze_and_split(\n        self,\n        user_input: str,\n        context: Dict[str, Any],\n        skill\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        ä½¿ç”¨LLMæ™ºèƒ½æ‹†åˆ†ä»»åŠ¡\n        \n        LLMä¼šåˆ†æä»»åŠ¡å¹¶å†³å®šï¼š\n        - éœ€è¦å“ªäº›å­ä»»åŠ¡\n        - æ¯ä¸ªå­ä»»åŠ¡ä½¿ç”¨å“ªä¸ªAgent\n        - å­ä»»åŠ¡çš„ä¼˜å…ˆçº§\n        \"\"\"\n        # è·å–å¯ç”¨çš„Agentåˆ—è¡¨\n        from ..core.agent import get_agent_registry\n        registry = get_agent_registry()\n        available_agents = registry.list_agents()\n        \n        # æ„å»ºåˆ†æPrompt\n        analysis_prompt = f\"\"\"\nåˆ†æä»¥ä¸‹ä»»åŠ¡ï¼Œæ‹†åˆ†æˆå¯ä»¥å¹¶è¡Œæ‰§è¡Œçš„å­ä»»åŠ¡ã€‚\n\nä»»åŠ¡: {user_input}\n\nå¯ç”¨çš„Agent:\n{chr(10).join([f\"- {agent}: ä¸“é—¨å¤„ç†ç›¸å…³ä»»åŠ¡\" for agent in available_agents[:10]])}\n\nè¯·è¿”å›JSONæ•°ç»„ï¼Œæ¯ä¸ªå­ä»»åŠ¡åŒ…å«ï¼š\n- name: å­ä»»åŠ¡åç§°ï¼ˆç®€çŸ­ï¼‰\n- description: å­ä»»åŠ¡æè¿°\n- agent: å»ºè®®ä½¿ç”¨çš„Agentï¼ˆä»ä¸Šé¢åˆ—è¡¨é€‰æ‹©ï¼‰\n- priority: ä¼˜å…ˆçº§ï¼ˆ1-10ï¼Œ10æœ€é«˜ï¼‰\n\nè¦æ±‚ï¼š\n1. å­ä»»åŠ¡åº”è¯¥å¯ä»¥å¹¶è¡Œæ‰§è¡Œï¼ˆäº’ä¸ä¾èµ–ï¼‰\n2. æ¯ä¸ªå­ä»»åŠ¡åº”è¯¥èšç„¦ä¸€ä¸ªæ–¹é¢\n3. ä¼˜å…ˆçº§é«˜çš„ä»»åŠ¡æ›´é‡è¦\n4. æœ€å¤šæ‹†åˆ†5ä¸ªå­ä»»åŠ¡\n\nç¤ºä¾‹è¾“å‡ºï¼š\n[\n  {{\"name\": \"search_code\", \"description\": \"æœç´¢ç›¸å…³ä»£ç \", \"agent\": \"code_explorer\", \"priority\": 8}},\n  {{\"name\": \"search_docs\", \"description\": \"æŸ¥æ‰¾æ–‡æ¡£\", \"agent\": \"transl"
},
{
"path": "daoyoucode/agents/orchestrators/parallel.py",
"start": 326,
"end": 459,
"text": "    def _prepare_tasks(\n        self,\n        agents_config: List[Dict[str, Any]],\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> List[Dict[str, Any]]:\n        \"\"\"å‡†å¤‡ä»»åŠ¡åˆ—è¡¨\"\"\"\n        tasks = []\n        \n        for config in agents_config:\n            task = {\n                'name': config.get('name', 'unnamed'),\n                'agent': config.get('agent'),\n                'task': config.get('task', user_input),\n                'prompt': config.get('prompt', {'use_agent_default': True})\n            }\n            tasks.append(task)\n        \n        return tasks\n    \n    async def _analyze_and_split(\n        self,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        åˆ†æä»»åŠ¡å¹¶è‡ªåŠ¨æ‹†åˆ†\n        \n        ç®€åŒ–ç‰ˆæœ¬ï¼šåŸºäºå…³é”®è¯æ‹†åˆ†\n        \"\"\"\n        tasks = []\n        \n        # æ£€æµ‹æ˜¯å¦éœ€è¦ä»£ç æœç´¢\n        if any(kw in user_input.lower() for kw in ['æŸ¥æ‰¾', 'æœç´¢', 'ä»£ç ', 'find', 'search']):\n            tasks.append({\n                'name': 'code_search',\n                'agent': 'explore',\n                'task': f\"åœ¨ä»£ç åº“ä¸­æŸ¥æ‰¾: {user_input}\",\n                'prompt': {'use_agent_default': True}\n            })\n        \n        # æ£€æµ‹æ˜¯å¦éœ€è¦æ–‡æ¡£æŸ¥è¯¢\n        if any(kw in user_input.lower() for kw in ['æ–‡æ¡£', 'å®˜æ–¹', 'docs', 'documentation']):\n            tasks.append({\n                'name': 'doc_search',\n                'agent': 'librarian',\n                'task': f\"æŸ¥æ‰¾å®˜æ–¹æ–‡æ¡£: {user_input}\",\n                'prompt': {'use_agent_default': True}\n            })\n        \n        # å¦‚æœæ²¡æœ‰ç‰¹å®šä»»åŠ¡ï¼Œä½¿ç”¨é»˜è®¤Agent\n        if not tasks:\n            tasks.append({\n                'name': 'default',\n                'agent': 'translator',  # é»˜è®¤Agent\n                'task': user_input,\n                'prompt': {'use_agent_default': True}\n            })\n        \n        return tasks\n    \n    async def _execute_task(\n        self,\n        task: Dict[str, Any],\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"æ‰§è¡Œå•ä¸ªä»»åŠ¡\"\"\"\n        agent_name = task['agent']\n        task_input = task['task']\n        prompt_config = task['prompt']\n        \n        # è·å–Agent\n        agent = self._get_agent(agent_name)\n        \n        # å‡†å¤‡å·¥å…·ï¼ˆä»ä»»åŠ¡é…ç½®æˆ–Skillé…ç½®è·å–ï¼‰\n        task_tools = task.get('tools')\n        if task_tools is None and '_current_skill' in context:\n            # å¦‚æœä»»åŠ¡æ²¡æœ‰æŒ‡å®šå·¥å…·ï¼Œä½¿ç”¨Skillçš„å·¥å…·\n            current_skill = context['_current_skill']\n            if hasattr(current_skill, 'tools'):\n                task_tools = current_skill.tools\n        \n        # æ‰§è¡Œ\n        result = await agent.execute(\n            prompt_source=prompt_config,\n            user_input=task_input,\n            context=context,\n            tools=task_tools if task_tools else None\n        )\n        \n        # æ·»åŠ ä»»åŠ¡ä¿¡æ¯\n        result['task_name'] = task['name']\n        result['agent_name'] = agent_name\n        \n        return result\n    \n    async def _smart_aggregate(\n        self,\n        results: List[Dict[str, Any]]\n    ) -> str:\n        \"\"\"\n        æ™ºèƒ½èšåˆç»“æœ\n        \n        æ ¹æ®ç»“æœç±»å‹å’Œå†…å®¹æ™ºèƒ½ç»„åˆ\n        \"\"\"\n        if not results:\n            return \"\"\n        \n        # æŒ‰ä»»åŠ¡ç±»å‹åˆ†ç»„\n        grouped = {}\n        for result in results:\n            task_name = result.get('task_name', 'unknown')\n            if task_name not in grouped:\n                grouped[task_name] = []\n            grouped[task_name].append(result)\n        \n        # ç»„åˆç»“æœ\n        sections = []\n        \n        for task_name, task_results in grouped.items():\n            # æå–å†…å®¹\n            contents = [\n                r.get('content', '')\n                for r in task_results\n                if r.get('success') and r.get('content')\n            ]\n            \n            if contents:\n                section = f\"## {task_name}\\n\\n\" + \"\\n\\n\".join(contents)\n                sections.append(section)\n        \n        return \"\\n\\n---\\n\\n\".join(sections)\n\n    "
},
{
"path": "daoyoucode/agents/orchestrators/parallel.py",
"start": 460,
"end": 601,
"text": "    def _prepare_tasks(\n        self,\n        agents_config: List[Dict[str, Any]],\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> List[Dict[str, Any]]:\n        \"\"\"å‡†å¤‡ä»»åŠ¡åˆ—è¡¨\"\"\"\n        tasks = []\n        \n        for config in agents_config:\n            task = {\n                'name': config.get('name', 'unnamed'),\n                'agent': config.get('agent'),\n                'task': config.get('task', user_input),\n                'prompt': config.get('prompt', {'use_agent_default': True}),\n                'priority': config.get('priority', 5)\n            }\n            tasks.append(task)\n        \n        return tasks\n    \n    async def _analyze_and_split(\n        self,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        ç®€å•çš„ä»»åŠ¡æ‹†åˆ†ï¼ˆåŸºäºå…³é”®è¯ï¼‰\n        \n        ä½œä¸ºLLMæ‹†åˆ†å¤±è´¥æ—¶çš„é™çº§æ–¹æ¡ˆ\n        \"\"\"\n        tasks = []\n        \n        # æ£€æµ‹æ˜¯å¦éœ€è¦ä»£ç æœç´¢\n        if any(kw in user_input.lower() for kw in ['æŸ¥æ‰¾', 'æœç´¢', 'ä»£ç ', 'find', 'search']):\n            tasks.append({\n                'name': 'code_search',\n                'agent': 'code_explorer',\n                'task': f\"åœ¨ä»£ç åº“ä¸­æŸ¥æ‰¾: {user_input}\",\n                'prompt': {'use_agent_default': True},\n                'priority': 8\n            })\n        \n        # æ£€æµ‹æ˜¯å¦éœ€è¦æ–‡æ¡£æŸ¥è¯¢\n        if any(kw in user_input.lower() for kw in ['æ–‡æ¡£', 'å®˜æ–¹', 'docs', 'documentation']):\n            tasks.append({\n                'name': 'doc_search',\n                'agent': 'translator',\n                'task': f\"æŸ¥æ‰¾å®˜æ–¹æ–‡æ¡£: {user_input}\",\n                'prompt': {'use_agent_default': True},\n                'priority': 5\n            })\n        \n        # å¦‚æœæ²¡æœ‰ç‰¹å®šä»»åŠ¡ï¼Œä½¿ç”¨é»˜è®¤Agent\n        if not tasks:\n            tasks.append({\n                'name': 'default',\n                'agent': 'translator',\n                'task': user_input,\n                'prompt': {'use_agent_default': True},\n                'priority': 5\n            })\n        \n        return tasks\n    \n    async def _execute_task(\n        self,\n        task: Dict[str, Any],\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"æ‰§è¡Œå•ä¸ªä»»åŠ¡\"\"\"\n        agent_name = task['agent']\n        task_input = task['task']\n        prompt_config = task['prompt']\n        \n        # è·å–Agent\n        agent = self._get_agent(agent_name)\n        \n        # å‡†å¤‡å·¥å…·\n        task_tools = task.get('tools')\n        if task_tools is None and '_current_skill' in context:\n            current_skill = context['_current_skill']\n            if hasattr(current_skill, 'tools'):\n                task_tools = current_skill.tools\n        \n        # æ‰§è¡Œ\n        result = await agent.execute(\n            prompt_source=prompt_config,\n            user_input=task_input,\n            context=context,\n            tools=task_tools if task_tools else None\n        )\n        \n        # è½¬æ¢ä¸ºå­—å…¸\n        return {\n            'success': result.success,\n            'content': result.content,\n            'error': result.error,\n            'task_name': task['name'],\n            'agent_name': agent_name,\n            'tokens_used': result.tokens_used\n        }\n    \n    async def _smart_aggregate(\n        self,\n        results: List[Dict[str, Any]]\n    ) -> str:\n        \"\"\"\n        ç®€å•èšåˆç»“æœ\n        \n        æ ¹æ®ç»“æœç±»å‹å’Œå†…å®¹æ™ºèƒ½ç»„åˆ\n        \"\"\"\n        if not results:\n            return \"\"\n        \n        # æŒ‰ä»»åŠ¡ç±»å‹åˆ†ç»„\n        grouped = {}\n        for result in results:\n            if isinstance(result, Exception):\n                continue\n            \n            task_name = result.get('task_name', 'unknown')\n            if task_name not in grouped:\n                grouped[task_name] = []\n            grouped[task_name].append(result)\n        \n        # ç»„åˆç»“æœ\n        sections = []\n        \n        for task_name, task_results in grouped.items():\n            # æå–å†…å®¹\n            contents = [\n                r.get('content', '')\n                for r in task_results\n                if r.get('success') and r.get('content')\n            ]\n            \n            if contents:\n       "
},
{
"path": "daoyoucode/agents/orchestrators/parallel_explore.py",
"start": 1,
"end": 22,
"text": "\"\"\"\nå¹¶è¡Œæ¢ç´¢ç¼–æ’å™¨\n\nä½¿ç”¨åå°ä»»åŠ¡å¹¶è¡Œæ‰§è¡Œå¤šä¸ªæ¢ç´¢ä»»åŠ¡ï¼Œæå‡å“åº”é€Ÿåº¦\n\nå¢å¼ºåŠŸèƒ½ï¼š\n- åŠ¨æ€ä»»åŠ¡ç”Ÿæˆï¼ˆLLMé©±åŠ¨ï¼Œå¯é€‰ï¼‰\n- è¿›åº¦é€šçŸ¥\n- ä»»åŠ¡ä¼˜å…ˆçº§\n- æ™ºèƒ½ç»“æœèšåˆ\n\"\"\"\n\nfrom ..core.orchestrator import BaseOrchestrator\nfrom ..core.background import get_background_manager\nfrom typing import Dict, Any, List, Optional\nimport logging\nimport asyncio\nimport json\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/orchestrators/parallel_explore.py",
"start": 23,
"end": 35,
"text": "class ParallelExploreOrchestrator(BaseOrchestrator):\n    \"\"\"\n    å¹¶è¡Œæ¢ç´¢ç¼–æ’å™¨\n    \n    ç‰¹ç‚¹ï¼š\n    - å¯åŠ¨å¤šä¸ªåå°æ¢ç´¢ä»»åŠ¡\n    - ä¸»ä»»åŠ¡ç«‹å³æ‰§è¡Œï¼Œä¸ç­‰å¾…åå°ä»»åŠ¡\n    - æ”¶é›†åå°ç»“æœï¼ˆå¦‚æœå®Œæˆï¼‰\n    - èšåˆæ‰€æœ‰ç»“æœ\n    - åŠ¨æ€ä»»åŠ¡ç”Ÿæˆï¼ˆLLMé©±åŠ¨ï¼Œå¯é€‰ï¼‰\n    - è¿›åº¦é€šçŸ¥\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/orchestrators/parallel_explore.py",
"start": 36,
"end": 210,
"text": "    def __init__(self):\n        super().__init__()\n        self.bg_manager = get_background_manager()\n    \n    async def execute(\n        self,\n        skill,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        æ‰§è¡Œå¹¶è¡Œæ¢ç´¢\n        \n        Skillé…ç½®ç¤ºä¾‹:\n        orchestrator: parallel_explore\n        agent: main_agent\n        \n        # æ¨¡å¼1: é™æ€é…ç½®ï¼ˆç°æœ‰ï¼‰\n        background_tasks:\n          - agent: explore\n            prompt: \"åœ¨ä»£ç åº“ä¸­æŸ¥æ‰¾: {{user_input}}\"\n            timeout: 5.0\n            priority: 8\n          \n          - agent: librarian\n            prompt: \"æŸ¥æ‰¾å®˜æ–¹æ–‡æ¡£: {{user_input}}\"\n            timeout: 5.0\n            priority: 5\n        \n        # æ¨¡å¼2: åŠ¨æ€ç”Ÿæˆï¼ˆæ–°å¢ï¼‰\n        use_dynamic_tasks: true\n        llm:\n          model: qwen-turbo\n        available_agents:\n          - explore: ä»£ç æ¢ç´¢\n          - librarian: æ–‡æ¡£æŸ¥æ‰¾\n          - web_search: ç½‘ç»œæœç´¢\n        \"\"\"\n        # åº”ç”¨ä¸­é—´ä»¶\n        if skill.middleware:\n            for middleware_name in skill.middleware:\n                context = await self._apply_middleware(\n                    middleware_name,\n                    user_input,\n                    context\n                )\n        \n        # å†³å®šä½¿ç”¨é™æ€è¿˜æ˜¯åŠ¨æ€ä»»åŠ¡\n        use_dynamic = getattr(skill, 'use_dynamic_tasks', False)\n        \n        if use_dynamic:\n            # åŠ¨æ€ç”Ÿæˆåå°ä»»åŠ¡\n            background_tasks = await self._generate_dynamic_tasks(\n                skill,\n                user_input,\n                context\n            )\n        else:\n            # ä½¿ç”¨é™æ€é…ç½®\n            background_tasks = getattr(skill, 'background_tasks', [])\n        \n        # 1. å¯åŠ¨åå°ä»»åŠ¡\n        task_ids = []\n        \n        for bg_task_config in background_tasks:\n            agent_name = bg_task_config.get('agent')\n            prompt_template = bg_task_config.get('prompt', '')\n            \n            if not agent_name:\n                logger.warning(\"åå°ä»»åŠ¡ç¼ºå°‘agenté…ç½®ï¼Œè·³è¿‡\")\n                continue\n            \n            # æ¸²æŸ“prompt\n            prompt = self._render_template(prompt_template, {\n                'user_input': user_input,\n                **context\n            })\n            \n            # æäº¤åå°ä»»åŠ¡\n            task_id = await self.bg_manager.submit(\n                agent_name=agent_name,\n                prompt=prompt,\n                context=context\n            )\n            \n            task_info = {\n                'task_id': task_id,\n                'agent_name': agent_name,\n                'timeout': bg_task_config.get('timeout', 5.0),\n                'priority': bg_task_config.get('priority', 5)\n            }\n            task_ids.append(task_info)\n            \n            # æ³¨å†Œè¿›åº¦å›è°ƒ\n            self._register_progress_callback(task_id, agent_name)\n        \n        logger.info(f\"å·²å¯åŠ¨ {len(task_ids)} ä¸ªåå°ä»»åŠ¡\")\n        \n        # 2. æ‰§è¡Œä¸»ä»»åŠ¡ï¼ˆä¸ç­‰å¾…åå°ä»»åŠ¡ï¼‰\n        main_agent = self._get_agent(skill.agent)\n        \n        main_result = await main_agent.execute(\n            prompt_source=skill.prompt,\n            user_input=user_input,\n            context=context,\n            tools=skill.tools if skill.tools else None\n        )\n        \n        logger.info(\"ä¸»ä»»åŠ¡æ‰§è¡Œå®Œæˆ\")\n        \n        # 3. æ”¶é›†åå°ç»“æœï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰\n        task_ids.sort(key=lambda t: t.get('priority', 5), reverse=True)\n        background_results = []\n        \n        for task_info in task_ids:\n            task_id = task_info['task_id']\n            timeout = task_info['timeout']\n            agent_name = task_info['agent_name']\n            \n            try:\n                result = await self.bg_manager.get_result(\n                    task_id,\n                    timeout=timeout\n                )\n                background_results.append({\n                    'agent': agent_name,\n                    'result': result,\n                    'priority': task_info['priority']\n                })\n                logger.info(f\"åå°ä»»åŠ¡å®Œæˆ: {agent_name}\")\n            \n            except asyncio.TimeoutError:\n                logger.warning(f\"åå°ä»»åŠ¡è¶…æ—¶: {agent_name}\")\n                background_re"
},
{
"path": "daoyoucode/agents/orchestrators/parallel_explore.py",
"start": 211,
"end": 304,
"text": "    def _render_template(\n        self,\n        template: str,\n        context: Dict[str, Any]\n    ) -> str:\n        \"\"\"æ¸²æŸ“æ¨¡æ¿\"\"\"\n        from jinja2 import Template\n        return Template(template).render(**context)\n    \n    async def _generate_dynamic_tasks(\n        self,\n        skill,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> List[Dict[str, Any]]:\n        \"\"\"ä½¿ç”¨LLMåŠ¨æ€ç”Ÿæˆåå°æ¢ç´¢ä»»åŠ¡\"\"\"\n        available_agents = getattr(skill, 'available_agents', {})\n        \n        if not available_agents:\n            logger.warning(\"æœªé…ç½®available_agentsï¼Œæ— æ³•åŠ¨æ€ç”Ÿæˆä»»åŠ¡\")\n            return []\n        \n        # æ„å»ºLLMæç¤ºè¯\n        agents_desc = \"\\n\".join([\n            f\"- {name}: {desc}\"\n            for name, desc in available_agents.items()\n        ])\n        \n        analysis_prompt = f\"\"\"åˆ†æä»¥ä¸‹ä»»åŠ¡ï¼Œå†³å®šéœ€è¦å“ªäº›åå°æ¢ç´¢æ¥è¾…åŠ©ä¸»ä»»åŠ¡ï¼š\n\nä»»åŠ¡: {user_input}\n\nå¯ç”¨çš„æ¢ç´¢Agent:\n{agents_desc}\n\nè¯·è¿”å›JSONæ•°ç»„ï¼Œæ¯ä¸ªæ¢ç´¢ä»»åŠ¡åŒ…å«ï¼š\n- agent: Agentåç§°\n- prompt: æ¢ç´¢æç¤ºè¯\n- priority: ä¼˜å…ˆçº§ï¼ˆ1-10ï¼Œ10æœ€é«˜ï¼‰\n- timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰\n\nç¤ºä¾‹:\n[\n  {{\"agent\": \"explore\", \"prompt\": \"æœç´¢ç›¸å…³ä»£ç å®ç°\", \"priority\": 8, \"timeout\": 5.0}},\n  {{\"agent\": \"librarian\", \"prompt\": \"æŸ¥æ‰¾APIæ–‡æ¡£\", \"priority\": 6, \"timeout\": 5.0}}\n]\n\næ³¨æ„ï¼š\n- åªé€‰æ‹©çœŸæ­£æœ‰å¸®åŠ©çš„æ¢ç´¢ä»»åŠ¡ï¼ˆ1-3ä¸ªï¼‰\n- ä¼˜å…ˆçº§é«˜çš„ä»»åŠ¡ä¼šä¼˜å…ˆæ”¶é›†ç»“æœ\n- è¶…æ—¶æ—¶é—´ä¸è¦å¤ªé•¿ï¼ˆå»ºè®®3-10ç§’ï¼‰\n\"\"\"\n        \n        try:\n            # è°ƒç”¨LLM\n            llm_config = getattr(skill, 'llm', {})\n            model = llm_config.get('model', 'qwen-turbo')\n            \n            # ä½¿ç”¨ç›¸å¯¹å¯¼å…¥\n            import sys\n            import os\n            parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n            if parent_dir not in sys.path:\n                sys.path.insert(0, parent_dir)\n            from llm.client_manager import get_client_manager\n            \n            client_manager = get_client_manager()\n            client = await client_manager.get_client(model)\n            \n            response = await client.chat(\n                messages=[{'role': 'user', 'content': analysis_prompt}],\n                temperature=0.3\n            )\n            \n            # è§£æå“åº”\n            content = response.get('content', '[]')\n            \n            # æå–JSONï¼ˆå¯èƒ½åŒ…å«åœ¨markdownä»£ç å—ä¸­ï¼‰\n            if '```json' in content:\n                content = content.split('```json')[1].split('```')[0].strip()\n            elif '```' in content:\n                content = content.split('```')[1].split('```')[0].strip()\n            \n            tasks = json.loads(content)\n            \n            logger.info(f\"LLMç”Ÿæˆäº† {len(tasks)} ä¸ªåå°ä»»åŠ¡\")\n            \n            return tasks\n        \n        except Exception as e:\n            logger.error(f\"åŠ¨æ€ç”Ÿæˆä»»åŠ¡å¤±è´¥: {e}\")\n            # é™çº§ï¼šè¿”å›ç©ºåˆ—è¡¨\n            return []\n    "
},
{
"path": "daoyoucode/agents/orchestrators/parallel_explore.py",
"start": 305,
"end": 306,
"text": "    def _register_progress_callback(self, task_id: str, agent_name: str):\n        \"\"\"æ³¨å†Œè¿›åº¦å›è°ƒ\"\"\""
},
{
"path": "daoyoucode/agents/orchestrators/parallel_explore.py",
"start": 307,
"end": 420,
"text": "        def on_progress(progress: float):\n            logger.info(f\"åå°ä»»åŠ¡ [{agent_name}] è¿›åº¦: {progress:.0f}%\")\n        \n        # å¦‚æœBackgroundManageræ”¯æŒè¿›åº¦å›è°ƒï¼Œæ³¨å†Œå®ƒ\n        if hasattr(self.bg_manager, 'on_progress'):\n            self.bg_manager.on_progress(task_id, on_progress)\n    \n    async def _smart_aggregate_with_llm(\n        self,\n        main_result: Dict[str, Any],\n        background_results: List[Dict[str, Any]],\n        skill\n    ) -> str:\n        \"\"\"ä½¿ç”¨LLMæ™ºèƒ½èšåˆç»“æœ\"\"\"\n        # æå–æ‰€æœ‰æˆåŠŸçš„ç»“æœ\n        main_content = main_result.get('content', '')\n        bg_contents = []\n        \n        for bg_result in background_results:\n            agent_name = bg_result['agent']\n            result = bg_result['result']\n            priority = bg_result.get('priority', 5)\n            \n            if isinstance(result, dict) and result.get('content'):\n                bg_contents.append({\n                    'agent': agent_name,\n                    'content': result['content'],\n                    'priority': priority\n                })\n        \n        if not bg_contents:\n            # æ²¡æœ‰åå°ç»“æœï¼Œç›´æ¥è¿”å›ä¸»ç»“æœ\n            return main_content\n        \n        # æ„å»ºèšåˆæç¤ºè¯\n        bg_sections = \"\\n\\n\".join([\n            f\"[{item['agent']} - ä¼˜å…ˆçº§{item['priority']}]\\n{item['content']}\"\n            for item in bg_contents\n        ])\n        \n        aggregation_prompt = f\"\"\"è¯·æ™ºèƒ½èšåˆä»¥ä¸‹ä¸»ä»»åŠ¡ç»“æœå’Œåå°æ¢ç´¢ç»“æœï¼š\n\nã€ä¸»è¦ç»“æœã€‘\n{main_content}\n\nã€åå°æ¢ç´¢ç»“æœã€‘\n{bg_sections}\n\nè¦æ±‚ï¼š\n1. ä»¥ä¸»è¦ç»“æœä¸ºæ ¸å¿ƒ\n2. å°†åå°æ¢ç´¢çš„æœ‰ä»·å€¼ä¿¡æ¯èå…¥å…¶ä¸­\n3. å»é™¤é‡å¤ä¿¡æ¯\n4. ä¿æŒè¿è´¯æ€§å’Œå¯è¯»æ€§\n5. çªå‡ºé‡ç‚¹ä¿¡æ¯\n\nè¯·ç›´æ¥è¿”å›èšåˆåçš„å†…å®¹ï¼Œä¸è¦æ·»åŠ é¢å¤–è¯´æ˜ã€‚\n\"\"\"\n        \n        try:\n            # è°ƒç”¨LLM\n            llm_config = getattr(skill, 'llm', {})\n            model = llm_config.get('model', 'qwen-turbo')\n            \n            # ä½¿ç”¨ç›¸å¯¹å¯¼å…¥\n            import sys\n            import os\n            parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n            if parent_dir not in sys.path:\n                sys.path.insert(0, parent_dir)\n            from llm.client_manager import get_client_manager\n            \n            client_manager = get_client_manager()\n            client = await client_manager.get_client(model)\n            \n            response = await client.chat(\n                messages=[{'role': 'user', 'content': aggregation_prompt}],\n                temperature=0.5\n            )\n            \n            aggregated = response.get('content', main_content)\n            \n            logger.info(\"LLMæ™ºèƒ½èšåˆå®Œæˆ\")\n            \n            return aggregated\n        \n        except Exception as e:\n            logger.error(f\"LLMèšåˆå¤±è´¥: {e}\")\n            # é™çº§ï¼šä½¿ç”¨ç®€å•èšåˆ\n            return await self._aggregate_results(main_result, background_results)\n    \n    async def _aggregate_results(\n        self,\n        main_result: Dict[str, Any],\n        background_results: List[Dict[str, Any]]\n    ) -> str:\n        \"\"\"èšåˆç»“æœ\"\"\"\n        parts = []\n        \n        # ä¸»ç»“æœ\n        if main_result.get('content'):\n            parts.append(f\"[ä¸»è¦ç»“æœ]\\n{main_result['content']}\")\n        \n        # åå°ç»“æœ\n        for bg_result in background_results:\n            agent_name = bg_result['agent']\n            result = bg_result['result']\n            \n            if isinstance(result, dict) and result.get('content'):\n                parts.append(f\"[{agent_name}]\\n{result['content']}\")\n            elif isinstance(result, dict) and result.get('error'):\n                # è·³è¿‡é”™è¯¯ç»“æœ\n                pass\n        \n        return \"\\n\\n\".join(parts)"
},
{
"path": "daoyoucode/agents/orchestrators/react.py",
"start": 1,
"end": 56,
"text": "\"\"\"\nReActå¾ªç¯ç¼–æ’å™¨\n\nå®ç°ReActï¼ˆReason-Act-Observe-Reflectï¼‰æ¨¡å¼çš„ç¼–æ’å™¨ã€‚\n\næ¶æ„è¯´æ˜ï¼š\n-----------\nReActå¾ªç¯çš„æ ¸å¿ƒé€»è¾‘å·²åœ¨Agentå±‚å®ç°ï¼ˆé€šè¿‡Function Callingæœºåˆ¶ï¼‰ï¼š\n- Thoughtï¼ˆæ€è€ƒï¼‰ï¼šLLMåˆ†æç”¨æˆ·é—®é¢˜ï¼Œå†³å®šæ˜¯å¦è°ƒç”¨å·¥å…·\n- Actionï¼ˆè¡ŒåŠ¨ï¼‰ï¼šæ‰§è¡Œå·¥å…·è·å–ä¿¡æ¯\n- Observationï¼ˆè§‚å¯Ÿï¼‰ï¼šå¤„ç†å·¥å…·è¿”å›çš„ç»“æœ\n- Reflectï¼ˆåæ€ï¼‰ï¼šLLMåŸºäºç»“æœå†³å®šä¸‹ä¸€æ­¥è¡ŒåŠ¨\n\nå½“å‰ç¼–æ’å™¨çš„èŒè´£ï¼š\n-----------------\n1. è°ƒç”¨Agentæ‰§è¡Œä»»åŠ¡\n2. å‡†å¤‡Promptå’Œä¸Šä¸‹æ–‡\n3. å¤„ç†æ‰§è¡Œç»“æœ\n4. è¿”å›ç»Ÿä¸€æ ¼å¼çš„å“åº”\n\nè¿™ç§è®¾è®¡çš„ä¼˜åŠ¿ï¼š\n--------------\n- ç®€å•é«˜æ•ˆï¼šLLMè‡ªåŠ¨æ§åˆ¶å¾ªç¯ï¼Œæ— éœ€é¢å¤–çš„è§„åˆ’æ­¥éª¤\n- æˆæœ¬ä½ï¼šå‡å°‘ä¸å¿…è¦çš„LLMè°ƒç”¨\n- çµæ´»æ€§ï¼šLLMå¯ä»¥æ ¹æ®å®é™…æƒ…å†µåŠ¨æ€è°ƒæ•´ç­–ç•¥\n- æ˜“äºä½¿ç”¨ï¼šå¯¹ç”¨æˆ·é€æ˜ï¼Œæ— éœ€é…ç½®å¤æ‚å‚æ•°\n\næ‰©å±•æ–¹å‘ï¼š\n---------\nå¦‚éœ€æ›´å¤æ‚çš„ç¼–æ’é€»è¾‘ï¼ˆå¦‚æ˜¾å¼è§„åˆ’ã€å¤šè½®åæ€ã€å¼ºé”™è¯¯æ¢å¤ï¼‰ï¼Œ\nå¯ä»¥åˆ›å»ºAdvancedReActOrchestratorï¼Œå®ç°ï¼š\n- æ˜¾å¼çš„è§„åˆ’é˜¶æ®µï¼ˆç”Ÿæˆè¯¦ç»†çš„æ‰§è¡Œè®¡åˆ’ï¼‰\n- æ˜¾å¼çš„åæ€é˜¶æ®µï¼ˆåˆ†æå¤±è´¥åŸå› å¹¶è°ƒæ•´ç­–ç•¥ï¼‰\n- æ›´å¼ºçš„é”™è¯¯æ¢å¤èƒ½åŠ›ï¼ˆè‡ªåŠ¨é‡è¯•å’Œç­–ç•¥è°ƒæ•´ï¼‰\n\nå‚è€ƒï¼š\n-----\n- daoyouCodePilotçš„OrchestratorCoder\n- REACT_IMPLEMENTATION_STATUS.mdï¼ˆè¯¦ç»†è¯´æ˜ï¼‰\n\"\"\"\n\nfrom typing import Dict, Any, List, Optional\nimport logging\nfrom dataclasses import dataclass\n\nfrom ..core.orchestrator import BaseOrchestrator\nfrom ..core.agent import BaseAgent\nfrom ..core.context import Context, get_context_manager\nfrom ..core.task import Task, TaskStatus, get_task_manager\nfrom ..core.feedback import get_feedback_loop\nfrom ..core.hooks import HookEvent, get_hook_manager\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/orchestrators/react.py",
"start": 57,
"end": 64,
"text": "class ReActPlan:\n    \"\"\"ReActæ‰§è¡Œè®¡åˆ’\"\"\"\n    steps: List[Dict[str, Any]]\n    estimated_time: float\n    complexity: int\n    risks: List[str]\n\n"
},
{
"path": "daoyoucode/agents/orchestrators/react.py",
"start": 65,
"end": 75,
"text": "class ReActOrchestrator(BaseOrchestrator):\n    \"\"\"\n    ReActå¾ªç¯ç¼–æ’å™¨\n    \n    å®ç°å®Œæ•´çš„Reason-Act-Observeå¾ªç¯ï¼š\n    1. Reasonï¼ˆè§„åˆ’ï¼‰ï¼šåˆ†æä»»åŠ¡ï¼Œç”Ÿæˆæ‰§è¡Œè®¡åˆ’\n    2. Actï¼ˆæ‰§è¡Œï¼‰ï¼šæ‰§è¡Œè®¡åˆ’ä¸­çš„æ­¥éª¤\n    3. Observeï¼ˆè§‚å¯Ÿï¼‰ï¼šæ£€æŸ¥æ‰§è¡Œç»“æœ\n    4. Reflectï¼ˆåæ€ï¼‰ï¼šå¦‚æœå¤±è´¥ï¼Œåˆ†æåŸå› å¹¶é‡æ–°è§„åˆ’\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/orchestrators/react.py",
"start": 76,
"end": 192,
"text": "    def __init__(\n        self,\n        max_reflections: int = 3,\n        require_approval: bool = False,\n        auto_verify: bool = True,\n        **kwargs\n    ):\n        \"\"\"\n        åˆå§‹åŒ–ReActç¼–æ’å™¨\n        \n        Args:\n            max_reflections: æœ€å¤§åæ€æ¬¡æ•°\n            require_approval: æ˜¯å¦éœ€è¦ç”¨æˆ·æ‰¹å‡†è®¡åˆ’\n            auto_verify: æ˜¯å¦è‡ªåŠ¨éªŒè¯ç»“æœ\n        \"\"\"\n        super().__init__(**kwargs)\n        self.max_reflections = max_reflections\n        self.require_approval = require_approval\n        self.auto_verify = auto_verify\n        self.hook_manager = get_hook_manager()\n        self.task_manager = get_task_manager()\n        self.feedback_loop = get_feedback_loop()\n    \n    async def execute(\n        self,\n        skill: Any,\n        user_input: str,\n        context: Optional[Dict[str, Any]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        æ‰§è¡ŒReActå¾ªç¯\n        \n        æ³¨æ„ï¼šReActå¾ªç¯çš„æ ¸å¿ƒé€»è¾‘å·²åœ¨Agentå±‚å®ç°ï¼ˆé€šè¿‡Function Callingï¼‰ã€‚\n        Agentä¼šè‡ªåŠ¨è¿›è¡Œï¼š\n        - Thoughtï¼ˆæ€è€ƒï¼‰ï¼šLLMåˆ†æé—®é¢˜\n        - Actionï¼ˆè¡ŒåŠ¨ï¼‰ï¼šè°ƒç”¨å·¥å…·\n        - Observationï¼ˆè§‚å¯Ÿï¼‰ï¼šè·å–å·¥å…·ç»“æœ\n        - Reflectï¼ˆåæ€ï¼‰ï¼šLLMå†³å®šä¸‹ä¸€æ­¥\n        \n        å½“å‰ç¼–æ’å™¨è´Ÿè´£ï¼š\n        - è°ƒç”¨Agentæ‰§è¡Œä»»åŠ¡\n        - å¤„ç†ç»“æœå’Œé”™è¯¯\n        - è¿”å›ç»Ÿä¸€æ ¼å¼çš„å“åº”\n        \n        å¦‚éœ€æ›´å¤æ‚çš„ç¼–æ’é€»è¾‘ï¼ˆå¦‚æ˜¾å¼è§„åˆ’ã€å¤šè½®åæ€ã€é”™è¯¯æ¢å¤ï¼‰ï¼Œ\n        å¯ä»¥åˆ›å»ºAdvancedReActOrchestratorã€‚\n        \n        Args:\n            skill: æŠ€èƒ½å®šä¹‰ï¼ˆSkillConfigå¯¹è±¡ï¼‰\n            user_input: ç”¨æˆ·è¾“å…¥\n            context: æ‰§è¡Œä¸Šä¸‹æ–‡\n            \n        Returns:\n            æ‰§è¡Œç»“æœ\n        \"\"\"\n        if context is None:\n            context = {}\n        \n        logger.info(f\"ReActç¼–æ’å™¨æ‰§è¡Œ: {skill.name}\")\n        \n        try:\n            # 1. è·å–Agent\n            from ..core.agent import get_agent_registry\n            registry = get_agent_registry()\n            agent = registry.get_agent(skill.agent)\n            \n            if not agent:\n                return {\n                    'success': False,\n                    'content': '',\n                    'error': f\"Agent '{skill.agent}' not found\"\n                }\n            \n            # 2. å‡†å¤‡prompt\n            prompt_source = self._prepare_prompt_source(skill)\n            \n            # 3. åªä¼ å…¥å·²æ³¨å†Œçš„å·¥å…·åï¼Œé¿å… Kiro ç­‰ç”Ÿæˆçš„é…ç½®é‡Œæœ‰é”™è¯¯å·¥å…·åå¯¼è‡´ä¸ç¨³å®š\n            from ..tools import get_tool_registry\n            tool_registry = get_tool_registry()\n            tools_to_use = tool_registry.filter_tool_names(skill.tools if skill.tools else None)\n            \n            # 4. æ‰§è¡ŒAgentï¼ˆå¸¦å·¥å…·ï¼‰\n            result = await agent.execute(\n                prompt_source=prompt_source,\n                user_input=user_input,\n                context=context,\n                llm_config=skill.llm,\n                tools=tools_to_use\n            )\n            \n            # 5. è¿”å›ç»“æœ\n            return {\n                'success': result.success,\n                'content': result.content,\n                'metadata': {\n                    **result.metadata,\n                    'skill': skill.name,\n                    'agent': skill.agent,\n                    'orchestrator': 'react',\n                    'tools_used': result.tools_used,\n                    'tokens_used': result.tokens_used,\n                    'cost': result.cost\n                },\n                'error': result.error,\n                'tools_used': result.tools_used,\n                'tokens_used': result.tokens_used,\n                'cost': result.cost\n            }\n        \n        except Exception as e:\n            logger.error(f\"ReActæ‰§è¡Œå¤±è´¥: {e}\", exc_info=True)\n            return {\n                'success': False,\n                'content': '',\n                'error': str(e)\n            }\n    "
},
{
"path": "daoyoucode/agents/orchestrators/react.py",
"start": 193,
"end": 633,
"text": "    def _prepare_prompt_source(self, skill: Any) -> Dict[str, Any]:\n        \"\"\"å‡†å¤‡promptæ¥æºé…ç½®\"\"\"\n        if skill.prompt:\n            if isinstance(skill.prompt, dict):\n                return skill.prompt\n            if isinstance(skill.prompt, str):\n                return {'file': skill.prompt}\n        \n        return {'use_agent_default': True}\n    \n    # ========================================================================\n    # ä»¥ä¸‹æ–¹æ³•ä¸ºAdvancedReActOrchestratoré¢„ç•™\n    # \n    # å½“å‰çš„ç®€åŒ–ç‰ˆæœ¬ä¸ä½¿ç”¨è¿™äº›æ–¹æ³•ï¼Œä½†ä¿ç•™å®ƒä»¬ä½œä¸ºå‚è€ƒå®ç°ã€‚\n    # è¿™äº›æ–¹æ³•åœ¨ test_advanced_features.py ä¸­æœ‰å®Œæ•´çš„å•å…ƒæµ‹è¯•ã€‚\n    # \n    # ä½¿ç”¨åœºæ™¯ï¼š\n    # - å½“éœ€è¦æ˜¾å¼çš„è§„åˆ’é˜¶æ®µï¼ˆç”Ÿæˆè¯¦ç»†çš„æ‰§è¡Œè®¡åˆ’ï¼‰\n    # - å½“éœ€è¦æ˜¾å¼çš„åæ€é˜¶æ®µï¼ˆåˆ†æå¤±è´¥åŸå› å¹¶è°ƒæ•´ç­–ç•¥ï¼‰\n    # - å½“éœ€è¦æ›´å¼ºçš„é”™è¯¯æ¢å¤èƒ½åŠ›ï¼ˆè‡ªåŠ¨é‡è¯•å’Œç­–ç•¥è°ƒæ•´ï¼‰\n    # - å½“éœ€è¦ç”¨æˆ·æ‰¹å‡†æ‰§è¡Œè®¡åˆ’\n    # - å½“éœ€è¦è‡ªåŠ¨éªŒè¯æ‰§è¡Œç»“æœ\n    # \n    # å®ç°AdvancedReActOrchestratoræ—¶ï¼Œå¯ä»¥ï¼š\n    # 1. ç»§æ‰¿ReActOrchestrator\n    # 2. é‡å†™execute()æ–¹æ³•ï¼Œè°ƒç”¨è¿™äº›é¢„ç•™æ–¹æ³•\n    # 3. å®ç°å®Œæ•´çš„Plan-Execute-Observe-Reflectå¾ªç¯\n    # \n    # å‚è€ƒï¼š\n    # - REACT_IMPLEMENTATION_STATUS.md - è¯¦ç»†çš„å®ç°è¯´æ˜\n    # - test_advanced_features.py - æ–¹æ³•çš„å•å…ƒæµ‹è¯•\n    # - daoyouCodePilotçš„OrchestratorCoder - åŸå§‹å®ç°å‚è€ƒ\n    # ========================================================================\n    \n    async def _plan(\n        self,\n        instruction: str,\n        context: Context,\n        last_error: Optional[str] = None,\n        last_plan: Optional[ReActPlan] = None\n    ) -> Optional[ReActPlan]:\n        \"\"\"\n        [é¢„ç•™æ–¹æ³•] ç”Ÿæˆæ‰§è¡Œè®¡åˆ’\n        \n        ç”¨äºAdvancedReActOrchestratorçš„æ˜¾å¼è§„åˆ’é˜¶æ®µã€‚\n        å½“å‰ç®€åŒ–ç‰ˆæœ¬ä¸ä½¿ç”¨æ­¤æ–¹æ³•ï¼Œä½†ä¿ç•™ä½œä¸ºå‚è€ƒå®ç°ã€‚\n        \n        åŠŸèƒ½ï¼š\n        - åˆ†æä»»åŠ¡éœ€æ±‚\n        - ç”Ÿæˆè¯¦ç»†çš„æ‰§è¡Œæ­¥éª¤\n        - ä¼°ç®—æ—¶é—´å’Œå¤æ‚åº¦\n        - è¯†åˆ«æ½œåœ¨é£é™©\n        - æ”¯æŒåŸºäºå¤±è´¥çš„é‡æ–°è§„åˆ’\n        \n        Args:\n            instruction: ä»»åŠ¡æŒ‡ä»¤\n            context: æ‰§è¡Œä¸Šä¸‹æ–‡\n            last_error: ä¸Šæ¬¡æ‰§è¡Œçš„é”™è¯¯ä¿¡æ¯ï¼ˆç”¨äºé‡æ–°è§„åˆ’ï¼‰\n            last_plan: ä¸Šæ¬¡çš„æ‰§è¡Œè®¡åˆ’ï¼ˆç”¨äºè°ƒæ•´ç­–ç•¥ï¼‰\n            \n        Returns:\n            ReActPlan: æ‰§è¡Œè®¡åˆ’ï¼ŒåŒ…å«æ­¥éª¤ã€æ—¶é—´ã€å¤æ‚åº¦ã€é£é™©\n            None: å¦‚æœæ— æ³•ç”Ÿæˆè®¡åˆ’\n            \n        æµ‹è¯•ï¼š\n            test_advanced_features.py::test_react_plan_generation\n        \"\"\"\n        # è¿™é‡Œåº”è¯¥è°ƒç”¨LLMç”Ÿæˆè®¡åˆ’\n        # ç®€åŒ–èµ·è§ï¼Œè¿”å›ä¸€ä¸ªç¤ºä¾‹è®¡åˆ’\n        \n        prompt = f\"\"\"\n        ä»»åŠ¡: {instruction}\n        \n        {\"ä¸Šæ¬¡æ‰§è¡Œå¤±è´¥: \" + last_error if last_error else \"\"}\n        {\"ä¸Šæ¬¡è®¡åˆ’: \" + str(last_plan) if last_plan else \"\"}\n        \n        è¯·ç”Ÿæˆä¸€ä¸ªè¯¦ç»†çš„æ‰§è¡Œè®¡åˆ’ï¼ŒåŒ…æ‹¬ï¼š\n        1. å…·ä½“çš„æ‰§è¡Œæ­¥éª¤\n        2. æ¯ä¸ªæ­¥éª¤çš„é¢„æœŸç»“æœ\n        3. å¯èƒ½çš„é£é™©ç‚¹\n        \"\"\"\n        \n        # TODO: è°ƒç”¨LLMç”Ÿæˆè®¡åˆ’\n        # è¿™é‡Œè¿”å›ä¸€ä¸ªç¤ºä¾‹è®¡åˆ’\n        return ReActPlan(\n            steps=[\n                {'action': 'analyze', 'description': 'åˆ†æä»»åŠ¡éœ€æ±‚'},\n                {'action': 'implement', 'description': 'å®ç°åŠŸèƒ½'},\n                {'action': 'test', 'description': 'æµ‹è¯•åŠŸèƒ½'},\n            ],\n            estimated_time=300.0,\n            complexity=3,\n            risks=['å¯èƒ½éœ€è¦ä¿®æ”¹å¤šä¸ªæ–‡ä»¶', 'å¯èƒ½å½±å“ç°æœ‰åŠŸèƒ½']\n        )\n    \n    async def _approve(self, plan: ReActPlan, context: Context) -> bool:\n        \"\"\"\n        [é¢„ç•™æ–¹æ³•] è¯·æ±‚ç”¨æˆ·æ‰¹å‡†è®¡åˆ’\n        \n        ç”¨äºAdvancedReActOrchestratorçš„äººå·¥å®¡æ ¸é˜¶æ®µã€‚\n        å½“å‰ç®€åŒ–ç‰ˆæœ¬ä¸ä½¿ç”¨æ­¤æ–¹æ³•ï¼Œä½†ä¿ç•™ä½œä¸ºå‚è€ƒå®ç°ã€‚\n        \n        åŠŸèƒ½ï¼š\n        - å±•ç¤ºæ‰§è¡Œè®¡åˆ’ç»™ç”¨æˆ·\n        - ç­‰å¾…ç”¨æˆ·ç¡®è®¤æˆ–æ‹’ç»\n        - æ”¯æŒè®¡åˆ’ä¿®æ”¹å»ºè®®\n        \n        Args:\n            plan: å¾…æ‰¹å‡†çš„æ‰§è¡Œè®¡åˆ’\n            context: æ‰§è¡Œä¸Šä¸‹æ–‡\n            \n        Returns:\n            bool: Trueè¡¨ç¤ºæ‰¹å‡†ï¼ŒFalseè¡¨ç¤ºæ‹’ç»\n            \n        æ³¨æ„ï¼š\n            å®é™…å®ç°éœ€è¦é›†æˆç”¨æˆ·äº¤äº’æœºåˆ¶ï¼ˆCLI/Webç•Œé¢ï¼‰\n        \"\"\"\n        # è¿™é‡Œåº”è¯¥æ˜¾ç¤ºè®¡åˆ’å¹¶è¯·æ±‚ç”¨æˆ·ç¡®è®¤\n        # ç®€åŒ–èµ·è§ï¼Œç›´æ¥è¿”å›True\n        logger.info(f\"æ‰§è¡Œè®¡åˆ’: {len(plan.steps)} ä¸ªæ­¥éª¤\")\n        for i, step in enumerate(plan.steps):\n            logger.info(f\"  {i+1}. {step['description']}\")\n        \n        # TODO: å®ç°ç”¨æˆ·ç¡®è®¤é€»è¾‘\n        return True\n    \n    async def _execute_plan(\n        self,\n        plan: ReActPlan,\n        context: Context,\n        agents: Optional[List[BaseAgent]],\n        parent_task: Task\n    ) -> Dict[str, Any]:\n        \"\"\"\n        [é¢„ç•™æ–¹æ³•] æ‰§è¡Œè®¡åˆ’\n        \n        ç”¨äºAdvancedReActOrchestratorçš„è®¡åˆ’æ‰§è¡Œé˜¶æ®µã€‚\n        å½“å‰ç®€åŒ–ç‰ˆæœ¬ä¸ä½¿ç”¨æ­¤æ–¹æ³•ï¼Œä½†ä¿ç•™ä½œä¸ºå‚è€ƒå®ç°ã€‚\n        \n        åŠŸèƒ½ï¼š\n        - æŒ‰é¡ºåºæ‰§è¡Œè®¡åˆ’ä¸­çš„æ­¥éª¤\n        - ä¸ºæ¯ä¸ªæ­¥éª¤åˆ›å»ºå­ä»»åŠ¡\n        - è·Ÿè¸ªæ‰§è¡Œè¿›åº¦\n        - å¤„ç†æ­¥éª¤å¤±è´¥ï¼ˆä¸­æ–­æ‰§è¡Œï¼‰\n        - è®°å½•æ‰§è¡Œç»“æœ\n        \n        Args:\n            plan: è¦æ‰§è¡Œçš„è®¡åˆ’\n            context: æ‰§è¡Œä¸Šä¸‹æ–‡\n            agents: å¯ç”¨çš„Agentåˆ—è¡¨\n            parent_task: çˆ¶ä»»åŠ¡ï¼ˆç”¨äºåˆ›å»ºå­ä»»åŠ¡ï¼‰\n  "
},
{
"path": "daoyoucode/agents/orchestrators/react.py",
"start": 634,
"end": 637,
"text": "    def get_name(self) -> str:\n        \"\"\"è·å–ç¼–æ’å™¨åç§°\"\"\"\n        return \"react\"\n    "
},
{
"path": "daoyoucode/agents/orchestrators/react.py",
"start": 638,
"end": 640,
"text": "    def get_description(self) -> str:\n        \"\"\"è·å–ç¼–æ’å™¨æè¿°\"\"\"\n        return \"ReActå¾ªç¯ç¼–æ’å™¨ï¼šå®ç°å®Œæ•´çš„è§„åˆ’-æ‰§è¡Œ-åæ€-é‡è¯•å¾ªç¯ï¼Œæä¾›è‡ªæ„ˆèƒ½åŠ›\""
},
{
"path": "daoyoucode/agents/orchestrators/simple.py",
"start": 1,
"end": 12,
"text": "\"\"\"\nç®€å•ç¼–æ’å™¨ï¼ˆå¢å¼ºç‰ˆï¼‰\n\nç›´æ¥æ‰§è¡Œå•ä¸ªAgentï¼Œæ”¯æŒé‡è¯•å’Œç»“æœéªŒè¯\n\"\"\"\n\nfrom typing import Dict, Any, Optional\nimport time\nimport asyncio\nfrom ..core.orchestrator import BaseOrchestrator\n\n"
},
{
"path": "daoyoucode/agents/orchestrators/simple.py",
"start": 13,
"end": 23,
"text": "class SimpleOrchestrator(BaseOrchestrator):\n    \"\"\"\n    ç®€å•ç¼–æ’å™¨ï¼ˆå¢å¼ºç‰ˆï¼‰\n    \n    æ–°å¢åŠŸèƒ½ï¼š\n    - è‡ªåŠ¨é‡è¯•æœºåˆ¶\n    - ç»“æœéªŒè¯\n    - æˆæœ¬è¿½è¸ª\n    - æ‰§è¡Œæ—¶é—´ç»Ÿè®¡\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/orchestrators/simple.py",
"start": 24,
"end": 155,
"text": "    def __init__(self, max_retries: int = 3, retry_delay: float = 1.0):\n        super().__init__()\n        self.max_retries = max_retries\n        self.retry_delay = retry_delay\n    \n    async def execute(\n        self,\n        skill: 'SkillConfig',\n        user_input: str,\n        context: Optional[Dict[str, Any]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"æ‰§è¡ŒSkillï¼ˆå¸¦é‡è¯•ï¼‰\"\"\"\n        if context is None:\n            context = {}\n        \n        # è·å–é…ç½®çš„é‡è¯•æ¬¡æ•°ï¼ˆä¼˜å…ˆä½¿ç”¨Skillé…ç½®ï¼‰\n        max_retries = getattr(skill, 'max_retries', self.max_retries)\n        retry_delay = getattr(skill, 'retry_delay', self.retry_delay)\n        \n        self.logger.info(f\"æ‰§è¡ŒSkill: {skill.name}, Agent: {skill.agent}, æœ€å¤§é‡è¯•: {max_retries}\")\n        \n        start_time = time.time()\n        last_error = None\n        \n        # é‡è¯•å¾ªç¯\n        for attempt in range(max_retries):\n            try:\n                # æ‰§è¡Œä¸€æ¬¡\n                result = await self._execute_once(skill, user_input, context)\n                \n                # éªŒè¯ç»“æœ\n                if self._validate_result(result):\n                    # æˆåŠŸï¼Œæ·»åŠ å…ƒæ•°æ®\n                    duration = time.time() - start_time\n                    result['metadata']['duration'] = duration\n                    result['metadata']['retries'] = attempt\n                    \n                    self.logger.info(f\"æ‰§è¡ŒæˆåŠŸï¼Œè€—æ—¶: {duration:.2f}s, é‡è¯•æ¬¡æ•°: {attempt}\")\n                    return result\n                \n                # ç»“æœæ— æ•ˆï¼Œè®°å½•å¹¶é‡è¯•\n                self.logger.warning(f\"ç»“æœéªŒè¯å¤±è´¥ï¼Œé‡è¯• {attempt + 1}/{max_retries}\")\n                last_error = \"ç»“æœéªŒè¯å¤±è´¥\"\n                \n                # ç­‰å¾…åé‡è¯•\n                if attempt < max_retries - 1:\n                    await asyncio.sleep(retry_delay)\n            \n            except Exception as e:\n                last_error = e\n                self.logger.error(f\"æ‰§è¡Œå¤±è´¥ {attempt + 1}/{max_retries}: {e}\")\n                \n                # ç­‰å¾…åé‡è¯•\n                if attempt < max_retries - 1:\n                    await asyncio.sleep(retry_delay)\n        \n        # æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥\n        duration = time.time() - start_time\n        \n        return {\n            'success': False,\n            'content': '',\n            'error': f'æ‰§è¡Œå¤±è´¥ï¼ˆå·²é‡è¯•{max_retries}æ¬¡ï¼‰: {last_error}',\n            'metadata': {\n                'skill': skill.name,\n                'agent': skill.agent,\n                'orchestrator': 'simple',\n                'duration': duration,\n                'retries': max_retries,\n                'failed': True\n            },\n            'tools_used': [],\n            'tokens_used': 0,\n            'cost': 0.0\n        }\n    \n    async def _execute_once(\n        self,\n        skill: 'SkillConfig',\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"æ‰§è¡Œä¸€æ¬¡ï¼ˆä¸é‡è¯•ï¼‰\"\"\"\n        \n        # 1. åº”ç”¨ä¸­é—´ä»¶\n        if skill.middleware:\n            for middleware_name in skill.middleware:\n                self.logger.debug(f\"åº”ç”¨ä¸­é—´ä»¶: {middleware_name}\")\n                context = await self._apply_middleware(\n                    middleware_name,\n                    user_input,\n                    context\n                )\n        \n        # 2. è·å–Agent\n        agent = self._get_agent(skill.agent)\n        \n        # 3. å‡†å¤‡promptæ¥æº\n        prompt_source = self._prepare_prompt_source(skill)\n        \n        # 4. åªä¼ å…¥å·²æ³¨å†Œçš„å·¥å…·å\n        from ..tools import get_tool_registry\n        tools_to_use = get_tool_registry().filter_tool_names(skill.tools if skill.tools else None)\n        \n        # 5. æ‰§è¡ŒAgent\n        result = await agent.execute(\n            prompt_source=prompt_source,\n            user_input=user_input,\n            context=context,\n            llm_config=skill.llm,\n            tools=tools_to_use\n        )\n        \n        # 6. è¿”å›ç»“æœ\n        return {\n            'success': result.success,\n            'content': result.content,\n            'metadata': {\n                **result.metadata,\n                'skill': skill.name,\n                'agent': skill.agent,\n                'orchestrator': 'simple',\n "
},
{
"path": "daoyoucode/agents/orchestrators/simple.py",
"start": 156,
"end": 178,
"text": "    def _validate_result(self, result: Dict[str, Any]) -> bool:\n        \"\"\"\n        éªŒè¯ç»“æœæ˜¯å¦æœ‰æ•ˆ\n        \n        éªŒè¯è§„åˆ™ï¼š\n        1. successæ ‡å¿—ä¸ºTrue\n        2. contentä¸ä¸ºç©º\n        3. æ²¡æœ‰error\n        \"\"\"\n        if not result.get('success'):\n            self.logger.debug(\"éªŒè¯å¤±è´¥: success=False\")\n            return False\n        \n        if not result.get('content'):\n            self.logger.debug(\"éªŒè¯å¤±è´¥: contentä¸ºç©º\")\n            return False\n        \n        if result.get('error'):\n            self.logger.debug(f\"éªŒè¯å¤±è´¥: æœ‰é”™è¯¯ - {result['error']}\")\n            return False\n        \n        return True\n    "
},
{
"path": "daoyoucode/agents/orchestrators/simple.py",
"start": 179,
"end": 187,
"text": "    def _prepare_prompt_source(self, skill: 'SkillConfig') -> Dict[str, Any]:\n        \"\"\"å‡†å¤‡promptæ¥æºé…ç½®\"\"\"\n        if skill.prompt:\n            if isinstance(skill.prompt, dict):\n                return skill.prompt\n            if isinstance(skill.prompt, str):\n                return {'file': skill.prompt}\n        \n        return {'use_agent_default': True}"
},
{
"path": "daoyoucode/agents/orchestrators/workflow.py",
"start": 1,
"end": 21,
"text": "\"\"\"\nå·¥ä½œæµç¼–æ’å™¨\n\næŒ‰æ­¥éª¤æ‰§è¡Œçš„å·¥ä½œæµï¼Œæ”¯æŒæ¡ä»¶åˆ†æ”¯å’Œæ•°æ®ä¼ é€’\n\nå¢å¼ºåŠŸèƒ½ï¼š\n- æ­¥éª¤ä¾èµ–æ£€æŸ¥\n- æ­¥éª¤è¶…æ—¶å’Œé‡è¯•\n- å¤±è´¥å›æ»š\n- æˆæœ¬è¿½è¸ª\n\"\"\"\n\nfrom ..core.orchestrator import BaseOrchestrator\nfrom typing import Dict, Any, Optional, List, Tuple\nimport logging\nimport asyncio\nimport time\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/orchestrators/workflow.py",
"start": 22,
"end": 292,
"text": "class WorkflowOrchestrator(BaseOrchestrator):\n    \"\"\"\n    å·¥ä½œæµç¼–æ’å™¨\n    \n    æ”¯æŒï¼š\n    - é¡ºåºæ‰§è¡Œå¤šä¸ªæ­¥éª¤\n    - æ­¥éª¤é—´æ•°æ®ä¼ é€’\n    - æ¡ä»¶åˆ†æ”¯\n    - é”™è¯¯å¤„ç†\n    - æ­¥éª¤ä¾èµ–æ£€æŸ¥ï¼ˆæ–°å¢ï¼‰\n    - æ­¥éª¤è¶…æ—¶å’Œé‡è¯•ï¼ˆæ–°å¢ï¼‰\n    - å¤±è´¥å›æ»šï¼ˆæ–°å¢ï¼‰\n    \"\"\"\n    \n    async def execute(\n        self,\n        skill,\n        user_input: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        æ‰§è¡Œå·¥ä½œæµ\n        \n        Skillé…ç½®ç¤ºä¾‹:\n        workflow:\n          - name: analyze\n            agent: analyzer\n            output: analysis_result\n            max_retries: 3\n            timeout: 30.0\n          \n          - name: implement\n            agent: programmer\n            depends_on: [analyze]  # ä¾èµ–\n            input: ${analysis_result}\n            condition: ${analysis_result.feasible}\n            output: code_changes\n            rollback: cleanup_agent  # å›æ»šAgent\n          \n          - name: review\n            agent: reviewer\n            depends_on: [implement]\n            input: ${code_changes}\n        \"\"\"\n        # è·å–å·¥ä½œæµå®šä¹‰\n        workflow = getattr(skill, 'workflow', None)\n        if not workflow:\n            return {\n                'success': False,\n                'content': '',\n                'error': 'Skillæœªå®šä¹‰workflow'\n            }\n        \n        # åˆå§‹åŒ–å·¥ä½œæµä¸Šä¸‹æ–‡\n        workflow_context = context.copy()\n        workflow_context['user_input'] = user_input\n        workflow_context['results'] = {}\n        workflow_context['_current_skill'] = skill\n        workflow_context['_start_time'] = time.time()\n        \n        # åº”ç”¨ä¸­é—´ä»¶\n        if skill.middleware:\n            for middleware_name in skill.middleware:\n                workflow_context = await self._apply_middleware(\n                    middleware_name,\n                    user_input,\n                    workflow_context\n                )\n        \n        # éªŒè¯ä¾èµ–å…³ç³»\n        if not self._validate_dependencies(workflow):\n            return {\n                'success': False,\n                'content': '',\n                'error': 'å·¥ä½œæµä¾èµ–å…³ç³»æ— æ•ˆï¼ˆå­˜åœ¨å¾ªç¯ä¾èµ–æˆ–æœªå®šä¹‰çš„æ­¥éª¤ï¼‰'\n            }\n        \n        # æ‰§è¡Œæ­¥éª¤ï¼ˆè®°å½•å·²æ‰§è¡Œçš„æ­¥éª¤ç”¨äºå›æ»šï¼‰\n        executed_steps: List[Tuple[Dict[str, Any], Dict[str, Any]]] = []\n        \n        try:\n            for step in workflow:\n                step_name = step.get('name', 'unnamed')\n                \n                logger.info(f\"æ‰§è¡Œå·¥ä½œæµæ­¥éª¤: {step_name}\")\n                \n                # æ£€æŸ¥ä¾èµ–\n                if not self._check_dependencies(step, workflow_context):\n                    logger.warning(f\"è·³è¿‡æ­¥éª¤ {step_name}ï¼ˆä¾èµ–æœªæ»¡è¶³ï¼‰\")\n                    continue\n                \n                # æ£€æŸ¥æ¡ä»¶\n                if not await self._check_condition(step, workflow_context):\n                    logger.info(f\"è·³è¿‡æ­¥éª¤ {step_name}ï¼ˆæ¡ä»¶ä¸æ»¡è¶³ï¼‰\")\n                    continue\n                \n                # æ‰§è¡Œæ­¥éª¤ï¼ˆå¸¦é‡è¯•å’Œè¶…æ—¶ï¼‰\n                step_result = await self._execute_step_with_retry(\n                    step,\n                    workflow_context\n                )\n                \n                # ä¿å­˜ç»“æœ\n                output_key = step.get('output', step_name)\n                step_result['_step_name'] = step_name  # ä¿å­˜æ­¥éª¤åç§°ç”¨äºä¾èµ–æ£€æŸ¥\n                workflow_context['results'][output_key] = step_result\n                \n                # è®°å½•å·²æ‰§è¡Œçš„æ­¥éª¤ï¼ˆç”¨äºå›æ»šï¼‰\n                executed_steps.append((step, step_result))\n                \n                # å¦‚æœæ­¥éª¤å¤±è´¥ä¸”æ²¡æœ‰é…ç½®ç»§ç»­æ‰§è¡Œï¼Œåˆ™ä¸­æ–­å¹¶å›æ»š\n                if not step_result.get('success') and not step.get('continue_on_error'):\n                    logger.error(f\"æ­¥éª¤ {step_name} å¤±è´¥ï¼Œå¼€å§‹å›æ»š\")\n                    await self._rollback_steps(executed_steps, workflow_context)\n                    \n                    return {\n                        'success': False,\n                        'content': '',\n                        'error': f\"æ­¥éª¤ {step_name} å¤±è´¥: {step_result.get('error')}\",\n                        'workflow_results': workflow_context['results'],\n                        'rollback_executed': True\n                    }\n        \n        except Exception as e:\n            logger.error(f\"å·¥ä½œæµæ‰§è¡Œå¼‚å¸¸: {e}\", exc_info=True)\n       "
},
{
"path": "daoyoucode/agents/orchestrators/workflow.py",
"start": 293,
"end": 314,
"text": "    def _validate_step_result(\n        self,\n        result: Dict[str, Any],\n        step: Dict[str, Any]\n    ) -> bool:\n        \"\"\"éªŒè¯æ­¥éª¤ç»“æœ\"\"\"\n        # åŸºæœ¬éªŒè¯\n        if not result.get('success'):\n            return False\n        \n        # æ£€æŸ¥æ˜¯å¦æœ‰å†…å®¹\n        if not result.get('content'):\n            return False\n        \n        # è‡ªå®šä¹‰éªŒè¯ï¼ˆå¦‚æœé…ç½®äº†ï¼‰\n        validation = step.get('validation')\n        if validation:\n            # å¯ä»¥æ‰©å±•ä¸ºæ›´å¤æ‚çš„éªŒè¯é€»è¾‘\n            pass\n        \n        return True\n    "
},
{
"path": "daoyoucode/agents/orchestrators/workflow.py",
"start": 315,
"end": 322,
"text": "    def _replace_variables(\n        self,\n        text: str,\n        context: Dict[str, Any]\n    ) -> str:\n        \"\"\"æ›¿æ¢å˜é‡ ${variable}\"\"\"\n        import re\n        "
},
{
"path": "daoyoucode/agents/orchestrators/workflow.py",
"start": 323,
"end": 329,
"text": "        def replace_var(match):\n            var_path = match.group(1)\n            value = self._get_nested_value(var_path, context)\n            return str(value) if value is not None else match.group(0)\n        \n        return re.sub(r'\\$\\{([^}]+)\\}', replace_var, text)\n    "
},
{
"path": "daoyoucode/agents/orchestrators/workflow.py",
"start": 330,
"end": 346,
"text": "    def _get_nested_value(\n        self,\n        path: str,\n        context: Dict[str, Any]\n    ) -> Any:\n        \"\"\"è·å–åµŒå¥—å€¼ (e.g., 'results.analyze.content')\"\"\"\n        keys = path.split('.')\n        value = context\n        \n        for key in keys:\n            if isinstance(value, dict):\n                value = value.get(key)\n            else:\n                return None\n        \n        return value\n    "
},
{
"path": "daoyoucode/agents/orchestrators/workflow.py",
"start": 347,
"end": 379,
"text": "    def _safe_eval(\n        self,\n        condition: str,\n        context: Dict[str, Any]\n    ) -> bool:\n        \"\"\"å®‰å…¨çš„æ¡ä»¶è¯„ä¼°\"\"\"\n        # åªå…è®¸ç®€å•çš„æ¯”è¾ƒæ“ä½œ\n        allowed_ops = ['==', '!=', '>', '<', '>=', '<=', 'and', 'or', 'not', 'in']\n        \n        # ç®€åŒ–ç‰ˆæœ¬ï¼šåªæ”¯æŒå¸ƒå°”å€¼å’Œç®€å•æ¯”è¾ƒ\n        try:\n            # ç§»é™¤å±é™©å­—ç¬¦\n            if any(char in condition for char in ['__', 'import', 'exec', 'eval']):\n                return False\n            \n            # åˆ›å»ºå®‰å…¨çš„å‘½åç©ºé—´\n            safe_dict = {\n                'True': True,\n                'False': False,\n                'None': None,\n            }\n            \n            # æ·»åŠ resultsåˆ°å‘½åç©ºé—´\n            if 'results' in context:\n                safe_dict['results'] = context['results']\n            \n            # è¯„ä¼°\n            return bool(eval(condition, {\"__builtins__\": {}}, safe_dict))\n        \n        except Exception as e:\n            logger.warning(f\"æ¡ä»¶è¯„ä¼°å¤±è´¥: {e}\")\n            return False\n    "
},
{
"path": "daoyoucode/agents/orchestrators/workflow.py",
"start": 380,
"end": 403,
"text": "    def _validate_dependencies(self, workflow: List[Dict[str, Any]]) -> bool:\n        \"\"\"éªŒè¯å·¥ä½œæµä¾èµ–å…³ç³»\"\"\"\n        # æ”¶é›†æ‰€æœ‰æ­¥éª¤åç§°\n        step_names = {step.get('name', f'step_{i}') for i, step in enumerate(workflow)}\n        \n        # æ£€æŸ¥æ¯ä¸ªæ­¥éª¤çš„ä¾èµ–\n        for step in workflow:\n            depends_on = step.get('depends_on', [])\n            if not depends_on:\n                continue\n            \n            # æ£€æŸ¥ä¾èµ–çš„æ­¥éª¤æ˜¯å¦å­˜åœ¨\n            for dep in depends_on:\n                if dep not in step_names:\n                    logger.error(f\"æ­¥éª¤ {step.get('name')} ä¾èµ–æœªå®šä¹‰çš„æ­¥éª¤: {dep}\")\n                    return False\n        \n        # æ£€æŸ¥å¾ªç¯ä¾èµ–\n        if self._has_circular_dependency(workflow):\n            logger.error(\"å·¥ä½œæµå­˜åœ¨å¾ªç¯ä¾èµ–\")\n            return False\n        \n        return True\n    "
},
{
"path": "daoyoucode/agents/orchestrators/workflow.py",
"start": 404,
"end": 416,
"text": "    def _has_circular_dependency(self, workflow: List[Dict[str, Any]]) -> bool:\n        \"\"\"æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¾ªç¯ä¾èµ–\"\"\"\n        # æ„å»ºä¾èµ–å›¾\n        graph = {}\n        for step in workflow:\n            step_name = step.get('name', f'step_{workflow.index(step)}')\n            depends_on = step.get('depends_on', [])\n            graph[step_name] = depends_on\n        \n        # DFSæ£€æµ‹å¾ªç¯\n        visited = set()\n        rec_stack = set()\n        "
},
{
"path": "daoyoucode/agents/orchestrators/workflow.py",
"start": 417,
"end": 437,
"text": "        def has_cycle(node):\n            visited.add(node)\n            rec_stack.add(node)\n            \n            for neighbor in graph.get(node, []):\n                if neighbor not in visited:\n                    if has_cycle(neighbor):\n                        return True\n                elif neighbor in rec_stack:\n                    return True\n            \n            rec_stack.remove(node)\n            return False\n        \n        for node in graph:\n            if node not in visited:\n                if has_cycle(node):\n                    return True\n        \n        return False\n    "
},
{
"path": "daoyoucode/agents/orchestrators/workflow.py",
"start": 438,
"end": 523,
"text": "    def _check_dependencies(\n        self,\n        step: Dict[str, Any],\n        context: Dict[str, Any]\n    ) -> bool:\n        \"\"\"æ£€æŸ¥æ­¥éª¤ä¾èµ–æ˜¯å¦æ»¡è¶³\"\"\"\n        depends_on = step.get('depends_on', [])\n        if not depends_on:\n            return True\n        \n        results = context.get('results', {})\n        \n        # æ£€æŸ¥æ‰€æœ‰ä¾èµ–çš„æ­¥éª¤æ˜¯å¦å·²æ‰§è¡Œä¸”æˆåŠŸ\n        for dep in depends_on:\n            # æ£€æŸ¥æ˜¯å¦åœ¨resultsä¸­ï¼ˆä½¿ç”¨output keyï¼‰\n            dep_found = False\n            for output_key, result in results.items():\n                # æ£€æŸ¥output keyæˆ–æ­¥éª¤åç§°\n                if output_key == dep or result.get('_step_name') == dep:\n                    dep_found = True\n                    if not result.get('success'):\n                        logger.warning(f\"ä¾èµ–æ­¥éª¤ {dep} æ‰§è¡Œå¤±è´¥\")\n                        return False\n                    break\n            \n            if not dep_found:\n                logger.warning(f\"ä¾èµ–æ­¥éª¤ {dep} æœªæ‰§è¡Œ\")\n                return False\n        \n        return True\n    \n    async def _rollback_steps(\n        self,\n        executed_steps: List[Tuple[Dict[str, Any], Dict[str, Any]]],\n        context: Dict[str, Any]\n    ):\n        \"\"\"å›æ»šå·²æ‰§è¡Œçš„æ­¥éª¤\"\"\"\n        if not executed_steps:\n            return\n        \n        logger.info(f\"å¼€å§‹å›æ»š {len(executed_steps)} ä¸ªæ­¥éª¤\")\n        \n        # é€†åºå›æ»š\n        for step, result in reversed(executed_steps):\n            step_name = step.get('name', 'unnamed')\n            rollback_agent = step.get('rollback')\n            \n            if not rollback_agent:\n                logger.debug(f\"æ­¥éª¤ {step_name} æ²¡æœ‰é…ç½®å›æ»šAgentï¼Œè·³è¿‡\")\n                continue\n            \n            try:\n                logger.info(f\"å›æ»šæ­¥éª¤: {step_name}\")\n                \n                # è·å–å›æ»šAgent\n                agent = self._get_agent(rollback_agent)\n                \n                # å‡†å¤‡å›æ»šè¾“å…¥ï¼ˆåŒ…å«åŸå§‹ç»“æœï¼‰\n                rollback_input = f\"å›æ»šæ­¥éª¤ {step_name}ï¼ŒåŸå§‹ç»“æœ: {result.get('content', '')}\"\n                \n                # æ‰§è¡Œå›æ»š\n                await agent.execute(\n                    prompt_source={'use_agent_default': True},\n                    user_input=rollback_input,\n                    context=context\n                )\n                \n                logger.info(f\"æ­¥éª¤ {step_name} å›æ»šæˆåŠŸ\")\n            \n            except Exception as e:\n                logger.error(f\"å›æ»šæ­¥éª¤ {step_name} å¤±è´¥: {e}\")\n                # ç»§ç»­å›æ»šå…¶ä»–æ­¥éª¤\n    \n    async def _aggregate_results(\n        self,\n        results: Dict[str, Any]\n    ) -> str:\n        \"\"\"èšåˆæ‰€æœ‰æ­¥éª¤çš„ç»“æœ\"\"\"\n        # ç®€å•èšåˆï¼šæ‹¼æ¥æ‰€æœ‰æˆåŠŸæ­¥éª¤çš„å†…å®¹\n        contents = []\n        \n        for step_name, result in results.items():\n            if result.get('success') and result.get('content'):\n                contents.append(f\"[{step_name}]\\n{result['content']}\")\n        \n        return \"\\n\\n\".join(contents)"
},
{
"path": "daoyoucode/agents/orchestrators/__init__.py",
"start": 1,
"end": 16,
"text": "\"\"\"\nå†…ç½®ç¼–æ’å™¨\n\nè‡ªåŠ¨æ³¨å†Œæ‰€æœ‰å†…ç½®ç¼–æ’å™¨\n\"\"\"\n\nfrom ..core.orchestrator import register_orchestrator\nfrom .simple import SimpleOrchestrator\nfrom .multi_agent import MultiAgentOrchestrator\nfrom .workflow import WorkflowOrchestrator\nfrom .conditional import ConditionalOrchestrator\nfrom .parallel import ParallelOrchestrator\nfrom .parallel_explore import ParallelExploreOrchestrator\nfrom .react import ReActOrchestrator\n\n"
},
{
"path": "daoyoucode/agents/orchestrators/__init__.py",
"start": 17,
"end": 41,
"text": "def register_builtin_orchestrators():\n    \"\"\"æ³¨å†Œæ‰€æœ‰å†…ç½®ç¼–æ’å™¨\"\"\"\n    register_orchestrator('simple', SimpleOrchestrator)\n    register_orchestrator('multi_agent', MultiAgentOrchestrator)\n    register_orchestrator('workflow', WorkflowOrchestrator)\n    register_orchestrator('conditional', ConditionalOrchestrator)\n    register_orchestrator('parallel', ParallelOrchestrator)\n    register_orchestrator('parallel_explore', ParallelExploreOrchestrator)\n    register_orchestrator('react', ReActOrchestrator)\n\n\n# è‡ªåŠ¨æ³¨å†Œ\nregister_builtin_orchestrators()\n\n\n__all__ = [\n    'SimpleOrchestrator',\n    'MultiAgentOrchestrator',\n    'WorkflowOrchestrator',\n    'ConditionalOrchestrator',\n    'ParallelOrchestrator',\n    'ParallelExploreOrchestrator',\n    'ReActOrchestrator',\n    'register_builtin_orchestrators',\n]"
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 1,
"end": 50,
"text": "\"\"\"\nASTå·¥å…· - åŸºäºast-grepçš„ASTçº§åˆ«ä»£ç æœç´¢å’Œæ›¿æ¢\n\næ¥æºï¼šoh-my-opencodeï¼ˆç‹¬æœ‰åŠŸèƒ½ï¼‰\nç‰¹ç‚¹ï¼š\n1. ASTçº§åˆ«çš„ç²¾ç¡®åŒ¹é…ï¼ˆä¸æ˜¯æ–‡æœ¬åŒ¹é…ï¼‰\n2. æ”¯æŒ25ç§è¯­è¨€\n3. å…ƒå˜é‡æ”¯æŒï¼ˆ$VAR, $$ï¼‰\n4. æ™ºèƒ½æç¤ºå’Œé”™è¯¯å¤„ç†\n5. è‡ªåŠ¨ä¸‹è½½å’Œç®¡ç†ast-grepäºŒè¿›åˆ¶\n\nå¯¹æ¯”ç»“è®ºï¼š\n- oh-my-opencode âœ… ç‹¬æœ‰ï¼šast-grepé›†æˆï¼Œ25ç§è¯­è¨€ï¼Œæ™ºèƒ½æç¤º\n- opencode: æ— ASTå·¥å…·\n- daoyouCodePilot: æ— ASTå·¥å…·\n\"\"\"\n\nimport asyncio\nimport json\nimport os\nimport platform\nimport shutil\nimport subprocess\nimport tempfile\nimport zipfile\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass\nimport logging\n\nfrom .base import BaseTool, ToolResult\n\nlogger = logging.getLogger(__name__)\n\n\n# æ”¯æŒçš„è¯­è¨€ï¼ˆ25ç§ï¼‰\nSUPPORTED_LANGUAGES = [\n    \"bash\", \"c\", \"cpp\", \"csharp\", \"css\", \"elixir\", \"go\", \"haskell\",\n    \"html\", \"java\", \"javascript\", \"json\", \"kotlin\", \"lua\", \"nix\",\n    \"php\", \"python\", \"ruby\", \"rust\", \"scala\", \"solidity\", \"swift\",\n    \"typescript\", \"tsx\", \"yaml\"\n]\n\n# é»˜è®¤é…ç½®\nDEFAULT_TIMEOUT_MS = 300_000  # 5åˆ†é’Ÿ\nDEFAULT_MAX_OUTPUT_BYTES = 1 * 1024 * 1024  # 1MB\nDEFAULT_MAX_MATCHES = 500\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 51,
"end": 57,
"text": "class Position:\n    \"\"\"ä½ç½®ä¿¡æ¯\"\"\"\n    line: int\n    column: int\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 58,
"end": 64,
"text": "class Range:\n    \"\"\"èŒƒå›´ä¿¡æ¯\"\"\"\n    start: Position\n    end: Position\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 65,
"end": 73,
"text": "class Match:\n    \"\"\"åŒ¹é…ç»“æœ\"\"\"\n    file: str\n    text: str\n    range: Range\n    lines: str\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 74,
"end": 82,
"text": "class SearchResult:\n    \"\"\"æœç´¢ç»“æœ\"\"\"\n    matches: List[Match]\n    total_matches: int\n    truncated: bool\n    truncated_reason: Optional[str] = None\n    error: Optional[str] = None\n\n"
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 83,
"end": 112,
"text": "class AstGrepManager:\n    \"\"\"\n    ast-grepäºŒè¿›åˆ¶ç®¡ç†å™¨\n    \n    èŒè´£ï¼š\n    1. æŸ¥æ‰¾å·²å®‰è£…çš„ast-grep\n    2. è‡ªåŠ¨ä¸‹è½½ast-grepäºŒè¿›åˆ¶\n    3. ç®¡ç†ç¼“å­˜ç›®å½•\n    4. æ£€æŸ¥NAPIå¯ç”¨æ€§ï¼ˆç¯å¢ƒè¯Šæ–­ï¼‰\n    \n    æ³¨æ„ï¼šä¸oh-my-opencodeä¸€è‡´ï¼Œåªä½¿ç”¨CLIæ¨¡å¼ï¼Œä¸ä½¿ç”¨NAPI\n    \"\"\"\n    \n    # GitHubä»“åº“\n    REPO = \"ast-grep/ast-grep\"\n    DEFAULT_VERSION = \"0.40.0\"\n    \n    # NAPIæ”¯æŒçš„è¯­è¨€ï¼ˆ5ç§ï¼‰\n    NAPI_LANGUAGES = [\"html\", \"javascript\", \"tsx\", \"css\", \"typescript\"]\n    \n    # å¹³å°æ˜ å°„\n    PLATFORM_MAP = {\n        \"Darwin-arm64\": {\"arch\": \"aarch64\", \"os\": \"apple-darwin\"},\n        \"Darwin-x86_64\": {\"arch\": \"x86_64\", \"os\": \"apple-darwin\"},\n        \"Linux-aarch64\": {\"arch\": \"aarch64\", \"os\": \"unknown-linux-gnu\"},\n        \"Linux-x86_64\": {\"arch\": \"x86_64\", \"os\": \"unknown-linux-gnu\"},\n        \"Windows-AMD64\": {\"arch\": \"x86_64\", \"os\": \"pc-windows-msvc\"},\n        \"Windows-ARM64\": {\"arch\": \"aarch64\", \"os\": \"pc-windows-msvc\"},\n    }\n    "
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 113,
"end": 117,
"text": "    def __init__(self):\n        self._binary_path: Optional[str] = None\n        self._cache_dir = self._get_cache_dir()\n        self._napi_available: Optional[bool] = None\n    "
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 118,
"end": 134,
"text": "    def _get_cache_dir(self) -> Path:\n        \"\"\"è·å–ç¼“å­˜ç›®å½•\"\"\"\n        if platform.system() == \"Windows\":\n            base = os.environ.get(\"LOCALAPPDATA\") or os.environ.get(\"APPDATA\")\n            if not base:\n                base = Path.home() / \"AppData\" / \"Local\"\n            else:\n                base = Path(base)\n            return base / \"daoyoucode\" / \"bin\"\n        else:\n            base = os.environ.get(\"XDG_CACHE_HOME\")\n            if not base:\n                base = Path.home() / \".cache\"\n            else:\n                base = Path(base)\n            return base / \"daoyoucode\" / \"bin\"\n    "
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 135,
"end": 138,
"text": "    def _get_binary_name(self) -> str:\n        \"\"\"è·å–äºŒè¿›åˆ¶æ–‡ä»¶å\"\"\"\n        return \"sg.exe\" if platform.system() == \"Windows\" else \"sg\"\n    "
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 139,
"end": 143,
"text": "    def _get_cached_binary_path(self) -> Optional[Path]:\n        \"\"\"è·å–ç¼“å­˜çš„äºŒè¿›åˆ¶è·¯å¾„\"\"\"\n        binary_path = self._cache_dir / self._get_binary_name()\n        return binary_path if binary_path.exists() else None\n    "
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 144,
"end": 259,
"text": "    def _find_system_binary(self) -> Optional[str]:\n        \"\"\"æŸ¥æ‰¾ç³»ç»Ÿä¸­å·²å®‰è£…çš„ast-grep\"\"\"\n        # 1. æ£€æŸ¥PATHä¸­çš„sgå‘½ä»¤\n        sg_path = shutil.which(\"sg\")\n        if sg_path:\n            return sg_path\n        \n        # 2. æ£€æŸ¥å¸¸è§å®‰è£…ä½ç½®ï¼ˆmacOS Homebrewï¼‰\n        if platform.system() == \"Darwin\":\n            homebrew_paths = [\n                \"/opt/homebrew/bin/sg\",\n                \"/usr/local/bin/sg\"\n            ]\n            for path in homebrew_paths:\n                if Path(path).exists():\n                    return path\n        \n        return None\n    \n    async def get_binary_path(self) -> Optional[str]:\n        \"\"\"\n        è·å–ast-grepäºŒè¿›åˆ¶è·¯å¾„\n        \n        ä¼˜å…ˆçº§ï¼š\n        1. ç¼“å­˜çš„è·¯å¾„\n        2. ç³»ç»Ÿå®‰è£…çš„sgå‘½ä»¤\n        3. è‡ªåŠ¨ä¸‹è½½\n        \n        Returns:\n            äºŒè¿›åˆ¶è·¯å¾„ï¼Œå¦‚æœå¤±è´¥è¿”å›None\n        \"\"\"\n        # 1. æ£€æŸ¥ç¼“å­˜\n        if self._binary_path and Path(self._binary_path).exists():\n            return self._binary_path\n        \n        # 2. æ£€æŸ¥ç¼“å­˜ç›®å½•\n        cached_path = self._get_cached_binary_path()\n        if cached_path:\n            self._binary_path = str(cached_path)\n            return self._binary_path\n        \n        # 3. æ£€æŸ¥ç³»ç»Ÿå®‰è£…\n        system_path = self._find_system_binary()\n        if system_path:\n            self._binary_path = system_path\n            logger.info(f\"ä½¿ç”¨ç³»ç»Ÿå®‰è£…çš„ast-grep: {system_path}\")\n            return self._binary_path\n        \n        # 4. è‡ªåŠ¨ä¸‹è½½\n        logger.info(\"ast-grepæœªå®‰è£…ï¼Œå¼€å§‹è‡ªåŠ¨ä¸‹è½½...\")\n        downloaded_path = await self._download_binary()\n        if downloaded_path:\n            self._binary_path = str(downloaded_path)\n            return self._binary_path\n        \n        return None\n    \n    async def _download_binary(self, version: str = DEFAULT_VERSION) -> Optional[Path]:\n        \"\"\"\n        ä¸‹è½½ast-grepäºŒè¿›åˆ¶\n        \n        Args:\n            version: ç‰ˆæœ¬å·\n        \n        Returns:\n            ä¸‹è½½çš„äºŒè¿›åˆ¶è·¯å¾„ï¼Œå¦‚æœå¤±è´¥è¿”å›None\n        \"\"\"\n        # è·å–å¹³å°ä¿¡æ¯\n        system = platform.system()\n        machine = platform.machine()\n        platform_key = f\"{system}-{machine}\"\n        \n        platform_info = self.PLATFORM_MAP.get(platform_key)\n        if not platform_info:\n            logger.error(f\"ä¸æ”¯æŒçš„å¹³å°: {platform_key}\")\n            return None\n        \n        # æ„å»ºä¸‹è½½URL\n        arch = platform_info[\"arch\"]\n        os_name = platform_info[\"os\"]\n        asset_name = f\"app-{arch}-{os_name}.zip\"\n        download_url = f\"https://github.com/{self.REPO}/releases/download/{version}/{asset_name}\"\n        \n        logger.info(f\"ä¸‹è½½URL: {download_url}\")\n        \n        try:\n            # åˆ›å»ºç¼“å­˜ç›®å½•\n            self._cache_dir.mkdir(parents=True, exist_ok=True)\n            \n            # ä¸‹è½½æ–‡ä»¶\n            import urllib.request\n            archive_path = self._cache_dir / asset_name\n            \n            logger.info(f\"æ­£åœ¨ä¸‹è½½åˆ°: {archive_path}\")\n            urllib.request.urlretrieve(download_url, archive_path)\n            \n            # è§£å‹\n            logger.info(\"æ­£åœ¨è§£å‹...\")\n            with zipfile.ZipFile(archive_path, 'r') as zip_ref:\n                zip_ref.extractall(self._cache_dir)\n            \n            # åˆ é™¤å‹ç¼©åŒ…\n            archive_path.unlink()\n            \n            # è®¾ç½®æ‰§è¡Œæƒé™ï¼ˆUnixç³»ç»Ÿï¼‰\n            binary_path = self._cache_dir / self._get_binary_name()\n            if platform.system() != \"Windows\":\n                os.chmod(binary_path, 0o755)\n            \n            logger.info(f\"ast-grepä¸‹è½½å®Œæˆ: {binary_path}\")\n            return binary_path\n            \n        except Exception as e:\n            logger.error(f\"ä¸‹è½½ast-grepå¤±è´¥: {e}\", exc_info=True)\n            return None\n    "
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 260,
"end": 268,
"text": "    def is_available(self) -> bool:\n        \"\"\"æ£€æŸ¥ast-grepæ˜¯å¦å¯ç”¨\"\"\"\n        return self._binary_path is not None or self._find_system_binary() is not None\n\n\n# å…¨å±€ç®¡ç†å™¨å®ä¾‹\n_ast_grep_manager = AstGrepManager()\n\n"
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 269,
"end": 284,
"text": "class AstGrepSearchTool(BaseTool):\n    \"\"\"\n    ASTçº§åˆ«çš„ä»£ç æœç´¢å·¥å…·\n    \n    åŠŸèƒ½ï¼š\n    1. ä½¿ç”¨ASTæ¨¡å¼åŒ¹é…ä»£ç \n    2. æ”¯æŒå…ƒå˜é‡ï¼ˆ$VAR, $$ï¼‰\n    3. æ”¯æŒ25ç§è¯­è¨€\n    4. æ™ºèƒ½æç¤ºå’Œé”™è¯¯å¤„ç†\n    \n    ç¤ºä¾‹ï¼š\n    - æœç´¢æ‰€æœ‰console.log: pattern='console.log($MSG)'\n    - æœç´¢æ‰€æœ‰å‡½æ•°å®šä¹‰: pattern='def $FUNC($$):'\n    - æœç´¢æ‰€æœ‰asyncå‡½æ•°: pattern='async function $NAME($$) { $$ }'\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 285,
"end": 435,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"ast_grep_search\",\n            description=\"\"\"Search code patterns using AST-aware matching. Supports 25 languages.\n\nUse meta-variables:\n- $VAR: matches single node\n- $$: matches multiple nodes\n\nIMPORTANT: Patterns must be complete AST nodes (valid code).\nFor functions, include params and body.\n\nExamples:\n- console.log($MSG)\n- def $FUNC($$):\n- async function $NAME($$) { $$ }\n\nSupported languages: bash, c, cpp, csharp, css, elixir, go, haskell, html, java, javascript, json, kotlin, lua, nix, php, python, ruby, rust, scala, solidity, swift, typescript, tsx, yaml\"\"\"\n        )\n        self.parameters = {\n            \"type\": \"object\",\n            \"properties\": {\n                \"pattern\": {\n                    \"type\": \"string\",\n                    \"description\": \"AST pattern with meta-variables ($VAR, $$). Must be complete AST node.\"\n                },\n                \"lang\": {\n                    \"type\": \"string\",\n                    \"enum\": SUPPORTED_LANGUAGES,\n                    \"description\": \"Target language\"\n                },\n                \"paths\": {\n                    \"type\": \"array\",\n                    \"items\": {\"type\": \"string\"},\n                    \"description\": \"Paths to search (default: ['.'])\",\n                    \"default\": [\".\"]\n                },\n                \"globs\": {\n                    \"type\": \"array\",\n                    \"items\": {\"type\": \"string\"},\n                    \"description\": \"Include/exclude globs (prefix ! to exclude)\",\n                    \"default\": []\n                },\n                \"context\": {\n                    \"type\": \"integer\",\n                    \"description\": \"Context lines around match\",\n                    \"default\": 0\n                }\n            },\n            \"required\": [\"pattern\", \"lang\"]\n        }\n    \n    async def execute(\n        self,\n        pattern: str,\n        lang: str,\n        paths: Optional[List[str]] = None,\n        globs: Optional[List[str]] = None,\n        context: int = 0\n    ) -> ToolResult:\n        \"\"\"\n        æ‰§è¡ŒASTæœç´¢\n        \n        Args:\n            pattern: ASTæ¨¡å¼\n            lang: ç›®æ ‡è¯­è¨€\n            paths: æœç´¢è·¯å¾„\n            globs: åŒ…å«/æ’é™¤æ¨¡å¼\n            context: ä¸Šä¸‹æ–‡è¡Œæ•°\n        \n        Returns:\n            æœç´¢ç»“æœ\n        \"\"\"\n        try:\n            # è·å–ast-grepäºŒè¿›åˆ¶\n            binary_path = await _ast_grep_manager.get_binary_path()\n            if not binary_path:\n                return ToolResult(\n                    success=False,\n                    content=\"\",\n                    error=\"ast-grep not available. Install: pip install ast-grep-cli or cargo install ast-grep\"\n                )\n            \n            # æ„å»ºå‘½ä»¤\n            args = [\n                binary_path,\n                \"run\",\n                \"-p\", pattern,\n                \"--lang\", lang,\n                \"--json=compact\"\n            ]\n            \n            if context > 0:\n                args.extend([\"-C\", str(context)])\n            \n            if globs:\n                for glob in globs:\n                    args.extend([\"--globs\", glob])\n            \n            if not paths:\n                paths = [\".\"]\n            args.extend(paths)\n            \n            # æ‰§è¡Œå‘½ä»¤\n            logger.debug(f\"æ‰§è¡Œå‘½ä»¤: {' '.join(args)}\")\n            \n            process = await asyncio.create_subprocess_exec(\n                *args,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n                cwd=os.getcwd()\n            )\n            \n            try:\n                stdout, stderr = await asyncio.wait_for(\n                    process.communicate(),\n                    timeout=DEFAULT_TIMEOUT_MS / 1000\n                )\n            except asyncio.TimeoutError:\n                process.kill()\n                return ToolResult(\n                    success=False,\n                    content=\"\",\n                    error=f\"Search timeout after {DEFAULT_TIMEOUT_MS}ms\"\n                )\n         "
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 436,
"end": 542,
"text": "    def _parse_result(\n        self,\n        stdout: bytes,\n        stderr: bytes,\n        returncode: int\n    ) -> SearchResult:\n        \"\"\"è§£æå‘½ä»¤è¾“å‡º\"\"\"\n        stdout_str = stdout.decode('utf-8', errors='ignore')\n        stderr_str = stderr.decode('utf-8', errors='ignore')\n        \n        # æ£€æŸ¥é”™è¯¯\n        if returncode != 0 and not stdout_str.strip():\n            if \"No files found\" in stderr_str:\n                return SearchResult(matches=[], total_matches=0, truncated=False)\n            if stderr_str.strip():\n                return SearchResult(\n                    matches=[],\n                    total_matches=0,\n                    truncated=False,\n                    error=stderr_str.strip()\n                )\n            return SearchResult(matches=[], total_matches=0, truncated=False)\n        \n        # ç©ºç»“æœ\n        if not stdout_str.strip():\n            return SearchResult(matches=[], total_matches=0, truncated=False)\n        \n        # æ£€æŸ¥è¾“å‡ºæ˜¯å¦è¢«æˆªæ–­\n        output_truncated = len(stdout) >= DEFAULT_MAX_OUTPUT_BYTES\n        output_to_process = stdout_str[:DEFAULT_MAX_OUTPUT_BYTES] if output_truncated else stdout_str\n        \n        # è§£æJSON\n        try:\n            raw_matches = json.loads(output_to_process)\n        except json.JSONDecodeError:\n            # å¦‚æœè¢«æˆªæ–­ï¼Œå°è¯•ä¿®å¤JSON\n            if output_truncated:\n                try:\n                    last_valid = output_to_process.rfind(\"}\")\n                    if last_valid > 0:\n                        bracket_index = output_to_process.rfind(\"},\", last_valid)\n                        if bracket_index > 0:\n                            truncated_json = output_to_process[:bracket_index + 1] + \"]\"\n                            raw_matches = json.loads(truncated_json)\n                        else:\n                            return SearchResult(\n                                matches=[],\n                                total_matches=0,\n                                truncated=True,\n                                truncated_reason=\"max_output_bytes\",\n                                error=\"Output too large and could not be parsed\"\n                            )\n                    else:\n                        return SearchResult(\n                            matches=[],\n                            total_matches=0,\n                            truncated=True,\n                            truncated_reason=\"max_output_bytes\",\n                            error=\"Output too large and could not be parsed\"\n                        )\n                except json.JSONDecodeError:\n                    return SearchResult(\n                        matches=[],\n                        total_matches=0,\n                        truncated=True,\n                        truncated_reason=\"max_output_bytes\",\n                        error=\"Output too large and could not be parsed\"\n                    )\n            else:\n                return SearchResult(matches=[], total_matches=0, truncated=False)\n        \n        # è½¬æ¢ä¸ºMatchå¯¹è±¡\n        matches = []\n        for raw_match in raw_matches:\n            try:\n                match = Match(\n                    file=raw_match[\"file\"],\n                    text=raw_match[\"text\"],\n                    range=Range(\n                        start=Position(\n                            line=raw_match[\"range\"][\"start\"][\"line\"],\n                            column=raw_match[\"range\"][\"start\"][\"column\"]\n                        ),\n                        end=Position(\n                            line=raw_match[\"range\"][\"end\"][\"line\"],\n                            column=raw_match[\"range\"][\"end\"][\"column\"]\n                        )\n                    ),\n                    lines=raw_match.get(\"lines\", \"\")\n                )\n                matches.append(match)\n            except (KeyError, TypeError) as e:\n                logger.warning(f\"è§£æåŒ¹é…å¤±è´¥: {e}\")\n                continue\n        \n        # æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§åŒ¹é…æ•°\n        total_matches = len(matches)\n        matches_truncated = total_matches > DEF"
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 543,
"end": 584,
"text": "    def _format_result(\n        self,\n        result: SearchResult,\n        pattern: str,\n        lang: str\n    ) -> str:\n        \"\"\"æ ¼å¼åŒ–æœç´¢ç»“æœ\"\"\"\n        if result.error:\n            return f\"Error: {result.error}\"\n        \n        if not result.matches:\n            # æä¾›æ™ºèƒ½æç¤º\n            hint = self._get_empty_result_hint(pattern, lang)\n            output = \"No matches found\"\n            if hint:\n                output += f\"\\n\\n{hint}\"\n            return output\n        \n        lines = []\n        \n        # æˆªæ–­è­¦å‘Š\n        if result.truncated:\n            reason = {\n                \"max_matches\": f\"showing first {len(result.matches)} of {result.total_matches}\",\n                \"max_output_bytes\": \"output exceeded 1MB limit\",\n                \"timeout\": \"search timed out\"\n            }.get(result.truncated_reason, \"unknown reason\")\n            lines.append(f\"âš ï¸ Results truncated ({reason})\\n\")\n        \n        # åŒ¹é…æ•°é‡\n        truncated_info = f\" (truncated from {result.total_matches})\" if result.truncated else \"\"\n        lines.append(f\"Found {len(result.matches)} match(es){truncated_info}:\\n\")\n        \n        # æ¯ä¸ªåŒ¹é…\n        for match in result.matches:\n            loc = f\"{match.file}:{match.range.start.line + 1}:{match.range.start.column + 1}\"\n            lines.append(f\"{loc}\")\n            lines.append(f\"  {match.lines.strip()}\")\n            lines.append(\"\")\n        \n        return \"\\n\".join(lines)\n    "
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 585,
"end": 604,
"text": "    def _get_empty_result_hint(self, pattern: str, lang: str) -> Optional[str]:\n        \"\"\"ä¸ºç©ºç»“æœæä¾›æ™ºèƒ½æç¤º\"\"\"\n        src = pattern.strip()\n        \n        # Pythonæç¤º\n        if lang == \"python\":\n            if src.startswith(\"class \") and src.endswith(\":\"):\n                return f\"ğŸ’¡ Hint: Remove trailing colon. Try: \\\"{src[:-1]}\\\"\"\n            if (src.startswith(\"def \") or src.startswith(\"async def \")) and src.endswith(\":\"):\n                return f\"ğŸ’¡ Hint: Remove trailing colon. Try: \\\"{src[:-1]}\\\"\"\n        \n        # JavaScript/TypeScriptæç¤º\n        if lang in [\"javascript\", \"typescript\", \"tsx\"]:\n            import re\n            if re.match(r\"^(export\\s+)?(async\\s+)?function\\s+\\$[A-Z_]+\\s*$\", src, re.IGNORECASE):\n                return \"ğŸ’¡ Hint: Function patterns need params and body. Try \\\"function $NAME($$) { $$ }\\\"\"\n        \n        return None\n\n"
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 605,
"end": 620,
"text": "class AstGrepReplaceTool(BaseTool):\n    \"\"\"\n    ASTçº§åˆ«çš„ä»£ç æ›¿æ¢å·¥å…·\n    \n    åŠŸèƒ½ï¼š\n    1. ä½¿ç”¨ASTæ¨¡å¼åŒ¹é…å’Œæ›¿æ¢ä»£ç \n    2. æ”¯æŒå…ƒå˜é‡åœ¨æ›¿æ¢ä¸­ä½¿ç”¨\n    3. é»˜è®¤dry-runæ¨¡å¼ï¼ˆé¢„è§ˆï¼‰\n    4. æ”¯æŒ25ç§è¯­è¨€\n    \n    ç¤ºä¾‹ï¼š\n    - æ›¿æ¢console.logä¸ºlogger.info:\n      pattern='console.log($MSG)'\n      rewrite='logger.info($MSG)'\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 621,
"end": 775,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"ast_grep_replace\",\n            description=\"\"\"Replace code patterns using AST-aware rewriting.\n\nDry-run by default (preview changes without applying).\nUse meta-variables in rewrite to preserve matched content.\n\nExample:\n  pattern='console.log($MSG)'\n  rewrite='logger.info($MSG)'\n\nSupported languages: bash, c, cpp, csharp, css, elixir, go, haskell, html, java, javascript, json, kotlin, lua, nix, php, python, ruby, rust, scala, solidity, swift, typescript, tsx, yaml\"\"\"\n        )\n        self.parameters = {\n            \"type\": \"object\",\n            \"properties\": {\n                \"pattern\": {\n                    \"type\": \"string\",\n                    \"description\": \"AST pattern to match\"\n                },\n                \"rewrite\": {\n                    \"type\": \"string\",\n                    \"description\": \"Replacement pattern (can use $VAR from pattern)\"\n                },\n                \"lang\": {\n                    \"type\": \"string\",\n                    \"enum\": SUPPORTED_LANGUAGES,\n                    \"description\": \"Target language\"\n                },\n                \"paths\": {\n                    \"type\": \"array\",\n                    \"items\": {\"type\": \"string\"},\n                    \"description\": \"Paths to search\",\n                    \"default\": [\".\"]\n                },\n                \"globs\": {\n                    \"type\": \"array\",\n                    \"items\": {\"type\": \"string\"},\n                    \"description\": \"Include/exclude globs\",\n                    \"default\": []\n                },\n                \"dry_run\": {\n                    \"type\": \"boolean\",\n                    \"description\": \"Preview changes without applying (default: true)\",\n                    \"default\": True\n                }\n            },\n            \"required\": [\"pattern\", \"rewrite\", \"lang\"]\n        }\n    \n    async def execute(\n        self,\n        pattern: str,\n        rewrite: str,\n        lang: str,\n        paths: Optional[List[str]] = None,\n        globs: Optional[List[str]] = None,\n        dry_run: bool = True\n    ) -> ToolResult:\n        \"\"\"\n        æ‰§è¡ŒASTæ›¿æ¢\n        \n        Args:\n            pattern: ASTæ¨¡å¼\n            rewrite: æ›¿æ¢æ¨¡å¼\n            lang: ç›®æ ‡è¯­è¨€\n            paths: æœç´¢è·¯å¾„\n            globs: åŒ…å«/æ’é™¤æ¨¡å¼\n            dry_run: æ˜¯å¦é¢„è§ˆï¼ˆä¸å®é™…ä¿®æ”¹ï¼‰\n        \n        Returns:\n            æ›¿æ¢ç»“æœ\n        \"\"\"\n        try:\n            # è·å–ast-grepäºŒè¿›åˆ¶\n            binary_path = await _ast_grep_manager.get_binary_path()\n            if not binary_path:\n                return ToolResult(\n                    success=False,\n                    content=\"\",\n                    error=\"ast-grep not available. Install: pip install ast-grep-cli or cargo install ast-grep\"\n                )\n            \n            # æ„å»ºå‘½ä»¤\n            args = [\n                binary_path,\n                \"run\",\n                \"-p\", pattern,\n                \"-r\", rewrite,\n                \"--lang\", lang,\n                \"--json=compact\"\n            ]\n            \n            # å¦‚æœä¸æ˜¯dry-runï¼Œæ·»åŠ --update-all\n            if not dry_run:\n                args.append(\"--update-all\")\n            \n            if globs:\n                for glob in globs:\n                    args.extend([\"--globs\", glob])\n            \n            if not paths:\n                paths = [\".\"]\n            args.extend(paths)\n            \n            # æ‰§è¡Œå‘½ä»¤\n            logger.debug(f\"æ‰§è¡Œå‘½ä»¤: {' '.join(args)}\")\n            \n            process = await asyncio.create_subprocess_exec(\n                *args,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n                cwd=os.getcwd()\n            )\n            \n            try:\n                stdout, stderr = await asyncio.wait_for(\n                    process.communicate(),\n                    timeout=DEFAULT_TIMEOUT_MS / 1000\n                )\n            except asyncio.TimeoutError:\n                process.kill()\n                return ToolResult(\n                    su"
},
{
"path": "daoyoucode/agents/tools/ast_tools.py",
"start": 776,
"end": 810,
"text": "    def _format_result(self, result: SearchResult, dry_run: bool) -> str:\n        \"\"\"æ ¼å¼åŒ–æ›¿æ¢ç»“æœ\"\"\"\n        if result.error:\n            return f\"Error: {result.error}\"\n        \n        if not result.matches:\n            return \"No matches found to replace\"\n        \n        prefix = \"[DRY RUN] \" if dry_run else \"\"\n        lines = []\n        \n        # æˆªæ–­è­¦å‘Š\n        if result.truncated:\n            reason = {\n                \"max_matches\": f\"showing first {len(result.matches)} of {result.total_matches}\",\n                \"max_output_bytes\": \"output exceeded 1MB limit\",\n                \"timeout\": \"search timed out\"\n            }.get(result.truncated_reason, \"unknown reason\")\n            lines.append(f\"âš ï¸ Results truncated ({reason})\\n\")\n        \n        # æ›¿æ¢æ•°é‡\n        lines.append(f\"{prefix}{len(result.matches)} replacement(s):\\n\")\n        \n        # æ¯ä¸ªæ›¿æ¢\n        for match in result.matches:\n            loc = f\"{match.file}:{match.range.start.line + 1}:{match.range.start.column + 1}\"\n            lines.append(f\"{loc}\")\n            lines.append(f\"  {match.text}\")\n            lines.append(\"\")\n        \n        # æç¤º\n        if dry_run:\n            lines.append(\"Use dry_run=false to apply changes\")\n        \n        return \"\\n\".join(lines)"
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 1,
"end": 16,
"text": "\"\"\"\nå·¥å…·åŸºç±»\n\næ‰€æœ‰å·¥å…·çš„åŸºç¡€æŠ½è±¡\n\"\"\"\n\nfrom typing import Dict, Any, Optional, List\nfrom dataclasses import dataclass, field\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 17,
"end": 36,
"text": "class ToolContext:\n    \"\"\"\n    å·¥å…·ä¸Šä¸‹æ–‡\n    \n    åŒ…å«å·¥å…·æ‰§è¡Œæ‰€éœ€çš„æ‰€æœ‰ç¯å¢ƒä¿¡æ¯ï¼Œç¡®ä¿è·¯å¾„å¤„ç†çš„ä¸€è‡´æ€§ã€‚\n    å‚è€ƒ daoyouCodePilot å’Œ aider çš„è®¾è®¡ã€‚\n    \n    Attributes:\n        repo_path: ä»“åº“æ ¹è·¯å¾„ï¼ˆç»å¯¹è·¯å¾„ï¼‰\n        session_id: ä¼šè¯ID\n        user_id: ç”¨æˆ·IDï¼ˆå¯é€‰ï¼‰\n        subtree_only: æ˜¯å¦åªæ‰«æå½“å‰ç›®å½•åŠå…¶å­ç›®å½•ï¼ˆå‚è€ƒ aiderï¼‰\n        cwd: å½“å‰å·¥ä½œç›®å½•ï¼ˆç”¨äº subtree_only è¿‡æ»¤ï¼‰\n    \"\"\"\n    repo_path: Path\n    session_id: Optional[str] = None\n    user_id: Optional[str] = None\n    subtree_only: bool = False\n    cwd: Optional[Path] = None\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 37,
"end": 49,
"text": "    def __post_init__(self):\n        \"\"\"ç¡®ä¿ repo_path æ˜¯ç»å¯¹è·¯å¾„\"\"\"\n        if not self.repo_path.is_absolute():\n            self.repo_path = self.repo_path.resolve()\n        \n        # å¦‚æœå¯ç”¨ subtree_only ä½†æ²¡æœ‰è®¾ç½® cwdï¼Œä½¿ç”¨å½“å‰ç›®å½•\n        if self.subtree_only and self.cwd is None:\n            self.cwd = Path.cwd()\n        \n        # ç¡®ä¿ cwd æ˜¯ç»å¯¹è·¯å¾„\n        if self.cwd and not self.cwd.is_absolute():\n            self.cwd = self.cwd.resolve()\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 50,
"end": 82,
"text": "    def should_include_path(self, path: str) -> bool:\n        \"\"\"\n        åˆ¤æ–­è·¯å¾„æ˜¯å¦åº”è¯¥è¢«åŒ…å«ï¼ˆç”¨äº subtree_only è¿‡æ»¤ï¼‰\n        \n        å‚è€ƒ aider çš„å®ç°ï¼š\n        - å¦‚æœ subtree_only=Falseï¼ŒåŒ…å«æ‰€æœ‰è·¯å¾„\n        - å¦‚æœ subtree_only=Trueï¼ŒåªåŒ…å« cwd åŠå…¶å­ç›®å½•ä¸‹çš„è·¯å¾„\n        \n        Args:\n            path: è¦æ£€æŸ¥çš„è·¯å¾„ï¼ˆç›¸å¯¹æˆ–ç»å¯¹ï¼‰\n        \n        Returns:\n            æ˜¯å¦åº”è¯¥åŒ…å«è¯¥è·¯å¾„\n        \"\"\"\n        if not self.subtree_only:\n            return True\n        \n        if not self.cwd:\n            return True\n        \n        # è½¬æ¢ä¸ºç»å¯¹è·¯å¾„\n        path_obj = Path(path)\n        if not path_obj.is_absolute():\n            path_obj = self.repo_path / path\n        \n        try:\n            # æ£€æŸ¥è·¯å¾„æ˜¯å¦åœ¨ cwd ä¸‹\n            path_obj.relative_to(self.cwd)\n            return True\n        except ValueError:\n            # ä¸åœ¨ cwd ä¸‹\n            return False\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 83,
"end": 102,
"text": "    def abs_path(self, path: str) -> Path:\n        \"\"\"\n        å°†ç›¸å¯¹è·¯å¾„è½¬æ¢ä¸ºç»å¯¹è·¯å¾„\n        \n        Args:\n            path: ç›¸å¯¹è·¯å¾„æˆ–ç»å¯¹è·¯å¾„\n        \n        Returns:\n            ç»å¯¹è·¯å¾„\n        \n        Examples:\n            >>> ctx = ToolContext(repo_path=Path(\"/project\"))\n            >>> ctx.abs_path(\"backend/file.py\")\n            Path(\"/project/backend/file.py\")\n        \"\"\"\n        path_obj = Path(path)\n        if path_obj.is_absolute():\n            return path_obj\n        return self.repo_path / path\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 103,
"end": 133,
"text": "    def rel_path(self, path: str) -> str:\n        \"\"\"\n        å°†ç»å¯¹è·¯å¾„è½¬æ¢ä¸ºç›¸å¯¹äº repo_path çš„è·¯å¾„\n        \n        Args:\n            path: ç»å¯¹è·¯å¾„æˆ–ç›¸å¯¹è·¯å¾„\n        \n        Returns:\n            ç›¸å¯¹äº repo_path çš„è·¯å¾„\n        \n        Examples:\n            >>> ctx = ToolContext(repo_path=Path(\"/project\"))\n            >>> ctx.rel_path(\"/project/backend/file.py\")\n            \"backend/file.py\"\n            >>> ctx.rel_path(\"backend/file.py\")\n            \"backend/file.py\"\n        \"\"\"\n        path_obj = Path(path)\n        \n        # å¦‚æœå·²ç»æ˜¯ç›¸å¯¹è·¯å¾„ï¼Œç›´æ¥è¿”å›\n        if not path_obj.is_absolute():\n            return str(path_obj)\n        \n        # è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„\n        try:\n            return str(path_obj.relative_to(self.repo_path))\n        except ValueError:\n            # ä¸åœ¨ repo_path ä¸‹ï¼Œè¿”å›åŸè·¯å¾„\n            logger.warning(f\"Path {path} is not under repo_path {self.repo_path}\")\n            return str(path_obj)\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 134,
"end": 149,
"text": "    def normalize_path(self, path: str) -> str:\n        \"\"\"\n        æ ‡å‡†åŒ–è·¯å¾„ï¼šç¡®ä¿è¿”å›ç›¸å¯¹äº repo_path çš„è·¯å¾„\n        \n        è¿™æ˜¯å·¥å…·è¿”å›è·¯å¾„æ—¶åº”è¯¥ä½¿ç”¨çš„æ–¹æ³•ã€‚\n        \n        Args:\n            path: ä»»æ„è·¯å¾„\n        \n        Returns:\n            ç›¸å¯¹äº repo_path çš„æ ‡å‡†è·¯å¾„\n        \"\"\"\n        return self.rel_path(path)\n\n\n@dataclass"
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 150,
"end": 157,
"text": "class ToolResult:\n    \"\"\"å·¥å…·æ‰§è¡Œç»“æœ\"\"\"\n    success: bool\n    content: Any\n    error: Optional[str] = None\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n"
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 158,
"end": 165,
"text": "class BaseTool(ABC):\n    \"\"\"å·¥å…·åŸºç±»\"\"\"\n    \n    # é»˜è®¤è¾“å‡ºé™åˆ¶ï¼ˆå­ç±»å¯ä»¥è¦†ç›–ï¼‰\n    MAX_OUTPUT_CHARS = 8000  # æœ€å¤§å­—ç¬¦æ•°\n    MAX_OUTPUT_LINES = 500   # æœ€å¤§è¡Œæ•°\n    TRUNCATION_STRATEGY = \"head_tail\"  # head_tail | head_only | none\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 166,
"end": 172,
"text": "    def __init__(self, name: str, description: str):\n        self.name = name\n        self.description = description\n        self.logger = logging.getLogger(f\"tool.{name}\")\n        self._working_directory = None  # å·¥ä½œç›®å½•ï¼ˆå‘åå…¼å®¹ï¼‰\n        self._context: Optional[ToolContext] = None  # æ–°çš„ä¸Šä¸‹æ–‡å¯¹è±¡\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 173,
"end": 179,
"text": "    def set_context(self, context: ToolContext):\n        \"\"\"è®¾ç½®å·¥å…·ä¸Šä¸‹æ–‡ï¼ˆæ–°æ–¹æ³•ï¼‰\"\"\"\n        self._context = context\n        # åŒæ—¶è®¾ç½® working_directory ä»¥ä¿æŒå‘åå…¼å®¹\n        self._working_directory = str(context.repo_path)\n        self.logger.debug(f\"å·¥å…· {self.name} ä¸Šä¸‹æ–‡è®¾ç½®ä¸º: repo_path={context.repo_path}\")\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 180,
"end": 188,
"text": "    def set_working_directory(self, working_dir: str):\n        \"\"\"è®¾ç½®å·¥ä½œç›®å½•ï¼ˆå‘åå…¼å®¹ï¼‰\"\"\"\n        self._working_directory = working_dir\n        # å¦‚æœæ²¡æœ‰ contextï¼Œåˆ›å»ºä¸€ä¸ª\n        if not self._context:\n            self._context = ToolContext(repo_path=Path(working_dir))\n        self.logger.debug(f\"å·¥å…· {self.name} å·¥ä½œç›®å½•è®¾ç½®ä¸º: {working_dir}\")\n    \n    @property"
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 189,
"end": 195,
"text": "    def context(self) -> ToolContext:\n        \"\"\"è·å–å·¥å…·ä¸Šä¸‹æ–‡\"\"\"\n        if not self._context:\n            # å¦‚æœæ²¡æœ‰è®¾ç½®ï¼Œä½¿ç”¨å½“å‰ç›®å½•\n            self._context = ToolContext(repo_path=Path.cwd())\n        return self._context\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 196,
"end": 244,
"text": "    def resolve_path(self, path: str) -> Path:\n        \"\"\"\n        è§£æè·¯å¾„ï¼ˆä½¿ç”¨ ToolContextï¼‰\n        \n        è‡ªåŠ¨æ£€æµ‹å¹¶ä¿®æ­£å¸¸è§çš„å ä½ç¬¦è·¯å¾„é”™è¯¯ã€‚\n        \n        Args:\n            path: ç›¸å¯¹æˆ–ç»å¯¹è·¯å¾„\n        \n        Returns:\n            ç»å¯¹è·¯å¾„\n        \"\"\"\n        # ğŸ†• æ£€æµ‹å ä½ç¬¦è·¯å¾„\n        placeholder_patterns = [\n            'your-repo-path',\n            'your-project',\n            'your-repo',\n            'path/to/your',\n            'path/to/file',\n            'example/path',\n            'example-path'\n        ]\n        \n        path_lower = path.lower()\n        for pattern in placeholder_patterns:\n            if pattern in path_lower:\n                self.logger.warning(\n                    f\"âš ï¸  æ£€æµ‹åˆ°å ä½ç¬¦è·¯å¾„: {path}\\n\"\n                    f\"   è‡ªåŠ¨ä¿®æ­£ä¸º: .\\n\"\n                    f\"   æç¤ºï¼šè¯·ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•\"\n                )\n                # è‡ªåŠ¨ä¿®æ­£ä¸ºå½“å‰å·¥ä½œç›®å½•\n                return self.context.repo_path\n        \n        # ğŸ†• å»æ‰ ./ å‰ç¼€ï¼ˆå¦‚æœè·¯å¾„ä¸å­˜åœ¨ï¼‰\n        if path.startswith('./'):\n            clean_path = path[2:]\n            full_path = self.context.repo_path / clean_path\n            \n            # å¦‚æœå»æ‰ ./ åçš„è·¯å¾„å­˜åœ¨ï¼Œä½¿ç”¨å®ƒ\n            if not full_path.exists():\n                self.logger.warning(\n                    f\"âš ï¸  è·¯å¾„ä¸å­˜åœ¨: {path}\\n\"\n                    f\"   å°è¯•å»æ‰ ./ å‰ç¼€: {clean_path}\"\n                )\n                path = clean_path\n        \n        return self.context.abs_path(path)\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 245,
"end": 261,
"text": "    def normalize_path(self, path: str) -> str:\n        \"\"\"\n        æ ‡å‡†åŒ–è·¯å¾„ï¼ˆä½¿ç”¨ ToolContextï¼‰\n        \n        Args:\n            path: ä»»æ„è·¯å¾„\n        \n        Returns:\n            ç›¸å¯¹äº repo_path çš„æ ‡å‡†è·¯å¾„\n        \"\"\"\n        return self.context.normalize_path(path)\n    \n    @abstractmethod\n    async def execute(self, **kwargs) -> ToolResult:\n        \"\"\"æ‰§è¡Œå·¥å…·\"\"\"\n        pass\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 262,
"end": 277,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        \"\"\"\n        è·å–Function Callingçš„schema\n        \n        å­ç±»åº”è¯¥é‡å†™æ­¤æ–¹æ³•ä»¥æä¾›è¯¦ç»†çš„å‚æ•°schema\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {},\n                \"required\": []\n            }\n        }\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 278,
"end": 312,
"text": "    def truncate_output(self, content: str) -> str:\n        \"\"\"\n        æ™ºèƒ½æˆªæ–­è¾“å‡ºå†…å®¹\n        \n        Args:\n            content: åŸå§‹å†…å®¹\n        \n        Returns:\n            æˆªæ–­åçš„å†…å®¹\n        \"\"\"\n        if self.TRUNCATION_STRATEGY == \"none\":\n            return content\n        \n        original_length = len(content)\n        \n        # å­—ç¬¦é™åˆ¶\n        if len(content) > self.MAX_OUTPUT_CHARS:\n            content = self._truncate_by_chars(content, self.MAX_OUTPUT_CHARS)\n        \n        # è¡Œæ•°é™åˆ¶\n        lines = content.splitlines()\n        if len(lines) > self.MAX_OUTPUT_LINES:\n            content = self._truncate_by_lines(lines, self.MAX_OUTPUT_LINES)\n        \n        # è®°å½•æˆªæ–­æƒ…å†µ\n        if len(content) < original_length:\n            reduction_pct = (1 - len(content) / original_length) * 100\n            self.logger.info(\n                f\"å·¥å…· {self.name} è¾“å‡ºè¢«æˆªæ–­: \"\n                f\"{original_length} -> {len(content)} å­—ç¬¦ \"\n                f\"({reduction_pct:.1f}% å‡å°‘)\"\n            )\n        \n        return content\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 313,
"end": 344,
"text": "    def _truncate_by_chars(self, content: str, max_chars: int) -> str:\n        \"\"\"\n        æŒ‰å­—ç¬¦æ•°æˆªæ–­\n        \n        ç­–ç•¥ï¼šä¿ç•™å‰40% + å40%ï¼Œä¸­é—´ç”¨æ‘˜è¦æ›¿ä»£\n        \"\"\"\n        if len(content) <= max_chars:\n            return content\n        \n        if self.TRUNCATION_STRATEGY == \"head_only\":\n            # åªä¿ç•™å¼€å¤´\n            return content[:max_chars] + \"\\n\\n... [å†…å®¹è¢«æˆªæ–­] ...\"\n        \n        # head_tailç­–ç•¥\n        keep_chars = max_chars - 200  # ç•™200å­—ç¬¦ç»™æ‘˜è¦ä¿¡æ¯\n        head_chars = int(keep_chars * 0.4)\n        tail_chars = int(keep_chars * 0.4)\n        \n        head = content[:head_chars]\n        tail = content[-tail_chars:]\n        \n        # ç»Ÿè®¡è¢«æˆªæ–­çš„éƒ¨åˆ†\n        truncated_chars = len(content) - head_chars - tail_chars\n        truncated_lines = content[head_chars:-tail_chars].count('\\n')\n        \n        summary = (\n            f\"\\n\\n... [æˆªæ–­äº† {truncated_chars:,} å­—ç¬¦ / \"\n            f\"{truncated_lines:,} è¡Œ] ...\\n\\n\"\n        )\n        \n        return head + summary + tail\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 345,
"end": 371,
"text": "    def _truncate_by_lines(self, lines: List[str], max_lines: int) -> str:\n        \"\"\"\n        æŒ‰è¡Œæ•°æˆªæ–­\n        \n        ç­–ç•¥ï¼šä¿ç•™å‰50% + å50%\n        \"\"\"\n        if len(lines) <= max_lines:\n            return '\\n'.join(lines)\n        \n        if self.TRUNCATION_STRATEGY == \"head_only\":\n            # åªä¿ç•™å¼€å¤´\n            result = lines[:max_lines]\n            result.append(f\"\\n... [æˆªæ–­äº† {len(lines) - max_lines:,} è¡Œ] ...\")\n            return '\\n'.join(result)\n        \n        # head_tailç­–ç•¥\n        keep_lines = max_lines - 2  # ç•™2è¡Œç»™æ‘˜è¦\n        head_lines = keep_lines // 2\n        tail_lines = keep_lines - head_lines\n        \n        result = lines[:head_lines]\n        result.append(f\"\\n... [æˆªæ–­äº† {len(lines) - keep_lines:,} è¡Œ] ...\\n\")\n        result.extend(lines[-tail_lines:])\n        \n        return '\\n'.join(result)\n\n"
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 372,
"end": 374,
"text": "class ToolRegistry:\n    \"\"\"å·¥å…·æ³¨å†Œè¡¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 375,
"end": 379,
"text": "    def __init__(self):\n        self._tools: Dict[str, BaseTool] = {}\n        self._working_directory = None  # å‘åå…¼å®¹\n        self._context: Optional[ToolContext] = None  # æ–°çš„ä¸Šä¸‹æ–‡å¯¹è±¡\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 380,
"end": 388,
"text": "    def set_context(self, context: ToolContext):\n        \"\"\"è®¾ç½®å·¥å…·ä¸Šä¸‹æ–‡ï¼ˆæ–°æ–¹æ³•ï¼‰\"\"\"\n        self._context = context\n        self._working_directory = str(context.repo_path)  # å‘åå…¼å®¹\n        logger.info(f\"å·¥å…·æ³¨å†Œè¡¨ä¸Šä¸‹æ–‡è®¾ç½®ä¸º: repo_path={context.repo_path}\")\n        # ä¼ é€’ç»™æ‰€æœ‰å·²æ³¨å†Œçš„å·¥å…·\n        for tool in self._tools.values():\n            tool.set_context(context)\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 389,
"end": 400,
"text": "    def set_working_directory(self, working_dir: str):\n        \"\"\"è®¾ç½®å·¥ä½œç›®å½•ï¼ˆå‘åå…¼å®¹ï¼‰\"\"\"\n        self._working_directory = working_dir\n        # åˆ›å»ºæˆ–æ›´æ–° context\n        if not self._context:\n            self._context = ToolContext(repo_path=Path(working_dir))\n        logger.info(f\"å·¥å…·æ³¨å†Œè¡¨å·¥ä½œç›®å½•è®¾ç½®ä¸º: {working_dir}\")\n        # ä¼ é€’ç»™æ‰€æœ‰å·²æ³¨å†Œçš„å·¥å…·\n        for tool in self._tools.values():\n            tool.set_working_directory(working_dir)\n    \n    @property"
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 401,
"end": 407,
"text": "    def context(self) -> ToolContext:\n        \"\"\"è·å–å·¥å…·ä¸Šä¸‹æ–‡\"\"\"\n        if not self._context:\n            # å¦‚æœæ²¡æœ‰è®¾ç½®ï¼Œä½¿ç”¨å½“å‰ç›®å½•\n            self._context = ToolContext(repo_path=Path.cwd())\n        return self._context\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 408,
"end": 417,
"text": "    def register(self, tool: BaseTool):\n        \"\"\"æ³¨å†Œå·¥å…·\"\"\"\n        self._tools[tool.name] = tool\n        # å¦‚æœå·²ç»è®¾ç½®äº†ä¸Šä¸‹æ–‡ï¼Œä¼ é€’ç»™æ–°å·¥å…·\n        if self._context:\n            tool.set_context(self._context)\n        elif self._working_directory:\n            tool.set_working_directory(self._working_directory)\n        logger.info(f\"å·²æ³¨å†Œå·¥å…·: {tool.name}\")\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 418,
"end": 421,
"text": "    def get_tool(self, name: str) -> Optional[BaseTool]:\n        \"\"\"è·å–å·¥å…·\"\"\"\n        return self._tools.get(name)\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 422,
"end": 439,
"text": "    def filter_tool_names(self, tool_names: Optional[List[str]]) -> Optional[List[str]]:\n        \"\"\"\n        åªä¿ç•™å·²æ³¨å†Œçš„å·¥å…·åï¼Œé¿å… Skill é…ç½®äº†ä¸å­˜åœ¨çš„å·¥å…·å¯¼è‡´è¿è¡Œæ—¶æŠ¥é”™ã€‚\n        è‹¥è¿‡æ»¤åä¸ºç©ºï¼Œè¿”å› Noneï¼ˆè¡¨ç¤ºä¸é™åˆ¶å·¥å…·ï¼‰ã€‚\n        \"\"\"\n        if not tool_names:\n            return None\n        available = set(self._tools.keys())\n        filtered = [n for n in tool_names if n in available]\n        missing = set(tool_names) - available\n        if missing:\n            logger.warning(\n                \"Skill å¼•ç”¨äº†ä¸å­˜åœ¨çš„å·¥å…·ï¼Œå·²å¿½ç•¥: %sï¼ˆå¯ç”¨: %sï¼‰\",\n                sorted(missing),\n                \", \".join(sorted(available)[:20]) + (\"...\" if len(available) > 20 else \"\"),\n            )\n        return filtered if filtered else None\n"
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 440,
"end": 443,
"text": "    def list_tools(self) -> List[str]:\n        \"\"\"åˆ—å‡ºæ‰€æœ‰å·¥å…·åç§°\"\"\"\n        return list(self._tools.keys())\n    "
},
{
"path": "daoyoucode/agents/tools/base.py",
"start": 444,
"end": 497,
"text": "    def get_function_schemas(self, tool_names: Optional[List[str]] = None) -> List[Dict[str, Any]]:\n        \"\"\"\n        è·å–å·¥å…·çš„Function Calling schemas\n        \n        Args:\n            tool_names: å·¥å…·åç§°åˆ—è¡¨ï¼Œå¦‚æœä¸ºNoneåˆ™è¿”å›æ‰€æœ‰å·¥å…·\n        \n        Returns:\n            Function schemasåˆ—è¡¨\n        \"\"\"\n        if tool_names is None:\n            tool_names = self.list_tools()\n        \n        schemas = []\n        for name in tool_names:\n            tool = self.get_tool(name)\n            if tool:\n                schemas.append(tool.get_function_schema())\n        \n        return schemas\n    \n    async def execute_tool(self, name: str, **kwargs) -> ToolResult:\n        \"\"\"æ‰§è¡Œå·¥å…·\"\"\"\n        tool = self.get_tool(name)\n        if not tool:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=f\"Tool not found: {name}\"\n            )\n        \n        try:\n            result = await tool.execute(**kwargs)\n            \n            # è‡ªåŠ¨æˆªæ–­è¾“å‡ºï¼ˆå¦‚æœå†…å®¹æ˜¯å­—ç¬¦ä¸²ï¼‰\n            if result.success and isinstance(result.content, str):\n                original_content = result.content\n                truncated_content = tool.truncate_output(original_content)\n                \n                # å¦‚æœå‘ç”Ÿäº†æˆªæ–­ï¼Œæ›´æ–°ç»“æœ\n                if len(truncated_content) < len(original_content):\n                    result.content = truncated_content\n                    result.metadata['truncated'] = True\n                    result.metadata['original_length'] = len(original_content)\n                    result.metadata['truncated_length'] = len(truncated_content)\n            \n            return result\n        except Exception as e:\n            logger.error(f\"å·¥å…· {name} æ‰§è¡Œå¤±è´¥: {e}\", exc_info=True)\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )"
},
{
"path": "daoyoucode/agents/tools/codebase_search_tool.py",
"start": 1,
"end": 12,
"text": "\"\"\"\nè¯­ä¹‰ä»£ç æ£€ç´¢å·¥å…·ï¼ˆCursor åŒçº§æŒ‰é—®æ£€ç´¢ï¼‰\n\næ ¹æ®è‡ªç„¶è¯­è¨€ query æ£€ç´¢æœ€ç›¸å…³çš„ä»£ç å—ï¼Œä½¿ç”¨ä»£ç åº“å‘é‡ç´¢å¼•æˆ–å…³é”®è¯å›é€€ã€‚\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional\n\nfrom .base import BaseTool, ToolResult\n\n"
},
{
"path": "daoyoucode/agents/tools/codebase_search_tool.py",
"start": 13,
"end": 17,
"text": "class SemanticCodeSearchTool(BaseTool):\n    \"\"\"æŒ‰é—®é¢˜è¯­ä¹‰æ£€ç´¢ç›¸å…³ä»£ç å—ï¼ˆç±»ä¼¼ Cursor @codebaseï¼‰\"\"\"\n\n    MAX_OUTPUT_CHARS = 8000\n"
},
{
"path": "daoyoucode/agents/tools/codebase_search_tool.py",
"start": 18,
"end": 23,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"semantic_code_search\",\n            description=\"æ ¹æ®è‡ªç„¶è¯­è¨€æè¿°æ£€ç´¢æœ€ç›¸å…³çš„ä»£ç ç‰‡æ®µï¼ˆè¯­ä¹‰/å…³é”®è¯ï¼‰ã€‚é€‚åˆã€Œå’Œå½“å‰é—®é¢˜æœ€ç›¸å…³çš„ä»£ç åœ¨å“ªã€ç±»é—®é¢˜ã€‚\"\n        )\n"
},
{
"path": "daoyoucode/agents/tools/codebase_search_tool.py",
"start": 24,
"end": 88,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"query\": {\n                        \"type\": \"string\",\n                        \"description\": \"ç”¨è‡ªç„¶è¯­è¨€æè¿°è¦æ‰¾çš„ä»£ç ï¼ˆå¦‚ï¼šè¶…æ—¶é‡è¯•é€»è¾‘ã€LLM è°ƒç”¨çš„å…¥å£ã€repo_map çš„ PageRankï¼‰\"\n                    },\n                    \"top_k\": {\n                        \"type\": \"integer\",\n                        \"description\": \"è¿”å›æœ€å¤šå‡ æ¡ç»“æœï¼ˆé»˜è®¤ 8ï¼‰\",\n                        \"default\": 8\n                    },\n                    \"repo_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"ä»“åº“è·¯å¾„ï¼Œä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰é¡¹ç›®æ ¹\",\n                        \"default\": \".\"\n                    }\n                },\n                \"required\": [\"query\"]\n            }\n        }\n\n    async def execute(\n        self,\n        query: str,\n        top_k: int = 8,\n        repo_path: str = \".\"\n    ) -> ToolResult:\n        try:\n            path = self.resolve_path(repo_path)\n            if not path.exists() or not path.is_dir():\n                return ToolResult(success=False, content=None, error=f\"ç›®å½•ä¸å­˜åœ¨: {repo_path}\")\n\n            from ..memory.codebase_index import search_codebase\n            results = search_codebase(path, query, top_k=top_k)\n\n            if not results:\n                return ToolResult(\n                    success=True,\n                    content=\"æœªæ‰¾åˆ°ç›¸å…³ä»£ç å—ã€‚å¯å°è¯•æ›´å…·ä½“çš„å…³é”®è¯æˆ–å…ˆè¿è¡Œ repo_map äº†è§£é¡¹ç›®ã€‚\",\n                    metadata={\"count\": 0}\n                )\n\n            lines = []\n            for i, r in enumerate(results, 1):\n                path_rel = r.get(\"path\", \"\")\n                start = r.get(\"start\", 0)\n                end = r.get(\"end\", 0)\n                text = (r.get(\"text\") or \"\")[:1200]\n                score = r.get(\"score\", 0)\n                lines.append(f\"[{i}] {path_rel} (L{start}-{end}) score={score:.3f}\\n```\\n{text}\\n```\")\n            content = \"\\n\\n\".join(lines)\n            if len(content) > self.MAX_OUTPUT_CHARS:\n                content = content[: self.MAX_OUTPUT_CHARS] + \"\\nâ€¦(å·²æˆªæ–­)\"\n            return ToolResult(\n                success=True,\n                content=content,\n                metadata={\"count\": len(results)}\n            )\n        except Exception as e:\n            return ToolResult(success=False, content=None, error=str(e))"
},
{
"path": "daoyoucode/agents/tools/command_tools.py",
"start": 1,
"end": 12,
"text": "\"\"\"\nå‘½ä»¤æ‰§è¡Œå·¥å…·\n\næä¾›shellå‘½ä»¤æ‰§è¡ŒåŠŸèƒ½\n\"\"\"\n\nfrom typing import Dict, Any, Optional\nimport subprocess\nimport asyncio\nfrom .base import BaseTool, ToolResult\n\n"
},
{
"path": "daoyoucode/agents/tools/command_tools.py",
"start": 13,
"end": 15,
"text": "class RunCommandTool(BaseTool):\n    \"\"\"è¿è¡Œå‘½ä»¤å·¥å…·\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/command_tools.py",
"start": 16,
"end": 96,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"run_command\",\n            description=\"æ‰§è¡Œshellå‘½ä»¤\"\n        )\n    \n    async def execute(\n        self,\n        command: str,\n        cwd: Optional[str] = None,\n        timeout: int = 30,\n        shell: bool = True\n    ) -> ToolResult:\n        \"\"\"\n        æ‰§è¡Œå‘½ä»¤\n        \n        Args:\n            command: å‘½ä»¤å­—ç¬¦ä¸²\n            cwd: å·¥ä½œç›®å½•\n            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰\n            shell: æ˜¯å¦ä½¿ç”¨shell\n        \"\"\"\n        try:\n            # ä½¿ç”¨asyncio.create_subprocess_shellå®ç°å¼‚æ­¥æ‰§è¡Œ\n            if shell:\n                process = await asyncio.create_subprocess_shell(\n                    command,\n                    stdout=asyncio.subprocess.PIPE,\n                    stderr=asyncio.subprocess.PIPE,\n                    cwd=cwd\n                )\n            else:\n                process = await asyncio.create_subprocess_exec(\n                    *command.split(),\n                    stdout=asyncio.subprocess.PIPE,\n                    stderr=asyncio.subprocess.PIPE,\n                    cwd=cwd\n                )\n            \n            # ç­‰å¾…å®Œæˆï¼ˆå¸¦è¶…æ—¶ï¼‰\n            try:\n                stdout, stderr = await asyncio.wait_for(\n                    process.communicate(),\n                    timeout=timeout\n                )\n            except asyncio.TimeoutError:\n                process.kill()\n                await process.wait()\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"Command timed out after {timeout} seconds\"\n                )\n            \n            # è§£ç è¾“å‡º\n            stdout_str = stdout.decode('utf-8', errors='ignore')\n            stderr_str = stderr.decode('utf-8', errors='ignore')\n            \n            success = process.returncode == 0\n            \n            return ToolResult(\n                success=success,\n                content={\n                    'stdout': stdout_str,\n                    'stderr': stderr_str,\n                    'returncode': process.returncode\n                },\n                error=stderr_str if not success else None,\n                metadata={\n                    'command': command,\n                    'cwd': cwd,\n                    'returncode': process.returncode\n                }\n            )\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/command_tools.py",
"start": 97,
"end": 127,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"command\": {\n                        \"type\": \"string\",\n                        \"description\": \"è¦æ‰§è¡Œçš„å‘½ä»¤\"\n                    },\n                    \"cwd\": {\n                        \"type\": \"string\",\n                        \"description\": \"å·¥ä½œç›®å½•\"\n                    },\n                    \"timeout\": {\n                        \"type\": \"integer\",\n                        \"description\": \"è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰\",\n                        \"default\": 30\n                    },\n                    \"shell\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦ä½¿ç”¨shell\",\n                        \"default\": True\n                    }\n                },\n                \"required\": [\"command\"]\n            }\n        }\n\n"
},
{
"path": "daoyoucode/agents/tools/command_tools.py",
"start": 128,
"end": 130,
"text": "class RunTestTool(BaseTool):\n    \"\"\"è¿è¡Œæµ‹è¯•å·¥å…·\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/command_tools.py",
"start": 131,
"end": 230,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"run_test\",\n            description=\"è¿è¡Œæµ‹è¯•ï¼ˆæ”¯æŒpytestã€unittestç­‰ï¼‰\"\n        )\n    \n    async def execute(\n        self,\n        test_path: Optional[str] = None,\n        test_framework: str = \"pytest\",\n        cwd: Optional[str] = None,\n        timeout: int = 60\n    ) -> ToolResult:\n        \"\"\"\n        è¿è¡Œæµ‹è¯•\n        \n        Args:\n            test_path: æµ‹è¯•æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„\n            test_framework: æµ‹è¯•æ¡†æ¶ï¼ˆpytest/unittest/jestç­‰ï¼‰\n            cwd: å·¥ä½œç›®å½•\n            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰\n        \"\"\"\n        try:\n            # æ„å»ºå‘½ä»¤\n            if test_framework == \"pytest\":\n                command = \"pytest\"\n                if test_path:\n                    command += f\" {test_path}\"\n                command += \" -v\"\n            elif test_framework == \"unittest\":\n                command = \"python -m unittest\"\n                if test_path:\n                    command += f\" {test_path}\"\n            elif test_framework == \"jest\":\n                command = \"npm test\"\n                if test_path:\n                    command += f\" -- {test_path}\"\n            else:\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"Unsupported test framework: {test_framework}\"\n                )\n            \n            # æ‰§è¡Œå‘½ä»¤\n            process = await asyncio.create_subprocess_shell(\n                command,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n                cwd=cwd\n            )\n            \n            try:\n                stdout, stderr = await asyncio.wait_for(\n                    process.communicate(),\n                    timeout=timeout\n                )\n            except asyncio.TimeoutError:\n                process.kill()\n                await process.wait()\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"Test timed out after {timeout} seconds\"\n                )\n            \n            stdout_str = stdout.decode('utf-8', errors='ignore')\n            stderr_str = stderr.decode('utf-8', errors='ignore')\n            \n            success = process.returncode == 0\n            \n            # è§£ææµ‹è¯•ç»“æœ\n            result_info = self._parse_test_output(\n                stdout_str,\n                stderr_str,\n                test_framework\n            )\n            \n            return ToolResult(\n                success=success,\n                content={\n                    'stdout': stdout_str,\n                    'stderr': stderr_str,\n                    'returncode': process.returncode,\n                    **result_info\n                },\n                error=stderr_str if not success else None,\n                metadata={\n                    'test_path': test_path,\n                    'test_framework': test_framework,\n                    'cwd': cwd\n                }\n            )\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/command_tools.py",
"start": 231,
"end": 260,
"text": "    def _parse_test_output(\n        self,\n        stdout: str,\n        stderr: str,\n        framework: str\n    ) -> Dict[str, Any]:\n        \"\"\"è§£ææµ‹è¯•è¾“å‡º\"\"\"\n        result = {\n            'passed': 0,\n            'failed': 0,\n            'skipped': 0,\n            'total': 0\n        }\n        \n        if framework == \"pytest\":\n            # è§£æpytestè¾“å‡º\n            import re\n            match = re.search(r'(\\d+) passed', stdout)\n            if match:\n                result['passed'] = int(match.group(1))\n            match = re.search(r'(\\d+) failed', stdout)\n            if match:\n                result['failed'] = int(match.group(1))\n            match = re.search(r'(\\d+) skipped', stdout)\n            if match:\n                result['skipped'] = int(match.group(1))\n            result['total'] = result['passed'] + result['failed'] + result['skipped']\n        \n        return result\n    "
},
{
"path": "daoyoucode/agents/tools/command_tools.py",
"start": 261,
"end": 291,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"test_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"æµ‹è¯•æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„\"\n                    },\n                    \"test_framework\": {\n                        \"type\": \"string\",\n                        \"description\": \"æµ‹è¯•æ¡†æ¶ï¼ˆpytest/unittest/jestï¼‰\",\n                        \"default\": \"pytest\"\n                    },\n                    \"cwd\": {\n                        \"type\": \"string\",\n                        \"description\": \"å·¥ä½œç›®å½•\"\n                    },\n                    \"timeout\": {\n                        \"type\": \"integer\",\n                        \"description\": \"è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰\",\n                        \"default\": 60\n                    }\n                },\n                \"required\": []\n            }\n        }\n\n"
},
{
"path": "daoyoucode/agents/tools/command_tools.py",
"start": 292,
"end": 299,
"text": "class RunLintTool(BaseTool):\n    \"\"\"\n    è¿è¡Œ Lintï¼ˆç¼–è¾‘åéªŒè¯ï¼Œä¸ run_test é…åˆä½¿ç”¨ï¼‰\n    \n    æ‰§è¡Œé¡¹ç›®é…ç½®çš„ lint å‘½ä»¤å¹¶è¿”å›ç»“æœï¼Œä¾¿äº Agent åœ¨ write_file/search_replace/apply_patch åè‡ªæ£€ã€‚\n    å»ºè®®æµç¨‹ï¼šç¼–è¾‘ â†’ run_lint / run_test â†’ æ ¹æ®è¾“å‡ºä¿®å¤ã€‚\n    \"\"\"\n"
},
{
"path": "daoyoucode/agents/tools/command_tools.py",
"start": 300,
"end": 360,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"run_lint\",\n            description=\"è¿è¡Œ lint æ£€æŸ¥ï¼ˆå¦‚ ruff checkã€eslintï¼‰ã€‚ç¼–è¾‘åå»ºè®®è°ƒç”¨ä»¥éªŒè¯ä»£ç ã€‚\"\n        )\n\n    async def execute(\n        self,\n        command: Optional[str] = None,\n        cwd: Optional[str] = None,\n        timeout: int = 45\n    ) -> ToolResult:\n        \"\"\"\n        Args:\n            command: è¦æ‰§è¡Œçš„ lint å‘½ä»¤ã€‚ä¸ä¼ æ—¶å°è¯•å¸¸è§å‘½ä»¤ï¼šruff check .ï¼ˆPythonï¼‰æˆ– eslint .ï¼ˆJSï¼‰\n            cwd: å·¥ä½œç›®å½•ï¼Œé»˜è®¤ä»“åº“æ ¹\n            timeout: è¶…æ—¶ç§’æ•°\n        \"\"\"\n        try:\n            work_dir = self.context.repo_path\n            if cwd:\n                from pathlib import Path\n                work_dir = self.resolve_path(cwd)\n            cmd = command\n            if not cmd:\n                # é»˜è®¤å°è¯•ï¼šä¼˜å…ˆ ruffï¼ˆPythonï¼‰ï¼Œå…¶æ¬¡ eslint\n                py_check = work_dir / \"pyproject.toml\"\n                if (work_dir / \"package.json\").exists():\n                    cmd = \"npx eslint . --max-warnings 0 2>/dev/null || true\"\n                elif py_check.exists() or list(work_dir.glob(\"*.py\")):\n                    cmd = \"ruff check . 2>/dev/null || true\"\n                else:\n                    cmd = \"echo 'No default lint for this project'\"\n            process = await asyncio.create_subprocess_shell(\n                cmd,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n                cwd=str(work_dir)\n            )\n            try:\n                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\n            except asyncio.TimeoutError:\n                process.kill()\n                await process.wait()\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"Lint è¶…æ—¶ï¼ˆ{timeout}ç§’ï¼‰\"\n                )\n            out = stdout.decode(\"utf-8\", errors=\"ignore\")\n            err = stderr.decode(\"utf-8\", errors=\"ignore\")\n            combined = (out + \"\\n\" + err).strip()\n            return ToolResult(\n                success=process.returncode == 0,\n                content=combined or \"Lint é€šè¿‡ï¼Œæ— è¾“å‡º\",\n                error=None if process.returncode == 0 else combined,\n                metadata={\"command\": cmd, \"returncode\": process.returncode}\n            )\n        except Exception as e:\n            return ToolResult(success=False, content=None, error=str(e))\n"
},
{
"path": "daoyoucode/agents/tools/command_tools.py",
"start": 361,
"end": 384,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"command\": {\n                        \"type\": \"string\",\n                        \"description\": \"lint å‘½ä»¤ï¼Œå¦‚ 'ruff check .' æˆ– 'npx eslint .'ã€‚ä¸ä¼ åˆ™è‡ªåŠ¨å°è¯•å¸¸è§å‘½ä»¤\"\n                    },\n                    \"cwd\": {\n                        \"type\": \"string\",\n                        \"description\": \"å·¥ä½œç›®å½•ï¼Œé»˜è®¤ä»“åº“æ ¹\"\n                    },\n                    \"timeout\": {\n                        \"type\": \"integer\",\n                        \"description\": \"è¶…æ—¶ç§’æ•°\",\n                        \"default\": 45\n                    }\n                },\n                \"required\": []\n            }\n        }"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 1,
"end": 18,
"text": "\"\"\"\nDiffå·¥å…· - åŸºäºopencodeçš„9ç§Replacerç­–ç•¥\n\né‡‡ç”¨opencodeæœ€å…ˆè¿›çš„Diffç³»ç»Ÿå®ç°ï¼Œæ”¯æŒï¼š\n- 9ç§æ™ºèƒ½æ›¿æ¢ç­–ç•¥\n- Levenshteinè·ç¦»ç®—æ³•\n- BlockAnchorReplacerï¼ˆé¦–å°¾è¡Œé”šå®šï¼‰\n- æ¨¡ç³ŠåŒ¹é…å’Œå®¹é”™\n\"\"\"\n\nfrom typing import Dict, Any, Generator, Optional, List, Tuple\nfrom pathlib import Path\nimport re\nfrom .base import BaseTool, ToolResult\n\n\n# ========== Levenshteinè·ç¦»ç®—æ³• ==========\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 19,
"end": 51,
"text": "def levenshtein(a: str, b: str) -> int:\n    \"\"\"\n    è®¡ç®—ä¸¤ä¸ªå­—ç¬¦ä¸²çš„Levenshteinç¼–è¾‘è·ç¦»\n    \n    ç”¨äºè¡¡é‡å­—ç¬¦ä¸²ç›¸ä¼¼åº¦ï¼Œè·ç¦»è¶Šå°è¶Šç›¸ä¼¼\n    \"\"\"\n    if a == \"\" or b == \"\":\n        return max(len(a), len(b))\n    \n    # åˆ›å»ºè·ç¦»çŸ©é˜µ\n    matrix = [[0] * (len(b) + 1) for _ in range(len(a) + 1)]\n    \n    # åˆå§‹åŒ–ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—\n    for i in range(len(a) + 1):\n        matrix[i][0] = i\n    for j in range(len(b) + 1):\n        matrix[0][j] = j\n    \n    # åŠ¨æ€è§„åˆ’è®¡ç®—è·ç¦»\n    for i in range(1, len(a) + 1):\n        for j in range(1, len(b) + 1):\n            cost = 0 if a[i - 1] == b[j - 1] else 1\n            matrix[i][j] = min(\n                matrix[i - 1][j] + 1,      # åˆ é™¤\n                matrix[i][j - 1] + 1,      # æ’å…¥\n                matrix[i - 1][j - 1] + cost  # æ›¿æ¢\n            )\n    \n    return matrix[len(a)][len(b)]\n\n\n# ========== 9ç§Replacerç­–ç•¥ ==========\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 52,
"end": 55,
"text": "class Replacer:\n    \"\"\"ReplaceråŸºç±»\"\"\"\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 56,
"end": 60,
"text": "    def find_matches(content: str, find: str) -> Generator[str, None, None]:\n        \"\"\"æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…é¡¹\"\"\"\n        raise NotImplementedError()\n\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 61,
"end": 64,
"text": "class SimpleReplacer(Replacer):\n    \"\"\"ç­–ç•¥1: ç²¾ç¡®åŒ¹é…\"\"\"\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 65,
"end": 69,
"text": "    def find_matches(content: str, find: str) -> Generator[str, None, None]:\n        if find in content:\n            yield find\n\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 70,
"end": 73,
"text": "class LineTrimmedReplacer(Replacer):\n    \"\"\"ç­–ç•¥2: å¿½ç•¥è¡Œé¦–å°¾ç©ºç™½\"\"\"\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 74,
"end": 100,
"text": "    def find_matches(content: str, find: str) -> Generator[str, None, None]:\n        original_lines = content.split(\"\\n\")\n        search_lines = find.split(\"\\n\")\n        \n        # ç§»é™¤æœ«å°¾ç©ºè¡Œ\n        if search_lines and search_lines[-1] == \"\":\n            search_lines.pop()\n        \n        # æ»‘åŠ¨çª—å£åŒ¹é…\n        for i in range(len(original_lines) - len(search_lines) + 1):\n            matches = True\n            \n            for j in range(len(search_lines)):\n                if original_lines[i + j].strip() != search_lines[j].strip():\n                    matches = False\n                    break\n            \n            if matches:\n                # è®¡ç®—åŒ¹é…çš„èµ·æ­¢ä½ç½®\n                match_start = sum(len(original_lines[k]) + 1 for k in range(i))\n                match_end = match_start + sum(\n                    len(original_lines[i + k]) + (1 if k < len(search_lines) - 1 else 0)\n                    for k in range(len(search_lines))\n                )\n                yield content[match_start:match_end]\n\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 101,
"end": 114,
"text": "class BlockAnchorReplacer(Replacer):\n    \"\"\"\n    ç­–ç•¥3: é¦–å°¾è¡Œé”šå®š + Levenshteinç›¸ä¼¼åº¦\n    \n    è¿™æ˜¯opencodeæœ€å¼ºå¤§çš„ç­–ç•¥ï¼š\n    - ä½¿ç”¨é¦–å°¾è¡Œä½œä¸ºé”šç‚¹\n    - è®¡ç®—ä¸­é—´è¡Œçš„Levenshteinç›¸ä¼¼åº¦\n    - å•å€™é€‰é˜ˆå€¼0.0ï¼Œå¤šå€™é€‰é˜ˆå€¼0.3\n    \"\"\"\n    \n    SINGLE_CANDIDATE_THRESHOLD = 0.0\n    MULTIPLE_CANDIDATES_THRESHOLD = 0.3\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 115,
"end": 217,
"text": "    def find_matches(content: str, find: str) -> Generator[str, None, None]:\n        original_lines = content.split(\"\\n\")\n        search_lines = find.split(\"\\n\")\n        \n        if len(search_lines) < 3:\n            return\n        \n        if search_lines and search_lines[-1] == \"\":\n            search_lines.pop()\n        \n        first_line = search_lines[0].strip()\n        last_line = search_lines[-1].strip()\n        search_block_size = len(search_lines)\n        \n        # æ”¶é›†æ‰€æœ‰å€™é€‰ä½ç½®\n        candidates: List[Tuple[int, int]] = []\n        for i in range(len(original_lines)):\n            if original_lines[i].strip() != first_line:\n                continue\n            \n            # æŸ¥æ‰¾åŒ¹é…çš„æœ«å°¾è¡Œ\n            for j in range(i + 2, len(original_lines)):\n                if original_lines[j].strip() == last_line:\n                    candidates.append((i, j))\n                    break\n        \n        if not candidates:\n            return\n        \n        # å•å€™é€‰æƒ…å†µï¼ˆä½¿ç”¨å®½æ¾é˜ˆå€¼ï¼‰\n        if len(candidates) == 1:\n            start_line, end_line = candidates[0]\n            actual_block_size = end_line - start_line + 1\n            \n            similarity = 0.0\n            lines_to_check = min(search_block_size - 2, actual_block_size - 2)\n            \n            if lines_to_check > 0:\n                for j in range(1, min(search_block_size - 1, actual_block_size - 1)):\n                    original_line = original_lines[start_line + j].strip()\n                    search_line = search_lines[j].strip()\n                    max_len = max(len(original_line), len(search_line))\n                    \n                    if max_len == 0:\n                        continue\n                    \n                    distance = levenshtein(original_line, search_line)\n                    similarity += (1 - distance / max_len) / lines_to_check\n                    \n                    if similarity >= BlockAnchorReplacer.SINGLE_CANDIDATE_THRESHOLD:\n                        break\n            else:\n                similarity = 1.0\n            \n            if similarity >= BlockAnchorReplacer.SINGLE_CANDIDATE_THRESHOLD:\n                match_start = sum(len(original_lines[k]) + 1 for k in range(start_line))\n                match_end = match_start + sum(\n                    len(original_lines[k]) + (1 if k < end_line else 0)\n                    for k in range(start_line, end_line + 1)\n                )\n                yield content[match_start:match_end]\n            return\n        \n        # å¤šå€™é€‰æƒ…å†µï¼ˆè®¡ç®—æœ€ä½³åŒ¹é…ï¼‰\n        best_match: Optional[Tuple[int, int]] = None\n        max_similarity = -1.0\n        \n        for start_line, end_line in candidates:\n            actual_block_size = end_line - start_line + 1\n            \n            similarity = 0.0\n            lines_to_check = min(search_block_size - 2, actual_block_size - 2)\n            \n            if lines_to_check > 0:\n                for j in range(1, min(search_block_size - 1, actual_block_size - 1)):\n                    original_line = original_lines[start_line + j].strip()\n                    search_line = search_lines[j].strip()\n                    max_len = max(len(original_line), len(search_line))\n                    \n                    if max_len == 0:\n                        continue\n                    \n                    distance = levenshtein(original_line, search_line)\n                    similarity += 1 - distance / max_len\n                \n                similarity /= lines_to_check\n            else:\n                similarity = 1.0\n            \n            if similarity > max_similarity:\n                max_similarity = similarity\n                best_match = (start_line, end_line)\n        \n        if max_similarity >= BlockAnchorReplacer.MULTIPLE_CANDIDATES_THRESHOLD and best_match:\n            start_line, end_line = best_match\n            match_start = sum(len(original_lines[k]) + 1 for k in range(start_line))\n            match_end = match_start + sum(\n                len(original_lines[k]) + (1 if k < end_li"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 218,
"end": 221,
"text": "class WhitespaceNormalizedReplacer(Replacer):\n    \"\"\"ç­–ç•¥4: ç©ºç™½å½’ä¸€åŒ–\"\"\"\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 222,
"end": 225,
"text": "    def normalize_whitespace(text: str) -> str:\n        return re.sub(r'\\s+', ' ', text).strip()\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 226,
"end": 243,
"text": "    def find_matches(content: str, find: str) -> Generator[str, None, None]:\n        normalized_find = WhitespaceNormalizedReplacer.normalize_whitespace(find)\n        \n        # å•è¡ŒåŒ¹é…\n        lines = content.split(\"\\n\")\n        for line in lines:\n            if WhitespaceNormalizedReplacer.normalize_whitespace(line) == normalized_find:\n                yield line\n        \n        # å¤šè¡ŒåŒ¹é…\n        find_lines = find.split(\"\\n\")\n        if len(find_lines) > 1:\n            for i in range(len(lines) - len(find_lines) + 1):\n                block = \"\\n\".join(lines[i:i + len(find_lines)])\n                if WhitespaceNormalizedReplacer.normalize_whitespace(block) == normalized_find:\n                    yield block\n\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 244,
"end": 247,
"text": "class IndentationFlexibleReplacer(Replacer):\n    \"\"\"ç­–ç•¥5: ç¼©è¿›çµæ´»åŒ¹é…\"\"\"\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 248,
"end": 265,
"text": "    def remove_indentation(text: str) -> str:\n        lines = text.split(\"\\n\")\n        non_empty_lines = [line for line in lines if line.strip()]\n        \n        if not non_empty_lines:\n            return text\n        \n        min_indent = min(\n            len(line) - len(line.lstrip())\n            for line in non_empty_lines\n        )\n        \n        return \"\\n\".join(\n            line[min_indent:] if line.strip() else line\n            for line in lines\n        )\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 266,
"end": 276,
"text": "    def find_matches(content: str, find: str) -> Generator[str, None, None]:\n        normalized_find = IndentationFlexibleReplacer.remove_indentation(find)\n        content_lines = content.split(\"\\n\")\n        find_lines = find.split(\"\\n\")\n        \n        for i in range(len(content_lines) - len(find_lines) + 1):\n            block = \"\\n\".join(content_lines[i:i + len(find_lines)])\n            if IndentationFlexibleReplacer.remove_indentation(block) == normalized_find:\n                yield block\n\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 277,
"end": 280,
"text": "class EscapeNormalizedReplacer(Replacer):\n    \"\"\"ç­–ç•¥6: è½¬ä¹‰å­—ç¬¦å¤„ç†\"\"\"\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 281,
"end": 297,
"text": "    def unescape_string(s: str) -> str:\n        replacements = {\n            r'\\n': '\\n',\n            r'\\t': '\\t',\n            r'\\r': '\\r',\n            r\"\\'\": \"'\",\n            r'\\\"': '\"',\n            r'\\`': '`',\n            r'\\\\': '\\\\',\n            r'\\$': '$',\n        }\n        result = s\n        for escaped, unescaped in replacements.items():\n            result = result.replace(escaped, unescaped)\n        return result\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 298,
"end": 313,
"text": "    def find_matches(content: str, find: str) -> Generator[str, None, None]:\n        unescaped_find = EscapeNormalizedReplacer.unescape_string(find)\n        \n        if unescaped_find in content:\n            yield unescaped_find\n        \n        # å°è¯•æŸ¥æ‰¾è½¬ä¹‰ç‰ˆæœ¬\n        lines = content.split(\"\\n\")\n        find_lines = unescaped_find.split(\"\\n\")\n        \n        for i in range(len(lines) - len(find_lines) + 1):\n            block = \"\\n\".join(lines[i:i + len(find_lines)])\n            if EscapeNormalizedReplacer.unescape_string(block) == unescaped_find:\n                yield block\n\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 314,
"end": 317,
"text": "class TrimmedBoundaryReplacer(Replacer):\n    \"\"\"ç­–ç•¥7: è¾¹ç•Œtrim\"\"\"\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 318,
"end": 335,
"text": "    def find_matches(content: str, find: str) -> Generator[str, None, None]:\n        trimmed_find = find.strip()\n        \n        if trimmed_find == find:\n            return\n        \n        if trimmed_find in content:\n            yield trimmed_find\n        \n        lines = content.split(\"\\n\")\n        find_lines = find.split(\"\\n\")\n        \n        for i in range(len(lines) - len(find_lines) + 1):\n            block = \"\\n\".join(lines[i:i + len(find_lines)])\n            if block.strip() == trimmed_find:\n                yield block\n\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 336,
"end": 339,
"text": "class ContextAwareReplacer(Replacer):\n    \"\"\"ç­–ç•¥8: ä¸Šä¸‹æ–‡æ„ŸçŸ¥\"\"\"\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 340,
"end": 379,
"text": "    def find_matches(content: str, find: str) -> Generator[str, None, None]:\n        find_lines = find.split(\"\\n\")\n        if len(find_lines) < 3:\n            return\n        \n        if find_lines and find_lines[-1] == \"\":\n            find_lines.pop()\n        \n        content_lines = content.split(\"\\n\")\n        first_line = find_lines[0].strip()\n        last_line = find_lines[-1].strip()\n        \n        for i in range(len(content_lines)):\n            if content_lines[i].strip() != first_line:\n                continue\n            \n            for j in range(i + 2, len(content_lines)):\n                if content_lines[j].strip() == last_line:\n                    block_lines = content_lines[i:j + 1]\n                    \n                    if len(block_lines) == len(find_lines):\n                        # æ£€æŸ¥ä¸­é—´è¡Œç›¸ä¼¼åº¦ï¼ˆè‡³å°‘50%åŒ¹é…ï¼‰\n                        matching_lines = 0\n                        total_non_empty = 0\n                        \n                        for k in range(1, len(block_lines) - 1):\n                            block_line = block_lines[k].strip()\n                            find_line = find_lines[k].strip()\n                            \n                            if block_line or find_line:\n                                total_non_empty += 1\n                                if block_line == find_line:\n                                    matching_lines += 1\n                        \n                        if total_non_empty == 0 or matching_lines / total_non_empty >= 0.5:\n                            yield \"\\n\".join(block_lines)\n                            break\n                    break\n\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 380,
"end": 383,
"text": "class MultiOccurrenceReplacer(Replacer):\n    \"\"\"ç­–ç•¥9: å¤šæ¬¡å‡ºç°å¤„ç†\"\"\"\n    \n    @staticmethod"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 384,
"end": 395,
"text": "    def find_matches(content: str, find: str) -> Generator[str, None, None]:\n        start_index = 0\n        while True:\n            index = content.find(find, start_index)\n            if index == -1:\n                break\n            yield find\n            start_index = index + len(find)\n\n\n# ========== æ ¸å¿ƒæ›¿æ¢å‡½æ•° ==========\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 396,
"end": 459,
"text": "def replace(content: str, old_string: str, new_string: str, replace_all: bool = False) -> str:\n    \"\"\"\n    ä½¿ç”¨9ç§ç­–ç•¥è¿›è¡Œæ™ºèƒ½æ›¿æ¢\n    \n    Args:\n        content: åŸå§‹å†…å®¹\n        old_string: è¦æ›¿æ¢çš„å­—ç¬¦ä¸²\n        new_string: æ›¿æ¢åçš„å­—ç¬¦ä¸²\n        replace_all: æ˜¯å¦æ›¿æ¢æ‰€æœ‰å‡ºç°\n    \n    Returns:\n        æ›¿æ¢åçš„å†…å®¹\n    \n    Raises:\n        ValueError: å¦‚æœæ‰¾ä¸åˆ°åŒ¹é…æˆ–æœ‰å¤šä¸ªåŒ¹é…\n    \"\"\"\n    if old_string == new_string:\n        raise ValueError(\"old_string and new_string must be different\")\n    \n    not_found = True\n    \n    # æŒ‰ä¼˜å…ˆçº§å°è¯•9ç§ç­–ç•¥\n    replacers = [\n        SimpleReplacer,\n        LineTrimmedReplacer,\n        BlockAnchorReplacer,\n        WhitespaceNormalizedReplacer,\n        IndentationFlexibleReplacer,\n        EscapeNormalizedReplacer,\n        TrimmedBoundaryReplacer,\n        ContextAwareReplacer,\n        MultiOccurrenceReplacer,\n    ]\n    \n    for replacer_class in replacers:\n        for search in replacer_class.find_matches(content, old_string):\n            index = content.find(search)\n            if index == -1:\n                continue\n            \n            not_found = False\n            \n            if replace_all:\n                return content.replace(search, new_string)\n            \n            # æ£€æŸ¥æ˜¯å¦å”¯ä¸€\n            last_index = content.rfind(search)\n            if index != last_index:\n                continue\n            \n            # æ‰§è¡Œæ›¿æ¢\n            return content[:index] + new_string + content[index + len(search):]\n    \n    if not_found:\n        raise ValueError(\"old_string not found in content\")\n    \n    raise ValueError(\n        \"Found multiple matches for old_string. \"\n        \"Provide more surrounding lines to identify the correct match.\"\n    )\n\n\n# ========== å·¥å…·å°è£… ==========\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 460,
"end": 462,
"text": "class SearchReplaceTool(BaseTool):\n    \"\"\"SEARCH/REPLACEç¼–è¾‘å·¥å…·\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 463,
"end": 520,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"search_replace\",\n            description=\"ä½¿ç”¨SEARCH/REPLACEæ¨¡å¼ç¼–è¾‘æ–‡ä»¶ï¼ˆæ”¯æŒ9ç§æ™ºèƒ½åŒ¹é…ç­–ç•¥ï¼‰\"\n        )\n    \n    async def execute(\n        self,\n        file_path: str,\n        search: str,\n        replace: str,\n        replace_all: bool = False\n    ) -> ToolResult:\n        \"\"\"\n        æ‰§è¡ŒSEARCH/REPLACE\n        \n        Args:\n            file_path: æ–‡ä»¶è·¯å¾„\n            search: è¦æœç´¢çš„å†…å®¹\n            replace: æ›¿æ¢åçš„å†…å®¹\n            replace_all: æ˜¯å¦æ›¿æ¢æ‰€æœ‰å‡ºç°\n        \"\"\"\n        try:\n            path = Path(file_path)\n            if not path.exists():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"File not found: {file_path}\"\n                )\n            \n            # è¯»å–æ–‡ä»¶\n            content = path.read_text(encoding='utf-8', errors='ignore')\n            \n            # æ‰§è¡Œæ›¿æ¢ï¼ˆä½¿ç”¨æ¨¡å—çº§å‡½æ•°ï¼‰\n            from . import diff_tools\n            new_content = diff_tools.replace(content, search, replace, replace_all)\n            \n            # å†™å…¥æ–‡ä»¶\n            path.write_text(new_content, encoding='utf-8')\n            \n            return ToolResult(\n                success=True,\n                content=f\"Successfully replaced in {file_path}\",\n                metadata={\n                    'file_path': str(path),\n                    'old_size': len(content),\n                    'new_size': len(new_content),\n                    'replace_all': replace_all\n                }\n            )\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 521,
"end": 552,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"file_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"æ–‡ä»¶è·¯å¾„\"\n                    },\n                    \"search\": {\n                        \"type\": \"string\",\n                        \"description\": \"è¦æœç´¢çš„å†…å®¹\"\n                    },\n                    \"replace\": {\n                        \"type\": \"string\",\n                        \"description\": \"æ›¿æ¢åçš„å†…å®¹\"\n                    },\n                    \"replace_all\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦æ›¿æ¢æ‰€æœ‰å‡ºç°\",\n                        \"default\": False\n                    }\n                },\n                \"required\": [\"file_path\", \"search\", \"replace\"]\n            }\n        }\n\n\n# ========== Unified Diff (editblock/udiff å¼ç»†ç²’åº¦ç¼–è¾‘) ==========\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 553,
"end": 606,
"text": "def _parse_unified_diff(diff_text: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    è§£æ unified diffï¼Œè¿”å› [{\"path\": str, \"hunks\": [(old_start, old_count, new_start, new_count, lines)]}, ...]\n    path ä¸ºç›¸å¯¹è·¯å¾„ï¼ˆå·²å»æ‰ a/ b/ å‰ç¼€ï¼‰\n    \"\"\"\n    files = []\n    current_file: Optional[Dict[str, Any]] = None\n    current_hunk: Optional[Tuple] = None\n    for line in diff_text.splitlines(keepends=True):\n        if line.startswith(\"--- \"):\n            # æ—§æ–‡ä»¶è·¯å¾„ï¼š--- a/foo.py æˆ– --- foo.py\n            raw = line[4:].rstrip()\n            path = raw.split(\"\\t\")[0].strip()\n            if path.startswith(\"a/\"):\n                path = path[2:]\n            if current_file and current_hunk is not None:\n                current_file[\"hunks\"].append(current_hunk)\n            current_file = {\"path\": path, \"hunks\": []}\n            current_hunk = None\n        elif line.startswith(\"+++ \"):\n            # æ–°æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ä½¿ç”¨ï¼‰\n            raw = line[4:].rstrip()\n            path = raw.split(\"\\t\")[0].strip()\n            if path.startswith(\"b/\"):\n                path = path[2:]\n            if current_file:\n                current_file[\"path\"] = path\n            current_hunk = None\n        elif line.startswith(\"@@ \"):\n            if current_file is None:\n                continue\n            if current_hunk is not None:\n                current_file[\"hunks\"].append(current_hunk)\n            # @@ -old_start,old_count +new_start,new_count @@\n            m = re.match(r\"@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@\", line.strip())\n            if m:\n                old_s, old_c, new_s, new_c = m.groups()\n                current_hunk = (\n                    int(old_s),\n                    int(old_c) if old_c else 1,\n                    int(new_s),\n                    int(new_c) if new_c else 1,\n                    [],\n                )\n        elif current_hunk is not None:\n            # è¡Œå†…å®¹ï¼šç©ºæ ¼=ä¸Šä¸‹æ–‡ï¼Œ-=åˆ é™¤ï¼Œ+=æ·»åŠ \n            current_hunk[4].append(line)\n    if current_file and current_hunk is not None:\n        current_file[\"hunks\"].append(current_hunk)\n    if current_file:\n        files.append(current_file)\n    return files\n\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 607,
"end": 628,
"text": "def _apply_hunk(old_lines: List[str], old_start: int, old_count: int, new_start: int, new_count: int, hunk_lines: List[str]) -> List[str]:\n    \"\"\"åº”ç”¨å•ä¸ª hunkã€‚old_lines ä¸ºå¸¦æ¢è¡Œç¬¦çš„è¡Œåˆ—è¡¨ï¼›unified diffï¼šç©ºæ ¼=ä¸Šä¸‹æ–‡ï¼Œ-=åˆ é™¤ï¼Œ+=æ·»åŠ ã€‚\"\"\"\n    if old_start <= 0:\n        result = []\n        old_pos = 0\n    else:\n        result = old_lines[: old_start - 1]\n        old_pos = old_start - 1\n    for hunk_line in hunk_lines:\n        if len(hunk_line) < 1:\n            continue\n        if hunk_line[0] == \" \":\n            result.append(hunk_line[1:] if hunk_line.endswith(\"\\n\") else hunk_line[1:] + \"\\n\")\n            old_pos += 1\n        elif hunk_line[0] == \"-\":\n            old_pos += 1\n        elif hunk_line[0] == \"+\":\n            result.append(hunk_line[1:] if hunk_line.endswith(\"\\n\") else hunk_line[1:] + \"\\n\")\n    result.extend(old_lines[old_pos:])\n    return result\n\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 629,
"end": 636,
"text": "class ApplyPatchTool(BaseTool):\n    \"\"\"\n    åº”ç”¨ Unified Diffï¼ˆeditblock/udiff å¼ç»†ç²’åº¦ç¼–è¾‘ï¼‰\n    \n    æ¥å—æ¨¡å‹è¾“å‡ºçš„æ ‡å‡† unified diff æ–‡æœ¬ï¼ŒæŒ‰ hunk ç²¾ç¡®åº”ç”¨ï¼Œä¾¿äºå®¡è®¡å’Œå›æ»šã€‚\n    å‚è€ƒ aider çš„ udiff ç¼–è¾‘èŒƒå¼ã€‚\n    \"\"\"\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 637,
"end": 692,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"apply_patch\",\n            description=\"åº”ç”¨ unified diff åˆ°æ–‡ä»¶ã€‚è¾“å…¥ä¸ºæ ‡å‡† diff æ–‡æœ¬ï¼ˆ---/+++ æ–‡ä»¶è·¯å¾„ï¼Œ@@ hunkï¼Œ- åˆ é™¤è¡Œï¼Œ+ æ·»åŠ è¡Œï¼‰ã€‚è·¯å¾„ä¸ºç›¸å¯¹é¡¹ç›®æ ¹ã€‚\"\n        )\n\n    async def execute(\n        self,\n        diff: str,\n        base_path: Optional[str] = None\n    ) -> ToolResult:\n        \"\"\"\n        åº”ç”¨ diffã€‚\n        \n        Args:\n            diff: unified diff å­—ç¬¦ä¸²ï¼ˆå¯å«å¤šä¸ªæ–‡ä»¶ï¼‰\n            base_path: ç›¸å¯¹è·¯å¾„çš„åŸºå‡†ç›®å½•ï¼Œé»˜è®¤ä½¿ç”¨å½“å‰ä»“åº“æ ¹\n        \"\"\"\n        try:\n            base = self.context.repo_path\n            if base_path:\n                base = self.resolve_path(base_path)\n            parsed = _parse_unified_diff(diff)\n            applied = []\n            errors = []\n            for file_info in parsed:\n                rel_path = file_info[\"path\"]\n                full_path = base / rel_path\n                if not full_path.exists() and not any(h[4] for h in file_info[\"hunks\"] if any(l.startswith(\"+\") for l in h[4])):\n                    errors.append(f\"æ–‡ä»¶ä¸å­˜åœ¨ä¸”æ— æ–°å¢å†…å®¹: {rel_path}\")\n                    continue\n                try:\n                    if full_path.exists():\n                        content = full_path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n                        old_lines = content.splitlines(keepends=True)\n                        if not content.endswith(\"\\n\") and old_lines:\n                            old_lines[-1] = old_lines[-1].rstrip(\"\\n\") + \"\\n\"\n                    else:\n                        full_path.parent.mkdir(parents=True, exist_ok=True)\n                        old_lines = []\n                    for (old_start, old_count, new_start, new_count, hunk_lines) in file_info[\"hunks\"]:\n                        old_lines = _apply_hunk(old_lines, old_start, old_count, new_start, new_count, hunk_lines)\n                    full_path.write_text(\"\".join(old_lines), encoding=\"utf-8\")\n                    applied.append(rel_path)\n                except Exception as e:\n                    errors.append(f\"{rel_path}: {e}\")\n            if errors and not applied:\n                return ToolResult(success=False, content=None, error=\"; \".join(errors))\n            return ToolResult(\n                success=True,\n                content=f\"å·²åº”ç”¨ diff åˆ°: {', '.join(applied)}\" + (\"; é”™è¯¯: \" + \"; \".join(errors) if errors else \"\"),\n                metadata={\"applied\": applied, \"errors\": errors if errors else None}\n            )\n        except Exception as e:\n            return ToolResult(success=False, content=None, error=str(e))\n"
},
{
"path": "daoyoucode/agents/tools/diff_tools.py",
"start": 693,
"end": 711,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"diff\": {\n                        \"type\": \"string\",\n                        \"description\": \"Unified diff å…¨æ–‡ï¼ˆåŒ…å« ---/+++ è·¯å¾„å’Œ @@ hunkï¼‰\"\n                    },\n                    \"base_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"ç›¸å¯¹è·¯å¾„åŸºå‡†ï¼Œé»˜è®¤å½“å‰ä»“åº“æ ¹ã€‚ä½¿ç”¨ '.' è¡¨ç¤ºä»“åº“æ ¹\"\n                    }\n                },\n                \"required\": [\"diff\"]\n            }\n        }"
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 1,
"end": 13,
"text": "\"\"\"\næ–‡ä»¶æ“ä½œå·¥å…·\n\næä¾›read_file, write_file, list_filesç­‰åŸºç¡€æ–‡ä»¶æ“ä½œ\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nimport os\nimport shutil\nfrom .base import BaseTool, ToolResult\n\n"
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 14,
"end": 20,
"text": "class ReadFileTool(BaseTool):\n    \"\"\"è¯»å–æ–‡ä»¶å·¥å…·\"\"\"\n    \n    # å•ä¸ªæ–‡ä»¶ä¸è¦å¤ªé•¿\n    MAX_OUTPUT_CHARS = 5000\n    MAX_OUTPUT_LINES = 200\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 21,
"end": 64,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"read_file\",\n            description=\"è¯»å–æ–‡ä»¶å†…å®¹\"\n        )\n    \n    async def execute(self, file_path: str, encoding: str = \"utf-8\") -> ToolResult:\n        \"\"\"\n        è¯»å–æ–‡ä»¶\n        \n        Args:\n            file_path: æ–‡ä»¶è·¯å¾„\n            encoding: ç¼–ç æ ¼å¼\n        \"\"\"\n        try:\n            # ä½¿ç”¨ resolve_path è§£æè·¯å¾„\n            path = self.resolve_path(file_path)\n            \n            if not path.exists():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"File not found: {file_path} (resolved to {path})\"\n                )\n            \n            with open(path, 'r', encoding=encoding) as f:\n                content = f.read()\n            \n            return ToolResult(\n                success=True,\n                content=content,\n                metadata={\n                    'file_path': str(path),\n                    'size': len(content),\n                    'lines': content.count('\\n') + 1\n                }\n            )\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 65,
"end": 86,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"file_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"æ–‡ä»¶çš„ç›¸å¯¹è·¯å¾„ã€‚ä¾‹å¦‚: 'backend/config.py' æˆ– 'README.md'ã€‚ä¸è¦ä½¿ç”¨å ä½ç¬¦ï¼\"\n                    },\n                    \"encoding\": {\n                        \"type\": \"string\",\n                        \"description\": \"ç¼–ç æ ¼å¼\",\n                        \"default\": \"utf-8\"\n                    }\n                },\n                \"required\": [\"file_path\"]\n            }\n        }\n\n"
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 87,
"end": 89,
"text": "class WriteFileTool(BaseTool):\n    \"\"\"å†™å…¥æ–‡ä»¶å·¥å…·\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 90,
"end": 137,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"write_file\",\n            description=\"å†™å…¥æ–‡ä»¶å†…å®¹ï¼ˆè‡ªåŠ¨åˆ›å»ºç›®å½•ï¼‰\"\n        )\n    \n    async def execute(\n        self,\n        file_path: str,\n        content: str,\n        encoding: str = \"utf-8\",\n        create_dirs: bool = True\n    ) -> ToolResult:\n        \"\"\"\n        å†™å…¥æ–‡ä»¶\n        \n        Args:\n            file_path: æ–‡ä»¶è·¯å¾„\n            content: æ–‡ä»¶å†…å®¹\n            encoding: ç¼–ç æ ¼å¼\n            create_dirs: æ˜¯å¦è‡ªåŠ¨åˆ›å»ºç›®å½•\n        \"\"\"\n        try:\n            path = Path(file_path)\n            \n            # åˆ›å»ºç›®å½•\n            if create_dirs and not path.parent.exists():\n                path.parent.mkdir(parents=True, exist_ok=True)\n            \n            with open(path, 'w', encoding=encoding) as f:\n                f.write(content)\n            \n            return ToolResult(\n                success=True,\n                content=f\"Successfully wrote {len(content)} bytes to {file_path}\",\n                metadata={\n                    'file_path': str(path),\n                    'size': len(content),\n                    'lines': content.count('\\n') + 1\n                }\n            )\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 138,
"end": 168,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"file_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"æ–‡ä»¶è·¯å¾„\"\n                    },\n                    \"content\": {\n                        \"type\": \"string\",\n                        \"description\": \"æ–‡ä»¶å†…å®¹\"\n                    },\n                    \"encoding\": {\n                        \"type\": \"string\",\n                        \"description\": \"ç¼–ç æ ¼å¼\",\n                        \"default\": \"utf-8\"\n                    },\n                    \"create_dirs\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦è‡ªåŠ¨åˆ›å»ºç›®å½•\",\n                        \"default\": True\n                    }\n                },\n                \"required\": [\"file_path\", \"content\"]\n            }\n        }\n\n"
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 169,
"end": 171,
"text": "class ListFilesTool(BaseTool):\n    \"\"\"åˆ—å‡ºç›®å½•å·¥å…·\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 172,
"end": 244,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"list_files\",\n            description=\"åˆ—å‡ºç›®å½•å†…å®¹ï¼ˆæ”¯æŒé€’å½’å’Œæ¨¡å¼åŒ¹é…ï¼‰\"\n        )\n    \n    async def execute(\n        self,\n        directory: str = \".\",\n        recursive: bool = False,\n        pattern: Optional[str] = None,\n        max_depth: Optional[int] = 3  # ğŸ†• æ”¹ä¸º Optional[int]\n    ) -> ToolResult:\n        \"\"\"\n        åˆ—å‡ºç›®å½•\n        \n        Args:\n            directory: ç›®å½•è·¯å¾„\n            recursive: æ˜¯å¦é€’å½’\n            pattern: æ–‡ä»¶åæ¨¡å¼ï¼ˆå¦‚ *.pyï¼‰\n            max_depth: æœ€å¤§é€’å½’æ·±åº¦ï¼ˆNone è¡¨ç¤ºæ— é™åˆ¶ï¼‰\n        \"\"\"\n        try:\n            # ä½¿ç”¨ resolve_path è§£æè·¯å¾„\n            path = self.resolve_path(directory)\n            \n            if not path.exists():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"Directory not found: {directory} (resolved to {path})\"\n                )\n            \n            if not path.is_dir():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"Not a directory: {directory}\"\n                )\n            \n            files = []\n            \n            if recursive:\n                # ğŸ†• å¦‚æœ max_depth æ˜¯ Noneï¼Œä½¿ç”¨ä¸€ä¸ªå¾ˆå¤§çš„æ•°å­—\n                effective_max_depth = max_depth if max_depth is not None else 999\n                files = self._list_recursive(path, pattern, effective_max_depth, 0)\n            else:\n                for item in path.iterdir():\n                    if pattern and not item.match(pattern):\n                        continue\n                    files.append({\n                        'path': self.normalize_path(str(item)),  # æ ‡å‡†åŒ–è·¯å¾„\n                        'name': item.name,\n                        'type': 'dir' if item.is_dir() else 'file',\n                        'size': item.stat().st_size if item.is_file() else 0\n                    })\n            \n            return ToolResult(\n                success=True,\n                content=files,\n                metadata={\n                    'directory': str(path),\n                    'count': len(files),\n                    'recursive': recursive\n                }\n            )\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 245,
"end": 279,
"text": "    def _list_recursive(\n        self,\n        path: Path,\n        pattern: Optional[str],\n        max_depth: int,\n        current_depth: int\n    ) -> List[Dict[str, Any]]:\n        \"\"\"é€’å½’åˆ—å‡ºæ–‡ä»¶\"\"\"\n        if current_depth >= max_depth:\n            return []\n        \n        files = []\n        try:\n            for item in path.iterdir():\n                if pattern and not item.match(pattern):\n                    if not item.is_dir():\n                        continue\n                \n                files.append({\n                    'path': self.normalize_path(str(item)),  # æ ‡å‡†åŒ–è·¯å¾„\n                    'name': item.name,\n                    'type': 'dir' if item.is_dir() else 'file',\n                    'size': item.stat().st_size if item.is_file() else 0,\n                    'depth': current_depth\n                })\n                \n                if item.is_dir():\n                    files.extend(self._list_recursive(\n                        item, pattern, max_depth, current_depth + 1\n                    ))\n        except PermissionError:\n            pass\n        \n        return files\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 280,
"end": 311,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"directory\": {\n                        \"type\": \"string\",\n                        \"description\": \"ç›®å½•è·¯å¾„ï¼ˆç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•ï¼Œä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰ç›®å½•ï¼‰\",\n                        \"default\": \".\"\n                    },\n                    \"recursive\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦é€’å½’åˆ—å‡ºå­ç›®å½•\",\n                        \"default\": False\n                    },\n                    \"pattern\": {\n                        \"type\": \"string\",\n                        \"description\": \"æ–‡ä»¶åæ¨¡å¼ï¼ˆå¦‚ '*.py' æˆ– '**/test_*.py'ï¼‰\"\n                    },\n                    \"max_depth\": {\n                        \"type\": \"integer\",\n                        \"description\": \"æœ€å¤§é€’å½’æ·±åº¦ï¼ˆé»˜è®¤3ï¼Œè®¾ç½®ä¸ºè¾ƒå¤§å€¼å¦‚999è¡¨ç¤ºæ— é™åˆ¶ï¼‰\",\n                        \"default\": 3\n                    }\n                },\n                \"required\": []\n            }\n        }\n\n"
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 312,
"end": 314,
"text": "class GetFileInfoTool(BaseTool):\n    \"\"\"è·å–æ–‡ä»¶ä¿¡æ¯å·¥å…·\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 315,
"end": 361,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"get_file_info\",\n            description=\"è·å–æ–‡ä»¶æˆ–ç›®å½•çš„è¯¦ç»†ä¿¡æ¯\"\n        )\n    \n    async def execute(self, path: str) -> ToolResult:\n        \"\"\"\n        è·å–æ–‡ä»¶ä¿¡æ¯\n        \n        Args:\n            path: æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„\n        \"\"\"\n        try:\n            p = Path(path)\n            if not p.exists():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"Path not found: {path}\"\n                )\n            \n            stat = p.stat()\n            info = {\n                'path': str(p),\n                'name': p.name,\n                'type': 'dir' if p.is_dir() else 'file',\n                'size': stat.st_size,\n                'created': stat.st_ctime,\n                'modified': stat.st_mtime,\n                'accessed': stat.st_atime,\n                'is_symlink': p.is_symlink(),\n                'parent': str(p.parent),\n                'suffix': p.suffix if p.is_file() else None\n            }\n            \n            return ToolResult(\n                success=True,\n                content=info\n            )\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 362,
"end": 378,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„\"\n                    }\n                },\n                \"required\": [\"path\"]\n            }\n        }\n\n"
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 379,
"end": 381,
"text": "class CreateDirectoryTool(BaseTool):\n    \"\"\"åˆ›å»ºç›®å½•å·¥å…·\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 382,
"end": 411,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"create_directory\",\n            description=\"åˆ›å»ºç›®å½•ï¼ˆæ”¯æŒé€’å½’åˆ›å»ºï¼‰\"\n        )\n    \n    async def execute(self, directory: str, parents: bool = True) -> ToolResult:\n        \"\"\"\n        åˆ›å»ºç›®å½•\n        \n        Args:\n            directory: ç›®å½•è·¯å¾„\n            parents: æ˜¯å¦é€’å½’åˆ›å»ºçˆ¶ç›®å½•\n        \"\"\"\n        try:\n            path = Path(directory)\n            path.mkdir(parents=parents, exist_ok=True)\n            \n            return ToolResult(\n                success=True,\n                content=f\"Successfully created directory: {directory}\",\n                metadata={'directory': str(path)}\n            )\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 412,
"end": 433,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"directory\": {\n                        \"type\": \"string\",\n                        \"description\": \"ç›®å½•è·¯å¾„\"\n                    },\n                    \"parents\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦é€’å½’åˆ›å»ºçˆ¶ç›®å½•\",\n                        \"default\": True\n                    }\n                },\n                \"required\": [\"directory\"]\n            }\n        }\n\n"
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 434,
"end": 436,
"text": "class DeleteFileTool(BaseTool):\n    \"\"\"åˆ é™¤æ–‡ä»¶/ç›®å½•å·¥å…·\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 437,
"end": 479,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"delete_file\",\n            description=\"åˆ é™¤æ–‡ä»¶æˆ–ç›®å½•\"\n        )\n    \n    async def execute(self, path: str, recursive: bool = False) -> ToolResult:\n        \"\"\"\n        åˆ é™¤æ–‡ä»¶æˆ–ç›®å½•\n        \n        Args:\n            path: æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„\n            recursive: æ˜¯å¦é€’å½’åˆ é™¤ç›®å½•\n        \"\"\"\n        try:\n            p = Path(path)\n            if not p.exists():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"Path not found: {path}\"\n                )\n            \n            if p.is_dir():\n                if recursive:\n                    shutil.rmtree(p)\n                else:\n                    p.rmdir()\n            else:\n                p.unlink()\n            \n            return ToolResult(\n                success=True,\n                content=f\"Successfully deleted: {path}\",\n                metadata={'path': str(p)}\n            )\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/file_tools.py",
"start": 480,
"end": 499,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„\"\n                    },\n                    \"recursive\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦é€’å½’åˆ é™¤ç›®å½•\",\n                        \"default\": False\n                    }\n                },\n                \"required\": [\"path\"]\n            }\n        }"
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 1,
"end": 22,
"text": "\"\"\"\nGit å·¥å…· - Git çŠ¶æ€æ„ŸçŸ¥\n\næä¾› Git ä»“åº“çŠ¶æ€ä¿¡æ¯ï¼Œå¸®åŠ© AI ç†è§£é¡¹ç›®å½“å‰çŠ¶æ€\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nimport logging\n\nfrom .base import BaseTool, ToolResult\n\nlogger = logging.getLogger(__name__)\n\ntry:\n    import git\n    GIT_AVAILABLE = True\nexcept ImportError:\n    GIT_AVAILABLE = False\n    logger.warning(\"GitPython æœªå®‰è£…ï¼ŒGit åŠŸèƒ½ä¸å¯ç”¨\")\n\n"
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 23,
"end": 34,
"text": "class GitStatusTool(BaseTool):\n    \"\"\"\n    è·å– Git ä»“åº“çŠ¶æ€\n    \n    åŠŸèƒ½ï¼š\n    - åˆ—å‡ºå·²ä¿®æ”¹çš„æ–‡ä»¶\n    - åˆ—å‡ºå·²æš‚å­˜çš„æ–‡ä»¶\n    - åˆ—å‡ºæœªè·Ÿè¸ªçš„æ–‡ä»¶\n    - æ˜¾ç¤ºå½“å‰åˆ†æ”¯\n    - æ˜¾ç¤ºæœ€è¿‘çš„æäº¤\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 35,
"end": 40,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"git_status\",\n            description=\"è·å– Git ä»“åº“çŠ¶æ€ï¼ŒåŒ…æ‹¬ä¿®æ”¹çš„æ–‡ä»¶ã€æš‚å­˜çš„æ–‡ä»¶ã€å½“å‰åˆ†æ”¯ç­‰\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 41,
"end": 219,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        \"\"\"è·å– Function Calling schema\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"repo_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"ä»“åº“æ ¹ç›®å½•è·¯å¾„ï¼ˆé»˜è®¤ä¸ºå½“å‰å·¥ä½œç›®å½•ï¼‰\",\n                        \"default\": \".\"\n                    },\n                    \"include_diff\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦åŒ…å«æ–‡ä»¶å·®å¼‚ï¼ˆé»˜è®¤ falseï¼‰\",\n                        \"default\": False\n                    }\n                },\n                \"required\": []\n            }\n        }\n    \n    async def execute(\n        self,\n        repo_path: str = \".\",\n        include_diff: bool = False\n    ) -> ToolResult:\n        \"\"\"\n        è·å– Git çŠ¶æ€\n        \n        Args:\n            repo_path: ä»“åº“æ ¹ç›®å½•\n            include_diff: æ˜¯å¦åŒ…å«æ–‡ä»¶å·®å¼‚\n            \n        Returns:\n            ToolResult\n        \"\"\"\n        if not GIT_AVAILABLE:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=\"GitPython æœªå®‰è£…ï¼Œè¯·è¿è¡Œ: pip install gitpython\"\n            )\n        \n        try:\n            # è§£æè·¯å¾„\n            repo_path_resolved = self.resolve_path(repo_path)\n            \n            # æ‰“å¼€ Git ä»“åº“\n            try:\n                repo = git.Repo(repo_path_resolved, search_parent_directories=True)\n            except git.InvalidGitRepositoryError:\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"ä¸æ˜¯æœ‰æ•ˆçš„ Git ä»“åº“: {repo_path}\"\n                )\n            \n            # è·å–ä»“åº“æ ¹ç›®å½•\n            repo_root = Path(repo.working_tree_dir)\n            \n            # è·å–å½“å‰åˆ†æ”¯\n            try:\n                current_branch = repo.active_branch.name\n            except TypeError:\n                current_branch = \"(detached HEAD)\"\n            \n            # è·å–å·²ä¿®æ”¹çš„æ–‡ä»¶ï¼ˆæœªæš‚å­˜ï¼‰\n            modified_files = []\n            for item in repo.index.diff(None):\n                file_path = self.normalize_path(str(repo_root / item.a_path))\n                modified_files.append({\n                    \"path\": file_path,\n                    \"change_type\": item.change_type\n                })\n            \n            # è·å–å·²æš‚å­˜çš„æ–‡ä»¶\n            staged_files = []\n            for item in repo.index.diff(\"HEAD\"):\n                file_path = self.normalize_path(str(repo_root / item.a_path))\n                staged_files.append({\n                    \"path\": file_path,\n                    \"change_type\": item.change_type\n                })\n            \n            # è·å–æœªè·Ÿè¸ªçš„æ–‡ä»¶\n            untracked_files = []\n            for file_path in repo.untracked_files:\n                normalized = self.normalize_path(str(repo_root / file_path))\n                # åº”ç”¨ subtree_only è¿‡æ»¤\n                if self.context.should_include_path(normalized):\n                    untracked_files.append(normalized)\n            \n            # è·å–æœ€è¿‘çš„æäº¤\n            recent_commits = []\n            try:\n                for commit in repo.iter_commits(max_count=5):\n                    recent_commits.append({\n                        \"hash\": commit.hexsha[:7],\n                        \"message\": commit.message.strip().split('\\n')[0],\n                        \"author\": commit.author.name,\n                        \"date\": commit.committed_datetime.isoformat()\n                    })\n            except Exception as e:\n                logger.warning(f\"æ— æ³•è·å–æäº¤å†å²: {e}\")\n            \n            # æ„å»ºç»“æœ\n            status = {\n                \"branch\": current_branch,\n                \"repo_root\": str(repo_root),\n                \"modified_files\": modified_files,\n                \"staged_files\": staged_files,\n                \"untracked_files\": untracked_files,\n                \"recent_commits\": recent_commits,\n                \"is_dirty\": repo.is_dirty()\n            "
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 220,
"end": 222,
"text": "class GitDiffTool(BaseTool):\n    \"\"\"è·å– Git å·®å¼‚ï¼ˆå ä½ç¬¦ï¼Œå¾…å®ç°ï¼‰\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 223,
"end": 228,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"git_diff\",\n            description=\"è·å– Git æ–‡ä»¶å·®å¼‚\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 229,
"end": 247,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {},\n                \"required\": []\n            }\n        }\n    \n    async def execute(self, **kwargs) -> ToolResult:\n        return ToolResult(\n            success=False,\n            content=None,\n            error=\"GitDiffTool å°šæœªå®ç°\"\n        )\n\n"
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 248,
"end": 250,
"text": "class GitCommitTool(BaseTool):\n    \"\"\"Git æäº¤å·¥å…·ï¼ˆå ä½ç¬¦ï¼Œå¾…å®ç°ï¼‰\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 251,
"end": 256,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"git_commit\",\n            description=\"æäº¤ Git æ›´æ”¹\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 257,
"end": 275,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {},\n                \"required\": []\n            }\n        }\n    \n    async def execute(self, **kwargs) -> ToolResult:\n        return ToolResult(\n            success=False,\n            content=None,\n            error=\"GitCommitTool å°šæœªå®ç°\"\n        )\n\n"
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 276,
"end": 278,
"text": "class GitLogTool(BaseTool):\n    \"\"\"Git æ—¥å¿—å·¥å…·ï¼ˆå ä½ç¬¦ï¼Œå¾…å®ç°ï¼‰\"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 279,
"end": 284,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"git_log\",\n            description=\"æŸ¥çœ‹ Git æäº¤å†å²\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/git_tools.py",
"start": 285,
"end": 301,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {},\n                \"required\": []\n            }\n        }\n    \n    async def execute(self, **kwargs) -> ToolResult:\n        return ToolResult(\n            success=False,\n            content=None,\n            error=\"GitLogTool å°šæœªå®ç°\"\n        )"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1,
"end": 29,
"text": "\"\"\"\nLSPå·¥å…· - Language Server Protocolé›†æˆ\n\nåŸºäºoh-my-opencodeçš„æœ€ä½³å®ç°ï¼š\n- 6ä¸ªç‹¬ç«‹å·¥å…·ï¼ˆdiagnostics, rename, goto_definition, find_references, symbols, code_actionsï¼‰\n- LSPæœåŠ¡å™¨ç®¡ç†ï¼ˆå¯åŠ¨ã€åœæ­¢ã€é‡å¯ï¼‰\n- æ”¯æŒå¤šç§è¯­è¨€ï¼ˆPythonã€JavaScriptã€TypeScriptç­‰ï¼‰\n- ç»“æœé™åˆ¶åˆç†ï¼ˆé¿å…è¾“å‡ºè¿‡å¤šï¼‰\n\nå‚è€ƒï¼šoh-my-opencode/src/tools/lsp/\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any, Tuple\nimport logging\nimport subprocess\nimport json\nimport asyncio\nfrom dataclasses import dataclass\nimport shutil\n\nfrom .base import BaseTool, ToolResult\n\nlogger = logging.getLogger(__name__)\n\n\n# ========== LSPé…ç½® ==========\n\n@dataclass"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 30,
"end": 91,
"text": "class LSPServerConfig:\n    \"\"\"LSPæœåŠ¡å™¨é…ç½®\"\"\"\n    id: str\n    command: List[str]\n    extensions: List[str]\n    env: Optional[Dict[str, str]] = None\n    initialization: Optional[Dict[str, Any]] = None\n\n\n# å†…ç½®LSPæœåŠ¡å™¨é…ç½®ï¼ˆå‚è€ƒoh-my-opencodeï¼‰\nBUILTIN_LSP_SERVERS = {\n    \"pyright\": LSPServerConfig(\n        id=\"pyright\",\n        command=[\"pyright-langserver\", \"--stdio\"],\n        extensions=[\".py\"]\n    ),\n    \"pylsp\": LSPServerConfig(\n        id=\"pylsp\",\n        command=[\"pylsp\"],\n        extensions=[\".py\"]\n    ),\n    \"typescript-language-server\": LSPServerConfig(\n        id=\"typescript-language-server\",\n        command=[\"typescript-language-server\", \"--stdio\"],\n        extensions=[\".ts\", \".tsx\", \".js\", \".jsx\"]\n    ),\n    \"rust-analyzer\": LSPServerConfig(\n        id=\"rust-analyzer\",\n        command=[\"rust-analyzer\"],\n        extensions=[\".rs\"]\n    ),\n    \"gopls\": LSPServerConfig(\n        id=\"gopls\",\n        command=[\"gopls\"],\n        extensions=[\".go\"]\n    ),\n}\n\n# æ‰©å±•ååˆ°è¯­è¨€IDçš„æ˜ å°„\nEXT_TO_LANG = {\n    \".py\": \"python\",\n    \".js\": \"javascript\",\n    \".jsx\": \"javascriptreact\",\n    \".ts\": \"typescript\",\n    \".tsx\": \"typescriptreact\",\n    \".rs\": \"rust\",\n    \".go\": \"go\",\n    \".java\": \"java\",\n    \".c\": \"c\",\n    \".cpp\": \"cpp\",\n    \".h\": \"c\",\n    \".hpp\": \"cpp\",\n}\n\n# é»˜è®¤é™åˆ¶ï¼ˆå‚è€ƒoh-my-opencodeï¼‰\nDEFAULT_MAX_REFERENCES = 50\nDEFAULT_MAX_SYMBOLS = 50\nDEFAULT_MAX_DIAGNOSTICS = 100\n\n\n# ========== LSPå®¢æˆ·ç«¯ï¼ˆå®Œæ•´å®ç°ï¼‰==========\n"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 92,
"end": 105,
"text": "class LSPClient:\n    \"\"\"\n    å®Œæ•´çš„LSPå®¢æˆ·ç«¯å®ç°\n    \n    åŠŸèƒ½ï¼š\n    - JSON-RPC 2.0åè®®\n    - å¼‚æ­¥æ¶ˆæ¯å¤„ç†\n    - æœåŠ¡å™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†\n    - è¯Šæ–­ä¿¡æ¯ç¼“å­˜\n    - æ–‡ä»¶åŒæ­¥\n    \n    å‚è€ƒï¼šoh-my-opencode/src/tools/lsp/client.ts\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 106,
"end": 119,
"text": "    def __init__(self, root: str, server_config: LSPServerConfig):\n        self.root = Path(root).resolve()\n        self.server_config = server_config\n        self.process: Optional[asyncio.subprocess.Process] = None\n        self.request_id = 0\n        self.opened_files: set = set()\n        self.pending_requests: Dict[int, asyncio.Future] = {}\n        self.diagnostics_store: Dict[str, List[Dict]] = {}\n        self.buffer = b\"\"\n        self.process_exited = False\n        self.stderr_buffer: List[str] = []\n        self._read_task: Optional[asyncio.Task] = None\n        self._stderr_task: Optional[asyncio.Task] = None\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 120,
"end": 190,
"text": "    def is_server_installed(self) -> bool:\n        \"\"\"æ£€æŸ¥LSPæœåŠ¡å™¨æ˜¯å¦å·²å®‰è£…\"\"\"\n        command = self.server_config.command[0]\n        return shutil.which(command) is not None\n    \n    async def start(self):\n        \"\"\"å¯åŠ¨LSPæœåŠ¡å™¨\"\"\"\n        if not self.is_server_installed():\n            raise FileNotFoundError(\n                f\"LSP server not found: {self.server_config.command[0]}\\n\"\n                f\"Please install it first.\"\n            )\n        \n        # å‡†å¤‡ç¯å¢ƒå˜é‡\n        env = dict(self.server_config.env) if self.server_config.env else {}\n        \n        # å¯åŠ¨è¿›ç¨‹\n        self.process = await asyncio.create_subprocess_exec(\n            *self.server_config.command,\n            stdin=asyncio.subprocess.PIPE,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n            cwd=str(self.root),\n            env={**dict(asyncio.subprocess.os.environ), **env}\n        )\n        \n        # å¯åŠ¨è¯»å–ä»»åŠ¡\n        self._read_task = asyncio.create_task(self._read_stdout())\n        self._stderr_task = asyncio.create_task(self._read_stderr())\n        \n        # ç­‰å¾…å¯åŠ¨\n        await asyncio.sleep(0.1)\n        \n        if self.process.returncode is not None:\n            stderr = '\\n'.join(self.stderr_buffer)\n            raise RuntimeError(\n                f\"LSP server exited immediately with code {self.process.returncode}\\n\"\n                f\"stderr: {stderr}\"\n            )\n    \n    async def _read_stdout(self):\n        \"\"\"è¯»å–stdoutï¼ˆå¼‚æ­¥ï¼‰\"\"\"\n        try:\n            while True:\n                chunk = await self.process.stdout.read(4096)\n                if not chunk:\n                    self.process_exited = True\n                    self._reject_all_pending(\"LSP server stdout closed\")\n                    break\n                \n                self.buffer += chunk\n                self._process_buffer()\n        except Exception as e:\n            self.process_exited = True\n            self._reject_all_pending(f\"LSP stdout read error: {e}\")\n    \n    async def _read_stderr(self):\n        \"\"\"è¯»å–stderrï¼ˆå¼‚æ­¥ï¼‰\"\"\"\n        try:\n            while True:\n                line = await self.process.stderr.readline()\n                if not line:\n                    break\n                \n                text = line.decode('utf-8', errors='ignore')\n                self.stderr_buffer.append(text)\n                if len(self.stderr_buffer) > 100:\n                    self.stderr_buffer.pop(0)\n        except:\n            pass\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 191,
"end": 197,
"text": "    def _reject_all_pending(self, reason: str):\n        \"\"\"æ‹’ç»æ‰€æœ‰å¾…å¤„ç†çš„è¯·æ±‚\"\"\"\n        for request_id, future in list(self.pending_requests.items()):\n            if not future.done():\n                future.set_exception(Exception(reason))\n            del self.pending_requests[request_id]\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 198,
"end": 242,
"text": "    def _process_buffer(self):\n        \"\"\"å¤„ç†ç¼“å†²åŒºä¸­çš„æ¶ˆæ¯\"\"\"\n        while True:\n            # æŸ¥æ‰¾Content-Lengthå¤´\n            header_end = self.buffer.find(b'\\r\\n\\r\\n')\n            if header_end == -1:\n                header_end = self.buffer.find(b'\\n\\n')\n                if header_end == -1:\n                    break\n                sep_len = 2\n            else:\n                sep_len = 4\n            \n            # è§£æContent-Length\n            header = self.buffer[:header_end].decode('utf-8', errors='ignore')\n            match = None\n            for line in header.split('\\n'):\n                if line.lower().startswith('content-length:'):\n                    try:\n                        match = int(line.split(':', 1)[1].strip())\n                    except:\n                        pass\n                    break\n            \n            if match is None:\n                break\n            \n            content_length = match\n            start = header_end + sep_len\n            end = start + content_length\n            \n            if len(self.buffer) < end:\n                break\n            \n            # æå–æ¶ˆæ¯\n            content = self.buffer[start:end].decode('utf-8', errors='ignore')\n            self.buffer = self.buffer[end:]\n            \n            # è§£æJSON\n            try:\n                msg = json.loads(content)\n                self._handle_message(msg)\n            except:\n                pass\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 243,
"end": 268,
"text": "    def _handle_message(self, msg: Dict[str, Any]):\n        \"\"\"å¤„ç†æ”¶åˆ°çš„æ¶ˆæ¯\"\"\"\n        # é€šçŸ¥æ¶ˆæ¯ï¼ˆæ²¡æœ‰idï¼‰\n        if 'method' in msg and 'id' not in msg:\n            if msg['method'] == 'textDocument/publishDiagnostics':\n                uri = msg.get('params', {}).get('uri')\n                diagnostics = msg.get('params', {}).get('diagnostics', [])\n                if uri:\n                    self.diagnostics_store[uri] = diagnostics\n        \n        # æœåŠ¡å™¨è¯·æ±‚ï¼ˆæœ‰idå’Œmethodï¼‰\n        elif 'id' in msg and 'method' in msg:\n            self._handle_server_request(msg['id'], msg['method'], msg.get('params'))\n        \n        # å“åº”æ¶ˆæ¯ï¼ˆæœ‰idï¼‰\n        elif 'id' in msg:\n            request_id = msg['id']\n            if request_id in self.pending_requests:\n                future = self.pending_requests[request_id]\n                del self.pending_requests[request_id]\n                \n                if 'error' in msg:\n                    future.set_exception(Exception(msg['error'].get('message', 'Unknown error')))\n                else:\n                    future.set_result(msg.get('result'))\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 269,
"end": 284,
"text": "    def _handle_server_request(self, request_id: Any, method: str, params: Any):\n        \"\"\"å¤„ç†æœåŠ¡å™¨è¯·æ±‚\"\"\"\n        # ç®€å•å“åº”ä¸€äº›å¸¸è§è¯·æ±‚\n        if method == 'workspace/configuration':\n            items = params.get('items', []) if params else []\n            result = []\n            for item in items:\n                if item.get('section') == 'json':\n                    result.append({'validate': {'enable': True}})\n                else:\n                    result.append({})\n            self._respond(request_id, result)\n        \n        elif method in ['client/registerCapability', 'window/workDoneProgress/create']:\n            self._respond(request_id, None)\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 285,
"end": 330,
"text": "    def _send(self, method: str, params: Any = None) -> asyncio.Future:\n        \"\"\"å‘é€è¯·æ±‚\"\"\"\n        if not self.process or self.process_exited or self.process.returncode is not None:\n            stderr = '\\n'.join(self.stderr_buffer[-10:])\n            raise RuntimeError(\n                f\"LSP server not running (returncode: {self.process.returncode if self.process else 'None'})\\n\"\n                f\"stderr: {stderr}\"\n            )\n        \n        self.request_id += 1\n        request_id = self.request_id\n        \n        msg = {\n            'jsonrpc': '2.0',\n            'id': request_id,\n            'method': method,\n            'params': params\n        }\n        \n        content = json.dumps(msg)\n        header = f'Content-Length: {len(content.encode())}\\r\\n\\r\\n'\n        \n        self.process.stdin.write((header + content).encode())\n        \n        # åˆ›å»ºFuture\n        future = asyncio.Future()\n        self.pending_requests[request_id] = future\n        \n        # è®¾ç½®è¶…æ—¶\n        async def timeout_handler():\n            await asyncio.sleep(15)\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n                if not future.done():\n                    stderr = '\\n'.join(self.stderr_buffer[-5:])\n                    future.set_exception(\n                        TimeoutError(\n                            f\"LSP request timeout (method: {method})\\n\"\n                            f\"recent stderr: {stderr}\"\n                        )\n                    )\n        \n        asyncio.create_task(timeout_handler())\n        \n        return future\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 331,
"end": 349,
"text": "    def _notify(self, method: str, params: Any = None):\n        \"\"\"å‘é€é€šçŸ¥ï¼ˆä¸éœ€è¦å“åº”ï¼‰\"\"\"\n        if not self.process or self.process_exited or self.process.returncode is not None:\n            return\n        \n        msg = {\n            'jsonrpc': '2.0',\n            'method': method,\n            'params': params\n        }\n        \n        content = json.dumps(msg)\n        header = f'Content-Length: {len(content.encode())}\\r\\n\\r\\n'\n        \n        try:\n            self.process.stdin.write((header + content).encode())\n        except:\n            pass\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 350,
"end": 579,
"text": "    def _respond(self, request_id: Any, result: Any):\n        \"\"\"å“åº”æœåŠ¡å™¨è¯·æ±‚\"\"\"\n        if not self.process or self.process_exited or self.process.returncode is not None:\n            return\n        \n        msg = {\n            'jsonrpc': '2.0',\n            'id': request_id,\n            'result': result\n        }\n        \n        content = json.dumps(msg)\n        header = f'Content-Length: {len(content.encode())}\\r\\n\\r\\n'\n        \n        try:\n            self.process.stdin.write((header + content).encode())\n        except:\n            pass\n    \n    async def initialize(self):\n        \"\"\"åˆå§‹åŒ–LSPæœåŠ¡å™¨\"\"\"\n        root_uri = self.root.as_uri()\n        \n        init_params = {\n            'processId': asyncio.subprocess.os.getpid(),\n            'rootUri': root_uri,\n            'rootPath': str(self.root),\n            'workspaceFolders': [{'uri': root_uri, 'name': 'workspace'}],\n            'capabilities': {\n                'textDocument': {\n                    'hover': {'contentFormat': ['markdown', 'plaintext']},\n                    'definition': {'linkSupport': True},\n                    'references': {},\n                    'documentSymbol': {'hierarchicalDocumentSymbolSupport': True},\n                    'publishDiagnostics': {},\n                    'rename': {\n                        'prepareSupport': True,\n                        'prepareSupportDefaultBehavior': 1,\n                        'honorsChangeAnnotations': True\n                    },\n                    'codeAction': {\n                        'codeActionLiteralSupport': {\n                            'codeActionKind': {\n                                'valueSet': [\n                                    'quickfix', 'refactor', 'refactor.extract',\n                                    'refactor.inline', 'refactor.rewrite',\n                                    'source', 'source.organizeImports', 'source.fixAll'\n                                ]\n                            }\n                        },\n                        'isPreferredSupport': True,\n                        'disabledSupport': True,\n                        'dataSupport': True,\n                        'resolveSupport': {'properties': ['edit', 'command']}\n                    }\n                },\n                'workspace': {\n                    'symbol': {},\n                    'workspaceFolders': True,\n                    'configuration': True,\n                    'applyEdit': True,\n                    'workspaceEdit': {'documentChanges': True}\n                }\n            }\n        }\n        \n        # åˆå¹¶è‡ªå®šä¹‰åˆå§‹åŒ–å‚æ•°\n        if self.server_config.initialization:\n            init_params.update(self.server_config.initialization)\n        \n        # å‘é€initializeè¯·æ±‚\n        await self._send('initialize', init_params)\n        \n        # å‘é€initializedé€šçŸ¥\n        self._notify('initialized')\n        \n        # å‘é€é…ç½®\n        self._notify('workspace/didChangeConfiguration', {\n            'settings': {'json': {'validate': {'enable': True}}}\n        })\n        \n        # ç­‰å¾…æœåŠ¡å™¨å‡†å¤‡å¥½\n        await asyncio.sleep(0.3)\n    \n    async def open_file(self, file_path: str):\n        \"\"\"æ‰“å¼€æ–‡ä»¶\"\"\"\n        abs_path = Path(file_path).resolve()\n        \n        if str(abs_path) in self.opened_files:\n            return\n        \n        # è¯»å–æ–‡ä»¶å†…å®¹\n        try:\n            text = abs_path.read_text(encoding='utf-8')\n        except Exception as e:\n            logger.warning(f\"Failed to read file {abs_path}: {e}\")\n            return\n        \n        # è·å–è¯­è¨€ID\n        ext = abs_path.suffix\n        language_id = EXT_TO_LANG.get(ext, 'plaintext')\n        \n        # å‘é€didOpené€šçŸ¥\n        self._notify('textDocument/didOpen', {\n            'textDocument': {\n                'uri': abs_path.as_uri(),\n                'languageId': language_id,\n                'version': 1,\n                'text': text\n            }\n        })\n        \n        self.opened_files.add(str(abs_path))\n        \n        # ç­‰å¾…è¯Šæ–­ä¿¡æ¯\n        await asyncio.sleep(1.0)\n    \n    async def definition(self,"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 580,
"end": 617,
"text": "    def is_alive(self) -> bool:\n        \"\"\"æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦å­˜æ´»\"\"\"\n        return (\n            self.process is not None and\n            not self.process_exited and\n            self.process.returncode is None\n        )\n    \n    async def stop(self):\n        \"\"\"åœæ­¢LSPæœåŠ¡å™¨\"\"\"\n        try:\n            self._notify('shutdown', {})\n            self._notify('exit')\n        except:\n            pass\n        \n        if self.process:\n            try:\n                self.process.terminate()\n                await asyncio.wait_for(self.process.wait(), timeout=5)\n            except asyncio.TimeoutError:\n                self.process.kill()\n            except:\n                pass\n        \n        # å–æ¶ˆè¯»å–ä»»åŠ¡\n        if self._read_task:\n            self._read_task.cancel()\n        if self._stderr_task:\n            self._stderr_task.cancel()\n        \n        self.process = None\n        self.process_exited = True\n        self.diagnostics_store.clear()\n\n\n# ========== LSPæœåŠ¡å™¨ç®¡ç†å™¨ ==========\n"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 618,
"end": 632,
"text": "class LSPServerManager:\n    \"\"\"\n    LSPæœåŠ¡å™¨ç®¡ç†å™¨ï¼ˆå•ä¾‹ï¼‰\n    \n    åŠŸèƒ½ï¼š\n    - ç®¡ç†å¤šä¸ªè¯­è¨€çš„LSPæœåŠ¡å™¨\n    - æœåŠ¡å™¨å¤ç”¨ï¼ˆé¿å…é‡å¤å¯åŠ¨ï¼‰\n    - è‡ªåŠ¨æ¸…ç†ç©ºé—²æœåŠ¡å™¨\n    - å¼•ç”¨è®¡æ•°ç®¡ç†\n    \n    å‚è€ƒï¼šoh-my-opencode/src/tools/lsp/client.ts (LSPServerManager)\n    \"\"\"\n    \n    _instance = None\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 633,
"end": 638,
"text": "    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 639,
"end": 653,
"text": "    def __init__(self):\n        if self._initialized:\n            return\n        \n        self.clients: Dict[str, Dict[str, Any]] = {}  # {key: {client, last_used, ref_count, init_promise}}\n        self.last_used: Dict[str, float] = {}\n        self.idle_timeout = 5 * 60  # 5åˆ†é’Ÿ\n        self._cleanup_task: Optional[asyncio.Task] = None\n        self._initialized = True\n        \n        # ä¸åœ¨åˆå§‹åŒ–æ—¶å¯åŠ¨æ¸…ç†ä»»åŠ¡ï¼Œè€Œæ˜¯åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶å¯åŠ¨\n        # self._start_cleanup_timer()\n        \n        logger.info(\"LSPæœåŠ¡å™¨ç®¡ç†å™¨å·²åˆå§‹åŒ–\")\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 654,
"end": 694,
"text": "    def _start_cleanup_timer(self):\n        \"\"\"å¯åŠ¨æ¸…ç†å®šæ—¶å™¨\"\"\"\n        try:\n            if self._cleanup_task is None or self._cleanup_task.done():\n                # åªåœ¨æœ‰è¿è¡Œçš„äº‹ä»¶å¾ªç¯æ—¶åˆ›å»ºä»»åŠ¡\n                loop = asyncio.get_running_loop()\n                self._cleanup_task = loop.create_task(self._cleanup_loop())\n        except RuntimeError:\n            # æ²¡æœ‰è¿è¡Œçš„äº‹ä»¶å¾ªç¯ï¼Œè·³è¿‡\n            pass\n    \n    async def _cleanup_loop(self):\n        \"\"\"æ¸…ç†å¾ªç¯\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(60)  # æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡\n                await self._cleanup_idle_clients()\n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Cleanup error: {e}\")\n    \n    async def _cleanup_idle_clients(self):\n        \"\"\"æ¸…ç†ç©ºé—²å®¢æˆ·ç«¯\"\"\"\n        import time\n        now = time.time()\n        \n        to_remove = []\n        for key, managed in list(self.clients.items()):\n            if managed['ref_count'] == 0:\n                last_used = managed['last_used']\n                if now - last_used > self.idle_timeout:\n                    to_remove.append(key)\n        \n        for key in to_remove:\n            managed = self.clients[key]\n            client = managed['client']\n            await client.stop()\n            del self.clients[key]\n            logger.info(f\"Cleaned up idle LSP client: {key}\")\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 695,
"end": 698,
"text": "    def _get_key(self, root: str, server_id: str) -> str:\n        \"\"\"ç”Ÿæˆå®¢æˆ·ç«¯key\"\"\"\n        return f\"{root}::{server_id}\"\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 699,
"end": 769,
"text": "    def find_server_for_extension(self, ext: str) -> Optional[LSPServerConfig]:\n        \"\"\"æ ¹æ®æ–‡ä»¶æ‰©å±•åæŸ¥æ‰¾LSPæœåŠ¡å™¨\"\"\"\n        for server_config in BUILTIN_LSP_SERVERS.values():\n            if ext in server_config.extensions:\n                # æ£€æŸ¥æ˜¯å¦å·²å®‰è£…\n                command = server_config.command[0]\n                if shutil.which(command):\n                    return server_config\n        \n        return None\n    \n    async def get_client(\n        self,\n        root: str,\n        server_config: LSPServerConfig\n    ) -> LSPClient:\n        \"\"\"è·å–æˆ–åˆ›å»ºLSPå®¢æˆ·ç«¯\"\"\"\n        # ç¡®ä¿æ¸…ç†ä»»åŠ¡å·²å¯åŠ¨\n        self._start_cleanup_timer()\n        \n        key = self._get_key(root, server_config.id)\n        \n        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨\n        if key in self.clients:\n            managed = self.clients[key]\n            \n            # ç­‰å¾…åˆå§‹åŒ–å®Œæˆ\n            if 'init_promise' in managed and managed['init_promise']:\n                await managed['init_promise']\n            \n            client = managed['client']\n            if client.is_alive():\n                import time\n                managed['ref_count'] += 1\n                managed['last_used'] = time.time()\n                return client\n            \n            # å®¢æˆ·ç«¯å·²æ­»äº¡ï¼Œæ¸…ç†\n            await client.stop()\n            del self.clients[key]\n        \n        # åˆ›å»ºæ–°å®¢æˆ·ç«¯\n        client = LSPClient(root, server_config)\n        \n        # åˆ›å»ºåˆå§‹åŒ–Promise\n        async def init_client():\n            await client.start()\n            await client.initialize()\n        \n        init_promise = asyncio.create_task(init_client())\n        \n        import time\n        self.clients[key] = {\n            'client': client,\n            'last_used': time.time(),\n            'ref_count': 1,\n            'init_promise': init_promise,\n            'is_initializing': True\n        }\n        \n        # ç­‰å¾…åˆå§‹åŒ–å®Œæˆ\n        await init_promise\n        \n        # æ¸…é™¤init_promise\n        self.clients[key]['init_promise'] = None\n        self.clients[key]['is_initializing'] = False\n        \n        logger.info(f\"LSPå®¢æˆ·ç«¯å·²å¯åŠ¨: {server_config.id} for {root}\")\n        \n        return client\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 770,
"end": 796,
"text": "    def release_client(self, root: str, server_id: str):\n        \"\"\"é‡Šæ”¾å®¢æˆ·ç«¯å¼•ç”¨\"\"\"\n        key = self._get_key(root, server_id)\n        if key in self.clients:\n            managed = self.clients[key]\n            if managed['ref_count'] > 0:\n                managed['ref_count'] -= 1\n                import time\n                managed['last_used'] = time.time()\n    \n    async def stop_all(self):\n        \"\"\"åœæ­¢æ‰€æœ‰LSPæœåŠ¡å™¨\"\"\"\n        for managed in self.clients.values():\n            client = managed['client']\n            await client.stop()\n        \n        self.clients.clear()\n        \n        if self._cleanup_task:\n            self._cleanup_task.cancel()\n            self._cleanup_task = None\n\n\n# å…¨å±€ç®¡ç†å™¨å®ä¾‹\n_lsp_manager = LSPServerManager()\n\n"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 797,
"end": 841,
"text": "def get_lsp_manager() -> LSPServerManager:\n    \"\"\"è·å–LSPç®¡ç†å™¨å•ä¾‹\"\"\"\n    return _lsp_manager\n\n\n# ========== è¾…åŠ©å‡½æ•° ==========\n\nasync def with_lsp_client(file_path: str, callback):\n    \"\"\"\n    ä½¿ç”¨LSPå®¢æˆ·ç«¯æ‰§è¡Œæ“ä½œçš„è¾…åŠ©å‡½æ•°\n    \n    å‚è€ƒï¼šoh-my-opencode/src/tools/lsp/utils.ts (withLspClient)\n    \"\"\"\n    file_path_obj = Path(file_path).resolve()\n    \n    if not file_path_obj.exists():\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n    \n    # æŸ¥æ‰¾LSPæœåŠ¡å™¨\n    ext = file_path_obj.suffix\n    manager = get_lsp_manager()\n    server_config = manager.find_server_for_extension(ext)\n    \n    if not server_config:\n        raise ValueError(f\"No LSP server found for {ext} files\")\n    \n    # æŸ¥æ‰¾é¡¹ç›®æ ¹ç›®å½•\n    root = file_path_obj.parent\n    while root.parent != root:\n        if (root / '.git').exists() or (root / 'package.json').exists() or (root / 'pyproject.toml').exists():\n            break\n        root = root.parent\n    \n    # è·å–LSPå®¢æˆ·ç«¯\n    client = await manager.get_client(str(root), server_config)\n    \n    try:\n        # æ‰§è¡Œå›è°ƒ\n        result = await callback(client)\n        return result\n    finally:\n        # é‡Šæ”¾å®¢æˆ·ç«¯\n        manager.release_client(str(root), server_config.id)\n\n"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 842,
"end": 874,
"text": "def format_location(location: Dict[str, Any]) -> str:\n    \"\"\"\n    æ ¼å¼åŒ–ä½ç½®ä¿¡æ¯\n    \n    å‚è€ƒï¼šoh-my-opencode/src/tools/lsp/utils.ts (formatLocation)\n    \"\"\"\n    if 'targetUri' in location:\n        # LocationLink\n        uri = location['targetUri']\n        range_info = location.get('targetRange', {})\n    else:\n        # Location\n        uri = location.get('uri', '')\n        range_info = location.get('range', {})\n    \n    # è§£æURI\n    from urllib.parse import urlparse, unquote\n    parsed = urlparse(uri)\n    file_path = unquote(parsed.path)\n    \n    # Windowsè·¯å¾„å¤„ç†\n    if file_path.startswith('/') and ':' in file_path[1:3]:\n        file_path = file_path[1:]\n    \n    start = range_info.get('start', {})\n    line = start.get('line', 0) + 1\n    char = start.get('character', 0)\n    \n    return f\"{file_path}:{line}:{char}\"\n\n\n# ========== LSPå·¥å…·å®ç° ==========\n"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 875,
"end": 881,
"text": "class LSPDiagnosticsTool(BaseTool):\n    \"\"\"\n    è·å–è¯Šæ–­ä¿¡æ¯ï¼ˆé”™è¯¯ã€è­¦å‘Šç­‰ï¼‰\n    \n    å‚è€ƒï¼šoh-my-opencode/src/tools/lsp/tools.ts (lsp_diagnostics)\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 882,
"end": 887,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"lsp_diagnostics\",\n            description=\"Get errors, warnings, hints from language server BEFORE running build\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 888,
"end": 1007,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        \"\"\"è·å–Function Calling schema\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"file_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"File path to check\"\n                    },\n                    \"severity\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"error\", \"warning\", \"information\", \"hint\", \"all\"],\n                        \"description\": \"Filter by severity level\",\n                        \"default\": \"all\"\n                    }\n                },\n                \"required\": [\"file_path\"]\n            }\n        }\n    \n    async def execute(\n        self,\n        file_path: str,\n        severity: str = \"all\"\n    ) -> ToolResult:\n        \"\"\"è·å–è¯Šæ–­ä¿¡æ¯\"\"\"\n        try:\n            file_path_obj = Path(file_path).resolve()\n            \n            if not file_path_obj.exists():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"File not found: {file_path}\"\n                )\n            \n            # æŸ¥æ‰¾LSPæœåŠ¡å™¨\n            ext = file_path_obj.suffix\n            manager = get_lsp_manager()\n            server_config = manager.find_server_for_extension(ext)\n            \n            if not server_config:\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"No LSP server found for {ext} files\"\n                )\n            \n            # è·å–LSPå®¢æˆ·ç«¯\n            root = file_path_obj.parent\n            while root.parent != root:\n                if (root / '.git').exists() or (root / 'package.json').exists():\n                    break\n                root = root.parent\n            \n            client = await manager.get_client(str(root), server_config)\n            \n            # è·å–è¯Šæ–­ä¿¡æ¯\n            result = await client.diagnostics(str(file_path_obj))\n            diagnostics = result.get('items', [])\n            \n            # è¿‡æ»¤ä¸¥é‡æ€§\n            if severity != \"all\":\n                severity_map = {'error': 1, 'warning': 2, 'information': 3, 'hint': 4}\n                target_severity = severity_map.get(severity)\n                if target_severity:\n                    diagnostics = [d for d in diagnostics if d.get('severity') == target_severity]\n            \n            # é™åˆ¶æ•°é‡\n            total = len(diagnostics)\n            if total > DEFAULT_MAX_DIAGNOSTICS:\n                diagnostics = diagnostics[:DEFAULT_MAX_DIAGNOSTICS]\n            \n            # æ ¼å¼åŒ–è¾“å‡º\n            if not diagnostics:\n                content = \"No diagnostics found\"\n            else:\n                lines = []\n                if total > DEFAULT_MAX_DIAGNOSTICS:\n                    lines.append(f\"Found {total} diagnostics (showing first {DEFAULT_MAX_DIAGNOSTICS}):\")\n                \n                for diag in diagnostics:\n                    range_info = diag.get('range', {})\n                    start = range_info.get('start', {})\n                    line = start.get('line', 0) + 1\n                    char = start.get('character', 0)\n                    severity_num = diag.get('severity', 1)\n                    severity_name = {1: 'error', 2: 'warning', 3: 'info', 4: 'hint'}.get(severity_num, 'unknown')\n                    message = diag.get('message', '')\n                    \n                    lines.append(f\"[{severity_name}] Line {line}:{char} - {message}\")\n                \n                content = '\\n'.join(lines)\n            \n            # é‡Šæ”¾å®¢æˆ·ç«¯\n            manager.release_client(str(root), server_config.id)\n            \n            return ToolResult(\n                success=True,\n                content=content,\n                metadata={\n                    'file_path': str(file_path_obj),\n                    'severity': s"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1008,
"end": 1014,
"text": "class LSPGotoDefinitionTool(BaseTool):\n    \"\"\"\n    è·³è½¬åˆ°å®šä¹‰\n    \n    å‚è€ƒï¼šoh-my-opencode/src/tools/lsp/tools.ts (lsp_goto_definition)\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1015,
"end": 1020,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"lsp_goto_definition\",\n            description=\"Jump to symbol definition. Find WHERE something is defined\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1021,
"end": 1097,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        \"\"\"è·å–Function Calling schema\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"file_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"File path\"\n                    },\n                    \"line\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Line number (1-based)\",\n                        \"minimum\": 1\n                    },\n                    \"character\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Character position (0-based)\",\n                        \"minimum\": 0\n                    }\n                },\n                \"required\": [\"file_path\", \"line\", \"character\"]\n            }\n        }\n    \n    async def execute(\n        self,\n        file_path: str,\n        line: int,\n        character: int\n    ) -> ToolResult:\n        \"\"\"è·³è½¬åˆ°å®šä¹‰\"\"\"\n        try:\n            result = await with_lsp_client(file_path, lambda client: client.definition(file_path, line, character))\n            \n            if not result:\n                return ToolResult(\n                    success=True,\n                    content=\"No definition found\",\n                    metadata={'file_path': file_path, 'line': line, 'character': character}\n                )\n            \n            # å¤„ç†ç»“æœï¼ˆå¯èƒ½æ˜¯Locationã€Location[]æˆ–LocationLink[]ï¼‰\n            locations = result if isinstance(result, list) else [result]\n            \n            if not locations:\n                return ToolResult(\n                    success=True,\n                    content=\"No definition found\",\n                    metadata={'file_path': file_path, 'line': line, 'character': character}\n                )\n            \n            # æ ¼å¼åŒ–è¾“å‡º\n            content = '\\n'.join(format_location(loc) for loc in locations)\n            \n            return ToolResult(\n                success=True,\n                content=content,\n                metadata={\n                    'file_path': file_path,\n                    'line': line,\n                    'character': character,\n                    'count': len(locations)\n                }\n            )\n            \n        except Exception as e:\n            logger.error(f\"LSP goto definition failed: {e}\", exc_info=True)\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n\n"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1098,
"end": 1104,
"text": "class LSPFindReferencesTool(BaseTool):\n    \"\"\"\n    æŸ¥æ‰¾å¼•ç”¨\n    \n    å‚è€ƒï¼šoh-my-opencode/src/tools/lsp/tools.ts (lsp_find_references)\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1105,
"end": 1110,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"lsp_find_references\",\n            description=\"Find ALL usages/references of a symbol across the entire workspace\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1111,
"end": 1198,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        \"\"\"è·å–Function Calling schema\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"file_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"File path\"\n                    },\n                    \"line\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Line number (1-based)\",\n                        \"minimum\": 1\n                    },\n                    \"character\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Character position (0-based)\",\n                        \"minimum\": 0\n                    },\n                    \"include_declaration\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Include the declaration itself\",\n                        \"default\": True\n                    }\n                },\n                \"required\": [\"file_path\", \"line\", \"character\"]\n            }\n        }\n    \n    async def execute(\n        self,\n        file_path: str,\n        line: int,\n        character: int,\n        include_declaration: bool = True\n    ) -> ToolResult:\n        \"\"\"æŸ¥æ‰¾å¼•ç”¨\"\"\"\n        try:\n            result = await with_lsp_client(\n                file_path,\n                lambda client: client.references(file_path, line, character, include_declaration)\n            )\n            \n            if not result or len(result) == 0:\n                return ToolResult(\n                    success=True,\n                    content=\"No references found\",\n                    metadata={'file_path': file_path, 'line': line, 'character': character}\n                )\n            \n            # é™åˆ¶æ•°é‡\n            total = len(result)\n            truncated = total > DEFAULT_MAX_REFERENCES\n            limited = result[:DEFAULT_MAX_REFERENCES] if truncated else result\n            \n            # æ ¼å¼åŒ–è¾“å‡º\n            lines = []\n            if truncated:\n                lines.append(f\"Found {total} references (showing first {DEFAULT_MAX_REFERENCES}):\")\n            \n            lines.extend(format_location(loc) for loc in limited)\n            content = '\\n'.join(lines)\n            \n            return ToolResult(\n                success=True,\n                content=content,\n                metadata={\n                    'file_path': file_path,\n                    'line': line,\n                    'character': character,\n                    'include_declaration': include_declaration,\n                    'total_count': total,\n                    'shown_count': len(limited)\n                }\n            )\n            \n        except Exception as e:\n            logger.error(f\"LSP find references failed: {e}\", exc_info=True)\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n\n"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1199,
"end": 1205,
"text": "class LSPSymbolsTool(BaseTool):\n    \"\"\"\n    è·å–ç¬¦å·åˆ—è¡¨\n    \n    å‚è€ƒï¼šoh-my-opencode/src/tools/lsp/tools.ts (lsp_symbols)\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1206,
"end": 1211,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"lsp_symbols\",\n            description=\"Get symbols from file (document) or search across workspace\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1212,
"end": 1330,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        \"\"\"è·å–Function Calling schema\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"file_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"File path for LSP context\"\n                    },\n                    \"scope\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"document\", \"workspace\"],\n                        \"description\": \"'document' for file symbols, 'workspace' for project-wide search\",\n                        \"default\": \"document\"\n                    },\n                    \"query\": {\n                        \"type\": \"string\",\n                        \"description\": \"Symbol name to search (required for workspace scope)\"\n                    },\n                    \"limit\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Max results (default 50)\",\n                        \"default\": 50\n                    }\n                },\n                \"required\": [\"file_path\"]\n            }\n        }\n    \n    async def execute(\n        self,\n        file_path: str,\n        scope: str = \"document\",\n        query: Optional[str] = None,\n        limit: int = 50\n    ) -> ToolResult:\n        \"\"\"è·å–ç¬¦å·åˆ—è¡¨\"\"\"\n        try:\n            if scope == \"workspace\" and not query:\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=\"'query' is required for workspace scope\"\n                )\n            \n            if scope == \"workspace\":\n                # å·¥ä½œåŒºç¬¦å·æœç´¢\n                result = await with_lsp_client(\n                    file_path,\n                    lambda client: client.workspace_symbols(query)\n                )\n            else:\n                # æ–‡æ¡£ç¬¦å·\n                result = await with_lsp_client(\n                    file_path,\n                    lambda client: client.document_symbols(file_path)\n                )\n            \n            if not result or len(result) == 0:\n                return ToolResult(\n                    success=True,\n                    content=\"No symbols found\",\n                    metadata={'file_path': file_path, 'scope': scope}\n                )\n            \n            # é™åˆ¶æ•°é‡\n            total = len(result)\n            limit = min(limit, DEFAULT_MAX_SYMBOLS)\n            truncated = total > limit\n            limited = result[:limit] if truncated else result\n            \n            # æ ¼å¼åŒ–è¾“å‡º\n            lines = []\n            if truncated:\n                lines.append(f\"Found {total} symbols (showing first {limit}):\")\n            \n            # å¤„ç†ä¸åŒçš„ç¬¦å·æ ¼å¼\n            for symbol in limited:\n                if 'range' in symbol:\n                    # DocumentSymbol\n                    name = symbol.get('name', '')\n                    kind = symbol.get('kind', 0)\n                    range_info = symbol.get('range', {})\n                    start = range_info.get('start', {})\n                    line = start.get('line', 0) + 1\n                    lines.append(f\"{name} (kind: {kind}, line: {line})\")\n                elif 'location' in symbol:\n                    # SymbolInfo\n                    name = symbol.get('name', '')\n                    kind = symbol.get('kind', 0)\n                    location = format_location(symbol['location'])\n                    lines.append(f\"{name} (kind: {kind}) - {location}\")\n            \n            content = '\\n'.join(lines)\n            \n            return ToolResult(\n                success=True,\n                content=content,\n                metadata={\n                    'file_path': file_path,\n                    'scope': scope,\n                    'query': query,\n                    'total_count': total,\n                    'shown_count': len(limited)\n                }\n            )\n"
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1331,
"end": 1337,
"text": "class LSPRenameTool(BaseTool):\n    \"\"\"\n    é‡å‘½åç¬¦å·\n    \n    å‚è€ƒï¼šoh-my-opencode/src/tools/lsp/tools.ts (lsp_rename)\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1338,
"end": 1343,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"lsp_rename\",\n            description=\"Rename symbol across entire workspace. APPLIES changes to all files\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1344,
"end": 1456,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        \"\"\"è·å–Function Calling schema\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"file_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"File path\"\n                    },\n                    \"line\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Line number (1-based)\",\n                        \"minimum\": 1\n                    },\n                    \"character\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Character position (0-based)\",\n                        \"minimum\": 0\n                    },\n                    \"new_name\": {\n                        \"type\": \"string\",\n                        \"description\": \"New symbol name\"\n                    }\n                },\n                \"required\": [\"file_path\", \"line\", \"character\", \"new_name\"]\n            }\n        }\n    \n    async def execute(\n        self,\n        file_path: str,\n        line: int,\n        character: int,\n        new_name: str\n    ) -> ToolResult:\n        \"\"\"é‡å‘½åç¬¦å·\"\"\"\n        try:\n            result = await with_lsp_client(\n                file_path,\n                lambda client: client.rename(file_path, line, character, new_name)\n            )\n            \n            if not result:\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=\"Rename not supported at this location\"\n                )\n            \n            # å¤„ç†WorkspaceEdit\n            changes_count = 0\n            files_changed = set()\n            \n            if 'changes' in result:\n                # changes: {uri: TextEdit[]}\n                for uri, edits in result['changes'].items():\n                    changes_count += len(edits)\n                    # è§£æURIè·å–æ–‡ä»¶è·¯å¾„\n                    from urllib.parse import urlparse, unquote\n                    parsed = urlparse(uri)\n                    file_path_str = unquote(parsed.path)\n                    if file_path_str.startswith('/') and ':' in file_path_str[1:3]:\n                        file_path_str = file_path_str[1:]\n                    files_changed.add(file_path_str)\n            \n            if 'documentChanges' in result:\n                # documentChanges: TextDocumentEdit[]\n                for change in result['documentChanges']:\n                    if 'textDocument' in change:\n                        uri = change['textDocument']['uri']\n                        edits = change.get('edits', [])\n                        changes_count += len(edits)\n                        # è§£æURI\n                        from urllib.parse import urlparse, unquote\n                        parsed = urlparse(uri)\n                        file_path_str = unquote(parsed.path)\n                        if file_path_str.startswith('/') and ':' in file_path_str[1:3]:\n                            file_path_str = file_path_str[1:]\n                        files_changed.add(file_path_str)\n            \n            content = (\n                f\"Rename successful:\\n\"\n                f\"- Files changed: {len(files_changed)}\\n\"\n                f\"- Total edits: {changes_count}\\n\"\n                f\"- New name: {new_name}\\n\\n\"\n                f\"Files:\\n\" + '\\n'.join(f\"  - {f}\" for f in sorted(files_changed))\n            )\n            \n            return ToolResult(\n                success=True,\n                content=content,\n                metadata={\n                    'file_path': file_path,\n                    'line': line,\n                    'character': character,\n                    'new_name': new_name,\n                    'files_changed': list(files_changed),\n                    'changes_count': changes_count\n                }\n            )\n            \n        except Exception "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1457,
"end": 1463,
"text": "class LSPCodeActionsTool(BaseTool):\n    \"\"\"\n    è·å–ä»£ç æ“ä½œï¼ˆå¿«é€Ÿä¿®å¤ç­‰ï¼‰\n    \n    å‚è€ƒï¼šoh-my-opencode/src/tools/lsp/tools.ts (lsp_code_actions)\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1464,
"end": 1469,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"lsp_code_actions\",\n            description=\"Get available code actions (quick fixes, refactorings) for a location\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/lsp_tools.py",
"start": 1470,
"end": 1544,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        \"\"\"è·å–Function Calling schema\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"file_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"File path\"\n                    },\n                    \"line\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Line number (1-based)\",\n                        \"minimum\": 1\n                    },\n                    \"character\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Character position (0-based)\",\n                        \"minimum\": 0\n                    }\n                },\n                \"required\": [\"file_path\", \"line\", \"character\"]\n            }\n        }\n    \n    async def execute(\n        self,\n        file_path: str,\n        line: int,\n        character: int\n    ) -> ToolResult:\n        \"\"\"è·å–ä»£ç æ“ä½œ\"\"\"\n        try:\n            result = await with_lsp_client(\n                file_path,\n                lambda client: client.code_actions(file_path, line, character)\n            )\n            \n            if not result or len(result) == 0:\n                return ToolResult(\n                    success=True,\n                    content=\"No code actions available\",\n                    metadata={'file_path': file_path, 'line': line, 'character': character}\n                )\n            \n            # æ ¼å¼åŒ–è¾“å‡º\n            lines = [f\"Found {len(result)} code actions:\"]\n            \n            for i, action in enumerate(result, 1):\n                title = action.get('title', 'Untitled')\n                kind = action.get('kind', 'unknown')\n                lines.append(f\"{i}. [{kind}] {title}\")\n            \n            content = '\\n'.join(lines)\n            \n            return ToolResult(\n                success=True,\n                content=content,\n                metadata={\n                    'file_path': file_path,\n                    'line': line,\n                    'character': character,\n                    'count': len(result)\n                }\n            )\n            \n        except Exception as e:\n            logger.error(f\"LSP code actions failed: {e}\", exc_info=True)\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )"
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 1,
"end": 14,
"text": "\"\"\"\nå·¥å…·åå¤„ç†å™¨\n\nåœ¨å·¥å…·æ‰§è¡Œåï¼ŒåŸºäºç”¨æˆ·æ„å›¾æ™ºèƒ½ä¼˜åŒ–ç»“æœ\n\"\"\"\n\nfrom typing import Dict, Any, List, Optional\nimport re\nimport logging\nfrom .base import ToolResult\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 15,
"end": 24,
"text": "class ToolPostProcessor:\n    \"\"\"\n    å·¥å…·åå¤„ç†å™¨åŸºç±»\n    \n    èŒè´£ï¼š\n    - æ ¹æ®ç”¨æˆ·é—®é¢˜ä¼˜åŒ–å·¥å…·ç»“æœ\n    - å‡å°‘æ— å…³ä¿¡æ¯\n    - æå‡ç›¸å…³æ€§\n    \"\"\"\n    "
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 25,
"end": 68,
"text": "    def __init__(self):\n        self.processors = {\n            'repo_map': RepoMapPostProcessor(),\n            'text_search': SearchPostProcessor(),\n            'regex_search': SearchPostProcessor(),\n            'read_file': ReadFilePostProcessor(),\n            'get_repo_structure': StructurePostProcessor(),\n        }\n    \n    async def process(\n        self,\n        tool_name: str,\n        result: ToolResult,\n        user_query: str,\n        context: Optional[Dict[str, Any]] = None\n    ) -> ToolResult:\n        \"\"\"\n        å¤„ç†å·¥å…·ç»“æœ\n        \n        Args:\n            tool_name: å·¥å…·åç§°\n            result: åŸå§‹å·¥å…·ç»“æœ\n            user_query: ç”¨æˆ·é—®é¢˜\n            context: ä¸Šä¸‹æ–‡ä¿¡æ¯\n        \n        Returns:\n            ä¼˜åŒ–åçš„å·¥å…·ç»“æœ\n        \"\"\"\n        if not result.success:\n            return result\n        \n        processor = self.processors.get(tool_name)\n        if not processor:\n            return result  # æ²¡æœ‰ä¸“é—¨çš„å¤„ç†å™¨ï¼Œè¿”å›åŸç»“æœ\n        \n        try:\n            processed = await processor.process(result, user_query, context or {})\n            logger.info(f\"å·¥å…· {tool_name} åå¤„ç†å®Œæˆ\")\n            return processed\n        except Exception as e:\n            logger.error(f\"å·¥å…· {tool_name} åå¤„ç†å¤±è´¥: {e}\", exc_info=True)\n            return result  # å¤±è´¥æ—¶è¿”å›åŸç»“æœ\n\n"
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 69,
"end": 80,
"text": "class BasePostProcessor:\n    \"\"\"åå¤„ç†å™¨åŸºç±»\"\"\"\n    \n    async def process(\n        self,\n        result: ToolResult,\n        user_query: str,\n        context: Dict[str, Any]\n    ) -> ToolResult:\n        \"\"\"å¤„ç†ç»“æœï¼ˆå­ç±»å®ç°ï¼‰\"\"\"\n        raise NotImplementedError\n    "
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 81,
"end": 135,
"text": "    def extract_keywords(self, query: str, max_keywords: int = 5) -> List[str]:\n        \"\"\"\n        æå–å…³é”®è¯\n        \n        ç­–ç•¥ï¼š\n        1. åˆ†è¯ï¼ˆæ”¯æŒä¸­è‹±æ–‡ï¼‰\n        2. ç§»é™¤åœç”¨è¯\n        3. ç§»é™¤çŸ­è¯ï¼ˆ<2å­—ç¬¦ï¼‰\n        4. è¿”å›å‰Nä¸ª\n        \"\"\"\n        # åœç”¨è¯\n        stop_words = {\n            # ä¸­æ–‡\n            'çš„', 'æ˜¯', 'åœ¨', 'æœ‰', 'å’Œ', 'äº†', 'å—', 'å‘¢', 'å•Š', 'è¿™', 'é‚£',\n            'æˆ‘', 'ä½ ', 'ä»–', 'å¥¹', 'å®ƒ', 'ä»¬', 'ä¸ª', 'ä¸­', 'ä¸º', 'ä¸', 'åŠ',\n            'æˆ–', 'ä½†', 'è€Œ', 'ç­‰', 'å¦‚', 'ä»', 'åˆ°', 'å¯¹', 'äº', 'ç»™', 'æŠŠ',\n            'æ€ä¹ˆ', 'å¦‚ä½•', 'ä»€ä¹ˆ', 'å“ªé‡Œ', 'å“ªä¸ª', 'ä¸ºä»€ä¹ˆ', 'å¤šå°‘', 'æ€æ ·',\n            # è‹±æ–‡\n            'the', 'is', 'in', 'at', 'of', 'and', 'a', 'an', 'to', 'for',\n            'with', 'on', 'by', 'from', 'as', 'or', 'but', 'if', 'this',\n            'that', 'what', 'which', 'who', 'where', 'when', 'how', 'why',\n        }\n        \n        # åˆ†è¯ï¼ˆæ”¯æŒä¸­è‹±æ–‡æ··åˆï¼‰\n        # 1. å…ˆæå–è‹±æ–‡å•è¯\n        words = []\n        \n        # æå–è‹±æ–‡å•è¯å’Œæ•°å­—\n        import re\n        english_words = re.findall(r'[a-zA-Z]+', query)\n        words.extend([w.lower() for w in english_words if len(w) >= 2])\n        \n        # æå–ä¸­æ–‡è¯ï¼ˆç®€å•æŒ‰å­—ç¬¦åˆ†å‰²ï¼Œå®é™…åº”è¯¥ç”¨åˆ†è¯åº“ï¼‰\n        chinese_chars = re.findall(r'[\\u4e00-\\u9fff]+', query)\n        for chars in chinese_chars:\n            # ç®€å•çš„ä¸­æ–‡åˆ†è¯ï¼šæå–2-4å­—çš„è¯\n            for i in range(len(chars)):\n                for length in [4, 3, 2]:  # ä¼˜å…ˆæå–é•¿è¯\n                    if i + length <= len(chars):\n                        word = chars[i:i+length]\n                        if word not in stop_words:\n                            words.append(word)\n        \n        # å»é‡å¹¶è¿‡æ»¤\n        seen = set()\n        keywords = []\n        for w in words:\n            if w not in stop_words and w not in seen and len(w) >= 2:\n                keywords.append(w)\n                seen.add(w)\n                if len(keywords) >= max_keywords:\n                    break\n        \n        return keywords\n    "
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 136,
"end": 151,
"text": "    def calculate_relevance(self, text: str, keywords: List[str]) -> float:\n        \"\"\"\n        è®¡ç®—æ–‡æœ¬ä¸å…³é”®è¯çš„ç›¸å…³æ€§\n        \n        Returns:\n            0.0 - 1.0 çš„ç›¸å…³æ€§åˆ†æ•°\n        \"\"\"\n        if not keywords:\n            return 1.0\n        \n        text_lower = text.lower()\n        matches = sum(1 for kw in keywords if kw in text_lower)\n        \n        return matches / len(keywords)\n\n"
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 152,
"end": 220,
"text": "class RepoMapPostProcessor(BasePostProcessor):\n    \"\"\"\n    RepoMapåå¤„ç†å™¨\n    \n    ç­–ç•¥ï¼š\n    1. æå–å…³é”®è¯\n    2. åªä¿ç•™ç›¸å…³çš„æ–‡ä»¶\n    3. é™åˆ¶æ–‡ä»¶æ•°é‡\n    \"\"\"\n    \n    async def process(\n        self,\n        result: ToolResult,\n        user_query: str,\n        context: Dict[str, Any]\n    ) -> ToolResult:\n        \"\"\"å¤„ç†RepoMapç»“æœ\"\"\"\n        if not isinstance(result.content, str):\n            return result\n        \n        # æå–å…³é”®è¯\n        keywords = self.extract_keywords(user_query)\n        \n        if not keywords:\n            return result  # æ²¡æœ‰å…³é”®è¯ï¼Œè¿”å›åŸç»“æœ\n        \n        # è§£æRepoMapï¼ˆæŒ‰æ–‡ä»¶åˆ†ç»„ï¼‰\n        files = self._parse_repo_map(result.content)\n        \n        # è®¡ç®—æ¯ä¸ªæ–‡ä»¶çš„ç›¸å…³æ€§\n        scored_files = []\n        for file_header, file_content in files:\n            relevance = self.calculate_relevance(\n                file_header + '\\n' + file_content,\n                keywords\n            )\n            scored_files.append((file_header, file_content, relevance))\n        \n        # è¿‡æ»¤ä½ç›¸å…³æ€§çš„æ–‡ä»¶\n        threshold = 0.2  # è‡³å°‘åŒ¹é…20%çš„å…³é”®è¯\n        relevant_files = [\n            (header, content) for header, content, score in scored_files\n            if score >= threshold\n        ]\n        \n        # å¦‚æœè¿‡æ»¤åå¤ªå°‘ï¼Œä¿ç•™åŸç»“æœ\n        if len(relevant_files) < 3:\n            return result\n        \n        # é™åˆ¶æ•°é‡ï¼ˆæœ€å¤š20ä¸ªæ–‡ä»¶ï¼‰\n        relevant_files = relevant_files[:20]\n        \n        # é‡æ–°æ ¼å¼åŒ–\n        filtered_content = self._format_repo_map(relevant_files)\n        \n        # æ›´æ–°ç»“æœ\n        result.content = filtered_content\n        result.metadata['post_processed'] = True\n        result.metadata['keywords'] = keywords\n        result.metadata['original_files'] = len(files)\n        result.metadata['filtered_files'] = len(relevant_files)\n        \n        logger.info(\n            f\"RepoMapè¿‡æ»¤: {len(files)} -> {len(relevant_files)} æ–‡ä»¶ \"\n            f\"(å…³é”®è¯: {', '.join(keywords)})\"\n        )\n        \n        return result\n    "
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 221,
"end": 249,
"text": "    def _parse_repo_map(self, content: str) -> List[tuple]:\n        \"\"\"\n        è§£æRepoMapå†…å®¹\n        \n        Returns:\n            [(file_header, file_content), ...]\n        \"\"\"\n        files = []\n        lines = content.splitlines()\n        \n        current_file = None\n        current_content = []\n        \n        for line in lines:\n            # æ–‡ä»¶å¤´ï¼ˆåŒ…å«å†’å·ï¼‰\n            if ':' in line and not line.startswith('  '):\n                if current_file:\n                    files.append((current_file, '\\n'.join(current_content)))\n                current_file = line\n                current_content = []\n            else:\n                current_content.append(line)\n        \n        # æ·»åŠ æœ€åä¸€ä¸ªæ–‡ä»¶\n        if current_file:\n            files.append((current_file, '\\n'.join(current_content)))\n        \n        return files\n    "
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 250,
"end": 260,
"text": "    def _format_repo_map(self, files: List[tuple]) -> str:\n        \"\"\"æ ¼å¼åŒ–RepoMap\"\"\"\n        lines = [f\"# ä»£ç åœ°å›¾ (Top {len(files)} ç›¸å…³æ–‡ä»¶)\\n\"]\n        \n        for file_header, file_content in files:\n            lines.append(file_header)\n            lines.append(file_content)\n        \n        return '\\n'.join(lines)\n\n"
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 261,
"end": 317,
"text": "class SearchPostProcessor(BasePostProcessor):\n    \"\"\"\n    æœç´¢ç»“æœåå¤„ç†å™¨\n    \n    ç­–ç•¥ï¼š\n    1. å»é‡ï¼ˆç›¸ä¼¼çš„ç»“æœï¼‰\n    2. æŒ‰ç›¸å…³æ€§æ’åº\n    3. é™åˆ¶æ•°é‡\n    \"\"\"\n    \n    async def process(\n        self,\n        result: ToolResult,\n        user_query: str,\n        context: Dict[str, Any]\n    ) -> ToolResult:\n        \"\"\"å¤„ç†æœç´¢ç»“æœ\"\"\"\n        if not isinstance(result.content, str):\n            return result\n        \n        # æå–å…³é”®è¯\n        keywords = self.extract_keywords(user_query)\n        \n        # è§£ææœç´¢ç»“æœ\n        matches = self._parse_search_results(result.content)\n        \n        if len(matches) <= 10:\n            return result  # ç»“æœä¸å¤šï¼Œä¸éœ€è¦è¿‡æ»¤\n        \n        # è®¡ç®—ç›¸å…³æ€§\n        scored_matches = []\n        for match in matches:\n            relevance = self.calculate_relevance(match, keywords)\n            scored_matches.append((match, relevance))\n        \n        # æ’åº\n        scored_matches.sort(key=lambda x: x[1], reverse=True)\n        \n        # å–å‰10ä¸ª\n        top_matches = [match for match, _ in scored_matches[:10]]\n        \n        # é‡æ–°æ ¼å¼åŒ–\n        filtered_content = '\\n\\n'.join(top_matches)\n        \n        # æ›´æ–°ç»“æœ\n        result.content = filtered_content\n        result.metadata['post_processed'] = True\n        result.metadata['keywords'] = keywords\n        result.metadata['original_matches'] = len(matches)\n        result.metadata['filtered_matches'] = len(top_matches)\n        \n        logger.info(\n            f\"æœç´¢ç»“æœè¿‡æ»¤: {len(matches)} -> {len(top_matches)} ä¸ªåŒ¹é…\"\n        )\n        \n        return result\n    "
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 318,
"end": 336,
"text": "    def _parse_search_results(self, content: str) -> List[str]:\n        \"\"\"\n        è§£ææœç´¢ç»“æœ\n        \n        å‡è®¾æ ¼å¼ï¼š\n        file1.py:10: match content\n        file1.py:20: match content\n        \n        æˆ–è€…æŒ‰ç©ºè¡Œåˆ†éš”çš„å—\n        \"\"\"\n        # å°è¯•æŒ‰ç©ºè¡Œåˆ†éš”\n        blocks = content.split('\\n\\n')\n        if len(blocks) > 1:\n            return blocks\n        \n        # å¦åˆ™æŒ‰è¡Œåˆ†éš”\n        return content.splitlines()\n\n"
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 337,
"end": 403,
"text": "class ReadFilePostProcessor(BasePostProcessor):\n    \"\"\"\n    æ–‡ä»¶å†…å®¹åå¤„ç†å™¨\n    \n    ç­–ç•¥ï¼š\n    1. æå–ç›¸å…³çš„å‡½æ•°/ç±»\n    2. æŠ˜å æ— å…³ä»£ç \n    \"\"\"\n    \n    async def process(\n        self,\n        result: ToolResult,\n        user_query: str,\n        context: Dict[str, Any]\n    ) -> ToolResult:\n        \"\"\"å¤„ç†æ–‡ä»¶å†…å®¹\"\"\"\n        if not isinstance(result.content, str):\n            return result\n        \n        # æå–å…³é”®è¯\n        keywords = self.extract_keywords(user_query)\n        \n        if not keywords:\n            return result\n        \n        # æŒ‰å‡½æ•°/ç±»åˆ†å‰²ï¼ˆç®€å•å®ç°ï¼‰\n        sections = self._split_into_sections(result.content)\n        \n        if len(sections) <= 1:\n            return result  # æ— æ³•åˆ†å‰²ï¼Œè¿”å›åŸç»“æœ\n        \n        # è®¡ç®—æ¯ä¸ªsectionçš„ç›¸å…³æ€§\n        scored_sections = []\n        for section in sections:\n            relevance = self.calculate_relevance(section, keywords)\n            scored_sections.append((section, relevance))\n        \n        # è¿‡æ»¤ä½ç›¸å…³æ€§çš„section\n        threshold = 0.2\n        relevant_sections = [\n            section for section, score in scored_sections\n            if score >= threshold\n        ]\n        \n        if not relevant_sections:\n            return result  # æ²¡æœ‰ç›¸å…³sectionï¼Œè¿”å›åŸç»“æœ\n        \n        # é‡æ–°ç»„åˆ\n        filtered_content = '\\n\\n'.join(relevant_sections)\n        \n        # å¦‚æœè¿‡æ»¤åå¤ªçŸ­ï¼Œè¿”å›åŸç»“æœ\n        if len(filtered_content) < len(result.content) * 0.3:\n            return result\n        \n        # æ›´æ–°ç»“æœ\n        result.content = filtered_content\n        result.metadata['post_processed'] = True\n        result.metadata['keywords'] = keywords\n        result.metadata['original_sections'] = len(sections)\n        result.metadata['filtered_sections'] = len(relevant_sections)\n        \n        logger.info(\n            f\"æ–‡ä»¶å†…å®¹è¿‡æ»¤: {len(sections)} -> {len(relevant_sections)} ä¸ªsection\"\n        )\n        \n        return result\n    "
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 404,
"end": 434,
"text": "    def _split_into_sections(self, content: str) -> List[str]:\n        \"\"\"\n        å°†æ–‡ä»¶å†…å®¹åˆ†å‰²æˆsections\n        \n        ç®€å•ç­–ç•¥ï¼šæŒ‰å‡½æ•°/ç±»å®šä¹‰åˆ†å‰²\n        \"\"\"\n        lines = content.splitlines()\n        sections = []\n        current_section = []\n        \n        for line in lines:\n            # æ£€æµ‹å‡½æ•°/ç±»å®šä¹‰\n            if (line.startswith('def ') or \n                line.startswith('class ') or\n                line.startswith('function ') or\n                line.startswith('const ') or\n                line.startswith('export ')):\n                \n                if current_section:\n                    sections.append('\\n'.join(current_section))\n                current_section = [line]\n            else:\n                current_section.append(line)\n        \n        # æ·»åŠ æœ€åä¸€ä¸ªsection\n        if current_section:\n            sections.append('\\n'.join(current_section))\n        \n        return sections\n\n"
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 435,
"end": 493,
"text": "class StructurePostProcessor(BasePostProcessor):\n    \"\"\"\n    ç›®å½•ç»“æ„åå¤„ç†å™¨\n    \n    ç­–ç•¥ï¼š\n    1. åªä¿ç•™ç›¸å…³çš„ç›®å½•\n    2. æŠ˜å æ·±å±‚ç›®å½•\n    \"\"\"\n    \n    async def process(\n        self,\n        result: ToolResult,\n        user_query: str,\n        context: Dict[str, Any]\n    ) -> ToolResult:\n        \"\"\"å¤„ç†ç›®å½•ç»“æ„\"\"\"\n        if not isinstance(result.content, str):\n            return result\n        \n        # æå–å…³é”®è¯\n        keywords = self.extract_keywords(user_query)\n        \n        if not keywords:\n            return result\n        \n        # æŒ‰è¡Œè¿‡æ»¤\n        lines = result.content.splitlines()\n        filtered_lines = []\n        \n        for line in lines:\n            # è®¡ç®—ç›¸å…³æ€§\n            relevance = self.calculate_relevance(line, keywords)\n            \n            # ä¿ç•™ç›¸å…³çš„è¡Œï¼Œæˆ–è€…æ˜¯ç›®å½•ç»“æ„çš„å¿…è¦éƒ¨åˆ†\n            if relevance > 0 or line.strip().endswith('/'):\n                filtered_lines.append(line)\n        \n        if len(filtered_lines) < len(lines) * 0.5:\n            # è¿‡æ»¤å¤ªå¤šï¼Œè¿”å›åŸç»“æœ\n            return result\n        \n        # æ›´æ–°ç»“æœ\n        result.content = '\\n'.join(filtered_lines)\n        result.metadata['post_processed'] = True\n        result.metadata['keywords'] = keywords\n        result.metadata['original_lines'] = len(lines)\n        result.metadata['filtered_lines'] = len(filtered_lines)\n        \n        logger.info(\n            f\"ç›®å½•ç»“æ„è¿‡æ»¤: {len(lines)} -> {len(filtered_lines)} è¡Œ\"\n        )\n        \n        return result\n\n\n# å…¨å±€å•ä¾‹\n_postprocessor = None\n\n"
},
{
"path": "daoyoucode/agents/tools/postprocessor.py",
"start": 494,
"end": 499,
"text": "def get_tool_postprocessor() -> ToolPostProcessor:\n    \"\"\"è·å–å·¥å…·åå¤„ç†å™¨ï¼ˆå•ä¾‹ï¼‰\"\"\"\n    global _postprocessor\n    if _postprocessor is None:\n        _postprocessor = ToolPostProcessor()\n    return _postprocessor"
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 1,
"end": 16,
"text": "\"\"\"\né¡¹ç›®æ–‡æ¡£å·¥å…· - è‡ªåŠ¨å‘ç°å’Œè¯»å–é¡¹ç›®æ–‡æ¡£\n\nç”¨äºé¡¹ç›®ç†è§£çš„ç¬¬ä¸€é˜¶æ®µï¼šæ–‡æ¡£å±‚\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nimport logging\nimport json\n\nfrom .base import BaseTool, ToolResult\n\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 17,
"end": 51,
"text": "class DiscoverProjectDocsTool(BaseTool):\n    \"\"\"\n    è‡ªåŠ¨å‘ç°å¹¶è¯»å–é¡¹ç›®æ–‡æ¡£\n    \n    åŠŸèƒ½ï¼š\n    - æŸ¥æ‰¾READMEã€ARCHITECTUREç­‰å…³é”®æ–‡æ¡£\n    - æå–package.jsonã€pyproject.tomlç­‰å…ƒä¿¡æ¯\n    - æ™ºèƒ½æ‘˜è¦ï¼Œæå–å…³é”®ä¿¡æ¯\n    \"\"\"\n    \n    # æ–‡æ¡£ä¼˜å…ˆçº§\n    README_PATTERNS = [\n        \"README.md\", \"README.rst\", \"README.txt\", \"README\",\n        \"readme.md\", \"readme.rst\", \"readme.txt\", \"readme\"\n    ]\n    \n    ARCHITECTURE_PATTERNS = [\n        \"ARCHITECTURE.md\", \"DESIGN.md\", \"STRUCTURE.md\",\n        \"architecture.md\", \"design.md\", \"structure.md\",\n        \"docs/ARCHITECTURE.md\", \"docs/architecture.md\"\n    ]\n    \n    CHANGELOG_PATTERNS = [\n        \"CHANGELOG.md\", \"HISTORY.md\", \"RELEASES.md\",\n        \"changelog.md\", \"history.md\", \"releases.md\"\n    ]\n    \n    PACKAGE_INFO_PATTERNS = [\n        \"package.json\",\n        \"pyproject.toml\",\n        \"setup.py\",\n        \"Cargo.toml\",\n        \"go.mod\"\n    ]\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 52,
"end": 57,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"discover_project_docs\",\n            description=\"è‡ªåŠ¨å‘ç°å¹¶è¯»å–é¡¹ç›®æ–‡æ¡£ï¼ˆREADMEã€æ¶æ„æ–‡æ¡£ã€åŒ…ä¿¡æ¯ç­‰ï¼‰\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 58,
"end": 190,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        \"\"\"è·å–Function Calling schema\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"repo_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"ä»“åº“æ ¹ç›®å½•è·¯å¾„ã€‚å¿…é¡»ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•ï¼Œä¸è¦ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼\"\n                    },\n                    \"include_changelog\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦åŒ…å«CHANGELOGï¼ˆé»˜è®¤falseï¼Œé¿å…è¿‡é•¿ï¼‰\",\n                        \"default\": False\n                    },\n                    \"max_doc_length\": {\n                        \"type\": \"integer\",\n                        \"description\": \"å•ä¸ªæ–‡æ¡£æœ€å¤§é•¿åº¦ï¼ˆå­—ç¬¦æ•°ï¼Œé»˜è®¤5000ï¼‰\",\n                        \"default\": 5000\n                    }\n                },\n                \"required\": [\"repo_path\"]\n            }\n        }\n    \n    async def execute(\n        self,\n        repo_path: str,\n        include_changelog: bool = False,\n        max_doc_length: int = 5000\n    ) -> ToolResult:\n        \"\"\"\n        å‘ç°å¹¶è¯»å–é¡¹ç›®æ–‡æ¡£\n        \n        Args:\n            repo_path: ä»“åº“æ ¹ç›®å½•\n            include_changelog: æ˜¯å¦åŒ…å«CHANGELOG\n            max_doc_length: å•ä¸ªæ–‡æ¡£æœ€å¤§é•¿åº¦\n            \n        Returns:\n            ToolResult\n        \"\"\"\n        try:\n            repo_path = Path(repo_path).resolve()\n            if not repo_path.exists():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"ä»“åº“è·¯å¾„ä¸å­˜åœ¨: {repo_path}\"\n                )\n            \n            docs = []\n            \n            # 1. æŸ¥æ‰¾READMEï¼ˆå¿…è¯»ï¼‰\n            readme = self._find_file(repo_path, self.README_PATTERNS)\n            if readme:\n                content = self._read_file(readme, max_doc_length)\n                if content:\n                    docs.append({\n                        'type': 'README',\n                        'path': str(readme.relative_to(repo_path)),\n                        'content': content,\n                        'summary': self._extract_readme_summary(content)\n                    })\n                    logger.info(f\"âœ“ æ‰¾åˆ°README: {readme.name}\")\n            \n            # 2. æŸ¥æ‰¾æ¶æ„æ–‡æ¡£\n            arch_doc = self._find_file(repo_path, self.ARCHITECTURE_PATTERNS)\n            if arch_doc:\n                content = self._read_file(arch_doc, max_doc_length)\n                if content:\n                    docs.append({\n                        'type': 'ARCHITECTURE',\n                        'path': str(arch_doc.relative_to(repo_path)),\n                        'content': content\n                    })\n                    logger.info(f\"âœ“ æ‰¾åˆ°æ¶æ„æ–‡æ¡£: {arch_doc.name}\")\n            \n            # 3. æŸ¥æ‰¾CHANGELOGï¼ˆå¯é€‰ï¼‰\n            if include_changelog:\n                changelog = self._find_file(repo_path, self.CHANGELOG_PATTERNS)\n                if changelog:\n                    content = self._read_file(changelog, max_doc_length)\n                    if content:\n                        docs.append({\n                            'type': 'CHANGELOG',\n                            'path': str(changelog.relative_to(repo_path)),\n                            'content': content\n                        })\n                        logger.info(f\"âœ“ æ‰¾åˆ°CHANGELOG: {changelog.name}\")\n            \n            # 4. æŸ¥æ‰¾åŒ…ä¿¡æ¯\n            package_info = self._find_file(repo_path, self.PACKAGE_INFO_PATTERNS)\n            if package_info:\n                metadata = self._extract_package_metadata(package_info)\n                if metadata:\n                    docs.append({\n                        'type': 'PACKAGE_INFO',\n                        'path': str(package_info.relative_to(repo_path)),\n                        'content': metadata\n                    })\n                    logger.info(f\"âœ“ æ‰¾åˆ°åŒ…ä¿¡æ¯: {package_info.name}\")\n            \n            if not docs:\n                return ToolResult(\n                    succ"
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 191,
"end": 198,
"text": "    def _find_file(self, repo_path: Path, patterns: List[str]) -> Optional[Path]:\n        \"\"\"æŸ¥æ‰¾æ–‡ä»¶ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰\"\"\"\n        for pattern in patterns:\n            file_path = repo_path / pattern\n            if file_path.exists() and file_path.is_file():\n                return file_path\n        return None\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 199,
"end": 212,
"text": "    def _read_file(self, file_path: Path, max_length: int) -> Optional[str]:\n        \"\"\"è¯»å–æ–‡ä»¶å†…å®¹ï¼ˆé™åˆ¶é•¿åº¦ï¼‰\"\"\"\n        try:\n            content = file_path.read_text(encoding='utf-8', errors='ignore')\n            \n            if len(content) > max_length:\n                # æˆªæ–­ï¼Œä¿ç•™å¼€å¤´\n                content = content[:max_length] + f\"\\n\\n... (æ–‡æ¡£è¿‡é•¿ï¼Œå·²æˆªæ–­ï¼Œæ€»é•¿åº¦: {len(content)} å­—ç¬¦)\"\n            \n            return content\n        except Exception as e:\n            logger.warning(f\"è¯»å–æ–‡ä»¶å¤±è´¥ {file_path}: {e}\")\n            return None\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 213,
"end": 270,
"text": "    def _extract_readme_summary(self, content: str) -> Dict[str, Any]:\n        \"\"\"æå–READMEå…³é”®ä¿¡æ¯\"\"\"\n        summary = {}\n        \n        lines = content.split('\\n')\n        \n        # æå–æ ‡é¢˜ï¼ˆç¬¬ä¸€ä¸ª#ï¼‰\n        for line in lines:\n            if line.strip().startswith('#'):\n                title = line.strip().lstrip('#').strip()\n                summary['title'] = title\n                break\n        \n        # æå–æè¿°ï¼ˆç¬¬ä¸€æ®µéæ ‡é¢˜æ–‡æœ¬ï¼‰\n        description_lines = []\n        in_description = False\n        for line in lines:\n            stripped = line.strip()\n            if not stripped:\n                if in_description:\n                    break\n                continue\n            if stripped.startswith('#'):\n                in_description = False\n                continue\n            if not in_description and not stripped.startswith('#'):\n                in_description = True\n            if in_description:\n                description_lines.append(stripped)\n                if len(description_lines) >= 3:  # æœ€å¤š3è¡Œ\n                    break\n        \n        if description_lines:\n            summary['description'] = ' '.join(description_lines)\n        \n        # æå–ç‰¹æ€§ï¼ˆFeaturesã€æ ¸å¿ƒç‰¹æ€§ç­‰ï¼‰\n        features = []\n        in_features = False\n        for line in lines:\n            stripped = line.strip()\n            if 'ç‰¹æ€§' in stripped or 'feature' in stripped.lower() or 'highlights' in stripped.lower():\n                in_features = True\n                continue\n            if in_features:\n                if stripped.startswith('#'):\n                    break\n                if stripped.startswith('-') or stripped.startswith('*') or stripped.startswith('â€¢'):\n                    feature = stripped.lstrip('-*â€¢').strip()\n                    if feature:\n                        features.append(feature)\n                        if len(features) >= 5:  # æœ€å¤š5ä¸ª\n                            break\n        \n        if features:\n            summary['features'] = features\n        \n        return summary\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 271,
"end": 288,
"text": "    def _extract_package_metadata(self, file_path: Path) -> Optional[str]:\n        \"\"\"æå–åŒ…å…ƒä¿¡æ¯\"\"\"\n        try:\n            if file_path.name == 'package.json':\n                return self._extract_package_json(file_path)\n            elif file_path.name == 'pyproject.toml':\n                return self._extract_pyproject_toml(file_path)\n            elif file_path.name == 'setup.py':\n                return self._extract_setup_py(file_path)\n            elif file_path.name == 'Cargo.toml':\n                return self._extract_cargo_toml(file_path)\n            elif file_path.name == 'go.mod':\n                return self._extract_go_mod(file_path)\n        except Exception as e:\n            logger.warning(f\"æå–åŒ…ä¿¡æ¯å¤±è´¥ {file_path}: {e}\")\n        \n        return None\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 289,
"end": 309,
"text": "    def _extract_package_json(self, file_path: Path) -> str:\n        \"\"\"æå–package.jsonä¿¡æ¯\"\"\"\n        data = json.loads(file_path.read_text(encoding='utf-8'))\n        \n        info = []\n        info.append(f\"åç§°: {data.get('name', 'N/A')}\")\n        info.append(f\"ç‰ˆæœ¬: {data.get('version', 'N/A')}\")\n        \n        if 'description' in data:\n            info.append(f\"æè¿°: {data['description']}\")\n        \n        if 'dependencies' in data:\n            deps = list(data['dependencies'].keys())[:10]  # æœ€å¤š10ä¸ª\n            info.append(f\"ä¾èµ–: {', '.join(deps)}\")\n        \n        if 'scripts' in data:\n            scripts = list(data['scripts'].keys())[:5]  # æœ€å¤š5ä¸ª\n            info.append(f\"è„šæœ¬: {', '.join(scripts)}\")\n        \n        return '\\n'.join(info)\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 310,
"end": 336,
"text": "    def _extract_pyproject_toml(self, file_path: Path) -> str:\n        \"\"\"æå–pyproject.tomlä¿¡æ¯\"\"\"\n        try:\n            import tomli\n        except ImportError:\n            # ç®€å•è§£æ\n            content = file_path.read_text(encoding='utf-8')\n            return self._simple_parse_toml(content)\n        \n        data = tomli.loads(file_path.read_text(encoding='utf-8'))\n        \n        info = []\n        \n        if 'project' in data:\n            project = data['project']\n            info.append(f\"åç§°: {project.get('name', 'N/A')}\")\n            info.append(f\"ç‰ˆæœ¬: {project.get('version', 'N/A')}\")\n            \n            if 'description' in project:\n                info.append(f\"æè¿°: {project['description']}\")\n            \n            if 'dependencies' in project:\n                deps = project['dependencies'][:10]  # æœ€å¤š10ä¸ª\n                info.append(f\"ä¾èµ–: {', '.join(deps)}\")\n        \n        return '\\n'.join(info) if info else self._simple_parse_toml(file_path.read_text(encoding='utf-8'))\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 337,
"end": 352,
"text": "    def _simple_parse_toml(self, content: str) -> str:\n        \"\"\"ç®€å•è§£æTOMLï¼ˆä¸ä¾èµ–tomliï¼‰\"\"\"\n        lines = content.split('\\n')[:20]  # åªçœ‹å‰20è¡Œ\n        info = []\n        \n        for line in lines:\n            line = line.strip()\n            if '=' in line and not line.startswith('#'):\n                key, value = line.split('=', 1)\n                key = key.strip()\n                value = value.strip().strip('\"\\'')\n                if key in ['name', 'version', 'description']:\n                    info.append(f\"{key}: {value}\")\n        \n        return '\\n'.join(info) if info else \"åŒ…ä¿¡æ¯ï¼ˆTOMLæ ¼å¼ï¼‰\"\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 353,
"end": 375,
"text": "    def _extract_setup_py(self, file_path: Path) -> str:\n        \"\"\"æå–setup.pyä¿¡æ¯ï¼ˆç®€å•è§£æï¼‰\"\"\"\n        content = file_path.read_text(encoding='utf-8')\n        \n        info = []\n        \n        # ç®€å•æ­£åˆ™æå–\n        import re\n        \n        name_match = re.search(r'name\\s*=\\s*[\"\\']([^\"\\']+)[\"\\']', content)\n        if name_match:\n            info.append(f\"åç§°: {name_match.group(1)}\")\n        \n        version_match = re.search(r'version\\s*=\\s*[\"\\']([^\"\\']+)[\"\\']', content)\n        if version_match:\n            info.append(f\"ç‰ˆæœ¬: {version_match.group(1)}\")\n        \n        desc_match = re.search(r'description\\s*=\\s*[\"\\']([^\"\\']+)[\"\\']', content)\n        if desc_match:\n            info.append(f\"æè¿°: {desc_match.group(1)}\")\n        \n        return '\\n'.join(info) if info else \"åŒ…ä¿¡æ¯ï¼ˆsetup.pyï¼‰\"\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 376,
"end": 379,
"text": "    def _extract_cargo_toml(self, file_path: Path) -> str:\n        \"\"\"æå–Cargo.tomlä¿¡æ¯\"\"\"\n        return self._simple_parse_toml(file_path.read_text(encoding='utf-8'))\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 380,
"end": 394,
"text": "    def _extract_go_mod(self, file_path: Path) -> str:\n        \"\"\"æå–go.modä¿¡æ¯\"\"\"\n        content = file_path.read_text(encoding='utf-8')\n        lines = content.split('\\n')[:10]  # å‰10è¡Œ\n        \n        info = []\n        for line in lines:\n            line = line.strip()\n            if line.startswith('module '):\n                info.append(f\"æ¨¡å—: {line.replace('module ', '')}\")\n            elif line.startswith('go '):\n                info.append(f\"Goç‰ˆæœ¬: {line.replace('go ', '')}\")\n        \n        return '\\n'.join(info) if info else \"åŒ…ä¿¡æ¯ï¼ˆgo.modï¼‰\"\n    "
},
{
"path": "daoyoucode/agents/tools/project_docs_tools.py",
"start": 395,
"end": 421,
"text": "    def _format_docs(self, docs: List[Dict[str, Any]]) -> str:\n        \"\"\"æ ¼å¼åŒ–æ–‡æ¡£è¾“å‡º\"\"\"\n        output = [\"# é¡¹ç›®æ–‡æ¡£\\n\"]\n        \n        for doc in docs:\n            doc_type = doc['type']\n            doc_path = doc['path']\n            \n            output.append(f\"\\n## {doc_type}\")\n            output.append(f\"æ–‡ä»¶: {doc_path}\\n\")\n            \n            if doc_type == 'README' and 'summary' in doc:\n                summary = doc['summary']\n                if 'title' in summary:\n                    output.append(f\"**é¡¹ç›®åç§°**: {summary['title']}\")\n                if 'description' in summary:\n                    output.append(f\"**æè¿°**: {summary['description']}\")\n                if 'features' in summary:\n                    output.append(\"\\n**æ ¸å¿ƒç‰¹æ€§**:\")\n                    for i, feature in enumerate(summary['features'], 1):\n                        output.append(f\"{i}. {feature}\")\n                output.append(\"\\n**å®Œæ•´å†…å®¹**:\")\n            \n            output.append(doc['content'])\n            output.append(\"\\n\" + \"-\" * 60)\n        \n        return '\\n'.join(output)"
},
{
"path": "daoyoucode/agents/tools/registry.py",
"start": 1,
"end": 16,
"text": "\"\"\"\nå…¨å±€å·¥å…·æ³¨å†Œè¡¨\n\nå•ä¾‹æ¨¡å¼ï¼Œé¿å…é‡å¤åŠ è½½\n\"\"\"\n\nfrom .base import ToolRegistry\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# å…¨å±€å•ä¾‹\n_tool_registry = None\n_registry_id = None  # ç”¨äºè°ƒè¯•\n\n"
},
{
"path": "daoyoucode/agents/tools/registry.py",
"start": 17,
"end": 30,
"text": "def get_tool_registry() -> ToolRegistry:\n    \"\"\"è·å–å·¥å…·æ³¨å†Œè¡¨å•ä¾‹\"\"\"\n    global _tool_registry, _registry_id\n    if _tool_registry is None:\n        logger.info(\"åˆ›å»ºæ–°çš„å·¥å…·æ³¨å†Œè¡¨å®ä¾‹\")\n        _tool_registry = ToolRegistry()\n        _registry_id = id(_tool_registry)\n        _register_builtin_tools()\n        logger.info(f\"å·¥å…·æ³¨å†Œè¡¨ID: {_registry_id}\")\n    else:\n        logger.debug(f\"è¿”å›ç°æœ‰å·¥å…·æ³¨å†Œè¡¨å®ä¾‹ (ID: {_registry_id})\")\n    return _tool_registry\n\n"
},
{
"path": "daoyoucode/agents/tools/registry.py",
"start": 31,
"end": 169,
"text": "def _register_builtin_tools():\n    \"\"\"æ³¨å†Œå†…ç½®å·¥å…·\"\"\"\n    from .file_tools import (\n        ReadFileTool,\n        WriteFileTool,\n        ListFilesTool,\n        GetFileInfoTool,\n        CreateDirectoryTool,\n        DeleteFileTool\n    )\n    from .search_tools import (\n        TextSearchTool,\n        RegexSearchTool\n    )\n    from .git_tools import (\n        GitStatusTool,\n        GitDiffTool,\n        GitCommitTool,\n        GitLogTool\n    )\n    from .command_tools import (\n        RunCommandTool,\n        RunTestTool,\n        RunLintTool\n    )\n    from .diff_tools import (\n        SearchReplaceTool,\n        ApplyPatchTool\n    )\n    from .repomap_tools import (\n        RepoMapTool,\n        GetRepoStructureTool,\n        GetFileSymbolsTool\n    )\n    from .project_docs_tools import (\n        DiscoverProjectDocsTool\n    )\n    from .lsp_tools import (\n        LSPDiagnosticsTool,\n        LSPGotoDefinitionTool,\n        LSPFindReferencesTool,\n        LSPSymbolsTool,\n        LSPRenameTool,\n        LSPCodeActionsTool\n    )\n    from .ast_tools import (\n        AstGrepSearchTool,\n        AstGrepReplaceTool\n    )\n    from .codebase_search_tool import SemanticCodeSearchTool\n\n    # æ–‡ä»¶æ“ä½œå·¥å…·ï¼ˆ6ä¸ªï¼‰\n    _tool_registry.register(ReadFileTool())\n    _tool_registry.register(WriteFileTool())\n    _tool_registry.register(ListFilesTool())\n    _tool_registry.register(GetFileInfoTool())\n    _tool_registry.register(CreateDirectoryTool())\n    _tool_registry.register(DeleteFileTool())\n    \n    # æœç´¢å·¥å…·ï¼ˆ2ä¸ªï¼‰\n    _tool_registry.register(TextSearchTool())\n    _tool_registry.register(RegexSearchTool())\n    \n    # Gitå·¥å…·ï¼ˆ4ä¸ªï¼‰\n    _tool_registry.register(GitStatusTool())\n    _tool_registry.register(GitDiffTool())\n    _tool_registry.register(GitCommitTool())\n    _tool_registry.register(GitLogTool())\n    \n    # å‘½ä»¤æ‰§è¡Œå·¥å…·ï¼ˆ3ä¸ªï¼‰\n    _tool_registry.register(RunCommandTool())\n    _tool_registry.register(RunTestTool())\n    _tool_registry.register(RunLintTool())\n    \n    # Diffå·¥å…·ï¼ˆ1ä¸ªï¼‰\n    try:\n        _tool_registry.register(SearchReplaceTool())\n    except Exception as e:\n        logger.error(f\"æ³¨å†ŒSearchReplaceToolå¤±è´¥: {e}\")\n    try:\n        _tool_registry.register(ApplyPatchTool())\n    except Exception as e:\n        logger.error(f\"æ³¨å†ŒApplyPatchToolå¤±è´¥: {e}\")\n    \n    # RepoMapå·¥å…·ï¼ˆ3ä¸ªï¼‰\n    try:\n        _tool_registry.register(RepoMapTool())\n        logger.info(\"âœ“ RepoMapToolæ³¨å†ŒæˆåŠŸ\")\n    except Exception as e:\n        logger.error(f\"æ³¨å†ŒRepoMapToolå¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n    \n    try:\n        _tool_registry.register(GetRepoStructureTool())\n        logger.info(\"âœ“ GetRepoStructureToolæ³¨å†ŒæˆåŠŸ\")\n    except Exception as e:\n        logger.error(f\"æ³¨å†ŒGetRepoStructureToolå¤±è´¥: {e}\")\n    try:\n        _tool_registry.register(GetFileSymbolsTool())\n    except Exception as e:\n        logger.error(f\"æ³¨å†ŒGetFileSymbolsToolå¤±è´¥: {e}\")\n    \n    try:\n        _tool_registry.register(DiscoverProjectDocsTool())\n        logger.info(\"âœ“ DiscoverProjectDocsToolæ³¨å†ŒæˆåŠŸ\")\n    except Exception as e:\n        logger.error(f\"æ³¨å†ŒDiscoverProjectDocsToolå¤±è´¥: {e}\")\n\n    # è¯­ä¹‰ä»£ç æ£€ç´¢ï¼ˆCursor åŒçº§æŒ‰é—®æ£€ç´¢ï¼‰\n    try:\n        _tool_registry.register(SemanticCodeSearchTool())\n        logger.info(\"âœ“ SemanticCodeSearchToolæ³¨å†ŒæˆåŠŸ\")\n    except Exception as e:\n        logger.error(f\"æ³¨å†ŒSemanticCodeSearchToolå¤±è´¥: {e}\")\n    \n    # LSPå·¥å…·ï¼ˆ6ä¸ªï¼‰\n    try:\n        _tool_registry.register(LSPDiagnosticsTool())\n        _tool_registry.register(LSPGotoDefinitionTool())\n        _tool_registry.register(LSPFindReferencesTool())\n        _tool_registry.register(LSPSymbolsTool())\n        _tool_registry.register(LSPRenameTool())\n        _tool_registry.register(LSPCodeActionsTool())\n    except Exception as e:\n        logger.error(f\"æ³¨å†ŒLSPå·¥å…·å¤±è´¥: {e}\")\n    \n    # ASTå·¥å…·ï¼ˆ2ä¸ªï¼‰\n    try:\n        _tool_registry.register(AstGrepSearchTool())\n        _tool_registry.register(AstGrepReplaceTool())\n    except Exception as e:\n        logger.error(f\"æ³¨å†ŒASTå·¥å…·å¤±è´¥: {e}\")\n    \n    logger.info(f\"å·²æ³¨å†Œ {len(_tool_registry.list_tools())} ä¸ªå†…ç½®å·¥å…·\")\n    \n    # åˆ—å‡ºæ‰€æœ‰å·²æ³¨å†Œçš„å·¥å…·\n    tools = _tool_regis"
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 1,
"end": 40,
"text": "\"\"\"\nRepoMapå·¥å…· - ä»£ç åœ°å›¾ç”Ÿæˆ\n\nåŸºäºdaoyouCodePilotçš„æœ€ä½³å®ç°ï¼š\n- Tree-sitterè§£æä»£ç ç»“æ„\n- PageRankç®—æ³•æ™ºèƒ½æ’åº\n- ä¸ªæ€§åŒ–æƒé‡ï¼ˆå¯¹è¯æ–‡ä»¶Ã—50ï¼Œæåˆ°çš„æ ‡è¯†ç¬¦Ã—10ï¼‰\n- ç¼“å­˜æœºåˆ¶ï¼ˆSQLite + mtimeæ£€æµ‹ï¼‰\n- Tokené¢„ç®—æ§åˆ¶\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Set, Tuple, Any\nimport logging\nimport sqlite3\nimport json\nfrom collections import defaultdict, namedtuple\nimport warnings\n\nfrom .base import BaseTool, ToolResult\n\n# å¿½ç•¥ tree_sitter çš„ FutureWarning\nwarnings.simplefilter(\"ignore\", category=FutureWarning)\n\n# å¯¼å…¥ grep_ast åº“\ntry:\n    from grep_ast import filename_to_lang\n    from grep_ast.tsl import USING_TSL_PACK, get_language, get_parser\n    from pygments.lexers import guess_lexer_for_filename\n    from pygments.token import Token\n    TREE_SITTER_AVAILABLE = True\nexcept ImportError:\n    TREE_SITTER_AVAILABLE = False\n\nlogger = logging.getLogger(__name__)\n\n# Tag æ•°æ®ç»“æ„\nTag = namedtuple(\"Tag\", \"rel_fname fname line name kind\".split())\n\n"
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 41,
"end": 56,
"text": "class RepoMapTool(BaseTool):\n    \"\"\"\n    ç”Ÿæˆä»£ç ä»“åº“åœ°å›¾\n    \n    åŠŸèƒ½ï¼š\n    - æå–å‡½æ•°ã€ç±»å®šä¹‰å’Œå¼•ç”¨å…³ç³»\n    - PageRankæ’åºï¼ˆåŸºäºå¼•ç”¨å…³ç³»ï¼‰\n    - ä¸ªæ€§åŒ–æƒé‡ï¼ˆå¯¹è¯æ–‡ä»¶ã€æåˆ°çš„æ ‡è¯†ç¬¦ï¼‰\n    - ç¼“å­˜æœºåˆ¶ï¼ˆé¿å…é‡å¤è§£æï¼‰\n    - Tokené¢„ç®—æ§åˆ¶\n    \"\"\"\n    \n    # RepoMapå¯ä»¥ç¨å¾®é•¿ä¸€ç‚¹ï¼Œå› ä¸ºå®ƒæ˜¯æ™ºèƒ½æ’åºçš„\n    MAX_OUTPUT_CHARS = 10000\n    MAX_OUTPUT_LINES = 1000\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 57,
"end": 64,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"repo_map\",\n            description=\"ç”Ÿæˆä»£ç ä»“åº“åœ°å›¾ï¼Œæ™ºèƒ½æ’åºæœ€ç›¸å…³çš„ä»£ç å®šä¹‰\"\n        )\n        self.cache_db = None\n        self.graph = None\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 65,
"end": 208,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        \"\"\"è·å–Function Calling schema\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"repo_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"ä»“åº“æ ¹ç›®å½•è·¯å¾„ã€‚å¿…é¡»ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•ï¼Œä¸è¦ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼\"\n                    },\n                    \"chat_files\": {\n                        \"type\": \"array\",\n                        \"items\": {\"type\": \"string\"},\n                        \"description\": \"å¯¹è¯ä¸­æåˆ°çš„æ–‡ä»¶åˆ—è¡¨ï¼ˆæƒé‡Ã—50ï¼‰ã€‚å¦‚æœä¸ºç©ºï¼Œä¼šè‡ªåŠ¨æ‰©å¤§tokené¢„ç®—ä»¥æä¾›æ›´å…¨é¢çš„é¡¹ç›®è§†å›¾\"\n                    },\n                    \"mentioned_idents\": {\n                        \"type\": \"array\",\n                        \"items\": {\"type\": \"string\"},\n                        \"description\": \"å¯¹è¯ä¸­æåˆ°çš„æ ‡è¯†ç¬¦åˆ—è¡¨ï¼ˆæƒé‡Ã—10ï¼‰\"\n                    },\n                    \"max_tokens\": {\n                        \"type\": \"integer\",\n                        \"description\": \"æœ€å¤§tokenæ•°é‡ï¼ˆé»˜è®¤3000ï¼‰ã€‚å¦‚æœchat_filesä¸ºç©ºï¼Œä¼šè‡ªåŠ¨æ‰©å¤§åˆ°6000\",\n                        \"default\": 3000\n                    },\n                    \"auto_scale\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦è‡ªåŠ¨è°ƒæ•´tokené¢„ç®—ï¼ˆé»˜è®¤trueï¼‰ã€‚å½“chat_filesä¸ºç©ºæ—¶ï¼Œè‡ªåŠ¨æ‰©å¤§é¢„ç®—ä»¥æä¾›æ›´å…¨é¢çš„è§†å›¾\",\n                        \"default\": True\n                    }\n                },\n                \"required\": [\"repo_path\"]\n            }\n        }\n        \n    async def execute(\n        self,\n        repo_path: str,\n        chat_files: Optional[List[str]] = None,\n        mentioned_idents: Optional[List[str]] = None,\n        max_tokens: int = 3000,\n        auto_scale: bool = True\n    ) -> ToolResult:\n        \"\"\"\n        ç”ŸæˆRepoMap\n        \n        Args:\n            repo_path: ä»“åº“æ ¹ç›®å½•\n            chat_files: å¯¹è¯ä¸­çš„æ–‡ä»¶ï¼ˆæƒé‡Ã—50ï¼‰\n            mentioned_idents: æåˆ°çš„æ ‡è¯†ç¬¦ï¼ˆæƒé‡Ã—10ï¼‰\n            max_tokens: æœ€å¤§tokenæ•°é‡\n            auto_scale: æ˜¯å¦è‡ªåŠ¨è°ƒæ•´tokené¢„ç®—\n            \n        Returns:\n            ToolResult\n        \"\"\"\n        try:\n            # ä½¿ç”¨ resolve_path è§£æè·¯å¾„ï¼ˆä½¿ç”¨ ToolContextï¼‰\n            repo_path_resolved = self.resolve_path(repo_path)\n            \n            if not repo_path_resolved.exists():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"ä»“åº“è·¯å¾„ä¸å­˜åœ¨: {repo_path}\"\n                )\n            \n            chat_files = chat_files or []\n            mentioned_idents = mentioned_idents or []\n            \n            # æ™ºèƒ½è°ƒæ•´tokené¢„ç®—ï¼ˆå€Ÿé‰´aiderï¼‰\n            original_max_tokens = max_tokens\n            if auto_scale:\n                if not chat_files or len(chat_files) == 0:\n                    # æ²¡æœ‰å¯¹è¯æ–‡ä»¶ï¼Œæ‰©å¤§é¢„ç®—ï¼ˆ2å€ï¼Œæœ€å¤š6000ï¼‰\n                    max_tokens = min(max_tokens * 2, 6000)\n                    logger.info(\n                        f\"ğŸ” æ™ºèƒ½è°ƒæ•´: æ— å¯¹è¯æ–‡ä»¶ï¼Œæ‰©å¤§tokené¢„ç®— \"\n                        f\"{original_max_tokens} â†’ {max_tokens} \"\n                        f\"(æä¾›æ›´å…¨é¢çš„é¡¹ç›®è§†å›¾)\"\n                    )\n                else:\n                    logger.info(\n                        f\"ğŸ“ æ™ºèƒ½è°ƒæ•´: æœ‰ {len(chat_files)} ä¸ªå¯¹è¯æ–‡ä»¶ï¼Œ\"\n                        f\"ä½¿ç”¨æ ‡å‡†tokené¢„ç®— {max_tokens}\"\n                    )\n            \n            # åˆå§‹åŒ–ç¼“å­˜\n            self._init_cache(repo_path_resolved)\n            \n            # æ‰«æä»“åº“\n            definitions = self._scan_repository(repo_path_resolved)\n            \n            # æ„å»ºå¼•ç”¨å›¾\n            graph = self._build_reference_graph(definitions, repo_path_resolved)\n            \n            # PageRankæ’åº\n            ranked = self._pagerank(\n                graph,\n                definitions,  # ä¼ é€’ definitions\n                chat_files=chat_files,\n                mentioned_idents=mentioned_idents\n            )\n            \n            # ç”Ÿæˆåœ°å›¾ï¼ˆæ§åˆ¶tokenï¼‰\n            repo_map = self._generate_map(\n                ranked,\n                definitions,\n                max_tokens=max_tokens\n            )\n            \n            # å…³é—­æ•°æ®åº“\n            if self.cache_db:\n                self.cach"
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 209,
"end": 227,
"text": "    def _init_cache(self, repo_path: Path):\n        \"\"\"åˆå§‹åŒ–SQLiteç¼“å­˜\"\"\"\n        cache_dir = repo_path / \".daoyoucode\" / \"cache\"\n        cache_dir.mkdir(parents=True, exist_ok=True)\n        \n        cache_file = cache_dir / \"repomap.db\"\n        self.cache_db = sqlite3.connect(str(cache_file))\n        \n        # åˆ›å»ºè¡¨\n        self.cache_db.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS definitions (\n                file_path TEXT,\n                mtime REAL,\n                definitions TEXT,\n                PRIMARY KEY (file_path)\n            )\n        \"\"\")\n        self.cache_db.commit()\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 228,
"end": 277,
"text": "    def _scan_repository(self, repo_path: Path) -> Dict[str, List[Dict]]:\n        \"\"\"\n        æ‰«æä»“åº“ï¼Œæå–å®šä¹‰\n        \n        Returns:\n            {file_path: [definition, ...]}\n        \"\"\"\n        definitions = {}\n        \n        # æ”¯æŒçš„æ–‡ä»¶æ‰©å±•å\n        extensions = {\".py\", \".js\", \".ts\", \".jsx\", \".tsx\", \".java\", \".go\", \".rs\"}\n        \n        for file_path in repo_path.rglob(\"*\"):\n            if not file_path.is_file():\n                continue\n            if file_path.suffix not in extensions:\n                continue\n            if self._should_ignore(file_path):\n                continue\n            \n            # ğŸ†• subtree_only è¿‡æ»¤\n            rel_path_str = str(file_path.relative_to(repo_path))\n            if not self.context.should_include_path(rel_path_str):\n                logger.debug(f\"è·³è¿‡æ–‡ä»¶ï¼ˆsubtree_onlyï¼‰: {rel_path_str}\")\n                continue\n            \n            # ğŸ†• subtree_only è¿‡æ»¤\n            rel_path_str = str(file_path.relative_to(repo_path))\n            if not self.context.should_include_path(rel_path_str):\n                logger.debug(f\"è·³è¿‡æ–‡ä»¶ï¼ˆsubtree_onlyï¼‰: {rel_path_str}\")\n                continue\n            \n            # æ£€æŸ¥ç¼“å­˜\n            rel_path = rel_path_str\n            mtime = file_path.stat().st_mtime\n            \n            cached = self._get_cached_definitions(rel_path, mtime)\n            if cached is not None:\n                definitions[rel_path] = cached\n                continue\n            \n            # è§£ææ–‡ä»¶\n            file_defs = self._parse_file(file_path)\n            definitions[rel_path] = file_defs\n            \n            # ç¼“å­˜ç»“æœ\n            self._cache_definitions(rel_path, mtime, file_defs)\n        \n        return definitions\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 278,
"end": 300,
"text": "    def _should_ignore(self, file_path: Path) -> bool:\n        \"\"\"\n        æ£€æŸ¥æ˜¯å¦åº”è¯¥å¿½ç•¥æ–‡ä»¶\n        \n        å¿½ç•¥è§„åˆ™ï¼š\n        1. å¸¸è§çš„æ„å»ºå’Œä¾èµ–ç›®å½•\n        2. è¯»å– .daoyoucodeignore æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰\n        \"\"\"\n        # å¸¸è§çš„æ„å»ºå’Œä¾èµ–ç›®å½•\n        common_ignore = {\n            \".git\", \"node_modules\", \"__pycache__\", \".venv\", \"venv\",\n            \"dist\", \"build\", \".next\", \".nuxt\", \"target\"\n        }\n        \n        for part in file_path.parts:\n            if part in common_ignore:\n                return True\n        \n        # TODO: è¯»å– .daoyoucodeignore æ–‡ä»¶\n        # è¿™æ ·ç”¨æˆ·å¯ä»¥è‡ªå®šä¹‰å¿½ç•¥è§„åˆ™ï¼Œä¸éœ€è¦ç¡¬ç¼–ç \n        \n        return False\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 301,
"end": 317,
"text": "    def _get_cached_definitions(self, file_path: str, mtime: float) -> Optional[List[Dict]]:\n        \"\"\"ä»ç¼“å­˜è·å–å®šä¹‰\"\"\"\n        cursor = self.cache_db.execute(\n            \"SELECT mtime, definitions FROM definitions WHERE file_path = ?\",\n            (file_path,)\n        )\n        row = cursor.fetchone()\n        \n        if row is None:\n            return None\n        \n        cached_mtime, cached_defs = row\n        if cached_mtime != mtime:\n            return None\n        \n        return json.loads(cached_defs)\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 318,
"end": 325,
"text": "    def _cache_definitions(self, file_path: str, mtime: float, definitions: List[Dict]):\n        \"\"\"ç¼“å­˜å®šä¹‰\"\"\"\n        self.cache_db.execute(\n            \"INSERT OR REPLACE INTO definitions (file_path, mtime, definitions) VALUES (?, ?, ?)\",\n            (file_path, mtime, json.dumps(definitions))\n        )\n        self.cache_db.commit()\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 326,
"end": 422,
"text": "    def _parse_file(self, file_path: Path) -> List[Dict]:\n        \"\"\"\n        è§£ææ–‡ä»¶ï¼Œæå–å®šä¹‰å’Œå¼•ç”¨\n        \n        ä½¿ç”¨ Tree-sitter è§£æï¼ˆå®Œæ•´å®ç°ï¼‰\n        \"\"\"\n        if not TREE_SITTER_AVAILABLE:\n            logger.warning(\"Tree-sitter ä¸å¯ç”¨ï¼Œè·³è¿‡æ–‡ä»¶è§£æ\")\n            return []\n        \n        # è·å–è¯­è¨€\n        lang = filename_to_lang(str(file_path))\n        if not lang:\n            return []\n        \n        try:\n            language = get_language(lang)\n            parser = get_parser(lang)\n        except Exception as err:\n            logger.warning(f\"è·³è¿‡æ–‡ä»¶ {file_path}: {err}\")\n            return []\n        \n        # è·å–æŸ¥è¯¢æ–‡ä»¶\n        query_scm = self._get_scm_fname(lang)\n        if not query_scm or not query_scm.exists():\n            return []\n        \n        query_scm_content = query_scm.read_text()\n        \n        # è¯»å–ä»£ç \n        try:\n            code = file_path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        except Exception as e:\n            logger.warning(f\"è¯»å–æ–‡ä»¶å¤±è´¥ {file_path}: {e}\")\n            return []\n        \n        if not code:\n            return []\n        \n        # è§£æä»£ç \n        tree = parser.parse(bytes(code, \"utf-8\"))\n        \n        # è¿è¡Œæ ‡ç­¾æŸ¥è¯¢\n        try:\n            from tree_sitter import Query, QueryCursor\n            query = Query(language, query_scm_content)\n            cursor = QueryCursor(query)\n            matches = cursor.matches(tree.root_node)\n        except Exception as e:\n            logger.warning(f\"æŸ¥è¯¢æ‰§è¡Œå¤±è´¥ {file_path}: {e}\")\n            return []\n        \n        definitions = []\n        saw = set()\n        \n        # å¤„ç†åŒ¹é…ç»“æœ: [(pattern_index, {capture_name: [nodes]})]\n        for pattern_index, captures_dict in matches:\n            for tag, nodes in captures_dict.items():\n                for node in nodes:\n                    if tag.startswith(\"name.definition.\"):\n                        kind = \"def\"\n                    elif tag.startswith(\"name.reference.\"):\n                        kind = \"ref\"\n                    else:\n                        continue\n                    \n                    saw.add(kind)\n                    \n                    # æå–ç±»å‹ï¼ˆclassã€functionã€methodç­‰ï¼‰\n                    type_name = tag.split(\".\")[-1]\n                    \n                    definitions.append({\n                        \"type\": type_name,\n                        \"name\": node.text.decode(\"utf-8\"),\n                        \"line\": node.start_point[0] + 1,\n                        \"kind\": kind\n                    })\n        \n        # å¦‚æœåªæœ‰å®šä¹‰æ²¡æœ‰å¼•ç”¨ï¼Œä½¿ç”¨ Pygments è¡¥å……å¼•ç”¨\n        if \"ref\" not in saw and \"def\" in saw:\n            try:\n                lexer = guess_lexer_for_filename(str(file_path), code)\n                tokens = list(lexer.get_tokens(code))\n                tokens = [token[1] for token in tokens if token[0] in Token.Name]\n                \n                for token in tokens:\n                    definitions.append({\n                        \"type\": \"reference\",\n                        \"name\": token,\n                        \"line\": -1,\n                        \"kind\": \"ref\"\n                    })\n            except Exception:\n                pass\n        \n        return definitions\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 423,
"end": 443,
"text": "    def _get_scm_fname(self, lang: str) -> Optional[Path]:\n        \"\"\"è·å– Tree-sitter æŸ¥è¯¢æ–‡ä»¶è·¯å¾„\"\"\"\n        # æŸ¥è¯¢æ–‡ä»¶ç›®å½•\n        queries_dir = Path(__file__).parent / \"queries\"\n        \n        # ä¼˜å…ˆä½¿ç”¨ tree-sitter-language-pack\n        if USING_TSL_PACK:\n            subdir = \"tree-sitter-language-pack\"\n            path = queries_dir / subdir / f\"{lang}-tags.scm\"\n            if path.exists():\n                return path\n        \n        # å›é€€åˆ° tree-sitter-languages\n        subdir = \"tree-sitter-languages\"\n        path = queries_dir / subdir / f\"{lang}-tags.scm\"\n        if path.exists():\n            return path\n        \n        return None\n\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 444,
"end": 479,
"text": "    def _build_reference_graph(self, definitions: Dict[str, List[Dict]], repo_path: Path) -> Dict[str, Dict[str, float]]:\n        \"\"\"\n        æ„å»ºå¼•ç”¨å›¾\n        \n        Returns:\n            {node: {referenced_node: weight, ...}}\n        \"\"\"\n        graph = defaultdict(lambda: defaultdict(float))\n        \n        # æ„å»ºæ ‡è¯†ç¬¦åˆ°æ–‡ä»¶çš„æ˜ å°„ï¼ˆåªåŒ…å«å®šä¹‰ï¼‰\n        ident_to_files = defaultdict(set)\n        for file_path, defs in definitions.items():\n            for d in defs:\n                # åªæ·»åŠ å®šä¹‰ï¼Œä¸æ·»åŠ å¼•ç”¨\n                if d.get(\"kind\") == \"def\":\n                    ident_to_files[d[\"name\"]].add(file_path)\n        \n        # æ‰«æå¼•ç”¨å…³ç³»\n        for file_path, defs in definitions.items():\n            # æ”¶é›†æ–‡ä»¶ä¸­çš„æ‰€æœ‰å¼•ç”¨\n            references_in_file = set()\n            for d in defs:\n                if d.get(\"kind\") == \"ref\":\n                    references_in_file.add(d[\"name\"])\n            \n            # ä¸ºæ¯ä¸ªå¼•ç”¨æ·»åŠ è¾¹\n            for ident in references_in_file:\n                if ident in ident_to_files:\n                    # æ–‡ä»¶å¼•ç”¨äº†è¿™ä¸ªæ ‡è¯†ç¬¦\n                    for ref_file in ident_to_files[ident]:\n                        if ref_file != file_path:\n                            # æ·»åŠ è¾¹ï¼šfile_path -> ref_file\n                            graph[file_path][ref_file] += 1.0\n        \n        return dict(graph)\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 480,
"end": 582,
"text": "    def _pagerank(\n        self,\n        graph: Dict[str, Dict[str, float]],\n        definitions: Dict[str, List[Dict]],  # æ·»åŠ  definitions å‚æ•°\n        chat_files: List[str],\n        mentioned_idents: List[str],\n        damping: float = 0.85,\n        iterations: int = 20\n    ) -> List[Tuple[str, float]]:\n        \"\"\"\n        PageRankç®—æ³•æ’åº\n        \n        Args:\n            graph: å¼•ç”¨å›¾\n            chat_files: å¯¹è¯ä¸­çš„æ–‡ä»¶ï¼ˆæƒé‡Ã—50ï¼‰\n            mentioned_idents: æåˆ°çš„æ ‡è¯†ç¬¦ï¼ˆæƒé‡Ã—10ï¼‰\n            damping: é˜»å°¼ç³»æ•°\n            iterations: è¿­ä»£æ¬¡æ•°\n            \n        Returns:\n            [(file_path, score), ...] æŒ‰åˆ†æ•°é™åº\n        \"\"\"\n        # æ‰€æœ‰èŠ‚ç‚¹\n        nodes = set(graph.keys())\n        for targets in graph.values():\n            nodes.update(targets.keys())\n        \n        if not nodes:\n            return []\n        \n        # åˆå§‹åŒ–åˆ†æ•°\n        scores = {node: 1.0 / len(nodes) for node in nodes}\n        \n        # ä¸ªæ€§åŒ–æƒé‡\n        personalization = {}\n        for node in nodes:\n            weight = 1.0\n            \n            # å¯¹è¯æ–‡ä»¶æƒé‡Ã—50\n            if node in chat_files:\n                weight *= 50\n            \n            # æåˆ°çš„æ ‡è¯†ç¬¦æƒé‡Ã—10\n            # æ£€æŸ¥ï¼š1) è·¯å¾„ç»„ä»¶  2) æ–‡ä»¶ä¸­çš„å®šä¹‰åç§°\n            if mentioned_idents:\n                # æ£€æŸ¥è·¯å¾„ç»„ä»¶ï¼ˆå¦‚ agents/llm/timeoutï¼‰\n                path_components = set(Path(node).parts)\n                basename_with_ext = Path(node).name\n                basename_without_ext = Path(node).stem\n                components_to_check = path_components.union({basename_with_ext, basename_without_ext})\n                \n                # æ£€æŸ¥è·¯å¾„æ˜¯å¦åŒ…å«æåˆ°çš„æ ‡è¯†ç¬¦\n                matched_path = components_to_check.intersection(set(ident.lower() for ident in mentioned_idents))\n                if matched_path:\n                    weight *= 10\n                \n                # æ£€æŸ¥æ–‡ä»¶ä¸­çš„å®šä¹‰æ˜¯å¦åŒ…å«æåˆ°çš„æ ‡è¯†ç¬¦\n                if node in definitions:\n                    file_defs = definitions.get(node, [])\n                    def_names = {d['name'].lower() for d in file_defs if d.get('kind') == 'def'}\n                    mentioned_lower = {ident.lower() for ident in mentioned_idents}\n                    \n                    # ç²¾ç¡®åŒ¹é…æˆ–éƒ¨åˆ†åŒ¹é…\n                    if def_names.intersection(mentioned_lower):\n                        weight *= 10\n                    else:\n                        # éƒ¨åˆ†åŒ¹é…ï¼ˆå¦‚ 'timeout' åŒ¹é… 'TimeoutError'ï¼‰\n                        for def_name in def_names:\n                            for ident in mentioned_lower:\n                                if ident in def_name or def_name in ident:\n                                    weight *= 5  # éƒ¨åˆ†åŒ¹é…æƒé‡è¾ƒä½\n                                    break\n            \n            personalization[node] = weight\n        \n        # å½’ä¸€åŒ–\n        total = sum(personalization.values())\n        personalization = {k: v / total for k, v in personalization.items()}\n        \n        # PageRankè¿­ä»£\n        for _ in range(iterations):\n            new_scores = {}\n            \n            for node in nodes:\n                # åŸºç¡€åˆ†æ•°ï¼ˆéšæœºè·³è½¬ï¼‰\n                score = (1 - damping) * personalization.get(node, 1.0 / len(nodes))\n                \n                # æ¥è‡ªå…¶ä»–èŠ‚ç‚¹çš„åˆ†æ•°\n                for source, targets in graph.items():\n                    if node in targets:\n                        # source -> node\n                        weight = targets[node]\n                        out_weight = sum(targets.values())\n                        score += damping * scores[source] * (weight / out_weight)\n                \n                new_scores[node] = score\n            \n            scores = new_scores\n        \n        # æ’åº\n        ranked = sorted(scores.items(), key=lambda x: x[1], reverse=True)\n        return ranked\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 583,
"end": 645,
"text": "    def _generate_map(\n        self,\n        ranked: List[Tuple[str, float]],\n        definitions: Dict[str, List[Dict]],\n        max_tokens: int\n    ) -> str:\n        \"\"\"\n        ç”Ÿæˆä»£ç åœ°å›¾ï¼ˆæ§åˆ¶tokenæ•°é‡ï¼‰\n        \n        ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°æœ€ä¼˜tokenæ•°é‡\n        \"\"\"\n        lines = []\n        current_tokens = 0\n        \n        for file_path, score in ranked:\n            if file_path not in definitions:\n                continue\n            \n            file_defs = definitions[file_path]\n            if not file_defs:\n                continue\n            \n            # åªåŒ…å«å®šä¹‰ï¼Œä¸åŒ…å«å¼•ç”¨\n            file_defs = [d for d in file_defs if d.get(\"kind\") == \"def\"]\n            if not file_defs:\n                continue\n            \n            # æ ‡å‡†åŒ–è·¯å¾„ï¼ˆç¡®ä¿è¿”å›ç›¸å¯¹äº repo_path çš„è·¯å¾„ï¼‰\n            normalized_path = self.normalize_path(file_path)\n            \n            # æ–‡ä»¶å¤´\n            file_line = f\"\\n{normalized_path}:\"\n            file_tokens = len(file_line.split())\n            \n            if current_tokens + file_tokens > max_tokens:\n                break\n            \n            lines.append(file_line)\n            current_tokens += file_tokens\n            \n            # å®šä¹‰åˆ—è¡¨\n            for d in file_defs:\n                def_line = f\"  {d.get('type', 'unknown')} {d['name']} (line {d['line']})\"\n                def_tokens = len(def_line.split())\n                \n                if current_tokens + def_tokens > max_tokens:\n                    break\n                \n                lines.append(def_line)\n                current_tokens += def_tokens\n            \n            if current_tokens >= max_tokens:\n                break\n        \n        if not lines:\n            return \"ä»£ç åœ°å›¾ä¸ºç©º\"\n        \n        # æ·»åŠ å¤´éƒ¨\n        file_count = len([l for l in lines if l.startswith('\\n')])\n        header = f\"# ä»£ç åœ°å›¾ (Top {file_count} æ–‡ä»¶)\\n\"\n        return header + \"\\n\".join(lines)\n\n"
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 646,
"end": 733,
"text": "class GetRepoStructureTool(BaseTool):\n    \"\"\"\n    è·å–ä»“åº“ç»“æ„ï¼ˆç®€åŒ–ç‰ˆRepoMapï¼‰\n    \n    åªè¿”å›æ–‡ä»¶æ ‘ï¼Œä¸åšæ™ºèƒ½æ’åº\n    æ”¯æŒæ™ºèƒ½æ³¨é‡Šï¼Œå¸®åŠ©ç†è§£ç›®å½•å«ä¹‰\n    \"\"\"\n    \n    # ç›®å½•ç»“æ„ä¹Ÿéœ€è¦é™åˆ¶\n    MAX_OUTPUT_LINES = 500\n    MAX_OUTPUT_CHARS = 8000\n    \n    # æ™ºèƒ½æ³¨é‡Šæ˜ å°„\n    DIRECTORY_ANNOTATIONS = {\n        'backend': 'åç«¯ä»£ç ',\n        'frontend': 'å‰ç«¯ä»£ç ',\n        'src': 'æºä»£ç ',\n        'lib': 'åº“æ–‡ä»¶',\n        'tests': 'æµ‹è¯•ä»£ç ',\n        'test': 'æµ‹è¯•ä»£ç ',\n        'docs': 'æ–‡æ¡£',\n        'doc': 'æ–‡æ¡£',\n        'scripts': 'è„šæœ¬å·¥å…·',\n        'script': 'è„šæœ¬å·¥å…·',\n        'config': 'é…ç½®æ–‡ä»¶',\n        'conf': 'é…ç½®æ–‡ä»¶',\n        'agents': 'Agentç³»ç»Ÿ',\n        'agent': 'Agentç³»ç»Ÿ',\n        'tools': 'å·¥å…·æ¨¡å—',\n        'tool': 'å·¥å…·æ¨¡å—',\n        'memory': 'è®°å¿†ç³»ç»Ÿ',\n        'orchestrators': 'ç¼–æ’å™¨',\n        'orchestrator': 'ç¼–æ’å™¨',\n        'llm': 'LLMå®¢æˆ·ç«¯',\n        'cli': 'å‘½ä»¤è¡Œç•Œé¢',\n        'api': 'APIæ¥å£',\n        'models': 'æ•°æ®æ¨¡å‹',\n        'model': 'æ•°æ®æ¨¡å‹',\n        'utils': 'å·¥å…·å‡½æ•°',\n        'util': 'å·¥å…·å‡½æ•°',\n        'core': 'æ ¸å¿ƒç»„ä»¶',\n        'common': 'å…¬å…±æ¨¡å—',\n        'shared': 'å…±äº«æ¨¡å—',\n        'components': 'ç»„ä»¶',\n        'component': 'ç»„ä»¶',\n        'services': 'æœåŠ¡',\n        'service': 'æœåŠ¡',\n        'controllers': 'æ§åˆ¶å™¨',\n        'controller': 'æ§åˆ¶å™¨',\n        'views': 'è§†å›¾',\n        'view': 'è§†å›¾',\n        'templates': 'æ¨¡æ¿',\n        'template': 'æ¨¡æ¿',\n        'static': 'é™æ€èµ„æº',\n        'assets': 'èµ„æºæ–‡ä»¶',\n        'public': 'å…¬å¼€èµ„æº',\n        'private': 'ç§æœ‰æ¨¡å—',\n        'internal': 'å†…éƒ¨æ¨¡å—',\n        'external': 'å¤–éƒ¨æ¨¡å—',\n        'vendor': 'ç¬¬ä¸‰æ–¹åº“',\n        'node_modules': 'ä¾èµ–åŒ…',\n        'dist': 'æ„å»ºäº§ç‰©',\n        'build': 'æ„å»ºäº§ç‰©',\n        'out': 'è¾“å‡ºç›®å½•',\n        'bin': 'å¯æ‰§è¡Œæ–‡ä»¶',\n        'pkg': 'åŒ…æ–‡ä»¶',\n        'examples': 'ç¤ºä¾‹ä»£ç ',\n        'example': 'ç¤ºä¾‹ä»£ç ',\n        'demo': 'æ¼”ç¤ºä»£ç ',\n        'plugins': 'æ’ä»¶',\n        'plugin': 'æ’ä»¶',\n        'extensions': 'æ‰©å±•',\n        'extension': 'æ‰©å±•',\n        'middleware': 'ä¸­é—´ä»¶',\n        'handlers': 'å¤„ç†å™¨',\n        'handler': 'å¤„ç†å™¨',\n        'routes': 'è·¯ç”±',\n        'route': 'è·¯ç”±',\n        'database': 'æ•°æ®åº“',\n        'db': 'æ•°æ®åº“',\n        'migrations': 'æ•°æ®è¿ç§»',\n        'migration': 'æ•°æ®è¿ç§»',\n        'seeds': 'æ•°æ®ç§å­',\n        'seed': 'æ•°æ®ç§å­',\n        'fixtures': 'æµ‹è¯•æ•°æ®',\n        'fixture': 'æµ‹è¯•æ•°æ®',\n    }\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 734,
"end": 739,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"get_repo_structure\",\n            description=\"è·å–ä»“åº“ç›®å½•ç»“æ„ï¼Œæ”¯æŒæ™ºèƒ½æ³¨é‡Š\"\n        )\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 740,
"end": 821,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        \"\"\"è·å–Function Calling schema\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"repo_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"ä»“åº“æ ¹ç›®å½•è·¯å¾„ã€‚å¿…é¡»ä½¿ç”¨ '.' è¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•ï¼Œä¸è¦ä½¿ç”¨å ä½ç¬¦è·¯å¾„ï¼\"\n                    },\n                    \"max_depth\": {\n                        \"type\": \"integer\",\n                        \"description\": \"æœ€å¤§æ·±åº¦\",\n                        \"default\": 3\n                    },\n                    \"show_files\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦æ˜¾ç¤ºæ–‡ä»¶ï¼ˆå¦åˆ™åªæ˜¾ç¤ºç›®å½•ï¼‰\",\n                        \"default\": True\n                    },\n                    \"annotate\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦æ·»åŠ æ™ºèƒ½æ³¨é‡Šï¼ˆå¸®åŠ©ç†è§£ç›®å½•å«ä¹‰ï¼‰\",\n                        \"default\": True\n                    }\n                },\n                \"required\": [\"repo_path\"]\n            }\n        }\n    \n    async def execute(\n        self,\n        repo_path: str,\n        max_depth: int = 3,\n        show_files: bool = True,\n        annotate: bool = True\n    ) -> ToolResult:\n        \"\"\"\n        è·å–ä»“åº“ç»“æ„\n        \n        Args:\n            repo_path: ä»“åº“æ ¹ç›®å½•\n            max_depth: æœ€å¤§æ·±åº¦\n            show_files: æ˜¯å¦æ˜¾ç¤ºæ–‡ä»¶\n            annotate: æ˜¯å¦æ·»åŠ æ™ºèƒ½æ³¨é‡Š\n            \n        Returns:\n            ToolResult\n        \"\"\"\n        try:\n            repo_path = Path(repo_path).resolve()\n            if not repo_path.exists():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"ä»“åº“è·¯å¾„ä¸å­˜åœ¨: {repo_path}\"\n                )\n            \n            lines = [f\"{repo_path.name}/\"]\n            self._build_tree(repo_path, lines, \"\", max_depth, show_files, annotate)\n            \n            return ToolResult(\n                success=True,\n                content=\"\\n\".join(lines),\n                metadata={\n                    'repo_path': str(repo_path),\n                    'max_depth': max_depth,\n                    'show_files': show_files,\n                    'annotate': annotate\n                }\n            )\n            \n        except Exception as e:\n            logger.error(f\"è·å–ä»“åº“ç»“æ„å¤±è´¥: {e}\", exc_info=True)\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 822,
"end": 864,
"text": "    def _build_tree(\n        self,\n        path: Path,\n        lines: List[str],\n        prefix: str,\n        max_depth: int,\n        show_files: bool,\n        annotate: bool,\n        current_depth: int = 0\n    ):\n        \"\"\"é€’å½’æ„å»ºæ ‘\"\"\"\n        if current_depth >= max_depth:\n            return\n        \n        # å¿½ç•¥çš„ç›®å½•\n        ignore = {\".git\", \"node_modules\", \"__pycache__\", \".venv\", \"venv\", \"dist\", \"build\"}\n        \n        try:\n            items = sorted(path.iterdir(), key=lambda x: (not x.is_dir(), x.name))\n        except PermissionError:\n            return\n        \n        for i, item in enumerate(items):\n            if item.name in ignore:\n                continue\n            \n            is_last = i == len(items) - 1\n            current_prefix = \"â””â”€â”€ \" if is_last else \"â”œâ”€â”€ \"\n            next_prefix = prefix + (\"    \" if is_last else \"â”‚   \")\n            \n            if item.is_dir():\n                # æ·»åŠ æ³¨é‡Š\n                dir_display = f\"{item.name}/\"\n                if annotate:\n                    annotation = self._get_annotation(item.name)\n                    if annotation:\n                        dir_display = f\"{item.name}/  # {annotation}\"\n                \n                lines.append(f\"{prefix}{current_prefix}{dir_display}\")\n                self._build_tree(item, lines, next_prefix, max_depth, show_files, annotate, current_depth + 1)\n            elif show_files:\n                lines.append(f\"{prefix}{current_prefix}{item.name}\")\n    "
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 865,
"end": 880,
"text": "    def _get_annotation(self, dir_name: str) -> Optional[str]:\n        \"\"\"è·å–ç›®å½•æ³¨é‡Š\"\"\"\n        dir_lower = dir_name.lower()\n        \n        # ç²¾ç¡®åŒ¹é…\n        if dir_lower in self.DIRECTORY_ANNOTATIONS:\n            return self.DIRECTORY_ANNOTATIONS[dir_lower]\n        \n        # éƒ¨åˆ†åŒ¹é…\n        for pattern, annotation in self.DIRECTORY_ANNOTATIONS.items():\n            if pattern in dir_lower:\n                return annotation\n        \n        return None\n\n"
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 881,
"end": 888,
"text": "class GetFileSymbolsTool(BaseTool):\n    \"\"\"\n    è·å–å•æ–‡ä»¶ç¬¦å·è¡¨ï¼ˆç±»/å‡½æ•°/æ–¹æ³•ç­‰ï¼ŒAST æ·±åº¦ï¼‰\n    \n    ä¸ repo_map äº’è¡¥ï¼šå·²çŸ¥æ–‡ä»¶æ—¶å¯ç›´æ¥å–è¯¥æ–‡ä»¶çš„å®šä¹‰åˆ—è¡¨ï¼Œä¾¿äºç²¾ç¡®ç†è§£ä»£ç ç»“æ„ã€‚\n    ä½¿ç”¨ä¸ RepoMap ç›¸åŒçš„ Tree-sitter è§£æã€‚\n    \"\"\"\n"
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 889,
"end": 925,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"get_file_symbols\",\n            description=\"è·å–æŒ‡å®šæ–‡ä»¶ä¸­çš„ç¬¦å·å®šä¹‰ï¼ˆç±»ã€å‡½æ•°ã€æ–¹æ³•ç­‰ï¼‰åŠè¡Œå·ï¼ŒåŸºäº AST è§£æã€‚\"\n        )\n\n    async def execute(self, file_path: str) -> ToolResult:\n        try:\n            path = self.resolve_path(file_path)\n            if not path.exists() or not path.is_file():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸æ˜¯æ–‡ä»¶: {file_path}\"\n                )\n            # å¤ç”¨ RepoMapTool çš„è§£æé€»è¾‘\n            repomap = RepoMapTool()\n            repomap._context = self.context\n            defs = repomap._parse_file(path)\n            defs = [d for d in defs if d.get(\"kind\") == \"def\"]\n            if not defs:\n                return ToolResult(\n                    success=True,\n                    content=\"è¯¥æ–‡ä»¶ä¸­æœªè§£æåˆ°ç¬¦å·å®šä¹‰ï¼ˆæˆ–è¯­è¨€/è§£æå™¨ä¸æ”¯æŒï¼‰\",\n                    metadata={\"file_path\": str(path), \"count\": 0}\n                )\n            lines = [f\"  {d.get('type', '?')} {d['name']} (line {d['line']})\" for d in defs]\n            text = f\"# {path.name}\\n\" + \"\\n\".join(lines)\n            return ToolResult(\n                success=True,\n                content=text,\n                metadata={\"file_path\": str(path), \"count\": len(defs)}\n            )\n        except Exception as e:\n            logger.exception(\"get_file_symbols å¤±è´¥\")\n            return ToolResult(success=False, content=None, error=str(e))\n"
},
{
"path": "daoyoucode/agents/tools/repomap_tools.py",
"start": 926,
"end": 940,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"file_path\": {\n                        \"type\": \"string\",\n                        \"description\": \"ç›¸å¯¹é¡¹ç›®æ ¹çš„æ–‡ä»¶è·¯å¾„\"\n                    }\n                },\n                \"required\": [\"file_path\"]\n            }\n        }"
},
{
"path": "daoyoucode/agents/tools/search_tools.py",
"start": 1,
"end": 12,
"text": "\"\"\"\nä»£ç æœç´¢å·¥å…·\n\næä¾›æ–‡æœ¬æœç´¢ã€æ­£åˆ™æœç´¢ç­‰åŠŸèƒ½\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nimport re\nfrom .base import BaseTool, ToolResult\n\n"
},
{
"path": "daoyoucode/agents/tools/search_tools.py",
"start": 13,
"end": 19,
"text": "class TextSearchTool(BaseTool):\n    \"\"\"æ–‡æœ¬æœç´¢å·¥å…·ï¼ˆç±»ä¼¼ripgrepï¼‰\"\"\"\n    \n    # æœç´¢ç»“æœé™åˆ¶è¡Œæ•°\n    MAX_OUTPUT_LINES = 100\n    MAX_OUTPUT_CHARS = 6000\n    "
},
{
"path": "daoyoucode/agents/tools/search_tools.py",
"start": 20,
"end": 111,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"text_search\",\n            description=\"åœ¨æ–‡ä»¶ä¸­æœç´¢æ–‡æœ¬\"\n        )\n    \n    async def execute(\n        self,\n        query: str,\n        directory: str = \".\",\n        file_pattern: Optional[str] = None,\n        case_sensitive: bool = False,\n        max_results: int = 100\n    ) -> ToolResult:\n        \"\"\"\n        æœç´¢æ–‡æœ¬\n        \n        Args:\n            query: æœç´¢å…³é”®è¯\n            directory: æœç´¢ç›®å½•\n            file_pattern: æ–‡ä»¶åæ¨¡å¼ï¼ˆå¦‚ *.pyï¼‰\n            case_sensitive: æ˜¯å¦åŒºåˆ†å¤§å°å†™\n            max_results: æœ€å¤§ç»“æœæ•°\n        \"\"\"\n        try:\n            # ä½¿ç”¨ resolve_path è§£æè·¯å¾„\n            path = self.resolve_path(directory)\n            \n            if not path.exists():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"Directory not found: {directory} (resolved to {path})\"\n                )\n            \n            results = []\n            count = 0\n            \n            # å‡†å¤‡æœç´¢\n            if not case_sensitive:\n                query_lower = query.lower()\n            \n            # éå†æ–‡ä»¶\n            for file_path in self._iter_files(path, file_pattern):\n                if count >= max_results:\n                    break\n                \n                try:\n                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                        for line_num, line in enumerate(f, 1):\n                            if count >= max_results:\n                                break\n                            \n                            # æœç´¢\n                            if case_sensitive:\n                                if query in line:\n                                    results.append({\n                                        'file': self.normalize_path(str(file_path)),  # æ ‡å‡†åŒ–è·¯å¾„\n                                        'line': line_num,\n                                        'content': line.rstrip(),\n                                        'match': query\n                                    })\n                                    count += 1\n                            else:\n                                if query_lower in line.lower():\n                                    results.append({\n                                        'file': self.normalize_path(str(file_path)),  # æ ‡å‡†åŒ–è·¯å¾„\n                                        'line': line_num,\n                                        'content': line.rstrip(),\n                                        'match': query\n                                    })\n                                    count += 1\n                except Exception:\n                    continue\n            \n            return ToolResult(\n                success=True,\n                content=results,\n                metadata={\n                    'query': query,\n                    'directory': str(path),\n                    'count': len(results),\n                    'truncated': count >= max_results\n                }\n            )\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/search_tools.py",
"start": 112,
"end": 120,
"text": "    def _iter_files(self, path: Path, pattern: Optional[str]):\n        \"\"\"è¿­ä»£æ–‡ä»¶\"\"\"\n        try:\n            for item in path.rglob(pattern or '*'):\n                if item.is_file() and not self._should_ignore(item):\n                    yield item\n        except Exception:\n            pass\n    "
},
{
"path": "daoyoucode/agents/tools/search_tools.py",
"start": 121,
"end": 136,
"text": "    def _should_ignore(self, path: Path) -> bool:\n        \"\"\"æ˜¯å¦åº”è¯¥å¿½ç•¥\"\"\"\n        ignore_dirs = {'.git', '__pycache__', 'node_modules', '.venv', 'venv', 'dist', 'build'}\n        ignore_exts = {'.pyc', '.pyo', '.so', '.dll', '.exe', '.bin'}\n        \n        # æ£€æŸ¥è·¯å¾„ä¸­æ˜¯å¦åŒ…å«å¿½ç•¥çš„ç›®å½•\n        for part in path.parts:\n            if part in ignore_dirs:\n                return True\n        \n        # æ£€æŸ¥æ‰©å±•å\n        if path.suffix in ignore_exts:\n            return True\n        \n        return False\n    "
},
{
"path": "daoyoucode/agents/tools/search_tools.py",
"start": 137,
"end": 172,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"query\": {\n                        \"type\": \"string\",\n                        \"description\": \"æœç´¢å…³é”®è¯\"\n                    },\n                    \"directory\": {\n                        \"type\": \"string\",\n                        \"description\": \"æœç´¢ç›®å½•ã€‚é»˜è®¤ä¸ºå½“å‰å·¥ä½œç›®å½•ï¼ˆ'.'ï¼‰ï¼Œä¹Ÿå¯ä»¥æŒ‡å®šå­ç›®å½•çš„ç›¸å¯¹è·¯å¾„\",\n                        \"default\": \".\"\n                    },\n                    \"file_pattern\": {\n                        \"type\": \"string\",\n                        \"description\": \"æ–‡ä»¶åæ¨¡å¼ï¼ˆå¦‚ *.pyï¼‰\"\n                    },\n                    \"case_sensitive\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"æ˜¯å¦åŒºåˆ†å¤§å°å†™\",\n                        \"default\": False\n                    },\n                    \"max_results\": {\n                        \"type\": \"integer\",\n                        \"description\": \"æœ€å¤§ç»“æœæ•°\",\n                        \"default\": 100\n                    }\n                },\n                \"required\": [\"query\"]\n            }\n        }\n\n"
},
{
"path": "daoyoucode/agents/tools/search_tools.py",
"start": 173,
"end": 179,
"text": "class RegexSearchTool(BaseTool):\n    \"\"\"æ­£åˆ™è¡¨è¾¾å¼æœç´¢å·¥å…·\"\"\"\n    \n    # æœç´¢ç»“æœé™åˆ¶\n    MAX_OUTPUT_LINES = 100\n    MAX_OUTPUT_CHARS = 6000\n    "
},
{
"path": "daoyoucode/agents/tools/search_tools.py",
"start": 180,
"end": 267,
"text": "    def __init__(self):\n        super().__init__(\n            name=\"regex_search\",\n            description=\"ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æœç´¢æ–‡ä»¶\"\n        )\n    \n    async def execute(\n        self,\n        pattern: str,\n        directory: str = \".\",\n        file_pattern: Optional[str] = None,\n        flags: int = 0,\n        max_results: int = 100\n    ) -> ToolResult:\n        \"\"\"\n        æ­£åˆ™æœç´¢\n        \n        Args:\n            pattern: æ­£åˆ™è¡¨è¾¾å¼\n            directory: æœç´¢ç›®å½•\n            file_pattern: æ–‡ä»¶åæ¨¡å¼\n            flags: æ­£åˆ™æ ‡å¿—ï¼ˆå¦‚ re.IGNORECASEï¼‰\n            max_results: æœ€å¤§ç»“æœæ•°\n        \"\"\"\n        try:\n            path = Path(directory)\n            if not path.exists():\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"Directory not found: {directory}\"\n                )\n            \n            # ç¼–è¯‘æ­£åˆ™\n            try:\n                regex = re.compile(pattern, flags)\n            except re.error as e:\n                return ToolResult(\n                    success=False,\n                    content=None,\n                    error=f\"Invalid regex pattern: {e}\"\n                )\n            \n            results = []\n            count = 0\n            \n            # éå†æ–‡ä»¶\n            for file_path in self._iter_files(path, file_pattern):\n                if count >= max_results:\n                    break\n                \n                try:\n                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                        for line_num, line in enumerate(f, 1):\n                            if count >= max_results:\n                                break\n                            \n                            # æœç´¢\n                            match = regex.search(line)\n                            if match:\n                                results.append({\n                                    'file': self.normalize_path(str(file_path)),  # æ ‡å‡†åŒ–è·¯å¾„\n                                    'line': line_num,\n                                    'content': line.rstrip(),\n                                    'match': match.group(0),\n                                    'groups': match.groups()\n                                })\n                                count += 1\n                except Exception:\n                    continue\n            \n            return ToolResult(\n                success=True,\n                content=results,\n                metadata={\n                    'pattern': pattern,\n                    'directory': str(path),\n                    'count': len(results),\n                    'truncated': count >= max_results\n                }\n            )\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                content=None,\n                error=str(e)\n            )\n    "
},
{
"path": "daoyoucode/agents/tools/search_tools.py",
"start": 268,
"end": 276,
"text": "    def _iter_files(self, path: Path, pattern: Optional[str]):\n        \"\"\"è¿­ä»£æ–‡ä»¶\"\"\"\n        try:\n            for item in path.rglob(pattern or '*'):\n                if item.is_file() and not self._should_ignore(item):\n                    yield item\n        except Exception:\n            pass\n    "
},
{
"path": "daoyoucode/agents/tools/search_tools.py",
"start": 277,
"end": 290,
"text": "    def _should_ignore(self, path: Path) -> bool:\n        \"\"\"æ˜¯å¦åº”è¯¥å¿½ç•¥\"\"\"\n        ignore_dirs = {'.git', '__pycache__', 'node_modules', '.venv', 'venv', 'dist', 'build'}\n        ignore_exts = {'.pyc', '.pyo', '.so', '.dll', '.exe', '.bin'}\n        \n        for part in path.parts:\n            if part in ignore_dirs:\n                return True\n        \n        if path.suffix in ignore_exts:\n            return True\n        \n        return False\n    "
},
{
"path": "daoyoucode/agents/tools/search_tools.py",
"start": 291,
"end": 324,
"text": "    def get_function_schema(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"pattern\": {\n                        \"type\": \"string\",\n                        \"description\": \"æ­£åˆ™è¡¨è¾¾å¼\"\n                    },\n                    \"directory\": {\n                        \"type\": \"string\",\n                        \"description\": \"æœç´¢ç›®å½•ã€‚é»˜è®¤ä¸ºå½“å‰å·¥ä½œç›®å½•ï¼ˆ'.'ï¼‰ï¼Œä¹Ÿå¯ä»¥æŒ‡å®šå­ç›®å½•çš„ç›¸å¯¹è·¯å¾„\",\n                        \"default\": \".\"\n                    },\n                    \"file_pattern\": {\n                        \"type\": \"string\",\n                        \"description\": \"æ–‡ä»¶åæ¨¡å¼ï¼ˆå¦‚ *.pyï¼‰\"\n                    },\n                    \"flags\": {\n                        \"type\": \"integer\",\n                        \"description\": \"æ­£åˆ™æ ‡å¿—\",\n                        \"default\": 0\n                    },\n                    \"max_results\": {\n                        \"type\": \"integer\",\n                        \"description\": \"æœ€å¤§ç»“æœæ•°\",\n                        \"default\": 100\n                    }\n                },\n                \"required\": [\"pattern\"]\n            }\n        }"
},
{
"path": "daoyoucode/agents/tools/tool_groups.py",
"start": 1,
"end": 222,
"text": "\"\"\"\nAgentå·¥å…·åˆ†ç»„é…ç½®\n\næ¯ä¸ªä¸“ä¸šAgentåªä½¿ç”¨å®ƒéœ€è¦çš„å·¥å…·å­é›†\n\"\"\"\n\n# ============================================================================\n# ä¸»ç¼–æ’Agentå·¥å…·é›†ï¼ˆ4ä¸ªï¼‰\n# ============================================================================\nORCHESTRATOR_TOOLS = [\n    'repo_map',              # ç”Ÿæˆä»£ç åœ°å›¾\n    'get_repo_structure',    # è·å–ç›®å½•ç»“æ„\n    'text_search',           # å¿«é€Ÿæœç´¢\n    'read_file'              # è¯»å–æ–‡ä»¶\n]\n\n# ============================================================================\n# ä»£ç æ¢ç´¢Agentå·¥å…·é›†ï¼ˆ8ä¸ªï¼‰\n# ============================================================================\nEXPLORE_TOOLS = [\n    # é¡¹ç›®ç»“æ„\n    'repo_map',\n    'get_repo_structure',\n    \n    # æœç´¢å·¥å…·\n    'text_search',\n    'regex_search',\n    \n    # æ–‡ä»¶è¯»å–\n    'read_file',\n    'list_files',\n    'get_file_info',\n    \n    # ASTæœç´¢\n    'find_function'\n]\n\n# ============================================================================\n# ä»£ç åˆ†æAgentå·¥å…·é›†ï¼ˆ10ä¸ªï¼‰\n# ============================================================================\nANALYZER_TOOLS = [\n    # é¡¹ç›®ç†è§£\n    'repo_map',\n    'get_repo_structure',\n    'read_file',\n    \n    # æœç´¢\n    'text_search',\n    'regex_search',\n    \n    # LSPå·¥å…·ï¼ˆä»£ç ç†è§£ï¼‰\n    'get_diagnostics',      # è·å–è¯Šæ–­ä¿¡æ¯\n    'find_references',      # æŸ¥æ‰¾å¼•ç”¨\n    'get_symbols',          # è·å–ç¬¦å·\n    \n    # ASTå·¥å…·\n    'parse_ast',            # è§£æAST\n    'find_function'         # æŸ¥æ‰¾å‡½æ•°\n]\n\n# ============================================================================\n# ç¼–ç¨‹Agentå·¥å…·é›†ï¼ˆ12ä¸ªï¼‰\n# ============================================================================\nPROGRAMMER_TOOLS = [\n    # æ–‡ä»¶æ“ä½œ\n    'read_file',\n    'write_file',\n    'list_files',\n    'get_file_info',\n    \n    # æœç´¢\n    'text_search',\n    'find_function',\n    \n    # Gitå·¥å…·\n    'git_status',\n    'git_diff',\n    'git_commit',\n    \n    # åŸºç¡€è¯Šæ–­\n    'get_diagnostics',\n    \n    # å‘½ä»¤æ‰§è¡Œ\n    'run_command'\n]\n\n# ============================================================================\n# é‡æ„Agentå·¥å…·é›†ï¼ˆ14ä¸ªï¼‰\n# ============================================================================\nREFACTOR_TOOLS = [\n    # æ–‡ä»¶æ“ä½œ\n    'read_file',\n    'write_file',\n    'list_files',\n    \n    # æœç´¢\n    'text_search',\n    'regex_search',\n    \n    # LSPå·¥å…·ï¼ˆé‡æ„å¿…å¤‡ï¼‰\n    'get_diagnostics',      # æ£€æŸ¥é”™è¯¯\n    'find_references',      # æŸ¥æ‰¾æ‰€æœ‰å¼•ç”¨\n    'semantic_rename',      # è¯­ä¹‰é‡å‘½å\n    'get_symbols',          # è·å–ç¬¦å·\n    \n    # ASTå·¥å…·\n    'parse_ast',\n    'find_function',\n    \n    # Gitå·¥å…·\n    'git_diff',\n    'git_commit'\n]\n\n# ============================================================================\n# æµ‹è¯•Agentå·¥å…·é›†ï¼ˆ11ä¸ªï¼‰\n# ============================================================================\nTEST_TOOLS = [\n    # æ–‡ä»¶æ“ä½œ\n    'read_file',\n    'write_file',\n    'list_files',\n    \n    # æœç´¢\n    'text_search',\n    'find_function',\n    \n    # æµ‹è¯•æ‰§è¡Œ\n    'run_command',          # è¿è¡Œæµ‹è¯•å‘½ä»¤\n    'run_tests',            # ä¸“ç”¨æµ‹è¯•å·¥å…·\n    \n    # Gitå·¥å…·\n    'git_diff',\n    'git_commit',\n    \n    # è¯Šæ–­\n    'get_diagnostics'\n]\n\n# ============================================================================\n# ç¿»è¯‘Agentå·¥å…·é›†ï¼ˆ6ä¸ªï¼‰\n# ============================================================================\nTRANSLATOR_TOOLS = [\n    # æ–‡ä»¶æ“ä½œ\n    'read_file',\n    'write_file',\n    'list_files',\n    \n    # æœç´¢\n    'text_search',\n    'regex_search',\n    \n    # Gitå·¥å…·\n    'git_commit'\n]\n\n# ============================================================================\n# å·¥å…·åˆ†ç±»ï¼ˆæŒ‰åŠŸèƒ½ï¼‰\n# ============================================================================\n\n# åªè¯»å·¥å…·ï¼ˆæ¢ç´¢å’Œåˆ†æï¼‰\nREADONLY_TOOLS = [\n    'repo_map',\n    'get_repo_structure',\n    'read_file',\n    'list_files',\n    'get_file_info',\n    'text_search',\n    'regex_search',\n    'find_function',\n    'parse_ast',\n    'get_symbols',\n    'get_diagnostics',\n    'find_references'\n]\n\n# å†™å…¥å·¥å…·ï¼ˆç¼–å†™å’Œä¿®æ”¹ï¼‰\nWRITE_TOOLS = [\n    'write_file',\n    'semantic_rename'\n]\n\n# Gitå·¥å…·ï¼ˆç‰ˆæœ¬æ§åˆ¶ï¼‰\nGIT_TOOLS = [\n    'git_status',\n    'git_diff',\n    'git_commit',\n    'git_log'\n]\n\n# æ‰§è¡Œå·¥å…·ï¼ˆè¿è¡Œå’Œæµ‹è¯•ï¼‰\nEXECUTION_TOOLS = [\n    'run_command',\n    'run_tests'\n]\n\n# é¡¹ç›®æ–‡æ¡£å·¥å…·\nDOC_TOOLS = [\n    'generate_project_doc'\n]\n\n# =="
},
{
"path": "daoyoucode/agents/tools/tool_groups.py",
"start": 223,
"end": 235,
"text": "def get_tools_for_agent(agent_name: str) -> list:\n    \"\"\"\n    æ ¹æ®Agentåç§°è·å–å·¥å…·é›†\n    \n    Args:\n        agent_name: Agentåç§°\n        \n    Returns:\n        å·¥å…·åç§°åˆ—è¡¨\n    \"\"\"\n    return AGENT_TOOL_MAPPING.get(agent_name, [])\n\n"
},
{
"path": "daoyoucode/agents/tools/tool_groups.py",
"start": 236,
"end": 243,
"text": "def get_all_tools() -> list:\n    \"\"\"è·å–æ‰€æœ‰å·¥å…·\"\"\"\n    all_tools = set()\n    for tools in AGENT_TOOL_MAPPING.values():\n        all_tools.update(tools)\n    return sorted(list(all_tools))\n\n"
},
{
"path": "daoyoucode/agents/tools/tool_groups.py",
"start": 244,
"end": 254,
"text": "def get_tool_categories() -> dict:\n    \"\"\"è·å–å·¥å…·åˆ†ç±»\"\"\"\n    return {\n        'readonly': READONLY_TOOLS,\n        'write': WRITE_TOOLS,\n        'git': GIT_TOOLS,\n        'execution': EXECUTION_TOOLS,\n        'doc': DOC_TOOLS\n    }\n\n"
},
{
"path": "daoyoucode/agents/tools/tool_groups.py",
"start": 255,
"end": 296,
"text": "def validate_tools(agent_name: str, requested_tools: list) -> tuple:\n    \"\"\"\n    éªŒè¯Agentè¯·æ±‚çš„å·¥å…·æ˜¯å¦åˆç†\n    \n    Args:\n        agent_name: Agentåç§°\n        requested_tools: è¯·æ±‚çš„å·¥å…·åˆ—è¡¨\n        \n    Returns:\n        (is_valid, invalid_tools, suggestions)\n    \"\"\"\n    allowed_tools = get_tools_for_agent(agent_name)\n    \n    if not allowed_tools:\n        # æœªé…ç½®å·¥å…·é›†ï¼Œå…è®¸æ‰€æœ‰å·¥å…·\n        return True, [], []\n    \n    invalid_tools = [t for t in requested_tools if t not in allowed_tools]\n    \n    if not invalid_tools:\n        return True, [], []\n    \n    # æä¾›å»ºè®®\n    suggestions = []\n    for tool in invalid_tools:\n        # æŸ¥æ‰¾å“ªäº›Agentå¯ä»¥ä½¿ç”¨è¿™ä¸ªå·¥å…·\n        agents_with_tool = [\n            name for name, tools in AGENT_TOOL_MAPPING.items()\n            if tool in tools\n        ]\n        if agents_with_tool:\n            suggestions.append(\n                f\"å·¥å…· '{tool}' å¯ç”±ä»¥ä¸‹Agentä½¿ç”¨: {', '.join(agents_with_tool)}\"\n            )\n    \n    return False, invalid_tools, suggestions\n\n\n# ============================================================================\n# ç»Ÿè®¡ä¿¡æ¯\n# ============================================================================\n"
},
{
"path": "daoyoucode/agents/tools/tool_groups.py",
"start": 297,
"end": 333,
"text": "def get_tool_stats() -> dict:\n    \"\"\"è·å–å·¥å…·ä½¿ç”¨ç»Ÿè®¡\"\"\"\n    stats = {\n        'total_tools': len(get_all_tools()),\n        'agents': {}\n    }\n    \n    for agent_name, tools in AGENT_TOOL_MAPPING.items():\n        stats['agents'][agent_name] = {\n            'tool_count': len(tools),\n            'tools': tools\n        }\n    \n    return stats\n\n\nif __name__ == '__main__':\n    # æ‰“å°ç»Ÿè®¡ä¿¡æ¯\n    print(\"=\" * 80)\n    print(\"Agentå·¥å…·åˆ†ç»„ç»Ÿè®¡\")\n    print(\"=\" * 80)\n    \n    stats = get_tool_stats()\n    print(f\"\\næ€»å·¥å…·æ•°: {stats['total_tools']}\")\n    print(f\"Agentæ•°é‡: {len(stats['agents'])}\")\n    \n    print(\"\\nå„Agentå·¥å…·æ•°é‡:\")\n    for agent_name, info in sorted(stats['agents'].items(), \n                                   key=lambda x: x[1]['tool_count']):\n        print(f\"  {agent_name:20s}: {info['tool_count']:2d} ä¸ªå·¥å…·\")\n    \n    print(\"\\nå·¥å…·åˆ†ç±»:\")\n    categories = get_tool_categories()\n    for cat_name, tools in categories.items():\n        print(f\"  {cat_name:15s}: {len(tools):2d} ä¸ªå·¥å…·\")\n    \n    print(\"\\n\" + \"=\" * 80)"
},
{
"path": "daoyoucode/agents/tools/__init__.py",
"start": 1,
"end": 15,
"text": "\"\"\"\nå·¥å…·ç³»ç»Ÿ\n\næä¾›LSPã€ASTã€Gitã€æ–‡ä»¶æ“ä½œç­‰å·¥å…·é›†æˆ\n\"\"\"\n\nfrom .base import BaseTool, ToolResult, ToolRegistry\nfrom .registry import get_tool_registry\n\n__all__ = [\n    'BaseTool',\n    'ToolResult',\n    'ToolRegistry',\n    'get_tool_registry'\n]"
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 1,
"end": 21,
"text": "\"\"\"\nå·¥å…·æ‰§è¡ŒUIæ˜¾ç¤º\n\næä¾›ç¾è§‚çš„å·¥å…·æ‰§è¡Œè¿›åº¦å’Œç»“æœæ˜¾ç¤º\n\"\"\"\n\nfrom typing import Optional\nimport time\n\n# å°è¯•å¯¼å…¥ rich\ntry:\n    from rich.console import Console\n    from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn\n    from rich.panel import Panel\n    from rich.table import Table\n    from rich.syntax import Syntax\n    RICH_AVAILABLE = True\nexcept ImportError:\n    RICH_AVAILABLE = False\n\n"
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 22,
"end": 24,
"text": "class ToolDisplay:\n    \"\"\"å·¥å…·æ‰§è¡Œæ˜¾ç¤ºå™¨\"\"\"\n    "
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 25,
"end": 27,
"text": "    def __init__(self):\n        self.console = Console() if RICH_AVAILABLE else None\n    "
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 28,
"end": 48,
"text": "    def show_tool_start(self, tool_name: str, args: dict):\n        \"\"\"æ˜¾ç¤ºå·¥å…·å¼€å§‹æ‰§è¡Œ\"\"\"\n        if RICH_AVAILABLE:\n            # åˆ›å»ºå‚æ•°è¡¨æ ¼\n            table = Table(show_header=False, box=None, padding=(0, 1))\n            table.add_column(\"Key\", style=\"cyan\")\n            table.add_column(\"Value\", style=\"white\")\n            \n            for key, value in args.items():\n                # æˆªæ–­é•¿å€¼\n                value_str = str(value)\n                if len(value_str) > 60:\n                    value_str = value_str[:57] + \"...\"\n                table.add_row(key, value_str)\n            \n            self.console.print(f\"\\n[bold blue]ğŸ”§ æ‰§è¡Œå·¥å…·:[/bold blue] [cyan]{tool_name}[/cyan]\")\n            self.console.print(table)\n        else:\n            print(f\"\\nğŸ”§ æ‰§è¡Œå·¥å…·: {tool_name}\")\n            print(f\"   å‚æ•°: {args}\")\n    "
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 49,
"end": 66,
"text": "    def show_progress(self, tool_name: str, message: str = \"æ­£åœ¨æ‰§è¡Œ...\"):\n        \"\"\"\n        æ˜¾ç¤ºè¿›åº¦æ¡\n        \n        è¿”å›ä¸€ä¸ªä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œç”¨äº with è¯­å¥\n        \"\"\"\n        if RICH_AVAILABLE:\n            return Progress(\n                SpinnerColumn(),\n                TextColumn(\"[bold blue]{task.description}\"),\n                BarColumn(),\n                TextColumn(\"[progress.percentage]{task.percentage:>3.0f}%\"),\n                TimeElapsedColumn(),\n                console=self.console,\n                transient=True  # å®Œæˆåè‡ªåŠ¨æ¶ˆå¤±\n            )\n        else:\n            # ç®€å•çš„è¿›åº¦æ˜¾ç¤º"
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 67,
"end": 67,
"text": "            class SimpleProgress:"
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 68,
"end": 71,
"text": "                def __enter__(self):\n                    print(f\"   â³ {message}\")\n                    return self\n                "
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 72,
"end": 74,
"text": "                def __exit__(self, *args):\n                    pass\n                "
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 75,
"end": 77,
"text": "                def add_task(self, description, total=100):\n                    return 0\n                "
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 78,
"end": 82,
"text": "                def update(self, task_id, **kwargs):\n                    pass\n            \n            return SimpleProgress()\n    "
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 83,
"end": 89,
"text": "    def show_success(self, tool_name: str, duration: float):\n        \"\"\"æ˜¾ç¤ºæ‰§è¡ŒæˆåŠŸ\"\"\"\n        if RICH_AVAILABLE:\n            self.console.print(f\"   [green]âœ“[/green] æ‰§è¡Œå®Œæˆ [dim]({duration:.2f}ç§’)[/dim]\")\n        else:\n            print(f\"   âœ“ æ‰§è¡Œå®Œæˆ ({duration:.2f}ç§’)\")\n    "
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 90,
"end": 107,
"text": "    def show_error(self, tool_name: str, error: Exception, duration: float):\n        \"\"\"æ˜¾ç¤ºæ‰§è¡Œé”™è¯¯\"\"\"\n        if RICH_AVAILABLE:\n            error_msg = f\"[red]âœ— æ‰§è¡Œå¤±è´¥[/red] [dim]({duration:.2f}ç§’)[/dim]\\n\\n{str(error)}\"\n            \n            # å¦‚æœé”™è¯¯ä¿¡æ¯å¾ˆé•¿ï¼Œæˆªæ–­æ˜¾ç¤º\n            if len(str(error)) > 200:\n                error_msg = f\"[red]âœ— æ‰§è¡Œå¤±è´¥[/red] [dim]({duration:.2f}ç§’)[/dim]\\n\\n{str(error)[:200]}...\"\n            \n            self.console.print(Panel(\n                error_msg,\n                title=f\"å·¥å…·æ‰§è¡Œé”™è¯¯: {tool_name}\",\n                border_style=\"red\",\n                padding=(1, 2)\n            ))\n        else:\n            print(f\"   âœ— æ‰§è¡Œå¤±è´¥ ({duration:.2f}ç§’): {error}\")\n    "
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 108,
"end": 114,
"text": "    def show_warning(self, tool_name: str, message: str):\n        \"\"\"æ˜¾ç¤ºè­¦å‘Š\"\"\"\n        if RICH_AVAILABLE:\n            self.console.print(f\"   [yellow]âš ï¸  {message}[/yellow]\")\n        else:\n            print(f\"   âš ï¸  {message}\")\n    "
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 115,
"end": 146,
"text": "    def show_result_preview(self, result: str, max_lines: int = 5):\n        \"\"\"æ˜¾ç¤ºç»“æœé¢„è§ˆ\"\"\"\n        if not result:\n            return\n        \n        lines = result.split('\\n')\n        preview_lines = lines[:max_lines]\n        \n        if RICH_AVAILABLE:\n            if len(lines) > max_lines:\n                preview = '\\n'.join(preview_lines) + f\"\\n\\n[dim]... (è¿˜æœ‰ {len(lines) - max_lines} è¡Œ)[/dim]\"\n            else:\n                preview = '\\n'.join(preview_lines)\n            \n            self.console.print(Panel(\n                preview,\n                title=\"ç»“æœé¢„è§ˆ\",\n                border_style=\"green\",\n                padding=(1, 2)\n            ))\n        else:\n            print(\"\\n   ç»“æœé¢„è§ˆ:\")\n            for line in preview_lines:\n                print(f\"   {line}\")\n            if len(lines) > max_lines:\n                print(f\"   ... (è¿˜æœ‰ {len(lines) - max_lines} è¡Œ)\")\n\n\n# å…¨å±€å®ä¾‹\n_display = None\n\n"
},
{
"path": "daoyoucode/agents/ui/tool_display.py",
"start": 147,
"end": 152,
"text": "def get_tool_display() -> ToolDisplay:\n    \"\"\"è·å–å·¥å…·æ˜¾ç¤ºå™¨å®ä¾‹ï¼ˆå•ä¾‹ï¼‰\"\"\"\n    global _display\n    if _display is None:\n        _display = ToolDisplay()\n    return _display"
},
{
"path": "daoyoucode/agents/ui/__init__.py",
"start": 1,
"end": 9,
"text": "\"\"\"\nUI ç»„ä»¶\n\næä¾›ç¾è§‚çš„ç”¨æˆ·ç•Œé¢æ˜¾ç¤º\n\"\"\"\n\nfrom .tool_display import ToolDisplay, get_tool_display\n\n__all__ = ['ToolDisplay', 'get_tool_display']"
},
{
"path": "tests/test_3_stage_understanding.py",
"start": 1,
"end": 242,
"text": "#!/usr/bin/env python3\n\"\"\"\næµ‹è¯•3é˜¶æ®µé¡¹ç›®ç†è§£åŠŸèƒ½\n\né˜¶æ®µ1: discover_project_docsï¼ˆæ–‡æ¡£å±‚ï¼‰\né˜¶æ®µ2: get_repo_structureï¼ˆç»“æ„å±‚ï¼‰\né˜¶æ®µ3: repo_mapï¼ˆä»£ç å±‚ï¼‰\n\"\"\"\n\nimport asyncio\nfrom pathlib import Path\nfrom daoyoucode.agents.tools import get_tool_registry\n\n\nasync def test_stage1_docs():\n    \"\"\"æµ‹è¯•é˜¶æ®µ1: æ–‡æ¡£å±‚\"\"\"\n    print(\"=\" * 60)\n    print(\"é˜¶æ®µ1: æ–‡æ¡£å±‚ - discover_project_docs\")\n    print(\"=\" * 60)\n    \n    registry = get_tool_registry()\n    \n    result = await registry.execute_tool(\n        \"discover_project_docs\",\n        repo_path=\".\"\n    )\n    \n    if result.success:\n        print(f\"\\nâœ“ æ–‡æ¡£å‘ç°æˆåŠŸ\")\n        print(f\"  - æ–‡æ¡£æ•°é‡: {result.metadata.get('doc_count')}\")\n        print(f\"  - æ–‡æ¡£ç±»å‹: {result.metadata.get('doc_types')}\")\n        \n        # æ˜¾ç¤ºå‰500å­—ç¬¦\n        content = result.content[:500] if result.content else \"\"\n        print(f\"\\nå†…å®¹é¢„è§ˆ:\")\n        print(\"-\" * 60)\n        print(content)\n        print(\"...\")\n        print(\"-\" * 60)\n        \n        return True\n    else:\n        print(f\"âœ— æ–‡æ¡£å‘ç°å¤±è´¥: {result.error}\")\n        return False\n\n\nasync def test_stage2_structure():\n    \"\"\"æµ‹è¯•é˜¶æ®µ2: ç»“æ„å±‚\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"é˜¶æ®µ2: ç»“æ„å±‚ - get_repo_structure\")\n    print(\"=\" * 60)\n    \n    registry = get_tool_registry()\n    \n    result = await registry.execute_tool(\n        \"get_repo_structure\",\n        repo_path=\".\",\n        annotate=True,\n        max_depth=3,\n        show_files=False  # åªæ˜¾ç¤ºç›®å½•\n    )\n    \n    if result.success:\n        print(f\"\\nâœ“ ç»“æ„è·å–æˆåŠŸ\")\n        print(f\"  - æ˜¯å¦æ·»åŠ æ³¨é‡Š: {result.metadata.get('annotate')}\")\n        print(f\"  - æœ€å¤§æ·±åº¦: {result.metadata.get('max_depth')}\")\n        \n        # æ˜¾ç¤ºå‰30è¡Œ\n        lines = result.content.split('\\n')[:30]\n        print(f\"\\nç›®å½•ç»“æ„é¢„è§ˆ:\")\n        print(\"-\" * 60)\n        print('\\n'.join(lines))\n        print(\"...\")\n        print(\"-\" * 60)\n        \n        return True\n    else:\n        print(f\"âœ— ç»“æ„è·å–å¤±è´¥: {result.error}\")\n        return False\n\n\nasync def test_stage3_code():\n    \"\"\"æµ‹è¯•é˜¶æ®µ3: ä»£ç å±‚\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"é˜¶æ®µ3: ä»£ç å±‚ - repo_map\")\n    print(\"=\" * 60)\n    \n    registry = get_tool_registry()\n    \n    result = await registry.execute_tool(\n        \"repo_map\",\n        repo_path=\".\",\n        chat_files=[],  # æ— chat_filesï¼Œè‡ªåŠ¨æ‰©å¤§åˆ°6000\n        max_tokens=3000\n    )\n    \n    if result.success:\n        print(f\"\\nâœ“ ä»£ç åœ°å›¾ç”ŸæˆæˆåŠŸ\")\n        print(f\"  - åŸå§‹max_tokens: {result.metadata.get('original_max_tokens')}\")\n        print(f\"  - å®é™…max_tokens: {result.metadata.get('max_tokens')}\")\n        print(f\"  - æ˜¯å¦è‡ªåŠ¨è°ƒæ•´: {result.metadata.get('auto_scaled')}\")\n        print(f\"  - æ–‡ä»¶æ•°é‡: {result.metadata.get('file_count')}\")\n        \n        # æ˜¾ç¤ºå‰20è¡Œ\n        lines = result.content.split('\\n')[:20]\n        print(f\"\\nä»£ç åœ°å›¾é¢„è§ˆ:\")\n        print(\"-\" * 60)\n        print('\\n'.join(lines))\n        print(\"...\")\n        print(\"-\" * 60)\n        \n        return True\n    else:\n        print(f\"âœ— ä»£ç åœ°å›¾ç”Ÿæˆå¤±è´¥: {result.error}\")\n        return False\n\n\nasync def test_full_workflow():\n    \"\"\"æµ‹è¯•å®Œæ•´çš„3é˜¶æ®µå·¥ä½œæµ\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"å®Œæ•´å·¥ä½œæµæµ‹è¯•\")\n    print(\"=\" * 60)\n    \n    registry = get_tool_registry()\n    \n    total_tokens = 0\n    \n    # é˜¶æ®µ1: æ–‡æ¡£\n    print(\"\\n[1/3] è·å–é¡¹ç›®æ–‡æ¡£...\")\n    result1 = await registry.execute_tool(\n        \"discover_project_docs\",\n        repo_path=\".\"\n    )\n    if result1.success:\n        doc_tokens = len(result1.content) // 4  # ç²—ç•¥ä¼°ç®—\n        total_tokens += doc_tokens\n        print(f\"âœ“ æ–‡æ¡£å±‚å®Œæˆ (~{doc_tokens} tokens)\")\n    \n    # é˜¶æ®µ2: ç»“æ„\n    print(\"\\n[2/3] è·å–ç›®å½•ç»“æ„...\")\n    result2 = await registry.execute_tool(\n        \"get_repo_structure\",\n        repo_path=\".\",\n        annotate=True,\n        max_depth=3\n    )\n    if result2.success:\n        struct_tokens = len(result2.content) // 4  # ç²—ç•¥ä¼°ç®—\n        total_tokens += struct_tokens\n        print(f\"âœ“ ç»“æ„å±‚å®Œæˆ (~{struct_tokens} tokens)\")\n    \n    # é˜¶æ®µ3: ä»£ç \n    print(\"\\n[3/3] ç”Ÿæˆä»£ç åœ°å›¾...\")\n    result3 = await registry.execute_tool(\n        \"repo_map\",\n        repo_path=\".\",\n        chat_files=[],\n        max_tokens=3000\n    )\n    if result3.success:\n        code_tokens = result3.metadata.get('max_tokens',"
},
{
"path": "tests/test_advanced_features.py",
"start": 1,
"end": 20,
"text": "\"\"\"\næµ‹è¯•é«˜çº§åŠŸèƒ½ï¼šHookç³»ç»Ÿã€æƒé™ç³»ç»Ÿã€ReActå¾ªç¯\n\"\"\"\n\nimport pytest\nimport asyncio\nfrom daoyoucode.agents.core.hooks import (\n    HookManager, HookEvent, HookContext, Hook, FunctionHook,\n    get_hook_manager, hook\n)\nfrom daoyoucode.agents.core.permission import (\n    PermissionManager, PermissionRule, PermissionCategory,\n    get_permission_manager, check_permission, require_permission\n)\nfrom daoyoucode.agents.orchestrators.react import ReActOrchestrator, ReActPlan\nfrom daoyoucode.agents.core.context import Context\n\n\n# ==================== Hookç³»ç»Ÿæµ‹è¯• ====================\n"
},
{
"path": "tests/test_advanced_features.py",
"start": 21,
"end": 27,
"text": "def test_hook_manager_singleton():\n    \"\"\"æµ‹è¯•Hookç®¡ç†å™¨å•ä¾‹\"\"\"\n    manager1 = HookManager()\n    manager2 = HookManager()\n    assert manager1 is manager2\n\n"
},
{
"path": "tests/test_advanced_features.py",
"start": 28,
"end": 33,
"text": "def test_hook_registration():\n    \"\"\"æµ‹è¯•Hookæ³¨å†Œ\"\"\"\n    manager = HookManager()\n    manager.clear()  # æ¸…ç©º\n    \n    # åˆ›å»ºHook"
},
{
"path": "tests/test_advanced_features.py",
"start": 34,
"end": 34,
"text": "    class TestHook(Hook):"
},
{
"path": "tests/test_advanced_features.py",
"start": 35,
"end": 60,
"text": "        def __init__(self):\n            super().__init__(\"test_hook\", priority=100)\n        \n        async def execute(self, context: HookContext):\n            context.set('executed', True)\n            return context\n    \n    # æ³¨å†ŒHook\n    hook_instance = TestHook()\n    manager.register(HookEvent.PRE_EXECUTE, hook_instance)\n    \n    # éªŒè¯\n    hooks = manager.list_hooks(HookEvent.PRE_EXECUTE)\n    assert HookEvent.PRE_EXECUTE.value in hooks\n    assert 'test_hook' in hooks[HookEvent.PRE_EXECUTE.value]\n\n\n@pytest.mark.asyncio\nasync def test_hook_trigger():\n    \"\"\"æµ‹è¯•Hookè§¦å‘\"\"\"\n    manager = HookManager()\n    manager.clear()\n    \n    # æ³¨å†ŒHook\n    executed = []\n    "
},
{
"path": "tests/test_advanced_features.py",
"start": 61,
"end": 87,
"text": "    def test_hook(context: HookContext):\n        executed.append(context.event.value)\n        context.set('hook_executed', True)\n        return context\n    \n    manager.register_function(HookEvent.PRE_EXECUTE, test_hook)\n    \n    # è§¦å‘Hook\n    context = await manager.trigger(\n        HookEvent.PRE_EXECUTE,\n        data={'test': 'data'}\n    )\n    \n    # éªŒè¯\n    assert len(executed) == 1\n    assert executed[0] == 'pre_execute'\n    assert context.get('hook_executed') is True\n\n\n@pytest.mark.asyncio\nasync def test_hook_priority():\n    \"\"\"æµ‹è¯•Hookä¼˜å…ˆçº§\"\"\"\n    manager = HookManager()\n    manager.clear()\n    \n    execution_order = []\n    "
},
{
"path": "tests/test_advanced_features.py",
"start": 88,
"end": 91,
"text": "    def hook1(context: HookContext):\n        execution_order.append('hook1')\n        return context\n    "
},
{
"path": "tests/test_advanced_features.py",
"start": 92,
"end": 95,
"text": "    def hook2(context: HookContext):\n        execution_order.append('hook2')\n        return context\n    "
},
{
"path": "tests/test_advanced_features.py",
"start": 96,
"end": 119,
"text": "    def hook3(context: HookContext):\n        execution_order.append('hook3')\n        return context\n    \n    # æ³¨å†ŒHookï¼ˆä¸åŒä¼˜å…ˆçº§ï¼‰\n    manager.register_function(HookEvent.PRE_EXECUTE, hook1, priority=100)\n    manager.register_function(HookEvent.PRE_EXECUTE, hook2, priority=50)   # ä¼˜å…ˆ\n    manager.register_function(HookEvent.PRE_EXECUTE, hook3, priority=200)  # æœ€å\n    \n    # è§¦å‘Hook\n    await manager.trigger(HookEvent.PRE_EXECUTE)\n    \n    # éªŒè¯æ‰§è¡Œé¡ºåº\n    assert execution_order == ['hook2', 'hook1', 'hook3']\n\n\n@pytest.mark.asyncio\nasync def test_hook_interruption():\n    \"\"\"æµ‹è¯•Hookä¸­æ–­\"\"\"\n    manager = HookManager()\n    manager.clear()\n    \n    executed = []\n    "
},
{
"path": "tests/test_advanced_features.py",
"start": 120,
"end": 123,
"text": "    def hook1(context: HookContext):\n        executed.append('hook1')\n        return context\n    "
},
{
"path": "tests/test_advanced_features.py",
"start": 124,
"end": 127,
"text": "    def hook2(context: HookContext):\n        executed.append('hook2')\n        return None  # ä¸­æ–­æ‰§è¡Œ\n    "
},
{
"path": "tests/test_advanced_features.py",
"start": 128,
"end": 144,
"text": "    def hook3(context: HookContext):\n        executed.append('hook3')\n        return context\n    \n    manager.register_function(HookEvent.PRE_EXECUTE, hook1, priority=10)\n    manager.register_function(HookEvent.PRE_EXECUTE, hook2, priority=20)\n    manager.register_function(HookEvent.PRE_EXECUTE, hook3, priority=30)\n    \n    # è§¦å‘Hook\n    context = await manager.trigger(HookEvent.PRE_EXECUTE)\n    \n    # éªŒè¯ï¼šhook2è¿”å›Noneååº”è¯¥ä¸­æ–­\n    # ä½¿ç”¨context.get()æ–¹æ³•è®¿é—®æ•°æ®\n    assert context.get('_interrupted') is True\n    assert context.get('_interrupted_by') == 'hook2'\n\n"
},
{
"path": "tests/test_advanced_features.py",
"start": 145,
"end": 150,
"text": "def test_hook_decorator():\n    \"\"\"æµ‹è¯•Hookè£…é¥°å™¨\"\"\"\n    manager = HookManager()\n    manager.clear()\n    \n    @hook(HookEvent.PRE_EXECUTE, priority=50)"
},
{
"path": "tests/test_advanced_features.py",
"start": 151,
"end": 161,
"text": "    def my_hook(context: HookContext):\n        context.set('decorator_hook', True)\n        return context\n    \n    # éªŒè¯Hookå·²æ³¨å†Œ\n    hooks = manager.list_hooks(HookEvent.PRE_EXECUTE)\n    assert 'my_hook' in hooks[HookEvent.PRE_EXECUTE.value]\n\n\n# ==================== æƒé™ç³»ç»Ÿæµ‹è¯• ====================\n"
},
{
"path": "tests/test_advanced_features.py",
"start": 162,
"end": 168,
"text": "def test_permission_manager_singleton():\n    \"\"\"æµ‹è¯•æƒé™ç®¡ç†å™¨å•ä¾‹\"\"\"\n    manager1 = PermissionManager()\n    manager2 = PermissionManager()\n    assert manager1 is manager2\n\n"
},
{
"path": "tests/test_advanced_features.py",
"start": 169,
"end": 193,
"text": "def test_permission_default_rules():\n    \"\"\"æµ‹è¯•é»˜è®¤æƒé™è§„åˆ™\"\"\"\n    manager = PermissionManager()\n    \n    # æµ‹è¯•è¯»å–æƒé™\n    assert manager.check_permission('read', 'test.py') == 'allow'\n    assert manager.check_permission('read', '.env') == 'ask'\n    assert manager.check_permission('read', '.env.example') == 'allow'\n    assert manager.check_permission('read', 'secret.key') == 'ask'\n    \n    # æµ‹è¯•å†™å…¥æƒé™\n    assert manager.check_permission('write', 'test.py') == 'allow'\n    assert manager.check_permission('write', '.env') == 'deny'\n    assert manager.check_permission('write', 'private.key') == 'deny'\n    \n    # æµ‹è¯•åˆ é™¤æƒé™\n    assert manager.check_permission('delete', 'test.pyc') == 'allow'\n    assert manager.check_permission('delete', '.env') == 'deny'\n    \n    # æµ‹è¯•æ‰§è¡Œæƒé™\n    assert manager.check_permission('execute', 'git status') == 'allow'\n    assert manager.check_permission('execute', 'rm -rf /') == 'deny'\n    assert manager.check_permission('execute', 'sudo apt install') == 'ask'\n\n"
},
{
"path": "tests/test_advanced_features.py",
"start": 194,
"end": 206,
"text": "def test_permission_rule_matching():\n    \"\"\"æµ‹è¯•æƒé™è§„åˆ™åŒ¹é…\"\"\"\n    rule = PermissionRule('*.py', 'allow')\n    \n    assert rule.matches('test.py') is True\n    assert rule.matches('test.js') is False\n    \n    # æµ‹è¯•é€šé…ç¬¦ï¼ˆfnmatchæ”¯æŒè·¯å¾„åŒ¹é…ï¼‰\n    rule2 = PermissionRule('**/*.py', 'allow')\n    assert rule2.matches('src/test.py') is True\n    assert rule2.matches('src/utils/helper.py') is True\n\n"
},
{
"path": "tests/test_advanced_features.py",
"start": 207,
"end": 220,
"text": "def test_permission_priority():\n    \"\"\"æµ‹è¯•æƒé™ä¼˜å…ˆçº§\"\"\"\n    manager = PermissionManager()\n    category = PermissionCategory('test', default_action='ask')\n    \n    # æ·»åŠ è§„åˆ™ï¼ˆä¸åŒä¼˜å…ˆçº§ï¼‰\n    category.add_rule('*.txt', 'allow', priority=100)\n    category.add_rule('secret.txt', 'deny', priority=10)  # æ›´é«˜ä¼˜å…ˆçº§\n    \n    # éªŒè¯ï¼šé«˜ä¼˜å…ˆçº§è§„åˆ™åº”è¯¥å…ˆåŒ¹é…\n    assert category.check('secret.txt') == 'deny'\n    assert category.check('normal.txt') == 'allow'\n\n"
},
{
"path": "tests/test_advanced_features.py",
"start": 221,
"end": 232,
"text": "def test_permission_add_rule():\n    \"\"\"æµ‹è¯•æ·»åŠ æƒé™è§„åˆ™\"\"\"\n    manager = PermissionManager()\n    manager.clear('test_category')\n    \n    # æ·»åŠ è§„åˆ™\n    manager.add_rule('test_category', '*.test', 'deny', priority=50)\n    \n    # éªŒè¯\n    assert manager.check_permission('test_category', 'file.test') == 'deny'\n\n"
},
{
"path": "tests/test_advanced_features.py",
"start": 233,
"end": 254,
"text": "def test_permission_load_config():\n    \"\"\"æµ‹è¯•ä»é…ç½®åŠ è½½æƒé™\"\"\"\n    manager = PermissionManager()\n    \n    config = {\n        'custom_read': {\n            '*.secret': 'deny',\n            '*.public': 'allow'\n        },\n        'custom_write': {\n            '*.lock': 'deny'\n        }\n    }\n    \n    manager.load_config(config)\n    \n    # éªŒè¯\n    assert manager.check_permission('custom_read', 'data.secret') == 'deny'\n    assert manager.check_permission('custom_read', 'data.public') == 'allow'\n    assert manager.check_permission('custom_write', 'file.lock') == 'deny'\n\n"
},
{
"path": "tests/test_advanced_features.py",
"start": 255,
"end": 262,
"text": "def test_permission_decorator():\n    \"\"\"æµ‹è¯•æƒé™è£…é¥°å™¨\"\"\"\n    manager = PermissionManager()\n    \n    # æ·»åŠ æ‹’ç»è§„åˆ™\n    manager.add_rule('write', 'forbidden.txt', 'deny', priority=1)\n    \n    @require_permission('write')"
},
{
"path": "tests/test_advanced_features.py",
"start": 263,
"end": 404,
"text": "    def write_file(path: str, content: str):\n        return f\"å†™å…¥ {path}: {content}\"\n    \n    # æµ‹è¯•å…è®¸çš„æ–‡ä»¶\n    result = write_file('allowed.txt', 'content')\n    assert 'allowed.txt' in result\n    \n    # æµ‹è¯•æ‹’ç»çš„æ–‡ä»¶\n    with pytest.raises(PermissionError):\n        write_file('forbidden.txt', 'content')\n\n\n# ==================== ReActå¾ªç¯æµ‹è¯• ====================\n# \n# è¿™äº›æµ‹è¯•éªŒè¯ReActç¼–æ’å™¨çš„é¢„ç•™æ–¹æ³•ã€‚\n# \n# èƒŒæ™¯ï¼š\n# - å½“å‰çš„ReActOrchestratorä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬ï¼ˆLLMè‡ªåŠ¨æ§åˆ¶å¾ªç¯ï¼‰\n# - é¢„ç•™æ–¹æ³•ï¼ˆ_plan, _reflect, _execute_planç­‰ï¼‰ä¸ºæœªæ¥çš„\n#   AdvancedReActOrchestratoræä¾›å‚è€ƒå®ç°\n# - è¿™äº›æ–¹æ³•å®ç°äº†å®Œæ•´çš„Plan-Execute-Observe-Reflectå¾ªç¯\n# \n# æµ‹è¯•ç›®çš„ï¼š\n# - ç¡®ä¿é¢„ç•™æ–¹æ³•çš„æ¥å£å’ŒåŸºæœ¬é€»è¾‘æ­£ç¡®\n# - ä¸ºæœªæ¥å®ç°AdvancedReActOrchestratoræä¾›éªŒè¯\n# - é˜²æ­¢è¿™äº›æ–¹æ³•è¢«è¯¯åˆ \n# \n# å‚è€ƒï¼š\n# - backend/daoyoucode/agents/orchestrators/react.py - å®ç°\n# - backend/AGENT_OPTIMIZATION_PLAN.md - ä¼˜åŒ–è®¡åˆ’è¯´æ˜\n# ==================== ReActå¾ªç¯æµ‹è¯• ====================\n\n@pytest.mark.asyncio\nasync def test_react_orchestrator_creation():\n    \"\"\"æµ‹è¯•ReActç¼–æ’å™¨åˆ›å»º\"\"\"\n    orchestrator = ReActOrchestrator(\n        max_reflections=3,\n        require_approval=False,\n        auto_verify=True\n    )\n    \n    assert orchestrator.max_reflections == 3\n    assert orchestrator.require_approval is False\n    assert orchestrator.auto_verify is True\n    assert orchestrator.get_name() == 'react'\n\n\n@pytest.mark.asyncio\nasync def test_react_plan_generation():\n    \"\"\"æµ‹è¯•ReActè®¡åˆ’ç”Ÿæˆ\"\"\"\n    orchestrator = ReActOrchestrator()\n    context = Context(session_id='test')\n    \n    plan = await orchestrator._plan(\n        instruction='å®ç°ä¸€ä¸ªç®€å•çš„åŠŸèƒ½',\n        context=context\n    )\n    \n    assert plan is not None\n    assert isinstance(plan, ReActPlan)\n    assert len(plan.steps) > 0\n    assert plan.complexity > 0\n\n\n@pytest.mark.asyncio\nasync def test_react_step_execution():\n    \"\"\"æµ‹è¯•ReActæ­¥éª¤æ‰§è¡Œ\"\"\"\n    orchestrator = ReActOrchestrator()\n    context = Context(session_id='test')\n    \n    step = {\n        'action': 'analyze',\n        'description': 'åˆ†æä»»åŠ¡'\n    }\n    \n    result = await orchestrator._execute_step(step, context, None)\n    \n    assert result is not None\n    assert 'analysis' in result\n\n\n@pytest.mark.asyncio\nasync def test_react_observation():\n    \"\"\"æµ‹è¯•ReActè§‚å¯Ÿ\"\"\"\n    orchestrator = ReActOrchestrator(auto_verify=False)\n    context = Context(session_id='test')\n    \n    # æµ‹è¯•æˆåŠŸç»“æœ\n    success_result = {\n        'steps': [\n            {'step': 1, 'success': True},\n            {'step': 2, 'success': True}\n        ],\n        'completed': 2,\n        'total': 2\n    }\n    \n    observation = await orchestrator._observe(success_result, context)\n    assert observation['success'] is True\n    \n    # æµ‹è¯•å¤±è´¥ç»“æœ\n    failure_result = {\n        'steps': [\n            {'step': 1, 'success': True},\n            {'step': 2, 'success': False, 'error': 'æµ‹è¯•é”™è¯¯'}\n        ],\n        'completed': 1,\n        'total': 2\n    }\n    \n    observation = await orchestrator._observe(failure_result, context)\n    assert observation['success'] is False\n    assert 'æµ‹è¯•é”™è¯¯' in observation['error']\n\n\n@pytest.mark.asyncio\nasync def test_react_reflection():\n    \"\"\"æµ‹è¯•ReActåæ€\"\"\"\n    orchestrator = ReActOrchestrator()\n    context = Context(session_id='test')\n    \n    plan = ReActPlan(\n        steps=[{'action': 'test', 'description': 'æµ‹è¯•'}],\n        estimated_time=100.0,\n        complexity=2,\n        risks=[]\n    )\n    \n    new_instruction = await orchestrator._reflect(\n        original_instruction='åŸå§‹ä»»åŠ¡',\n        current_instruction='å½“å‰ä»»åŠ¡',\n        error='æµ‹è¯•é”™è¯¯',\n        plan=plan,\n        context=context,\n        attempt=1\n    )\n    \n    assert new_instruction is not None\n    assert isinstance(new_instruction, str)\n    assert len(new_instruction) > 0\n\n"
},
{
"path": "tests/test_advanced_features.py",
"start": 405,
"end": 415,
"text": "def test_react_orchestrator_info():\n    \"\"\"æµ‹è¯•ReActç¼–æ’å™¨ä¿¡æ¯\"\"\"\n    orchestrator = ReActOrchestrator()\n    \n    assert orchestrator.get_name() == 'react'\n    assert 'ReAct' in orchestrator.get_description()\n    assert 'è§„åˆ’-æ‰§è¡Œ-åæ€-é‡è¯•' in orchestrator.get_description()\n\n\nif __name__ == '__main__':\n    pytest.main([__file__, '-v'])"
},
{
"path": "tests/test_agent_integration.py",
"start": 1,
"end": 11,
"text": "\"\"\"\næµ‹è¯•Agenté›†æˆ\n\"\"\"\n\nimport sys\nimport os\nimport asyncio\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, os.path.dirname(__file__))\n"
},
{
"path": "tests/test_agent_integration.py",
"start": 12,
"end": 58,
"text": "def test_agent_system():\n    \"\"\"æµ‹è¯•Agentç³»ç»Ÿæ˜¯å¦å¯ç”¨\"\"\"\n    print(\"=\" * 60)\n    print(\"æµ‹è¯• Agent ç³»ç»Ÿ\")\n    print(\"=\" * 60)\n    \n    try:\n        from daoyoucode.agents.core.agent import (\n            get_agent_registry,\n            register_agent,\n            BaseAgent,\n            AgentConfig\n        )\n        \n        print(\"âœ“ Agentç³»ç»Ÿå¯¼å…¥æˆåŠŸ\")\n        \n        # è·å–æ³¨å†Œè¡¨\n        registry = get_agent_registry()\n        print(f\"âœ“ Agentæ³¨å†Œè¡¨è·å–æˆåŠŸ\")\n        print(f\"  å·²æ³¨å†Œçš„Agent: {registry.list_agents()}\")\n        \n        # åˆ›å»ºæµ‹è¯•Agent\n        config = AgentConfig(\n            name=\"TestAgent\",\n            description=\"æµ‹è¯•Agent\",\n            model=\"qwen-max\",\n            temperature=0.7,\n            system_prompt=\"ä½ æ˜¯ä¸€ä¸ªæµ‹è¯•Agent\"\n        )\n        \n        agent = BaseAgent(config)\n        print(f\"âœ“ åˆ›å»ºAgentæˆåŠŸ: {agent.name}\")\n        \n        # æ³¨å†ŒAgent\n        register_agent(agent)\n        print(f\"âœ“ æ³¨å†ŒAgentæˆåŠŸ\")\n        print(f\"  å½“å‰å·²æ³¨å†Œ: {registry.list_agents()}\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"âœ— Agentç³»ç»Ÿæµ‹è¯•å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n"
},
{
"path": "tests/test_agent_integration.py",
"start": 59,
"end": 93,
"text": "def test_llm_client():\n    \"\"\"æµ‹è¯•LLMå®¢æˆ·ç«¯\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯• LLM å®¢æˆ·ç«¯\")\n    print(\"=\" * 60)\n    \n    try:\n        from daoyoucode.agents.llm.client_manager import get_client_manager\n        \n        manager = get_client_manager()\n        print(\"âœ“ LLMå®¢æˆ·ç«¯ç®¡ç†å™¨è·å–æˆåŠŸ\")\n        \n        # æ£€æŸ¥æ˜¯å¦æœ‰é…ç½®\n        if not manager.provider_configs:\n            print(\"âš  æœªé…ç½®ä»»ä½•LLMæä¾›å•†\")\n            print(\"  éœ€è¦é…ç½®APIæ‰èƒ½ä½¿ç”¨çœŸå®LLM\")\n            print(\"\\n  é…ç½®ç¤ºä¾‹:\")\n            print(\"  manager.configure_provider(\")\n            print(\"      provider='qwen',\")\n            print(\"      api_key='your-api-key',\")\n            print(\"      base_url='https://dashscope.aliyuncs.com/compatible-mode/v1',\")\n            print(\"      models=['qwen-max', 'qwen-plus']\")\n            print(\"  )\")\n            return False\n        else:\n            print(f\"âœ“ å·²é…ç½®æä¾›å•†: {list(manager.provider_configs.keys())}\")\n            return True\n            \n    except Exception as e:\n        print(f\"âœ— LLMå®¢æˆ·ç«¯æµ‹è¯•å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n"
},
{
"path": "tests/test_agent_integration.py",
"start": 94,
"end": 121,
"text": "def test_chat_integration():\n    \"\"\"æµ‹è¯•chatå‘½ä»¤çš„Agenté›†æˆ\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯• chat å‘½ä»¤ Agent é›†æˆ\")\n    print(\"=\" * 60)\n    \n    try:\n        from cli.commands.chat import initialize_agents\n        \n        # æµ‹è¯•åˆå§‹åŒ–\n        print(\"æ­£åœ¨åˆå§‹åŒ–Agent...\")\n        agent_available = initialize_agents(\"qwen-max\")\n        \n        if agent_available:\n            print(\"âœ“ Agentåˆå§‹åŒ–æˆåŠŸ - å¯ä»¥ä½¿ç”¨çœŸå®AI\")\n        else:\n            print(\"âš  Agentåˆå§‹åŒ–å¤±è´¥ - å°†ä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼\")\n            print(\"  è¿™æ˜¯æ­£å¸¸çš„ï¼Œå¦‚æœæ²¡æœ‰é…ç½®APIçš„è¯\")\n        \n        return agent_available\n        \n    except Exception as e:\n        print(f\"âœ— chaté›†æˆæµ‹è¯•å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n"
},
{
"path": "tests/test_agent_integration.py",
"start": 122,
"end": 149,
"text": "def test_edit_integration():\n    \"\"\"æµ‹è¯•editå‘½ä»¤çš„Agenté›†æˆ\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯• edit å‘½ä»¤ Agent é›†æˆ\")\n    print(\"=\" * 60)\n    \n    try:\n        from cli.commands.edit import initialize_edit_agent\n        \n        # æµ‹è¯•åˆå§‹åŒ–\n        print(\"æ­£åœ¨åˆå§‹åŒ–CodeAgent...\")\n        agent_available = initialize_edit_agent(\"qwen-max\")\n        \n        if agent_available:\n            print(\"âœ“ CodeAgentåˆå§‹åŒ–æˆåŠŸ - å¯ä»¥ä½¿ç”¨çœŸå®AI\")\n        else:\n            print(\"âš  CodeAgentåˆå§‹åŒ–å¤±è´¥ - å°†ä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼\")\n            print(\"  è¿™æ˜¯æ­£å¸¸çš„ï¼Œå¦‚æœæ²¡æœ‰é…ç½®APIçš„è¯\")\n        \n        return agent_available\n        \n    except Exception as e:\n        print(f\"âœ— edité›†æˆæµ‹è¯•å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n"
},
{
"path": "tests/test_agent_integration.py",
"start": 150,
"end": 184,
"text": "def main():\n    \"\"\"è¿è¡Œæ‰€æœ‰æµ‹è¯•\"\"\"\n    print(\"\\n\" + \"ğŸ§ª DaoyouCode CLI Agent é›†æˆæµ‹è¯•\")\n    print(\"=\" * 60)\n    \n    results = {\n        \"Agentç³»ç»Ÿ\": test_agent_system(),\n        \"LLMå®¢æˆ·ç«¯\": test_llm_client(),\n        \"chaté›†æˆ\": test_chat_integration(),\n        \"edité›†æˆ\": test_edit_integration()\n    }\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•ç»“æœæ±‡æ€»\")\n    print(\"=\" * 60)\n    \n    for name, result in results.items():\n        status = \"âœ“ é€šè¿‡\" if result else \"âš  éœ€è¦é…ç½®\"\n        print(f\"{name}: {status}\")\n    \n    print(\"\\n\" + \"=\" * 60)\n    \n    if all(results.values()):\n        print(\"ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼å¯ä»¥ä½¿ç”¨çœŸå®AIåŠŸèƒ½\")\n    elif results[\"Agentç³»ç»Ÿ\"]:\n        print(\"âœ… Agentç³»ç»Ÿæ­£å¸¸ï¼Œä½†éœ€è¦é…ç½®APIæ‰èƒ½ä½¿ç”¨çœŸå®LLM\")\n        print(\"ğŸ’¡ å½“å‰å¯ä»¥ä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼æµ‹è¯•CLIåŠŸèƒ½\")\n    else:\n        print(\"âŒ Agentç³»ç»Ÿæœ‰é—®é¢˜ï¼Œè¯·æ£€æŸ¥\")\n    \n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()"
},
{
"path": "tests/test_api_call.py",
"start": 1,
"end": 154,
"text": "\"\"\"\næµ‹è¯•çœŸå®çš„APIè°ƒç”¨\n\"\"\"\n\nimport sys\nimport os\nimport asyncio\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, os.path.dirname(__file__))\n\n\nasync def test_llm_call():\n    \"\"\"æµ‹è¯•LLM APIè°ƒç”¨\"\"\"\n    print(\"=\" * 60)\n    print(\"æµ‹è¯• LLM API è°ƒç”¨\")\n    print(\"=\" * 60)\n    \n    try:\n        # 1. å¯¼å…¥å¹¶é…ç½®\n        from daoyoucode.agents.llm.client_manager import get_client_manager\n        from daoyoucode.agents.llm.config_loader import auto_configure\n        \n        print(\"\\n1. é…ç½®LLMå®¢æˆ·ç«¯...\")\n        manager = get_client_manager()\n        auto_configure(manager)\n        \n        if not manager.provider_configs:\n            print(\"âœ— æœªé…ç½®ä»»ä½•æä¾›å•†\")\n            return False\n        \n        print(f\"âœ“ å·²é…ç½®æä¾›å•†: {list(manager.provider_configs.keys())}\")\n        \n        # 2. è·å–å®¢æˆ·ç«¯\n        print(\"\\n2. è·å–å®¢æˆ·ç«¯...\")\n        client = manager.get_client(model=\"qwen-turbo\")\n        print(f\"âœ“ å®¢æˆ·ç«¯åˆ›å»ºæˆåŠŸ\")\n        \n        # 3. æ„å»ºè¯·æ±‚\n        print(\"\\n3. å‘é€æµ‹è¯•è¯·æ±‚...\")\n        from daoyoucode.agents.llm.base import LLMRequest\n        \n        request = LLMRequest(\n            prompt=\"ä½ å¥½ï¼Œè¯·ç”¨ä¸€å¥è¯ä»‹ç»ä½ è‡ªå·±ã€‚\",\n            model=\"qwen-turbo\",\n            temperature=0.7\n        )\n        \n        print(f\"   æç¤ºè¯: {request.prompt}\")\n        \n        # 4. è°ƒç”¨API\n        print(\"\\n4. è°ƒç”¨API...\")\n        response = await client.chat(request)\n        \n        print(f\"âœ“ APIè°ƒç”¨æˆåŠŸï¼\")\n        print(f\"\\nå“åº”å†…å®¹:\")\n        print(f\"  {response.content}\")\n        print(f\"\\nå…ƒæ•°æ®:\")\n        print(f\"  æ¨¡å‹: {response.model}\")\n        print(f\"  Tokens: {response.usage.get('total_tokens', 'N/A')}\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"\\nâœ— APIè°ƒç”¨å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n\nasync def test_agent_with_llm():\n    \"\"\"æµ‹è¯•Agentä½¿ç”¨LLM\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯• Agent ä½¿ç”¨ LLM\")\n    print(\"=\" * 60)\n    \n    try:\n        # 1. é…ç½®LLM\n        from daoyoucode.agents.llm.client_manager import get_client_manager\n        from daoyoucode.agents.llm.config_loader import auto_configure\n        \n        manager = get_client_manager()\n        auto_configure(manager)\n        \n        if not manager.provider_configs:\n            print(\"âœ— æœªé…ç½®æä¾›å•†\")\n            return False\n        \n        # 2. åˆ›å»ºAgent\n        from daoyoucode.agents.core.agent import BaseAgent, AgentConfig\n        \n        print(\"\\n1. åˆ›å»ºAgent...\")\n        config = AgentConfig(\n            name=\"TestAgent\",\n            description=\"æµ‹è¯•Agent\",\n            model=\"qwen-turbo\",\n            temperature=0.7,\n            system_prompt=\"ä½ æ˜¯ä¸€ä¸ªå‹å¥½çš„AIåŠ©æ‰‹ã€‚\"\n        )\n        \n        agent = BaseAgent(config)\n        print(f\"âœ“ Agentåˆ›å»ºæˆåŠŸ: {agent.name}\")\n        \n        # 3. æ‰§è¡Œä»»åŠ¡\n        print(\"\\n2. æ‰§è¡Œä»»åŠ¡...\")\n        result = await agent.execute(\n            prompt_source={\"use_agent_default\": True},\n            user_input=\"ä½ å¥½ï¼Œè¯·ç”¨ä¸€å¥è¯ä»‹ç»ä½ è‡ªå·±ã€‚\",\n            context={}\n        )\n        \n        if result.success:\n            print(f\"âœ“ Agentæ‰§è¡ŒæˆåŠŸï¼\")\n            print(f\"\\nå“åº”å†…å®¹:\")\n            print(f\"  {result.content}\")\n            return True\n        else:\n            print(f\"âœ— Agentæ‰§è¡Œå¤±è´¥: {result.error}\")\n            return False\n        \n    except Exception as e:\n        print(f\"\\nâœ— Agentæµ‹è¯•å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n\nasync def main():\n    \"\"\"è¿è¡Œæ‰€æœ‰æµ‹è¯•\"\"\"\n    print(\"\\nğŸ§ª DaoyouCode API è°ƒç”¨æµ‹è¯•\")\n    print(\"=\" * 60)\n    \n    # æµ‹è¯•1: ç›´æ¥LLMè°ƒç”¨\n    test1 = await test_llm_call()\n    \n    # æµ‹è¯•2: Agentä½¿ç”¨LLM\n    test2 = await test_agent_with_llm()\n    \n    # æ€»ç»“\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•ç»“æœæ±‡æ€»\")\n    print(\"=\" * 60)\n    print(f\"LLM APIè°ƒç”¨: {'âœ“ é€šè¿‡' if test1 else 'âœ— å¤±è´¥'}\")\n    print(f\"Agentä½¿ç”¨LLM: {'âœ“ é€šè¿‡' if test2 else 'âœ— å¤±è´¥'}\")\n    print(\"=\" * 60)\n    \n    if test1 and test2:\n        print(\"\\nğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼APIé…ç½®æ­£ç¡®ï¼Œå¯ä»¥ä½¿ç”¨çœŸå®AIåŠŸèƒ½ï¼\")\n    else:\n        print(\"\\nâŒ éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥é…ç½®å’Œç½‘ç»œè¿æ¥\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())"
},
{
"path": "tests/test_app_direct.py",
"start": 1,
"end": 34,
"text": "#!/usr/bin/env python\n\"\"\"ç›´æ¥æµ‹è¯•app.py\"\"\"\n\nimport sys\nsys.path.insert(0, '.')\n\nprint(\"å¼€å§‹å¯¼å…¥...\")\n\ntry:\n    print(\"1. å¯¼å…¥typer...\")\n    import typer\n    print(\"   âœ“ typerå¯¼å…¥æˆåŠŸ\")\n    \n    print(\"2. å¯¼å…¥cli...\")\n    import cli\n    print(f\"   âœ“ cliå¯¼å…¥æˆåŠŸ, version={cli.__version__}\")\n    \n    print(\"3. å¯¼å…¥cli.app...\")\n    import cli.app as app_module\n    print(f\"   âœ“ cli.appå¯¼å…¥æˆåŠŸ\")\n    print(f\"   æ¨¡å—å†…å®¹: {[x for x in dir(app_module) if not x.startswith('_')]}\")\n    \n    if hasattr(app_module, 'main'):\n        print(\"   âœ“ æ‰¾åˆ°mainå‡½æ•°\")\n        print(\"   å°è¯•è¿è¡Œ --help...\")\n        sys.argv = ['test', '--help']\n        app_module.main()\n    else:\n        print(\"   âœ— æ²¡æœ‰æ‰¾åˆ°mainå‡½æ•°\")\n        \nexcept Exception as e:\n    print(f\"\\nâŒ é”™è¯¯: {e}\")\n    import traceback\n    traceback.print_exc()"
},
{
"path": "tests/test_app_step.py",
"start": 1,
"end": 33,
"text": "#!/usr/bin/env python\n\"\"\"é€æ­¥æµ‹è¯•app.py\"\"\"\n\nimport sys\nsys.path.insert(0, '.')\n\nprint(\"Step 1: å¯¼å…¥typer\")\nimport typer\nprint(\"âœ“\")\n\nprint(\"Step 2: å¯¼å…¥typing\")\nfrom typing import Optional\nprint(\"âœ“\")\n\nprint(\"Step 3: å¯¼å…¥pathlib\")\nfrom pathlib import Path\nprint(\"âœ“\")\n\nprint(\"Step 4: å®šä¹‰ç‰ˆæœ¬\")\n__version__ = \"0.1.0\"\nprint(\"âœ“\")\n\nprint(\"Step 5: åˆ›å»ºTyperåº”ç”¨\")\napp = typer.Typer(\n    name=\"daoyoucode\",\n    help=\"DaoyouCode - æ™ºèƒ½AIä»£ç åŠ©æ‰‹\",\n    add_completion=True,\n    no_args_is_help=True,\n)\nprint(\"âœ“\")\n\nprint(\"Step 6: å®šä¹‰chatå‘½ä»¤\")\n@app.command()"
},
{
"path": "tests/test_app_step.py",
"start": 34,
"end": 45,
"text": "def chat(\n    files: Optional[list[Path]] = typer.Argument(None, help=\"è¦åŠ è½½çš„æ–‡ä»¶\"),\n    model: str = typer.Option(\"qwen-max\", \"--model\", \"-m\", help=\"ä½¿ç”¨çš„æ¨¡å‹\"),\n    repo: Path = typer.Option(\".\", \"--repo\", \"-r\", help=\"ä»“åº“è·¯å¾„\"),\n):\n    \"\"\"å¯åŠ¨äº¤äº’å¼å¯¹è¯\"\"\"\n    print(\"chatå‘½ä»¤\")\nprint(\"âœ“\")\n\nprint(\"\\næ‰€æœ‰æ­¥éª¤å®Œæˆï¼\")\nprint(f\"appå¯¹è±¡: {app}\")\nprint(f\"appå‘½ä»¤: {app.registered_commands}\")"
},
{
"path": "tests/test_ast_tools.py",
"start": 1,
"end": 19,
"text": "\"\"\"\nASTå·¥å…·æµ‹è¯•\n\næµ‹è¯•ast-grepé›†æˆçš„ASTçº§åˆ«ä»£ç æœç´¢å’Œæ›¿æ¢åŠŸèƒ½\n\"\"\"\n\nimport pytest\nimport asyncio\nimport tempfile\nfrom pathlib import Path\n\nfrom daoyoucode.agents.tools.ast_tools import (\n    AstGrepSearchTool,\n    AstGrepReplaceTool,\n    AstGrepManager,\n    _ast_grep_manager\n)\n\n"
},
{
"path": "tests/test_ast_tools.py",
"start": 20,
"end": 22,
"text": "class TestAstGrepManager:\n    \"\"\"AST-grepç®¡ç†å™¨æµ‹è¯•\"\"\"\n    "
},
{
"path": "tests/test_ast_tools.py",
"start": 23,
"end": 31,
"text": "    def test_get_cache_dir(self):\n        \"\"\"æµ‹è¯•è·å–ç¼“å­˜ç›®å½•\"\"\"\n        manager = AstGrepManager()\n        cache_dir = manager._get_cache_dir()\n        \n        assert cache_dir is not None\n        assert \"daoyoucode\" in str(cache_dir)\n        assert \"bin\" in str(cache_dir)\n    "
},
{
"path": "tests/test_ast_tools.py",
"start": 32,
"end": 57,
"text": "    def test_get_binary_name(self):\n        \"\"\"æµ‹è¯•è·å–äºŒè¿›åˆ¶æ–‡ä»¶å\"\"\"\n        manager = AstGrepManager()\n        binary_name = manager._get_binary_name()\n        \n        import platform\n        if platform.system() == \"Windows\":\n            assert binary_name == \"sg.exe\"\n        else:\n            assert binary_name == \"sg\"\n    \n    @pytest.mark.asyncio\n    async def test_get_binary_path(self):\n        \"\"\"æµ‹è¯•è·å–äºŒè¿›åˆ¶è·¯å¾„\"\"\"\n        manager = AstGrepManager()\n        \n        # å°è¯•è·å–äºŒè¿›åˆ¶è·¯å¾„\n        # æ³¨æ„ï¼šè¿™å¯èƒ½ä¼šè§¦å‘ä¸‹è½½ï¼Œæ‰€ä»¥æˆ‘ä»¬åªæ£€æŸ¥è¿”å›å€¼ç±»å‹\n        binary_path = await manager.get_binary_path()\n        \n        # å¦‚æœè¿”å›äº†è·¯å¾„ï¼Œåº”è¯¥æ˜¯å­—ç¬¦ä¸²\n        if binary_path:\n            assert isinstance(binary_path, str)\n            assert len(binary_path) > 0\n\n"
},
{
"path": "tests/test_ast_tools.py",
"start": 58,
"end": 67,
"text": "class TestAstGrepSearchTool:\n    \"\"\"ASTæœç´¢å·¥å…·æµ‹è¯•\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_search_python_function(self):\n        \"\"\"æµ‹è¯•æœç´¢Pythonå‡½æ•°\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            test_file = Path(tmpdir) / \"test.py\"\n            test_file.write_text(\"\"\""
},
{
"path": "tests/test_ast_tools.py",
"start": 68,
"end": 71,
"text": "def hello():\n    print(\"Hello\")\n    return True\n"
},
{
"path": "tests/test_ast_tools.py",
"start": 72,
"end": 75,
"text": "def world():\n    print(\"World\")\n    return False\n"
},
{
"path": "tests/test_ast_tools.py",
"start": 76,
"end": 76,
"text": "class Calculator:"
},
{
"path": "tests/test_ast_tools.py",
"start": 77,
"end": 142,
"text": "    def add(self, a, b):\n        return a + b\n\"\"\")\n            \n            # åˆ›å»ºå·¥å…·\n            tool = AstGrepSearchTool()\n            \n            # æœç´¢æ‰€æœ‰å‡½æ•°å®šä¹‰\n            result = await tool.execute(\n                pattern=\"def $FUNC($$):\",\n                lang=\"python\",\n                paths=[str(tmpdir)]\n            )\n            \n            # éªŒè¯ç»“æœ\n            # æ³¨æ„ï¼šå¦‚æœast-grepæœªå®‰è£…ï¼Œä¼šè¿”å›é”™è¯¯\n            if result.success:\n                assert \"hello\" in result.content or \"world\" in result.content or \"add\" in result.content\n            else:\n                # ast-grepæœªå®‰è£…ï¼Œè·³è¿‡\n                assert \"not available\" in result.error or \"not found\" in result.error\n    \n    @pytest.mark.asyncio\n    async def test_search_javascript_console(self):\n        \"\"\"æµ‹è¯•æœç´¢JavaScript console.log\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            test_file = Path(tmpdir) / \"test.js\"\n            test_file.write_text(\"\"\"\nfunction hello() {\n    console.log(\"Hello\");\n    return true;\n}\n\nfunction world() {\n    console.log(\"World\");\n    console.error(\"Error\");\n    return false;\n}\n\"\"\")\n            \n            # åˆ›å»ºå·¥å…·\n            tool = AstGrepSearchTool()\n            \n            # æœç´¢console.log\n            result = await tool.execute(\n                pattern=\"console.log($MSG)\",\n                lang=\"javascript\",\n                paths=[str(tmpdir)]\n            )\n            \n            # éªŒè¯ç»“æœ\n            if result.success:\n                assert \"console.log\" in result.content\n                assert result.metadata[\"total_matches\"] >= 2\n            else:\n                # ast-grepæœªå®‰è£…ï¼Œè·³è¿‡\n                assert \"not available\" in result.error or \"not found\" in result.error\n    \n    @pytest.mark.asyncio\n    async def test_search_with_context(self):\n        \"\"\"æµ‹è¯•å¸¦ä¸Šä¸‹æ–‡çš„æœç´¢\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            test_file = Path(tmpdir) / \"test.py\"\n            test_file.write_text(\"\"\""
},
{
"path": "tests/test_ast_tools.py",
"start": 143,
"end": 202,
"text": "def calculate(a, b):\n    result = a + b\n    print(result)\n    return result\n\"\"\")\n            \n            # åˆ›å»ºå·¥å…·\n            tool = AstGrepSearchTool()\n            \n            # æœç´¢printè¯­å¥ï¼Œå¸¦2è¡Œä¸Šä¸‹æ–‡\n            result = await tool.execute(\n                pattern=\"print($MSG)\",\n                lang=\"python\",\n                paths=[str(tmpdir)],\n                context=2\n            )\n            \n            # éªŒè¯ç»“æœ\n            if result.success:\n                assert \"print\" in result.content\n            else:\n                # ast-grepæœªå®‰è£…ï¼Œè·³è¿‡\n                assert \"not available\" in result.error or \"not found\" in result.error\n    \n    @pytest.mark.asyncio\n    async def test_search_with_globs(self):\n        \"\"\"æµ‹è¯•ä½¿ç”¨globæ¨¡å¼æœç´¢\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # åˆ›å»ºå¤šä¸ªæµ‹è¯•æ–‡ä»¶\n            (Path(tmpdir) / \"test1.py\").write_text(\"def hello(): pass\")\n            (Path(tmpdir) / \"test2.py\").write_text(\"def world(): pass\")\n            (Path(tmpdir) / \"ignore.txt\").write_text(\"def ignore(): pass\")\n            \n            # åˆ›å»ºå·¥å…·\n            tool = AstGrepSearchTool()\n            \n            # åªæœç´¢.pyæ–‡ä»¶\n            result = await tool.execute(\n                pattern=\"def $FUNC():\",\n                lang=\"python\",\n                paths=[str(tmpdir)],\n                globs=[\"*.py\"]\n            )\n            \n            # éªŒè¯ç»“æœ\n            if result.success:\n                # åº”è¯¥æ‰¾åˆ°helloå’Œworldï¼Œä½†ä¸åŒ…æ‹¬ignore\n                assert \"hello\" in result.content or \"world\" in result.content\n                assert \"ignore.txt\" not in result.content\n            else:\n                # ast-grepæœªå®‰è£…ï¼Œè·³è¿‡\n                assert \"not available\" in result.error or \"not found\" in result.error\n    \n    @pytest.mark.asyncio\n    async def test_search_no_matches(self):\n        \"\"\"æµ‹è¯•æ— åŒ¹é…ç»“æœ\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            test_file = Path(tmpdir) / \"test.py\"\n            test_file.write_text(\"\"\""
},
{
"path": "tests/test_ast_tools.py",
"start": 203,
"end": 224,
"text": "def hello():\n    print(\"Hello\")\n\"\"\")\n            \n            # åˆ›å»ºå·¥å…·\n            tool = AstGrepSearchTool()\n            \n            # æœç´¢ä¸å­˜åœ¨çš„æ¨¡å¼\n            result = await tool.execute(\n                pattern=\"class $NAME:\",\n                lang=\"python\",\n                paths=[str(tmpdir)]\n            )\n            \n            # éªŒè¯ç»“æœ\n            if result.success:\n                assert \"No matches found\" in result.content\n            else:\n                # ast-grepæœªå®‰è£…ï¼Œè·³è¿‡\n                assert \"not available\" in result.error or \"not found\" in result.error\n\n"
},
{
"path": "tests/test_ast_tools.py",
"start": 225,
"end": 307,
"text": "class TestAstGrepReplaceTool:\n    \"\"\"ASTæ›¿æ¢å·¥å…·æµ‹è¯•\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_replace_dry_run(self):\n        \"\"\"æµ‹è¯•dry-runæ¨¡å¼ï¼ˆé¢„è§ˆï¼‰\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            test_file = Path(tmpdir) / \"test.js\"\n            original_content = \"\"\"\nfunction hello() {\n    console.log(\"Hello\");\n    return true;\n}\n\"\"\"\n            test_file.write_text(original_content)\n            \n            # åˆ›å»ºå·¥å…·\n            tool = AstGrepReplaceTool()\n            \n            # æ›¿æ¢console.logä¸ºlogger.infoï¼ˆdry-runï¼‰\n            result = await tool.execute(\n                pattern=\"console.log($MSG)\",\n                rewrite=\"logger.info($MSG)\",\n                lang=\"javascript\",\n                paths=[str(tmpdir)],\n                dry_run=True\n            )\n            \n            # éªŒè¯ç»“æœ\n            if result.success:\n                assert \"[DRY RUN]\" in result.content\n                assert \"replacement\" in result.content.lower()\n                # æ–‡ä»¶å†…å®¹ä¸åº”è¯¥æ”¹å˜\n                assert test_file.read_text() == original_content\n            else:\n                # ast-grepæœªå®‰è£…ï¼Œè·³è¿‡\n                assert \"not available\" in result.error or \"not found\" in result.error\n    \n    @pytest.mark.asyncio\n    async def test_replace_apply(self):\n        \"\"\"æµ‹è¯•å®é™…åº”ç”¨æ›¿æ¢\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            test_file = Path(tmpdir) / \"test.js\"\n            test_file.write_text(\"\"\"\nfunction hello() {\n    console.log(\"Hello\");\n    return true;\n}\n\"\"\")\n            \n            # åˆ›å»ºå·¥å…·\n            tool = AstGrepReplaceTool()\n            \n            # æ›¿æ¢console.logä¸ºlogger.infoï¼ˆå®é™…åº”ç”¨ï¼‰\n            result = await tool.execute(\n                pattern=\"console.log($MSG)\",\n                rewrite=\"logger.info($MSG)\",\n                lang=\"javascript\",\n                paths=[str(tmpdir)],\n                dry_run=False\n            )\n            \n            # éªŒè¯ç»“æœ\n            if result.success:\n                assert \"[DRY RUN]\" not in result.content\n                assert \"replacement\" in result.content.lower()\n                # æ–‡ä»¶å†…å®¹åº”è¯¥æ”¹å˜\n                new_content = test_file.read_text()\n                assert \"logger.info\" in new_content\n                assert \"console.log\" not in new_content\n            else:\n                # ast-grepæœªå®‰è£…ï¼Œè·³è¿‡\n                assert \"not available\" in result.error or \"not found\" in result.error\n    \n    @pytest.mark.asyncio\n    async def test_replace_python_print(self):\n        \"\"\"æµ‹è¯•æ›¿æ¢Python printè¯­å¥\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            test_file = Path(tmpdir) / \"test.py\"\n            test_file.write_text(\"\"\""
},
{
"path": "tests/test_ast_tools.py",
"start": 308,
"end": 340,
"text": "def calculate(a, b):\n    result = a + b\n    print(result)\n    return result\n\"\"\")\n            \n            # åˆ›å»ºå·¥å…·\n            tool = AstGrepReplaceTool()\n            \n            # æ›¿æ¢printä¸ºlogger.infoï¼ˆdry-runï¼‰\n            result = await tool.execute(\n                pattern=\"print($MSG)\",\n                rewrite=\"logger.info($MSG)\",\n                lang=\"python\",\n                paths=[str(tmpdir)],\n                dry_run=True\n            )\n            \n            # éªŒè¯ç»“æœ\n            if result.success:\n                assert \"[DRY RUN]\" in result.content\n                assert \"replacement\" in result.content.lower()\n            else:\n                # ast-grepæœªå®‰è£…ï¼Œè·³è¿‡\n                assert \"not available\" in result.error or \"not found\" in result.error\n    \n    @pytest.mark.asyncio\n    async def test_replace_no_matches(self):\n        \"\"\"æµ‹è¯•æ— åŒ¹é…ç»“æœ\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            test_file = Path(tmpdir) / \"test.py\"\n            test_file.write_text(\"\"\""
},
{
"path": "tests/test_ast_tools.py",
"start": 341,
"end": 364,
"text": "def hello():\n    print(\"Hello\")\n\"\"\")\n            \n            # åˆ›å»ºå·¥å…·\n            tool = AstGrepReplaceTool()\n            \n            # æ›¿æ¢ä¸å­˜åœ¨çš„æ¨¡å¼\n            result = await tool.execute(\n                pattern=\"class $NAME:\",\n                rewrite=\"class New$NAME:\",\n                lang=\"python\",\n                paths=[str(tmpdir)],\n                dry_run=True\n            )\n            \n            # éªŒè¯ç»“æœ\n            if result.success:\n                assert \"No matches found\" in result.content\n            else:\n                # ast-grepæœªå®‰è£…ï¼Œè·³è¿‡\n                assert \"not available\" in result.error or \"not found\" in result.error\n\n"
},
{
"path": "tests/test_ast_tools.py",
"start": 365,
"end": 478,
"text": "class TestAstToolsIntegration:\n    \"\"\"ASTå·¥å…·é›†æˆæµ‹è¯•\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_search_and_replace_workflow(self):\n        \"\"\"æµ‹è¯•æœç´¢å’Œæ›¿æ¢å·¥ä½œæµ\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            test_file = Path(tmpdir) / \"test.js\"\n            test_file.write_text(\"\"\"\nfunction processData(data) {\n    console.log(\"Processing:\", data);\n    const result = data.map(x => x * 2);\n    console.log(\"Result:\", result);\n    return result;\n}\n\"\"\")\n            \n            # 1. å…ˆæœç´¢\n            search_tool = AstGrepSearchTool()\n            search_result = await search_tool.execute(\n                pattern=\"console.log($MSG)\",\n                lang=\"javascript\",\n                paths=[str(tmpdir)]\n            )\n            \n            if not search_result.success:\n                # ast-grepæœªå®‰è£…ï¼Œè·³è¿‡\n                pytest.skip(\"ast-grep not available\")\n            \n            # éªŒè¯æ‰¾åˆ°äº†åŒ¹é…\n            assert search_result.metadata[\"total_matches\"] >= 2\n            \n            # 2. é¢„è§ˆæ›¿æ¢\n            replace_tool = AstGrepReplaceTool()\n            preview_result = await replace_tool.execute(\n                pattern=\"console.log($MSG)\",\n                rewrite=\"logger.info($MSG)\",\n                lang=\"javascript\",\n                paths=[str(tmpdir)],\n                dry_run=True\n            )\n            \n            assert preview_result.success\n            assert \"[DRY RUN]\" in preview_result.content\n            \n            # 3. åº”ç”¨æ›¿æ¢\n            apply_result = await replace_tool.execute(\n                pattern=\"console.log($MSG)\",\n                rewrite=\"logger.info($MSG)\",\n                lang=\"javascript\",\n                paths=[str(tmpdir)],\n                dry_run=False\n            )\n            \n            assert apply_result.success\n            \n            # 4. éªŒè¯æ›¿æ¢æˆåŠŸ\n            new_content = test_file.read_text()\n            assert \"logger.info\" in new_content\n            assert \"console.log\" not in new_content\n    \n    @pytest.mark.asyncio\n    async def test_multiple_languages(self):\n        \"\"\"æµ‹è¯•å¤šç§è¯­è¨€æ”¯æŒ\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # Pythonæ–‡ä»¶\n            (Path(tmpdir) / \"test.py\").write_text(\"def hello(): pass\")\n            \n            # JavaScriptæ–‡ä»¶\n            (Path(tmpdir) / \"test.js\").write_text(\"function hello() {}\")\n            \n            # TypeScriptæ–‡ä»¶\n            (Path(tmpdir) / \"test.ts\").write_text(\"function hello(): void {}\")\n            \n            search_tool = AstGrepSearchTool()\n            \n            # æœç´¢Python\n            py_result = await search_tool.execute(\n                pattern=\"def $FUNC():\",\n                lang=\"python\",\n                paths=[str(tmpdir)],\n                globs=[\"*.py\"]\n            )\n            \n            # æœç´¢JavaScript\n            js_result = await search_tool.execute(\n                pattern=\"function $FUNC() {}\",\n                lang=\"javascript\",\n                paths=[str(tmpdir)],\n                globs=[\"*.js\"]\n            )\n            \n            # æœç´¢TypeScript\n            ts_result = await search_tool.execute(\n                pattern=\"function $FUNC(): void {}\",\n                lang=\"typescript\",\n                paths=[str(tmpdir)],\n                globs=[\"*.ts\"]\n            )\n            \n            # è‡³å°‘æœ‰ä¸€ä¸ªåº”è¯¥æˆåŠŸï¼ˆå¦‚æœast-grepå·²å®‰è£…ï¼‰\n            if py_result.success or js_result.success or ts_result.success:\n                # éªŒè¯æ‰¾åˆ°äº†åŒ¹é…\n                if py_result.success:\n                    assert \"hello\" in py_result.content\n                if js_result.success:\n                    assert \"hello\" in js_result.content\n                if ts_result.success:\n                    assert \"hello\" in ts_result.content\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\", \"-s\"])"
},
{
"path": "tests/test_auto_scale_tokens.py",
"start": 1,
"end": 269,
"text": "#!/usr/bin/env python3\n\"\"\"\næµ‹è¯•æ™ºèƒ½tokené¢„ç®—è°ƒæ•´åŠŸèƒ½\n\næµ‹è¯•åœºæ™¯ï¼š\n1. æ— chat_files: åº”è¯¥è‡ªåŠ¨æ‰©å¤§åˆ°10000 tokens\n2. æœ‰chat_files: åº”è¯¥ä¿æŒ5000 tokens\n3. ç¦ç”¨auto_scale: åº”è¯¥ä¿æŒåŸå§‹å€¼\n\"\"\"\n\nimport asyncio\nfrom pathlib import Path\nfrom daoyoucode.agents.tools.repomap_tools import RepoMapTool\n\n\nasync def test_no_chat_files():\n    \"\"\"æµ‹è¯•æ— å¯¹è¯æ–‡ä»¶åœºæ™¯ï¼ˆåº”è¯¥æ‰©å¤§é¢„ç®—ï¼‰\"\"\"\n    print(\"=\" * 60)\n    print(\"æµ‹è¯•1: æ— å¯¹è¯æ–‡ä»¶ï¼ˆåº”è¯¥è‡ªåŠ¨æ‰©å¤§åˆ°6000 tokensï¼‰\")\n    print(\"=\" * 60)\n    \n    tool = RepoMapTool()\n    \n    result = await tool.execute(\n        repo_path=\".\",\n        chat_files=[],  # ç©ºåˆ—è¡¨\n        mentioned_idents=[],\n        max_tokens=3000,  # é»˜è®¤3000\n        auto_scale=True\n    )\n    \n    if result.success:\n        metadata = result.metadata\n        print(f\"\\nâœ“ ç”ŸæˆæˆåŠŸ\")\n        print(f\"  - åŸå§‹max_tokens: {metadata.get('original_max_tokens')}\")\n        print(f\"  - å®é™…max_tokens: {metadata.get('max_tokens')}\")\n        print(f\"  - æ˜¯å¦è‡ªåŠ¨è°ƒæ•´: {metadata.get('auto_scaled')}\")\n        print(f\"  - chat_filesæ•°é‡: {metadata.get('chat_files_count')}\")\n        print(f\"  - åŒ…å«æ–‡ä»¶æ•°: {metadata.get('file_count')}\")\n        \n        # éªŒè¯\n        if metadata.get('max_tokens') == 6000:\n            print(\"\\nâœ… éªŒè¯é€šè¿‡: tokené¢„ç®—å·²æ‰©å¤§åˆ°6000\")\n            return True\n        else:\n            print(f\"\\nâŒ éªŒè¯å¤±è´¥: æœŸæœ›6000ï¼Œå®é™…{metadata.get('max_tokens')}\")\n            return False\n    else:\n        print(f\"âœ— ç”Ÿæˆå¤±è´¥: {result.error}\")\n        return False\n\n\nasync def test_with_chat_files():\n    \"\"\"æµ‹è¯•æœ‰å¯¹è¯æ–‡ä»¶åœºæ™¯ï¼ˆåº”è¯¥ä¿æŒæ ‡å‡†é¢„ç®—ï¼‰\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•2: æœ‰å¯¹è¯æ–‡ä»¶ï¼ˆåº”è¯¥ä¿æŒ3000 tokensï¼‰\")\n    print(\"=\" * 60)\n    \n    tool = RepoMapTool()\n    \n    result = await tool.execute(\n        repo_path=\".\",\n        chat_files=[\"daoyoucode/agents/core/agent.py\"],  # æŒ‡å®šæ–‡ä»¶\n        mentioned_idents=[\"BaseAgent\"],\n        max_tokens=3000,  # é»˜è®¤3000\n        auto_scale=True\n    )\n    \n    if result.success:\n        metadata = result.metadata\n        print(f\"\\nâœ“ ç”ŸæˆæˆåŠŸ\")\n        print(f\"  - åŸå§‹max_tokens: {metadata.get('original_max_tokens')}\")\n        print(f\"  - å®é™…max_tokens: {metadata.get('max_tokens')}\")\n        print(f\"  - æ˜¯å¦è‡ªåŠ¨è°ƒæ•´: {metadata.get('auto_scaled')}\")\n        print(f\"  - chat_filesæ•°é‡: {metadata.get('chat_files_count')}\")\n        print(f\"  - åŒ…å«æ–‡ä»¶æ•°: {metadata.get('file_count')}\")\n        \n        # éªŒè¯\n        if metadata.get('max_tokens') == 3000:\n            print(\"\\nâœ… éªŒè¯é€šè¿‡: tokené¢„ç®—ä¿æŒ3000\")\n            return True\n        else:\n            print(f\"\\nâŒ éªŒè¯å¤±è´¥: æœŸæœ›3000ï¼Œå®é™…{metadata.get('max_tokens')}\")\n            return False\n    else:\n        print(f\"âœ— ç”Ÿæˆå¤±è´¥: {result.error}\")\n        return False\n\n\nasync def test_auto_scale_disabled():\n    \"\"\"æµ‹è¯•ç¦ç”¨è‡ªåŠ¨è°ƒæ•´ï¼ˆåº”è¯¥ä¿æŒåŸå§‹å€¼ï¼‰\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•3: ç¦ç”¨auto_scaleï¼ˆåº”è¯¥ä¿æŒåŸå§‹å€¼ï¼‰\")\n    print(\"=\" * 60)\n    \n    tool = RepoMapTool()\n    \n    result = await tool.execute(\n        repo_path=\".\",\n        chat_files=[],  # ç©ºåˆ—è¡¨\n        mentioned_idents=[],\n        max_tokens=3000,  # é»˜è®¤3000\n        auto_scale=False  # ç¦ç”¨è‡ªåŠ¨è°ƒæ•´\n    )\n    \n    if result.success:\n        metadata = result.metadata\n        print(f\"\\nâœ“ ç”ŸæˆæˆåŠŸ\")\n        print(f\"  - åŸå§‹max_tokens: {metadata.get('original_max_tokens')}\")\n        print(f\"  - å®é™…max_tokens: {metadata.get('max_tokens')}\")\n        print(f\"  - æ˜¯å¦è‡ªåŠ¨è°ƒæ•´: {metadata.get('auto_scaled')}\")\n        print(f\"  - chat_filesæ•°é‡: {metadata.get('chat_files_count')}\")\n        print(f\"  - åŒ…å«æ–‡ä»¶æ•°: {metadata.get('file_count')}\")\n        \n        # éªŒè¯\n        if metadata.get('max_tokens') == 3000:\n            print(\"\\nâœ… éªŒè¯é€šè¿‡: tokené¢„ç®—ä¿æŒ3000ï¼ˆæœªè°ƒæ•´ï¼‰\")\n            return True\n        else:\n            print(f\"\\nâŒ éªŒè¯å¤±è´¥: æœŸæœ›3000ï¼Œå®é™…{metadata.get('max_tokens')}\")\n            return False\n    else:\n        print(f\"âœ— ç”Ÿæˆå¤±è´¥: {result.error}\")\n        return False\n\n\nasync def test_custom_max_tokens():\n    \"\"\"æµ‹è¯•è‡ªå®šä¹‰max_tokensï¼ˆåº”è¯¥æŒ‰æ¯”ä¾‹æ‰©å¤§ï¼‰\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•4: è‡ªå®šä¹‰max_tokens=2000ï¼ˆåº”è¯¥æ‰©å¤§åˆ°4000ï¼‰\")\n    print(\"=\" * 60)\n    \n    tool = RepoMapTool()\n    \n    result = await tool.execute(\n        repo_path=\".\",\n        chat_files=[],  # ç©ºåˆ—è¡¨\n        mentioned_idents=[],\n        max_tokens=2000,  # è‡ªå®šä¹‰å€¼\n        auto_scale=True\n "
},
{
"path": "tests/test_cache_layer.py",
"start": 1,
"end": 14,
"text": "\"\"\"\næµ‹è¯•ç¼“å­˜å±‚åŠŸèƒ½\n\néªŒè¯ç¼“å­˜æ˜¯å¦æ­£å¸¸å·¥ä½œï¼Œä»¥åŠæ€§èƒ½æå‡æ•ˆæœ\n\"\"\"\n\nimport asyncio\nimport time\nfrom daoyoucode.agents.core.cache import (\n    SimpleCache, get_cache, get_namespaced_cache,\n    get_profile_cache, get_summary_cache\n)\n\n"
},
{
"path": "tests/test_cache_layer.py",
"start": 15,
"end": 67,
"text": "def test_basic_cache():\n    \"\"\"æµ‹è¯•åŸºç¡€ç¼“å­˜åŠŸèƒ½\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šåŸºç¡€ç¼“å­˜åŠŸèƒ½\")\n    print(\"=\"*60)\n    \n    cache = SimpleCache(default_ttl=2)  # 2ç§’TTL\n    \n    # 1. è®¾ç½®å’Œè·å–\n    print(\"\\n1. è®¾ç½®å’Œè·å–\")\n    cache.set(\"key1\", \"value1\")\n    value = cache.get(\"key1\")\n    assert value == \"value1\", \"è·å–å¤±è´¥\"\n    print(f\"âœ“ è®¾ç½®å’Œè·å–æˆåŠŸ: {value}\")\n    \n    # 2. ç¼“å­˜å‘½ä¸­\n    print(\"\\n2. ç¼“å­˜å‘½ä¸­\")\n    value = cache.get(\"key1\")\n    assert value == \"value1\", \"ç¼“å­˜å‘½ä¸­å¤±è´¥\"\n    print(f\"âœ“ ç¼“å­˜å‘½ä¸­: {value}\")\n    \n    # 3. ç¼“å­˜æœªå‘½ä¸­\n    print(\"\\n3. ç¼“å­˜æœªå‘½ä¸­\")\n    value = cache.get(\"nonexistent\", default=\"default_value\")\n    assert value == \"default_value\", \"é»˜è®¤å€¼å¤±è´¥\"\n    print(f\"âœ“ ç¼“å­˜æœªå‘½ä¸­ï¼Œè¿”å›é»˜è®¤å€¼: {value}\")\n    \n    # 4. TTLè¿‡æœŸ\n    print(\"\\n4. TTLè¿‡æœŸ\")\n    cache.set(\"key2\", \"value2\", ttl=1)  # 1ç§’TTL\n    print(\"ç­‰å¾…2ç§’...\")\n    time.sleep(2)\n    value = cache.get(\"key2\", default=\"expired\")\n    assert value == \"expired\", \"TTLè¿‡æœŸå¤±è´¥\"\n    print(f\"âœ“ TTLè¿‡æœŸï¼Œè¿”å›é»˜è®¤å€¼: {value}\")\n    \n    # 5. åˆ é™¤\n    print(\"\\n5. åˆ é™¤\")\n    cache.set(\"key3\", \"value3\")\n    deleted = cache.delete(\"key3\")\n    assert deleted, \"åˆ é™¤å¤±è´¥\"\n    value = cache.get(\"key3\")\n    assert value is None, \"åˆ é™¤åä»èƒ½è·å–\"\n    print(f\"âœ“ åˆ é™¤æˆåŠŸ\")\n    \n    # 6. ç»Ÿè®¡ä¿¡æ¯\n    print(\"\\n6. ç»Ÿè®¡ä¿¡æ¯\")\n    stats = cache.get_stats()\n    print(f\"âœ“ ç»Ÿè®¡ä¿¡æ¯: {stats}\")\n    \n    print(\"\\nâœ… åŸºç¡€ç¼“å­˜åŠŸèƒ½æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_cache_layer.py",
"start": 68,
"end": 77,
"text": "def test_get_or_set():\n    \"\"\"æµ‹è¯•get_or_setåŠŸèƒ½\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šget_or_setåŠŸèƒ½\")\n    print(\"=\"*60)\n    \n    cache = SimpleCache()\n    \n    call_count = 0\n    "
},
{
"path": "tests/test_cache_layer.py",
"start": 78,
"end": 110,
"text": "    def expensive_function():\n        nonlocal call_count\n        call_count += 1\n        print(f\"  è°ƒç”¨expensive_function (ç¬¬{call_count}æ¬¡)\")\n        time.sleep(0.1)  # æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ\n        return \"expensive_result\"\n    \n    # ç¬¬1æ¬¡è°ƒç”¨ï¼ˆç¼“å­˜æœªå‘½ä¸­ï¼Œæ‰§è¡Œå‡½æ•°ï¼‰\n    print(\"\\nç¬¬1æ¬¡è°ƒç”¨ï¼ˆåº”è¯¥æ‰§è¡Œå‡½æ•°ï¼‰:\")\n    start = time.time()\n    result1 = cache.get_or_set(\"expensive_key\", expensive_function)\n    time1 = time.time() - start\n    print(f\"  ç»“æœ: {result1}, è€—æ—¶: {time1*1000:.0f}ms\")\n    \n    # ç¬¬2æ¬¡è°ƒç”¨ï¼ˆç¼“å­˜å‘½ä¸­ï¼Œä¸æ‰§è¡Œå‡½æ•°ï¼‰\n    print(\"\\nç¬¬2æ¬¡è°ƒç”¨ï¼ˆåº”è¯¥ä½¿ç”¨ç¼“å­˜ï¼‰:\")\n    start = time.time()\n    result2 = cache.get_or_set(\"expensive_key\", expensive_function)\n    time2 = time.time() - start\n    print(f\"  ç»“æœ: {result2}, è€—æ—¶: {time2*1000:.0f}ms\")\n    \n    assert result1 == result2, \"ç»“æœä¸ä¸€è‡´\"\n    assert call_count == 1, \"å‡½æ•°è¢«å¤šæ¬¡è°ƒç”¨\"\n    assert time2 < time1 * 0.5, \"ç¼“å­˜æœªç”Ÿæ•ˆ\"\n    \n    print(f\"\\nâœ… get_or_setæµ‹è¯•é€šè¿‡\")\n    print(f\"   å‡½æ•°è°ƒç”¨æ¬¡æ•°: {call_count}\")\n    if time2 > 0:\n        print(f\"   æ€§èƒ½æå‡: {time1/time2:.1f}x\")\n    else:\n        print(f\"   æ€§èƒ½æå‡: æå¿«ï¼ˆç¼“å­˜å‘½ä¸­æ—¶é—´<1msï¼‰\")\n\n"
},
{
"path": "tests/test_cache_layer.py",
"start": 111,
"end": 136,
"text": "def test_namespaced_cache():\n    \"\"\"æµ‹è¯•å‘½åç©ºé—´ç¼“å­˜\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šå‘½åç©ºé—´ç¼“å­˜\")\n    print(\"=\"*60)\n    \n    cache1 = get_namespaced_cache(\"namespace1\")\n    cache2 = get_namespaced_cache(\"namespace2\")\n    \n    # è®¾ç½®ç›¸åŒçš„é”®ï¼Œä¸åŒçš„å‘½åç©ºé—´\n    cache1.set(\"key\", \"value1\")\n    cache2.set(\"key\", \"value2\")\n    \n    # è·å–åº”è¯¥è¿”å›ä¸åŒçš„å€¼\n    value1 = cache1.get(\"key\")\n    value2 = cache2.get(\"key\")\n    \n    print(f\"namespace1:key = {value1}\")\n    print(f\"namespace2:key = {value2}\")\n    \n    assert value1 == \"value1\", \"å‘½åç©ºé—´1å€¼é”™è¯¯\"\n    assert value2 == \"value2\", \"å‘½åç©ºé—´2å€¼é”™è¯¯\"\n    \n    print(\"\\nâœ… å‘½åç©ºé—´ç¼“å­˜æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_cache_layer.py",
"start": 137,
"end": 145,
"text": "def test_cache_performance():\n    \"\"\"æµ‹è¯•ç¼“å­˜æ€§èƒ½æå‡\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šç¼“å­˜æ€§èƒ½æå‡\")\n    print(\"=\"*60)\n    \n    cache = SimpleCache()\n    \n    # æ¨¡æ‹Ÿæ–‡ä»¶è¯»å–"
},
{
"path": "tests/test_cache_layer.py",
"start": 146,
"end": 188,
"text": "    def read_file(filename):\n        time.sleep(0.01)  # æ¨¡æ‹Ÿ10msçš„æ–‡ä»¶I/O\n        return f\"content of {filename}\"\n    \n    files = [f\"file{i}.txt\" for i in range(10)]\n    \n    # ç¬¬1è½®ï¼šæ— ç¼“å­˜ï¼ˆå…¨éƒ¨è¯»å–ï¼‰\n    print(\"\\nç¬¬1è½®ï¼šæ— ç¼“å­˜\")\n    start = time.time()\n    for filename in files:\n        content = read_file(filename)\n    time_no_cache = time.time() - start\n    print(f\"  è€—æ—¶: {time_no_cache*1000:.0f}ms\")\n    \n    # ç¬¬2è½®ï¼šæœ‰ç¼“å­˜ï¼ˆç¬¬1æ¬¡è¯»å–ï¼‰\n    print(\"\\nç¬¬2è½®ï¼šæœ‰ç¼“å­˜ï¼ˆç¬¬1æ¬¡è¯»å–ï¼‰\")\n    start = time.time()\n    for filename in files:\n        content = cache.get_or_set(filename, lambda f=filename: read_file(f))\n    time_first_cache = time.time() - start\n    print(f\"  è€—æ—¶: {time_first_cache*1000:.0f}ms\")\n    \n    # ç¬¬3è½®ï¼šæœ‰ç¼“å­˜ï¼ˆç¬¬2æ¬¡è¯»å–ï¼Œå…¨éƒ¨å‘½ä¸­ï¼‰\n    print(\"\\nç¬¬3è½®ï¼šæœ‰ç¼“å­˜ï¼ˆç¬¬2æ¬¡è¯»å–ï¼Œå…¨éƒ¨å‘½ä¸­ï¼‰\")\n    start = time.time()\n    for filename in files:\n        content = cache.get_or_set(filename, lambda f=filename: read_file(f))\n    time_cached = time.time() - start\n    print(f\"  è€—æ—¶: {time_cached*1000:.0f}ms\")\n    \n    # ç»Ÿè®¡\n    stats = cache.get_stats()\n    print(f\"\\nç¼“å­˜ç»Ÿè®¡:\")\n    print(f\"  å‘½ä¸­ç‡: {stats['hit_rate']}\")\n    print(f\"  å‘½ä¸­æ¬¡æ•°: {stats['hits']}\")\n    print(f\"  æœªå‘½ä¸­æ¬¡æ•°: {stats['misses']}\")\n    \n    speedup = time_no_cache / time_cached if time_cached > 0 else float('inf')\n    print(f\"\\nâœ… æ€§èƒ½æå‡: {speedup:.1f}x\" if speedup != float('inf') else \"\\nâœ… æ€§èƒ½æå‡: æå¿«ï¼ˆ>100xï¼‰\")\n    print(f\"   æ— ç¼“å­˜: {time_no_cache*1000:.0f}ms\")\n    print(f\"   æœ‰ç¼“å­˜: {time_cached*1000:.0f}ms\")\n\n"
},
{
"path": "tests/test_cache_layer.py",
"start": 189,
"end": 254,
"text": "def test_memory_integration():\n    \"\"\"æµ‹è¯•Memoryæ¨¡å—é›†æˆ\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šMemoryæ¨¡å—é›†æˆ\")\n    print(\"=\"*60)\n    \n    from daoyoucode.agents.memory import get_memory_manager\n    \n    memory = get_memory_manager()\n    \n    # æµ‹è¯•å¯¹è¯å†å²ç¼“å­˜\n    print(\"\\n1. å¯¹è¯å†å²ç¼“å­˜\")\n    session_id = \"test_session_cache\"\n    \n    # æ·»åŠ å¯¹è¯\n    memory.add_conversation(\n        session_id,\n        \"ä½ å¥½\",\n        \"ä½ å¥½ï¼æœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ\",\n        user_id=\"test_user\"\n    )\n    \n    # ç¬¬1æ¬¡è·å–ï¼ˆä»å­˜å‚¨ï¼‰\n    start = time.time()\n    history1 = memory.get_conversation_history(session_id)\n    time1 = time.time() - start\n    print(f\"  ç¬¬1æ¬¡è·å–: {time1*1000:.2f}ms\")\n    \n    # ç¬¬2æ¬¡è·å–ï¼ˆä»ç¼“å­˜ï¼‰\n    start = time.time()\n    history2 = memory.get_conversation_history(session_id)\n    time2 = time.time() - start\n    print(f\"  ç¬¬2æ¬¡è·å–: {time2*1000:.2f}ms\")\n    \n    assert len(history1) == len(history2), \"å†å²ä¸ä¸€è‡´\"\n    if time1 > 0:\n        speedup = time1 / time2 if time2 > 0 else float('inf')\n        print(f\"  æ€§èƒ½æå‡: {speedup:.1f}x\")\n    \n    # æµ‹è¯•ç”¨æˆ·åå¥½ç¼“å­˜\n    print(\"\\n2. ç”¨æˆ·åå¥½ç¼“å­˜\")\n    user_id = \"test_user_cache\"\n    \n    # è®¾ç½®åå¥½\n    memory.remember_preference(user_id, \"language\", \"python\")\n    \n    # ç¬¬1æ¬¡è·å–ï¼ˆä»å­˜å‚¨ï¼‰\n    start = time.time()\n    prefs1 = memory.get_preferences(user_id)\n    time1 = time.time() - start\n    print(f\"  ç¬¬1æ¬¡è·å–: {time1*1000:.2f}ms\")\n    \n    # ç¬¬2æ¬¡è·å–ï¼ˆä»ç¼“å­˜ï¼‰\n    start = time.time()\n    prefs2 = memory.get_preferences(user_id)\n    time2 = time.time() - start\n    print(f\"  ç¬¬2æ¬¡è·å–: {time2*1000:.2f}ms\")\n    \n    assert prefs1 == prefs2, \"åå¥½ä¸ä¸€è‡´\"\n    if time1 > 0:\n        speedup = time1 / time2 if time2 > 0 else float('inf')\n        print(f\"  æ€§èƒ½æå‡: {speedup:.1f}x\")\n    \n    print(\"\\nâœ… Memoryæ¨¡å—é›†æˆæµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_cache_layer.py",
"start": 255,
"end": 301,
"text": "def test_cache_stats():\n    \"\"\"æµ‹è¯•ç¼“å­˜ç»Ÿè®¡\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šç¼“å­˜ç»Ÿè®¡\")\n    print(\"=\"*60)\n    \n    # åˆ›å»ºç‹¬ç«‹çš„ç¼“å­˜å®ä¾‹\n    cache = SimpleCache()\n    \n    # æ‰§è¡Œä¸€äº›æ“ä½œ\n    cache.set(\"key1\", \"value1\")\n    cache.set(\"key2\", \"value2\")\n    cache.get(\"key1\")  # å‘½ä¸­\n    cache.get(\"key1\")  # å‘½ä¸­\n    cache.get(\"key3\")  # æœªå‘½ä¸­\n    cache.delete(\"key2\")\n    \n    # è·å–ç»Ÿè®¡\n    stats = cache.get_stats()\n    \n    print(\"\\nç¼“å­˜ç»Ÿè®¡:\")\n    for key, value in stats.items():\n        print(f\"  {key}: {value}\")\n    \n    assert stats['hits'] == 2, f\"å‘½ä¸­æ¬¡æ•°é”™è¯¯: æœŸæœ›2, å®é™…{stats['hits']}\"\n    assert stats['misses'] == 1, f\"æœªå‘½ä¸­æ¬¡æ•°é”™è¯¯: æœŸæœ›1, å®é™…{stats['misses']}\"\n    assert stats['sets'] == 2, f\"è®¾ç½®æ¬¡æ•°é”™è¯¯: æœŸæœ›2, å®é™…{stats['sets']}\"\n    assert stats['deletes'] == 1, f\"åˆ é™¤æ¬¡æ•°é”™è¯¯: æœŸæœ›1, å®é™…{stats['deletes']}\"\n    \n    print(\"\\nâœ… ç¼“å­˜ç»Ÿè®¡æµ‹è¯•é€šè¿‡\")\n\n\nif __name__ == \"__main__\":\n    print(\"=\"*60)\n    print(\"ç¼“å­˜å±‚åŠŸèƒ½æµ‹è¯•å¥—ä»¶\")\n    print(\"=\"*60)\n    \n    test_basic_cache()\n    test_get_or_set()\n    test_namespaced_cache()\n    test_cache_performance()\n    test_memory_integration()\n    test_cache_stats()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"âœ… æ‰€æœ‰æµ‹è¯•å®Œæˆ\")\n    print(\"=\"*60)"
},
{
"path": "tests/test_chat_flow.py",
"start": 1,
"end": 84,
"text": "\"\"\"\næµ‹è¯•å®Œæ•´çš„chatæµç¨‹\n\"\"\"\n\nimport asyncio\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\nasync def test_chat():\n    print(\"=\"*60)\n    print(\"æµ‹è¯•å®Œæ•´chatæµç¨‹\")\n    print(\"=\"*60)\n    \n    # 1. é…ç½®LLM\n    print(\"\\n1. é…ç½®LLM...\")\n    from daoyoucode.agents.llm.client_manager import get_client_manager\n    from daoyoucode.agents.llm.config_loader import auto_configure\n    \n    client_manager = get_client_manager()\n    auto_configure(client_manager)\n    \n    if not client_manager.provider_configs:\n        print(\"âŒ æœªæ‰¾åˆ°LLMé…ç½®\")\n        return False\n    \n    print(f\"âœ“ å·²é…ç½® {len(client_manager.provider_configs)} ä¸ªæä¾›å•†\")\n    \n    # 2. æ³¨å†ŒAgent\n    print(\"\\n2. æ³¨å†ŒAgent...\")\n    from daoyoucode.agents.builtin import register_builtin_agents\n    register_builtin_agents()\n    \n    from daoyoucode.agents.core.agent import get_agent_registry\n    registry = get_agent_registry()\n    agents = registry.list_agents()\n    \n    if \"MainAgent\" not in agents:\n        print(\"âŒ MainAgentæœªæ³¨å†Œ\")\n        return False\n    \n    print(f\"âœ“ å·²æ³¨å†Œ {len(agents)} ä¸ªAgent: {', '.join(agents)}\")\n    \n    # 3. æµ‹è¯•execute_skill\n    print(\"\\n3. æµ‹è¯•execute_skill...\")\n    from daoyoucode.agents.executor import execute_skill\n    \n    context = {\n        \"session_id\": \"test-session\",\n        \"repo\": \".\",\n        \"model\": \"qwen-max\"\n    }\n    \n    try:\n        result = await execute_skill(\n            skill_name=\"chat_assistant\",\n            user_input=\"ä½ å¥½\",\n            session_id=context[\"session_id\"],\n            context=context\n        )\n        \n        print(f\"\\nâœ“ æ‰§è¡Œå®Œæˆ\")\n        print(f\"  â€¢ æˆåŠŸ: {result.get('success')}\")\n        print(f\"  â€¢ å†…å®¹: {result.get('content', '')[:200]}\")\n        print(f\"  â€¢ é”™è¯¯: {result.get('error', 'N/A')}\")\n        \n        return result.get('success', False)\n    \n    except Exception as e:\n        print(f\"\\nâŒ æ‰§è¡Œå¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\nif __name__ == \"__main__\":\n    success = asyncio.run(test_chat())\n    print(\"\\n\" + \"=\"*60)\n    if success:\n        print(\"âœ… æµ‹è¯•é€šè¿‡ï¼å¯ä»¥ä½¿ç”¨chatå‘½ä»¤äº†\")\n    else:\n        print(\"âŒ æµ‹è¯•å¤±è´¥\")\n    print(\"=\"*60)"
},
{
"path": "tests/test_chat_real.py",
"start": 1,
"end": 10,
"text": "\"\"\"\næµ‹è¯•chatå‘½ä»¤çš„çœŸå®AIåŠŸèƒ½\n\"\"\"\n\nimport sys\nimport os\n\nsys.path.insert(0, os.path.dirname(__file__))\n\n"
},
{
"path": "tests/test_chat_real.py",
"start": 11,
"end": 72,
"text": "def test_chat_with_real_ai():\n    \"\"\"æµ‹è¯•chatå‘½ä»¤ä½¿ç”¨çœŸå®AI\"\"\"\n    print(\"=\" * 60)\n    print(\"æµ‹è¯• chat å‘½ä»¤ - çœŸå®AI\")\n    print(\"=\" * 60)\n    \n    from cli.commands.chat import initialize_agents, handle_chat_with_agent\n    \n    # 1. åˆå§‹åŒ–Agent\n    print(\"\\n1. åˆå§‹åŒ–Agent...\")\n    agent_available = initialize_agents(\"qwen-turbo\")\n    \n    if not agent_available:\n        print(\"âœ— Agentåˆå§‹åŒ–å¤±è´¥\")\n        return False\n    \n    print(\"âœ“ Agentåˆå§‹åŒ–æˆåŠŸ\")\n    \n    # 2. æµ‹è¯•å¯¹è¯\n    print(\"\\n2. æµ‹è¯•å¯¹è¯...\")\n    \n    context = {\n        \"session_id\": \"test-session\",\n        \"files\": [],\n        \"repo\": \".\",\n        \"history\": []\n    }\n    \n    test_inputs = [\n        \"ä½ å¥½\",\n        \"ä½ èƒ½åšä»€ä¹ˆ\",\n        \"å†™ä¸€ä¸ªPythonå‡½æ•°è®¡ç®—1åˆ°10çš„å’Œ\"\n    ]\n    \n    for user_input in test_inputs:\n        print(f\"\\nç”¨æˆ·: {user_input}\")\n        print(\"AIæ­£åœ¨æ€è€ƒ...\")\n        \n        try:\n            response = handle_chat_with_agent(user_input, context)\n            print(f\"AI: {response[:200]}...\")\n            print(\"âœ“ å¯¹è¯æˆåŠŸ\")\n        except Exception as e:\n            print(f\"âœ— å¯¹è¯å¤±è´¥: {e}\")\n            import traceback\n            traceback.print_exc()\n            return False\n    \n    return True\n\n\nif __name__ == \"__main__\":\n    success = test_chat_with_real_ai()\n    \n    print(\"\\n\" + \"=\" * 60)\n    if success:\n        print(\"ğŸ‰ chatå‘½ä»¤çœŸå®AIæµ‹è¯•é€šè¿‡ï¼\")\n        print(\"\\nç°åœ¨å¯ä»¥è¿è¡Œ:\")\n        print(\"  python daoyoucode.py chat\")\n    else:\n        print(\"âŒ æµ‹è¯•å¤±è´¥\")\n    print(\"=\" * 60)"
},
{
"path": "tests/test_chat_simple.py",
"start": 1,
"end": 10,
"text": "\"\"\"\nç®€å•æµ‹è¯•chatå‘½ä»¤ - ä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼\n\"\"\"\n\nimport sys\nimport os\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, os.path.dirname(__file__))\n"
},
{
"path": "tests/test_chat_simple.py",
"start": 11,
"end": 42,
"text": "def test_chat_mock():\n    \"\"\"æµ‹è¯•chatå‘½ä»¤çš„æ¨¡æ‹Ÿæ¨¡å¼\"\"\"\n    print(\"=\" * 60)\n    print(\"æµ‹è¯• chat å‘½ä»¤ - æ¨¡æ‹Ÿæ¨¡å¼\")\n    print(\"=\" * 60)\n    \n    from cli.commands.chat import generate_mock_response\n    \n    # æµ‹è¯•ç”¨ä¾‹\n    test_cases = [\n        \"ä½ å¥½\",\n        \"å¸®åŠ©\",\n        \"ä½ èƒ½åšä»€ä¹ˆ\",\n        \"å†™ä¸ªPythonå‡½æ•°\",\n        \"å…¶ä»–é—®é¢˜\"\n    ]\n    \n    context = {\n        \"files\": [],\n        \"repo\": \".\",\n        \"model\": \"qwen-max\",\n        \"history\": []\n    }\n    \n    for user_input in test_cases:\n        print(f\"\\nç”¨æˆ·: {user_input}\")\n        response = generate_mock_response(user_input, context)\n        print(f\"AI: {response[:100]}...\")\n        print(\"-\" * 60)\n\nif __name__ == \"__main__\":\n    test_chat_mock()"
},
{
"path": "tests/test_chat_with_init.py",
"start": 1,
"end": 92,
"text": "\"\"\"\næµ‹è¯•å®Œæ•´çš„chatæµç¨‹ï¼ˆä½¿ç”¨æ–°çš„åˆå§‹åŒ–ç³»ç»Ÿï¼‰\n\næ¨¡æ‹Ÿå®é™…çš„CLI chatå‘½ä»¤æ‰§è¡Œæµç¨‹\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport asyncio\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nbackend_dir = Path(__file__).parent\nsys.path.insert(0, str(backend_dir))\n\nimport logging\nlogging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')\n\nasync def test_chat_flow():\n    \"\"\"æµ‹è¯•å®Œæ•´çš„chatæµç¨‹\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•å®Œæ•´çš„Chatæµç¨‹\")\n    print(\"=\"*60)\n    \n    # 1. åˆå§‹åŒ–Agentç³»ç»Ÿ\n    print(\"\\n1. åˆå§‹åŒ–Agentç³»ç»Ÿ...\")\n    from daoyoucode.agents.init import initialize_agent_system\n    tool_registry = initialize_agent_system()\n    print(f\"   âœ“ å·¥å…·æ•°é‡: {len(tool_registry.list_tools())}\")\n    \n    # 2. é…ç½®LLMå®¢æˆ·ç«¯\n    print(\"\\n2. é…ç½®LLMå®¢æˆ·ç«¯...\")\n    from daoyoucode.agents.llm.client_manager import get_client_manager\n    from daoyoucode.agents.llm.config_loader import auto_configure\n    \n    client_manager = get_client_manager()\n    auto_configure(client_manager)\n    \n    if client_manager.provider_configs:\n        print(f\"   âœ“ å·²é…ç½® {len(client_manager.provider_configs)} ä¸ªæä¾›å•†\")\n    else:\n        print(\"   âš  æœªé…ç½®LLMæä¾›å•†ï¼ˆå°†ä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼ï¼‰\")\n    \n    # 3. å‡†å¤‡ä¸Šä¸‹æ–‡\n    print(\"\\n3. å‡†å¤‡ä¸Šä¸‹æ–‡...\")\n    context = {\n        \"session_id\": \"test_session\",\n        \"repo\": \".\",\n        \"model\": \"qwen-plus\",\n        \"initial_files\": []\n    }\n    print(\"   âœ“ ä¸Šä¸‹æ–‡å·²å‡†å¤‡\")\n    \n    # 4. æ‰§è¡ŒSkill\n    print(\"\\n4. æ‰§è¡Œchat_assistant Skill...\")\n    from daoyoucode.agents.executor import execute_skill\n    \n    user_input = \"ä½ å¥½ï¼Œä½ èƒ½ç†è§£è¿™ä¸ªé¡¹ç›®å—ï¼Ÿ\"\n    print(f\"   ç”¨æˆ·è¾“å…¥: {user_input}\")\n    \n    try:\n        result = await execute_skill(\n            skill_name=\"chat_assistant\",\n            user_input=user_input,\n            session_id=context[\"session_id\"],\n            context=context\n        )\n        \n        if result.get('success'):\n            print(\"   âœ“ Skillæ‰§è¡ŒæˆåŠŸ\")\n            response = result.get('content', '')\n            print(f\"\\n   AIå“åº”: {response[:200]}...\")\n            \n            # æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†å·¥å…·\n            tools_used = result.get('tools_used', [])\n            if tools_used:\n                print(f\"\\n   ä½¿ç”¨çš„å·¥å…·: {', '.join(tools_used)}\")\n            else:\n                print(\"\\n   æœªä½¿ç”¨å·¥å…·ï¼ˆå¯èƒ½æ˜¯LLMä¸æ”¯æŒfunction callingï¼‰\")\n            \n            return True\n        else:\n            error = result.get('error', 'æœªçŸ¥é”™è¯¯')\n            print(f\"   âœ— Skillæ‰§è¡Œå¤±è´¥: {error}\")\n            return False\n    \n    except Exception as e:\n        print(f\"   âœ— æ‰§è¡Œå¼‚å¸¸: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n"
},
{
"path": "tests/test_chat_with_init.py",
"start": 93,
"end": 108,
"text": "def main():\n    \"\"\"ä¸»å‡½æ•°\"\"\"\n    success = asyncio.run(test_chat_flow())\n    \n    print(\"\\n\" + \"=\"*60)\n    if success:\n        print(\"âœ“ æµ‹è¯•é€šè¿‡\")\n    else:\n        print(\"âœ— æµ‹è¯•å¤±è´¥\")\n    print(\"=\"*60)\n    \n    return 0 if success else 1\n\n\nif __name__ == '__main__':\n    sys.exit(main())"
},
{
"path": "tests/test_cli_env.py",
"start": 1,
"end": 36,
"text": "\"\"\"æµ‹è¯•CLIç¯å¢ƒä¸‹çš„å·¥å…·æ³¨å†Œ\"\"\"\nimport sys\nfrom pathlib import Path\n\n# æ¨¡æ‹ŸCLIçš„è·¯å¾„è®¾ç½®\nbackend_path = Path(__file__).parent\nsys.path.insert(0, str(backend_path))\n\nprint(\"=\"*60)\nprint(\"æµ‹è¯•CLIç¯å¢ƒä¸‹çš„å·¥å…·æ³¨å†Œ\")\nprint(\"=\"*60)\n\nprint(f\"\\nå½“å‰å·¥ä½œç›®å½•: {Path.cwd()}\")\nprint(f\"backendè·¯å¾„: {backend_path}\")\nprint(f\"sys.path[0]: {sys.path[0]}\")\n\n# å¯¼å…¥å·¥å…·æ³¨å†Œè¡¨\nprint(\"\\nå¯¼å…¥å·¥å…·æ³¨å†Œè¡¨...\")\nfrom daoyoucode.agents.tools import get_tool_registry\n\ntool_registry = get_tool_registry()\ntools = tool_registry.list_tools()\n\nprint(f\"\\nâœ“ å·¥å…·æ•°é‡: {len(tools)}\")\nprint(f\"âœ“ repo_mapå­˜åœ¨: {'repo_map' in tools}\")\n\nif 'repo_map' not in tools:\n    print(\"\\nâŒ repo_mapæœªæ‰¾åˆ°ï¼\")\n    print(f\"å¯ç”¨å·¥å…·: {', '.join(sorted(tools))}\")\nelse:\n    print(\"\\nâœ“ repo_mapå·²æ³¨å†Œ\")\n    tool = tool_registry.get_tool(\"repo_map\")\n    print(f\"  åç§°: {tool.name}\")\n    print(f\"  æè¿°: {tool.description}\")\n\nprint(\"\\n\" + \"=\"*60)"
},
{
"path": "tests/test_cli_help.py",
"start": 1,
"end": 16,
"text": "\"\"\"\næµ‹è¯•CLIå¸®åŠ©ç³»ç»Ÿ\n\néªŒè¯æ‰€æœ‰å¸®åŠ©å‘½ä»¤éƒ½èƒ½æ­£å¸¸å·¥ä½œ\n\"\"\"\n\nimport subprocess\nimport sys\nimport os\n\n# è®¾ç½®è¾“å‡ºç¼–ç \nif sys.platform == 'win32':\n    import io\n    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')\n\n"
},
{
"path": "tests/test_cli_help.py",
"start": 17,
"end": 29,
"text": "def run_command(cmd):\n    \"\"\"è¿è¡Œå‘½ä»¤å¹¶è¿”å›ç»“æœ\"\"\"\n    result = subprocess.run(\n        cmd,\n        shell=True,\n        capture_output=True,\n        text=True,\n        cwd=os.path.dirname(os.path.abspath(__file__)),\n        encoding='utf-8'\n    )\n    return result.returncode, result.stdout, result.stderr\n\n"
},
{
"path": "tests/test_cli_help.py",
"start": 30,
"end": 58,
"text": "def test_help_commands():\n    \"\"\"æµ‹è¯•æ‰€æœ‰--helpå‘½ä»¤\"\"\"\n    commands = [\n        \"python daoyoucode.py --help\",\n        \"python daoyoucode.py chat --help\",\n        \"python daoyoucode.py agent --help\",\n        \"python daoyoucode.py skills --help\",\n        \"python daoyoucode.py examples --help\",\n    ]\n    \n    print(\"=\" * 60)\n    print(\"æµ‹è¯• --help å‘½ä»¤\")\n    print(\"=\" * 60)\n    \n    for cmd in commands:\n        print(f\"\\næµ‹è¯•: {cmd}\")\n        returncode, stdout, stderr = run_command(cmd)\n        \n        if returncode == 0:\n            print(\"âœ“ æˆåŠŸ\")\n            # æ£€æŸ¥æ˜¯å¦åŒ…å«å…³é”®å†…å®¹\n            if \"Usage:\" in stdout and \"Options\" in stdout:\n                print(\"âœ“ è¾“å‡ºæ ¼å¼æ­£ç¡®\")\n            else:\n                print(\"âœ— è¾“å‡ºæ ¼å¼ä¸æ­£ç¡®\")\n        else:\n            print(f\"âœ— å¤±è´¥: {stderr}\")\n\n"
},
{
"path": "tests/test_cli_help.py",
"start": 59,
"end": 89,
"text": "def test_examples_commands():\n    \"\"\"æµ‹è¯•æ‰€æœ‰--exampleså‘½ä»¤\"\"\"\n    commands = [\n        \"python daoyoucode.py examples\",\n        \"python daoyoucode.py examples chat\",\n        \"python daoyoucode.py examples agent\",\n        \"python daoyoucode.py examples skills\",\n        \"python daoyoucode.py chat --examples\",\n        \"python daoyoucode.py agent --examples\",\n        \"python daoyoucode.py skills --examples\",\n    ]\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯• examples å‘½ä»¤\")\n    print(\"=\" * 60)\n    \n    for cmd in commands:\n        print(f\"\\næµ‹è¯•: {cmd}\")\n        returncode, stdout, stderr = run_command(cmd)\n        \n        if returncode == 0:\n            print(\"âœ“ æˆåŠŸ\")\n            # æ£€æŸ¥æ˜¯å¦åŒ…å«ç¤ºä¾‹å†…å®¹\n            if \"ç¤ºä¾‹\" in stdout or \"ç”¨æ³•\" in stdout:\n                print(\"âœ“ è¾“å‡ºåŒ…å«ç¤ºä¾‹\")\n            else:\n                print(\"âœ— è¾“å‡ºä¸åŒ…å«ç¤ºä¾‹\")\n        else:\n            print(f\"âœ— å¤±è´¥: {stderr}\")\n\n"
},
{
"path": "tests/test_cli_help.py",
"start": 90,
"end": 146,
"text": "def test_help_content():\n    \"\"\"æµ‹è¯•å¸®åŠ©å†…å®¹çš„å®Œæ•´æ€§\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•å¸®åŠ©å†…å®¹å®Œæ•´æ€§\")\n    print(\"=\" * 60)\n    \n    # æµ‹è¯•chat --help\n    print(\"\\næµ‹è¯•: chat --help å†…å®¹\")\n    returncode, stdout, stderr = run_command(\"python daoyoucode.py chat --help\")\n    \n    required_content = [\n        \"å¯åŠ¨äº¤äº’å¼å¯¹è¯\",\n        \"--model\",\n        \"--skill\",\n        \"--repo\",\n        \"--examples\",\n    ]\n    \n    for content in required_content:\n        if content in stdout:\n            print(f\"âœ“ åŒ…å«: {content}\")\n        else:\n            print(f\"âœ— ç¼ºå¤±: {content}\")\n    \n    # æµ‹è¯•agent --help\n    print(\"\\næµ‹è¯•: agent --help å†…å®¹\")\n    returncode, stdout, stderr = run_command(\"python daoyoucode.py agent --help\")\n    \n    required_content = [\n        \"Agentç®¡ç†\",\n        \"--tools\",\n        \"--examples\",\n    ]\n    \n    for content in required_content:\n        if content in stdout:\n            print(f\"âœ“ åŒ…å«: {content}\")\n        else:\n            print(f\"âœ— ç¼ºå¤±: {content}\")\n    \n    # æµ‹è¯•skills --help\n    print(\"\\næµ‹è¯•: skills --help å†…å®¹\")\n    returncode, stdout, stderr = run_command(\"python daoyoucode.py skills --help\")\n    \n    required_content = [\n        \"Skillå’Œç¼–æ’å™¨ç®¡ç†\",\n        \"--orchestrators\",\n        \"--examples\",\n    ]\n    \n    for content in required_content:\n        if content in stdout:\n            print(f\"âœ“ åŒ…å«: {content}\")\n        else:\n            print(f\"âœ— ç¼ºå¤±: {content}\")\n\n"
},
{
"path": "tests/test_cli_help.py",
"start": 147,
"end": 209,
"text": "def test_examples_content():\n    \"\"\"æµ‹è¯•ç¤ºä¾‹å†…å®¹çš„å®Œæ•´æ€§\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•ç¤ºä¾‹å†…å®¹å®Œæ•´æ€§\")\n    print(\"=\" * 60)\n    \n    # æµ‹è¯•chat --examples\n    print(\"\\næµ‹è¯•: chat --examples å†…å®¹\")\n    returncode, stdout, stderr = run_command(\"python daoyoucode.py chat --examples\")\n    \n    required_content = [\n        \"åŸºæœ¬ç”¨æ³•\",\n        \"æŒ‡å®šSkill\",\n        \"æŒ‡å®šæ¨¡å‹\",\n        \"åŠ è½½æ–‡ä»¶\",\n        \"äº¤äº’å¼å‘½ä»¤\",\n        \"æ¨èSkill\",\n    ]\n    \n    for content in required_content:\n        if content in stdout:\n            print(f\"âœ“ åŒ…å«: {content}\")\n        else:\n            print(f\"âœ— ç¼ºå¤±: {content}\")\n    \n    # æµ‹è¯•agent --examples\n    print(\"\\næµ‹è¯•: agent --examples å†…å®¹\")\n    returncode, stdout, stderr = run_command(\"python daoyoucode.py agent --examples\")\n    \n    required_content = [\n        \"åŸºæœ¬ç”¨æ³•\",\n        \"æŸ¥çœ‹Agentè¯¦æƒ…\",\n        \"æŸ¥çœ‹Agentå·¥å…·\",\n        \"å¯ç”¨Agent\",\n        \"Agentä¸Skillçš„å…³ç³»\",\n    ]\n    \n    for content in required_content:\n        if content in stdout:\n            print(f\"âœ“ åŒ…å«: {content}\")\n        else:\n            print(f\"âœ— ç¼ºå¤±: {content}\")\n    \n    # æµ‹è¯•skills --examples\n    print(\"\\næµ‹è¯•: skills --examples å†…å®¹\")\n    returncode, stdout, stderr = run_command(\"python daoyoucode.py skills --examples\")\n    \n    required_content = [\n        \"åŸºæœ¬ç”¨æ³•\",\n        \"æŸ¥çœ‹Skillè¯¦æƒ…\",\n        \"æŸ¥çœ‹ç¼–æ’å™¨\",\n        \"æ¨èSkill\",\n        \"ç¼–æ’å™¨ç±»å‹\",\n        \"Multi-Agentåä½œæ¨¡å¼\",\n    ]\n    \n    for content in required_content:\n        if content in stdout:\n            print(f\"âœ“ åŒ…å«: {content}\")\n        else:\n            print(f\"âœ— ç¼ºå¤±: {content}\")\n\n"
},
{
"path": "tests/test_cli_help.py",
"start": 210,
"end": 227,
"text": "def main():\n    \"\"\"ä¸»æµ‹è¯•å‡½æ•°\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"CLIå¸®åŠ©ç³»ç»Ÿæµ‹è¯•\")\n    print(\"=\" * 60)\n    \n    test_help_commands()\n    test_examples_commands()\n    test_help_content()\n    test_examples_content()\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•å®Œæˆ\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()"
},
{
"path": "tests/test_cli_skills.py",
"start": 1,
"end": 28,
"text": "\"\"\"\næµ‹è¯•CLI skillså’Œagentå‘½ä»¤çš„è¾“å‡º\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nbackend_dir = Path(__file__).parent\nsys.path.insert(0, str(backend_dir))\n\nfrom cli.commands.skills import list_all_skills, show_orchestrators\nfrom cli.commands.agent import list_all_agents\n\nprint(\"=\" * 80)\nprint(\"æµ‹è¯•1: åˆ—å‡ºæ‰€æœ‰Agent\")\nprint(\"=\" * 80)\nlist_all_agents()\n\nprint(\"\\n\" + \"=\" * 80)\nprint(\"æµ‹è¯•2: åˆ—å‡ºæ‰€æœ‰Skill\")\nprint(\"=\" * 80)\nlist_all_skills()\n\nprint(\"\\n\" + \"=\" * 80)\nprint(\"æµ‹è¯•3: æ˜¾ç¤ºç¼–æ’å™¨\")\nprint(\"=\" * 80)\nshow_orchestrators()"
},
{
"path": "tests/test_context_enhancements.py",
"start": 1,
"end": 19,
"text": "\"\"\"\næµ‹è¯•ä¸Šä¸‹æ–‡ç®¡ç†å¢å¼ºåŠŸèƒ½\n\næµ‹è¯•ï¼š\n1. RepoMapé›†æˆ\n2. Tokené¢„ç®—æ§åˆ¶\n3. æ™ºèƒ½æ‘˜è¦\n4. è‡ªåŠ¨ä¼˜åŒ–\n\"\"\"\n\nimport pytest\nimport asyncio\nfrom pathlib import Path\nimport tempfile\nimport shutil\n\nfrom daoyoucode.agents.core.context import ContextManager, get_context_manager\n\n"
},
{
"path": "tests/test_context_enhancements.py",
"start": 20,
"end": 23,
"text": "class TestRepoMapIntegration:\n    \"\"\"æµ‹è¯•RepoMapé›†æˆ\"\"\"\n    \n    @pytest.fixture"
},
{
"path": "tests/test_context_enhancements.py",
"start": 24,
"end": 31,
"text": "    def temp_repo(self):\n        \"\"\"åˆ›å»ºä¸´æ—¶ä»“åº“\"\"\"\n        temp_dir = tempfile.mkdtemp()\n        repo_path = Path(temp_dir) / \"test_repo\"\n        repo_path.mkdir()\n        \n        # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n        (repo_path / \"main.py\").write_text(\"\"\""
},
{
"path": "tests/test_context_enhancements.py",
"start": 32,
"end": 34,
"text": "def hello():\n    print(\"Hello\")\n"
},
{
"path": "tests/test_context_enhancements.py",
"start": 35,
"end": 35,
"text": "class MyClass:"
},
{
"path": "tests/test_context_enhancements.py",
"start": 36,
"end": 40,
"text": "    def method(self):\n        pass\n\"\"\")\n        \n        (repo_path / \"utils.py\").write_text(\"\"\""
},
{
"path": "tests/test_context_enhancements.py",
"start": 41,
"end": 43,
"text": "def helper():\n    return 42\n"
},
{
"path": "tests/test_context_enhancements.py",
"start": 44,
"end": 107,
"text": "class Helper:\n    pass\n\"\"\")\n        \n        yield repo_path\n        \n        # æ¸…ç†\n        shutil.rmtree(temp_dir)\n    \n    @pytest.mark.asyncio\n    async def test_add_repo_map(self, temp_repo):\n        \"\"\"æµ‹è¯•æ·»åŠ RepoMap\"\"\"\n        manager = ContextManager()\n        context = manager.create_context(\"test_session\")\n        \n        # æ·»åŠ RepoMap\n        success = await manager.add_repo_map(\n            session_id=\"test_session\",\n            repo_path=str(temp_repo),\n            max_tokens=5000  # å¢åŠ tokené™åˆ¶\n        )\n        \n        assert success\n        assert context.has('repo_map')\n        assert context.has('repo_map_metadata')\n        \n        repo_map = context.get('repo_map')\n        print(f\"RepoMap content: {repo_map}\")  # è°ƒè¯•è¾“å‡º\n        \n        # RepoMapå¯èƒ½ä¸ºç©ºï¼ˆå¦‚æœæ²¡æœ‰å¼•ç”¨å…³ç³»ï¼‰\n        # åªè¦æˆåŠŸç”Ÿæˆå°±ç®—é€šè¿‡\n        assert repo_map is not None\n    \n    @pytest.mark.asyncio\n    async def test_add_repo_map_with_chat_files(self, temp_repo):\n        \"\"\"æµ‹è¯•å¸¦å¯¹è¯æ–‡ä»¶çš„RepoMap\"\"\"\n        manager = ContextManager()\n        context = manager.create_context(\"test_session\")\n        \n        # æ·»åŠ RepoMapï¼ˆæŒ‡å®šå¯¹è¯æ–‡ä»¶ï¼‰\n        success = await manager.add_repo_map(\n            session_id=\"test_session\",\n            repo_path=str(temp_repo),\n            chat_files=[\"main.py\"],\n            mentioned_idents=[\"hello\", \"MyClass\"],\n            max_tokens=1000\n        )\n        \n        assert success\n        assert context.has('repo_map')\n    \n    @pytest.mark.asyncio\n    async def test_add_repo_map_nonexistent_session(self, temp_repo):\n        \"\"\"æµ‹è¯•ä¸å­˜åœ¨çš„ä¼šè¯\"\"\"\n        manager = ContextManager()\n        \n        success = await manager.add_repo_map(\n            session_id=\"nonexistent\",\n            repo_path=str(temp_repo)\n        )\n        \n        assert not success\n\n"
},
{
"path": "tests/test_context_enhancements.py",
"start": 108,
"end": 110,
"text": "class TestTokenBudgetControl:\n    \"\"\"æµ‹è¯•Tokené¢„ç®—æ§åˆ¶\"\"\"\n    "
},
{
"path": "tests/test_context_enhancements.py",
"start": 111,
"end": 126,
"text": "    def test_enforce_token_budget_no_pruning(self):\n        \"\"\"æµ‹è¯•Tokenå……è¶³æ—¶ä¸å‰ªæ\"\"\"\n        manager = ContextManager(default_token_budget=10000)\n        context = manager.create_context(\"test_session\")\n        \n        # æ·»åŠ å°‘é‡æ•°æ®\n        context.set('key1', 'value1')\n        context.set('key2', 'value2')\n        \n        # æ‰§è¡Œé¢„ç®—æ§åˆ¶\n        stats = manager.enforce_token_budget(\"test_session\")\n        \n        assert stats['success']\n        assert not stats['pruned']\n        assert stats['original_tokens'] == stats['final_tokens']\n    "
},
{
"path": "tests/test_context_enhancements.py",
"start": 127,
"end": 145,
"text": "    def test_enforce_token_budget_with_pruning(self):\n        \"\"\"æµ‹è¯•Tokenè¶…å‡ºæ—¶å‰ªæ\"\"\"\n        manager = ContextManager(default_token_budget=100)\n        context = manager.create_context(\"test_session\")\n        \n        # æ·»åŠ å¤§é‡æ•°æ®\n        context.set('key1', 'x' * 1000)\n        context.set('key2', 'y' * 1000)\n        context.set('key3', 'z' * 1000)\n        \n        # æ‰§è¡Œé¢„ç®—æ§åˆ¶\n        stats = manager.enforce_token_budget(\"test_session\")\n        \n        assert stats['success']\n        assert stats['pruned']\n        assert stats['final_tokens'] < stats['original_tokens']\n        assert stats['final_tokens'] <= stats['budget']\n        assert len(stats['removed_keys']) > 0\n    "
},
{
"path": "tests/test_context_enhancements.py",
"start": 146,
"end": 170,
"text": "    def test_enforce_token_budget_with_priority(self):\n        \"\"\"æµ‹è¯•ä¼˜å…ˆçº§ä¿æŠ¤\"\"\"\n        manager = ContextManager(default_token_budget=100)\n        context = manager.create_context(\"test_session\")\n        \n        # æ·»åŠ æ•°æ®\n        context.set('important', 'x' * 500)\n        context.set('optional1', 'y' * 500)\n        context.set('optional2', 'z' * 500)\n        \n        # æ‰§è¡Œé¢„ç®—æ§åˆ¶ï¼ˆä¿æŠ¤importantï¼‰\n        stats = manager.enforce_token_budget(\n            \"test_session\",\n            priority_keys=['important']\n        )\n        \n        assert stats['success']\n        assert stats['pruned']\n        \n        # importantåº”è¯¥ä¿ç•™\n        assert context.has('important')\n        \n        # è‡³å°‘æœ‰ä¸€ä¸ªoptionalè¢«ç§»é™¤\n        assert not context.has('optional1') or not context.has('optional2')\n    "
},
{
"path": "tests/test_context_enhancements.py",
"start": 171,
"end": 190,
"text": "    def test_enforce_token_budget_custom_budget(self):\n        \"\"\"æµ‹è¯•è‡ªå®šä¹‰é¢„ç®—\"\"\"\n        manager = ContextManager(default_token_budget=10000)\n        context = manager.create_context(\"test_session\")\n        \n        # æ·»åŠ æ•°æ®\n        context.set('key1', 'x' * 1000)\n        context.set('key2', 'y' * 1000)\n        \n        # ä½¿ç”¨å°é¢„ç®—\n        stats = manager.enforce_token_budget(\n            \"test_session\",\n            token_budget=50\n        )\n        \n        assert stats['success']\n        assert stats['pruned']\n        assert stats['budget'] == 50\n        assert stats['final_tokens'] <= 50\n    "
},
{
"path": "tests/test_context_enhancements.py",
"start": 191,
"end": 211,
"text": "    def test_enforce_token_budget_with_snapshot(self):\n        \"\"\"æµ‹è¯•å‰ªææ—¶åˆ›å»ºå¿«ç…§\"\"\"\n        manager = ContextManager(default_token_budget=100)\n        context = manager.create_context(\"test_session\")\n        \n        # æ·»åŠ æ•°æ®\n        context.set('key1', 'x' * 1000)\n        context.set('key2', 'y' * 1000)\n        \n        # æ‰§è¡Œé¢„ç®—æ§åˆ¶\n        stats = manager.enforce_token_budget(\"test_session\")\n        \n        assert stats['success']\n        assert stats['pruned']\n        assert 'snapshot_id' in stats\n        \n        # éªŒè¯å¿«ç…§å­˜åœ¨\n        snapshot = context.get_snapshot(stats['snapshot_id'])\n        assert snapshot is not None\n\n"
},
{
"path": "tests/test_context_enhancements.py",
"start": 212,
"end": 255,
"text": "class TestIntelligentSummary:\n    \"\"\"æµ‹è¯•æ™ºèƒ½æ‘˜è¦\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_summarize_content(self):\n        \"\"\"æµ‹è¯•å†…å®¹æ‘˜è¦\"\"\"\n        manager = ContextManager()\n        context = manager.create_context(\"test_session\")\n        \n        # æ·»åŠ é•¿å†…å®¹\n        long_content = \"\"\"\n        This is a very long content that needs to be summarized.\n        It contains multiple paragraphs and lots of information.\n        Some information is important, some is redundant.\n        We want to keep the important parts and remove the redundant parts.\n        \"\"\" * 10\n        \n        context.set('long_text', long_content)\n        \n        # æ‘˜è¦ï¼ˆä½¿ç”¨mocké¿å…çœŸå®LLMè°ƒç”¨ï¼‰\n        # è¿™é‡Œéœ€è¦mock LLMClient\n        # success = await manager.summarize_content(\n        #     \"test_session\",\n        #     \"long_text\",\n        #     target_ratio=0.33\n        # )\n        \n        # æš‚æ—¶è·³è¿‡ï¼ˆéœ€è¦LLMï¼‰\n        pytest.skip(\"éœ€è¦LLMé›†æˆ\")\n    \n    @pytest.mark.asyncio\n    async def test_summarize_nonexistent_key(self):\n        \"\"\"æµ‹è¯•æ‘˜è¦ä¸å­˜åœ¨çš„key\"\"\"\n        manager = ContextManager()\n        context = manager.create_context(\"test_session\")\n        \n        success = await manager.summarize_content(\n            \"test_session\",\n            \"nonexistent_key\"\n        )\n        \n        assert not success\n\n"
},
{
"path": "tests/test_context_enhancements.py",
"start": 256,
"end": 280,
"text": "class TestAutoOptimization:\n    \"\"\"æµ‹è¯•è‡ªåŠ¨ä¼˜åŒ–\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_auto_optimize_context(self):\n        \"\"\"æµ‹è¯•è‡ªåŠ¨ä¼˜åŒ–\"\"\"\n        manager = ContextManager(default_token_budget=100)\n        context = manager.create_context(\"test_session\")\n        \n        # æ·»åŠ æ•°æ®\n        context.set('key1', 'x' * 1000)\n        context.set('key2', 'y' * 1000)\n        context.set('key3', 'z' * 1000)\n        \n        # è‡ªåŠ¨ä¼˜åŒ–ï¼ˆä¸ä½¿ç”¨æ‘˜è¦ï¼‰\n        stats = await manager.auto_optimize_context(\n            \"test_session\",\n            token_budget=100\n        )\n        \n        assert stats['success']\n        assert stats['pruning_stats']['pruned']\n        assert stats['pruning_stats']['final_tokens'] <= 100\n\n"
},
{
"path": "tests/test_context_enhancements.py",
"start": 281,
"end": 283,
"text": "class TestPriorityCalculation:\n    \"\"\"æµ‹è¯•ä¼˜å…ˆçº§è®¡ç®—\"\"\"\n    "
},
{
"path": "tests/test_context_enhancements.py",
"start": 284,
"end": 312,
"text": "    def test_sort_by_priority(self):\n        \"\"\"æµ‹è¯•ä¼˜å…ˆçº§æ’åº\"\"\"\n        manager = ContextManager()\n        \n        variables = {\n            'normal_key': 'value1',\n            '_internal_key': 'value2',\n            'repo_map': 'value3',\n            'priority_key': 'value4'\n        }\n        \n        sorted_vars = manager._sort_by_priority(\n            variables,\n            priority_keys=['priority_key']\n        )\n        \n        # æ£€æŸ¥æ’åº\n        keys = [key for key, _, _ in sorted_vars]\n        \n        # priority_keyåº”è¯¥åœ¨æœ€å‰é¢\n        assert keys[0] == 'priority_key'\n        \n        # repo_mapåº”è¯¥åœ¨ä¸­é—´\n        assert 'repo_map' in keys[:2]\n        \n        # _internal_keyåº”è¯¥åœ¨æœ€å\n        assert keys[-1] == '_internal_key'\n\n"
},
{
"path": "tests/test_context_enhancements.py",
"start": 313,
"end": 315,
"text": "class TestBinarySearch:\n    \"\"\"æµ‹è¯•äºŒåˆ†æŸ¥æ‰¾\"\"\"\n    "
},
{
"path": "tests/test_context_enhancements.py",
"start": 316,
"end": 340,
"text": "    def test_binary_search_optimal_vars(self):\n        \"\"\"æµ‹è¯•äºŒåˆ†æŸ¥æ‰¾æœ€ä¼˜å˜é‡æ•°é‡\"\"\"\n        manager = ContextManager()\n        \n        sorted_vars = [\n            ('key1', 'x' * 100, 100),\n            ('key2', 'y' * 100, 50),\n            ('key3', 'z' * 100, 50),\n            ('key4', 'w' * 100, 10)\n        ]\n        \n        result = manager._binary_search_optimal_vars(\n            sorted_vars,\n            token_budget=100,\n            priority_keys=[]\n        )\n        \n        # åº”è¯¥åªåŒ…å«éƒ¨åˆ†å˜é‡\n        assert len(result) < len(sorted_vars)\n        \n        # Tokenåº”è¯¥åœ¨é¢„ç®—å†…\n        tokens = manager._estimate_tokens(result)\n        assert tokens <= 100\n\n"
},
{
"path": "tests/test_context_enhancements.py",
"start": 341,
"end": 343,
"text": "class TestTokenEstimation:\n    \"\"\"æµ‹è¯•Tokenä¼°ç®—\"\"\"\n    "
},
{
"path": "tests/test_context_enhancements.py",
"start": 344,
"end": 360,
"text": "    def test_estimate_tokens(self):\n        \"\"\"æµ‹è¯•Tokenä¼°ç®—\"\"\"\n        manager = ContextManager()\n        \n        # ç®€å•æµ‹è¯•\n        data = {'key': 'value'}\n        tokens = manager._estimate_tokens(data)\n        assert tokens > 0\n        \n        # å¤§æ•°æ®\n        large_data = {'key': 'x' * 1000}\n        large_tokens = manager._estimate_tokens(large_data)\n        assert large_tokens > tokens\n\n\nif __name__ == '__main__':\n    pytest.main([__file__, '-v'])"
},
{
"path": "tests/test_context_manager.py",
"start": 1,
"end": 8,
"text": "\"\"\"\næµ‹è¯•ContextManager\n\"\"\"\n\nimport asyncio\nfrom daoyoucode.agents.core.context import get_context_manager\n\n"
},
{
"path": "tests/test_context_manager.py",
"start": 9,
"end": 46,
"text": "def test_context_basic():\n    \"\"\"æµ‹è¯•åŸºæœ¬ä¸Šä¸‹æ–‡æ“ä½œ\"\"\"\n    print(\"\\n=== æµ‹è¯•1: åŸºæœ¬ä¸Šä¸‹æ–‡æ“ä½œ ===\")\n    \n    manager = get_context_manager()\n    \n    # åˆ›å»ºä¸Šä¸‹æ–‡\n    ctx = manager.create_context('session1')\n    \n    # è®¾ç½®å˜é‡\n    ctx.set('user_name', 'Alice')\n    ctx.set('user_age', 25)\n    ctx.set('user_role', 'developer')\n    \n    print(f\"âœ“ è®¾ç½®äº†3ä¸ªå˜é‡\")\n    \n    # è·å–å˜é‡\n    assert ctx.get('user_name') == 'Alice'\n    assert ctx.get('user_age') == 25\n    assert ctx.get('user_role') == 'developer'\n    print(f\"âœ“ å˜é‡è·å–æ­£ç¡®\")\n    \n    # æ£€æŸ¥å­˜åœ¨\n    assert ctx.has('user_name')\n    assert not ctx.has('non_existent')\n    print(f\"âœ“ å­˜åœ¨æ€§æ£€æŸ¥æ­£ç¡®\")\n    \n    # æ›´æ–°å˜é‡\n    ctx.set('user_age', 26)\n    assert ctx.get('user_age') == 26\n    print(f\"âœ“ å˜é‡æ›´æ–°æˆåŠŸ\")\n    \n    # åˆ é™¤å˜é‡\n    ctx.delete('user_role')\n    assert not ctx.has('user_role')\n    print(f\"âœ“ å˜é‡åˆ é™¤æˆåŠŸ\")\n\n"
},
{
"path": "tests/test_context_manager.py",
"start": 47,
"end": 92,
"text": "def test_context_snapshot():\n    \"\"\"æµ‹è¯•å¿«ç…§å’Œå›æ»š\"\"\"\n    print(\"\\n=== æµ‹è¯•2: å¿«ç…§å’Œå›æ»š ===\")\n    \n    manager = get_context_manager()\n    ctx = manager.create_context('session2')\n    \n    # åˆå§‹çŠ¶æ€\n    ctx.set('counter', 0)\n    ctx.set('status', 'init')\n    \n    # åˆ›å»ºå¿«ç…§1\n    snapshot1 = ctx.create_snapshot('åˆå§‹çŠ¶æ€')\n    print(f\"âœ“ åˆ›å»ºå¿«ç…§1: {snapshot1[:8]}...\")\n    \n    # ä¿®æ”¹çŠ¶æ€\n    ctx.set('counter', 10)\n    ctx.set('status', 'running')\n    ctx.set('new_field', 'value')\n    \n    assert ctx.get('counter') == 10\n    assert ctx.get('status') == 'running'\n    print(f\"âœ“ ä¿®æ”¹äº†çŠ¶æ€\")\n    \n    # åˆ›å»ºå¿«ç…§2\n    snapshot2 = ctx.create_snapshot('è¿è¡ŒçŠ¶æ€')\n    print(f\"âœ“ åˆ›å»ºå¿«ç…§2: {snapshot2[:8]}...\")\n    \n    # ç»§ç»­ä¿®æ”¹\n    ctx.set('counter', 20)\n    ctx.set('status', 'completed')\n    \n    # å›æ»šåˆ°å¿«ç…§1\n    success = ctx.rollback_to_snapshot(snapshot1)\n    assert success\n    assert ctx.get('counter') == 0\n    assert ctx.get('status') == 'init'\n    assert not ctx.has('new_field')\n    print(f\"âœ“ å›æ»šåˆ°å¿«ç…§1æˆåŠŸ\")\n    \n    # åˆ—å‡ºå¿«ç…§\n    snapshots = ctx.list_snapshots()\n    print(f\"âœ“ å…±æœ‰ {len(snapshots)} ä¸ªå¿«ç…§\")\n    assert len(snapshots) == 2\n\n"
},
{
"path": "tests/test_context_manager.py",
"start": 93,
"end": 124,
"text": "def test_context_history():\n    \"\"\"æµ‹è¯•å˜æ›´å†å²\"\"\"\n    print(\"\\n=== æµ‹è¯•3: å˜æ›´å†å² ===\")\n    \n    manager = get_context_manager()\n    ctx = manager.create_context('session3')\n    \n    # æ‰§è¡Œä¸€ç³»åˆ—æ“ä½œ\n    ctx.set('x', 1)\n    ctx.set('y', 2)\n    ctx.set('x', 10)  # æ›´æ–°\n    ctx.delete('y')   # åˆ é™¤\n    ctx.set('z', 3)\n    \n    # è·å–å†å²\n    history = ctx.get_history()\n    print(f\"âœ“ å…±æœ‰ {len(history)} æ¡å˜æ›´è®°å½•\")\n    assert len(history) == 5\n    \n    # æ£€æŸ¥æ“ä½œç±»å‹\n    operations = [h['operation'] for h in history]\n    assert 'set' in operations\n    assert 'update' in operations\n    assert 'delete' in operations\n    print(f\"âœ“ æ“ä½œç±»å‹: {set(operations)}\")\n    \n    # è·å–ç‰¹å®šå˜é‡çš„å†å²\n    x_history = ctx.get_changes_for_key('x')\n    print(f\"âœ“ å˜é‡xçš„å˜æ›´: {len(x_history)} æ¬¡\")\n    assert len(x_history) == 2  # set + update\n\n"
},
{
"path": "tests/test_context_manager.py",
"start": 125,
"end": 161,
"text": "def test_nested_context():\n    \"\"\"æµ‹è¯•åµŒå¥—ä¸Šä¸‹æ–‡\"\"\"\n    print(\"\\n=== æµ‹è¯•4: åµŒå¥—ä¸Šä¸‹æ–‡ ===\")\n    \n    manager = get_context_manager()\n    \n    # åˆ›å»ºçˆ¶ä¸Šä¸‹æ–‡\n    parent = manager.create_context('parent')\n    parent.set('global_var', 'global_value')\n    parent.set('parent_var', 'parent_value')\n    \n    # åˆ›å»ºå­ä¸Šä¸‹æ–‡\n    child = parent.create_child()\n    child.set('child_var', 'child_value')\n    child.set('parent_var', 'overridden')  # è¦†ç›–çˆ¶å˜é‡\n    \n    # å­ä¸Šä¸‹æ–‡å¯ä»¥è®¿é—®çˆ¶å˜é‡\n    assert child.get('global_var') == 'global_value'\n    print(f\"âœ“ å­ä¸Šä¸‹æ–‡å¯ä»¥è®¿é—®çˆ¶å˜é‡\")\n    \n    # å­ä¸Šä¸‹æ–‡è¦†ç›–çˆ¶å˜é‡\n    assert child.get('parent_var') == 'overridden'\n    assert parent.get('parent_var') == 'parent_value'\n    print(f\"âœ“ å­ä¸Šä¸‹æ–‡å¯ä»¥è¦†ç›–çˆ¶å˜é‡\")\n    \n    # å­ä¸Šä¸‹æ–‡çš„å˜é‡ä¸å½±å“çˆ¶ä¸Šä¸‹æ–‡\n    assert not parent.has('child_var')\n    print(f\"âœ“ å­å˜é‡ä¸å½±å“çˆ¶ä¸Šä¸‹æ–‡\")\n    \n    # keysåŒ…å«çˆ¶ä¸Šä¸‹æ–‡çš„key\n    child_keys = child.keys()\n    assert 'global_var' in child_keys\n    assert 'parent_var' in child_keys\n    assert 'child_var' in child_keys\n    print(f\"âœ“ å­ä¸Šä¸‹æ–‡keysåŒ…å«çˆ¶å˜é‡\")\n\n"
},
{
"path": "tests/test_context_manager.py",
"start": 162,
"end": 191,
"text": "def test_batch_operations():\n    \"\"\"æµ‹è¯•æ‰¹é‡æ“ä½œ\"\"\"\n    print(\"\\n=== æµ‹è¯•5: æ‰¹é‡æ“ä½œ ===\")\n    \n    manager = get_context_manager()\n    ctx = manager.create_context('session5')\n    \n    # æ‰¹é‡æ›´æ–°\n    ctx.update({\n        'var1': 'value1',\n        'var2': 'value2',\n        'var3': 'value3'\n    })\n    \n    assert ctx.get('var1') == 'value1'\n    assert ctx.get('var2') == 'value2'\n    assert ctx.get('var3') == 'value3'\n    print(f\"âœ“ æ‰¹é‡æ›´æ–°æˆåŠŸ\")\n    \n    # è½¬æ¢ä¸ºå­—å…¸\n    ctx_dict = ctx.to_dict()\n    assert len(ctx_dict) == 3\n    print(f\"âœ“ è½¬æ¢ä¸ºå­—å…¸: {len(ctx_dict)} ä¸ªå˜é‡\")\n    \n    # æ¸…ç©º\n    ctx.clear()\n    assert len(ctx.keys()) == 0\n    print(f\"âœ“ æ¸…ç©ºæˆåŠŸ\")\n\n"
},
{
"path": "tests/test_context_manager.py",
"start": 192,
"end": 232,
"text": "def test_context_manager():\n    \"\"\"æµ‹è¯•ä¸Šä¸‹æ–‡ç®¡ç†å™¨\"\"\"\n    print(\"\\n=== æµ‹è¯•6: ä¸Šä¸‹æ–‡ç®¡ç†å™¨ ===\")\n    \n    manager = get_context_manager()\n    \n    # åˆ›å»ºå¤šä¸ªä¸Šä¸‹æ–‡\n    ctx1 = manager.create_context('session_a')\n    ctx2 = manager.create_context('session_b')\n    ctx3 = manager.create_context('session_c')\n    \n    ctx1.set('name', 'Alice')\n    ctx2.set('name', 'Bob')\n    ctx3.set('name', 'Charlie')\n    \n    # è·å–ä¸Šä¸‹æ–‡\n    retrieved = manager.get_context('session_b')\n    assert retrieved.get('name') == 'Bob'\n    print(f\"âœ“ è·å–ä¸Šä¸‹æ–‡æˆåŠŸ\")\n    \n    # åˆ—å‡ºæ‰€æœ‰ä¸Šä¸‹æ–‡\n    contexts = manager.list_contexts()\n    print(f\"âœ“ å…±æœ‰ {len(contexts)} ä¸ªä¸Šä¸‹æ–‡\")\n    \n    # è·å–æˆ–åˆ›å»º\n    ctx4 = manager.get_or_create_context('session_d')\n    assert ctx4 is not None\n    print(f\"âœ“ è·å–æˆ–åˆ›å»ºæˆåŠŸ\")\n    \n    # åˆ é™¤ä¸Šä¸‹æ–‡\n    manager.delete_context('session_a')\n    assert manager.get_context('session_a') is None\n    print(f\"âœ“ åˆ é™¤ä¸Šä¸‹æ–‡æˆåŠŸ\")\n    \n    # ç»Ÿè®¡ä¿¡æ¯\n    stats = manager.get_stats()\n    print(f\"âœ“ ç»Ÿè®¡ä¿¡æ¯:\")\n    print(f\"  æ€»ä¸Šä¸‹æ–‡æ•°: {stats['total_contexts']}\")\n    print(f\"  æ€»å˜é‡æ•°: {stats['total_variables']}\")\n\n"
},
{
"path": "tests/test_context_manager.py",
"start": 233,
"end": 249,
"text": "def test_snapshot_limit():\n    \"\"\"æµ‹è¯•å¿«ç…§æ•°é‡é™åˆ¶\"\"\"\n    print(\"\\n=== æµ‹è¯•7: å¿«ç…§æ•°é‡é™åˆ¶ ===\")\n    \n    manager = get_context_manager()\n    ctx = manager.create_context('session7')\n    \n    # åˆ›å»ºè¶…è¿‡é™åˆ¶çš„å¿«ç…§\n    for i in range(15):\n        ctx.set('counter', i)\n        ctx.create_snapshot(f'å¿«ç…§{i}')\n    \n    snapshots = ctx.list_snapshots()\n    print(f\"âœ“ å¿«ç…§æ•°é‡: {len(snapshots)} (é™åˆ¶: {ctx.max_snapshots})\")\n    assert len(snapshots) == ctx.max_snapshots\n\n"
},
{
"path": "tests/test_context_manager.py",
"start": 250,
"end": 270,
"text": "def test_singleton():\n    \"\"\"æµ‹è¯•å•ä¾‹æ¨¡å¼\"\"\"\n    print(\"\\n=== æµ‹è¯•8: å•ä¾‹æ¨¡å¼ ===\")\n    \n    manager1 = get_context_manager()\n    manager2 = get_context_manager()\n    \n    print(f\"âœ“ manager1 is manager2: {manager1 is manager2}\")\n    assert manager1 is manager2\n    \n    # åœ¨manager1åˆ›å»ºä¸Šä¸‹æ–‡\n    ctx = manager1.create_context('singleton_test')\n    ctx.set('test', 'value')\n    \n    # åœ¨manager2åº”è¯¥èƒ½çœ‹åˆ°\n    ctx2 = manager2.get_context('singleton_test')\n    assert ctx2 is not None\n    assert ctx2.get('test') == 'value'\n    print(f\"âœ“ å•ä¾‹æ¨¡å¼å·¥ä½œæ­£å¸¸\")\n\n"
},
{
"path": "tests/test_context_manager.py",
"start": 271,
"end": 302,
"text": "def main():\n    \"\"\"è¿è¡Œæ‰€æœ‰æµ‹è¯•\"\"\"\n    print(\"=\" * 60)\n    print(\"ContextManager æµ‹è¯•\")\n    print(\"=\" * 60)\n    \n    try:\n        test_context_basic()\n        test_context_snapshot()\n        test_context_history()\n        test_nested_context()\n        test_batch_operations()\n        test_context_manager()\n        test_snapshot_limit()\n        test_singleton()\n        \n        print(\"\\n\" + \"=\" * 60)\n        print(\"âœ“ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼\")\n        print(\"=\" * 60)\n    \n    except AssertionError as e:\n        print(f\"\\nâœ— æµ‹è¯•å¤±è´¥: {e}\")\n        raise\n    except Exception as e:\n        print(f\"\\nâœ— æµ‹è¯•é”™è¯¯: {e}\")\n        import traceback\n        traceback.print_exc()\n        raise\n\n\nif __name__ == \"__main__\":\n    main()"
},
{
"path": "tests/test_conversation_tree.py",
"start": 1,
"end": 360,
"text": "\"\"\"\næµ‹è¯•å¯¹è¯æ ‘åŠŸèƒ½\n\"\"\"\n\nimport asyncio\nimport sys\nfrom pathlib import Path\n\n# è®¾ç½®UTF-8ç¼–ç \nimport io\nsys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents.memory import get_conversation_tree\n\n\nasync def test_basic_tree():\n    \"\"\"æµ‹è¯•åŸºç¡€æ ‘ç»“æ„\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•1: åŸºç¡€æ ‘ç»“æ„\")\n    print(\"=\"*60)\n    \n    # é‡æ–°åˆ›å»ºæ ‘å®ä¾‹ï¼ˆé¿å…å•ä¾‹å½±å“ï¼‰\n    from daoyoucode.agents.memory.conversation_tree import ConversationTree\n    tree = ConversationTree(enabled=True)\n    \n    # æ·»åŠ ç¬¬ä¸€ä¸ªå¯¹è¯\n    node1 = tree.add_conversation(\n        user_message=\"æˆ‘çš„çŒ«ä¸åƒé¥­\",\n        ai_response=\"å¯èƒ½æ˜¯è‚ èƒƒé—®é¢˜ï¼Œå»ºè®®è§‚å¯Ÿ...\"\n    )\n    print(f\"âœ… æ·»åŠ å¯¹è¯1: branch={node1.branch_id}, depth={node1.depth}\")\n    print(f\"   è¯é¢˜å…³é”®è¯: {tree._topic_keywords.get(node1.branch_id, set())}\")\n    \n    # æ·»åŠ ç¬¬äºŒä¸ªå¯¹è¯ï¼ˆåŒä¸€è¯é¢˜ - åŒ…å«\"çŒ«\"å…³é”®è¯ï¼‰\n    node2 = tree.add_conversation(\n        user_message=\"çŒ«ä¸åƒé¥­éœ€è¦å»åŒ»é™¢å—ï¼Ÿ\",\n        ai_response=\"å¦‚æœæŒç»­2å¤©ä»¥ä¸Šï¼Œå»ºè®®å°±åŒ»...\"\n    )\n    print(f\"âœ… æ·»åŠ å¯¹è¯2: branch={node2.branch_id}, depth={node2.depth}\")\n    print(f\"   è¯é¢˜å…³é”®è¯: {tree._topic_keywords.get(node2.branch_id, set())}\")\n    \n    # æ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€åˆ†æ”¯\n    assert node1.branch_id == node2.branch_id, f\"åº”è¯¥åœ¨åŒä¸€åˆ†æ”¯: {node1.branch_id} vs {node2.branch_id}\"\n    print(f\"âœ“ å¯¹è¯1å’Œ2åœ¨åŒä¸€åˆ†æ”¯: {node1.branch_id}\")\n    \n    # æ·»åŠ ç¬¬ä¸‰ä¸ªå¯¹è¯ï¼ˆè¯é¢˜åˆ‡æ¢ï¼‰\n    node3 = tree.add_conversation(\n        user_message=\"é‚£ç‹—å‘¢ï¼Ÿç‹—çš„çš®è‚¤æœ‰çº¢ç‚¹\",\n        ai_response=\"ç‹—çš„çš®è‚¤é—®é¢˜å¯èƒ½æ˜¯è¿‡æ•...\"\n    )\n    print(f\"âœ… æ·»åŠ å¯¹è¯3: branch={node3.branch_id}, depth={node3.depth}\")\n    \n    # æ£€æŸ¥æ˜¯å¦åˆ›å»ºäº†æ–°åˆ†æ”¯\n    assert node3.branch_id != node1.branch_id, \"åº”è¯¥åˆ›å»ºæ–°åˆ†æ”¯\"\n    print(f\"âœ“ å¯¹è¯3åˆ›å»ºäº†æ–°åˆ†æ”¯: {node3.branch_id}\")\n    \n    # è·å–ç»Ÿè®¡ä¿¡æ¯\n    stats = tree.get_tree_stats()\n    print(f\"\\nğŸ“Š æ ‘ç»Ÿè®¡:\")\n    print(f\"  - æ€»å¯¹è¯æ•°: {stats['total_conversations']}\")\n    print(f\"  - æ€»åˆ†æ”¯æ•°: {stats['total_branches']}\")\n    print(f\"  - æœ€å¤§æ·±åº¦: {stats['max_depth']}\")\n    print(f\"  - å½“å‰åˆ†æ”¯: {stats['current_branch_id']}\")\n    \n    assert stats['total_conversations'] == 3\n    assert stats['total_branches'] == 2\n    \n    print(\"\\nâœ… æµ‹è¯•1é€šè¿‡\")\n\n\nasync def test_branch_retrieval():\n    \"\"\"æµ‹è¯•åˆ†æ”¯æ£€ç´¢\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•2: åˆ†æ”¯æ£€ç´¢\")\n    print(\"=\"*60)\n    \n    tree = get_conversation_tree(enabled=True)\n    \n    # åˆ›å»ºå¤šä¸ªåˆ†æ”¯\n    # åˆ†æ”¯1: çŒ«-è‚ èƒƒé—®é¢˜\n    tree.add_conversation(\"æˆ‘çš„çŒ«ä¸åƒé¥­\", \"å¯èƒ½æ˜¯è‚ èƒƒé—®é¢˜...\")\n    tree.add_conversation(\"éœ€è¦åƒè¯å—ï¼Ÿ\", \"å¯ä»¥å…ˆè§‚å¯Ÿ...\")\n    tree.add_conversation(\"åƒä»€ä¹ˆè¯ï¼Ÿ\", \"å»ºè®®ç›Šç”ŸèŒ...\")\n    \n    # åˆ†æ”¯2: ç‹—-çš®è‚¤é—®é¢˜\n    tree.add_conversation(\"ç‹—çš„çš®è‚¤æœ‰çº¢ç‚¹\", \"å¯èƒ½æ˜¯è¿‡æ•...\")\n    tree.add_conversation(\"æ€ä¹ˆæ²»ç–—ï¼Ÿ\", \"å¯ä»¥ç”¨è¯è†...\")\n    \n    # åˆ†æ”¯3: çŒ«-ç–«è‹—\n    tree.add_conversation(\"çŒ«éœ€è¦æ‰“ç–«è‹—å—ï¼Ÿ\", \"éœ€è¦å®šæœŸæ¥ç§...\")\n    \n    stats = tree.get_tree_stats()\n    print(f\"ğŸ“Š åˆ›å»ºäº†{stats['total_branches']}ä¸ªåˆ†æ”¯ï¼Œ{stats['total_conversations']}ä¸ªå¯¹è¯\")\n    \n    # æµ‹è¯•å½“å‰åˆ†æ”¯æ£€ç´¢\n    current_branch_convs = tree.get_branch_conversations()\n    print(f\"\\nâœ… å½“å‰åˆ†æ”¯æœ‰{len(current_branch_convs)}ä¸ªå¯¹è¯\")\n    \n    # æµ‹è¯•å…³é”®è¯æ£€ç´¢\n    relevant_convs = tree.get_relevant_conversations(\n        current_message=\"çŒ«çš„è‚ èƒƒé—®é¢˜æ€ä¹ˆåŠï¼Ÿ\",\n        limit=3,\n        strategy='keyword'\n    )\n    print(f\"\\nâœ… å…³é”®è¯æ£€ç´¢æ‰¾åˆ°{len(relevant_convs)}ä¸ªç›¸å…³å¯¹è¯:\")\n    for i, conv in enumerate(relevant_convs, 1):\n        print(f\"  {i}. {conv['user'][:30]}...\")\n    \n    # æµ‹è¯•æ ‘ç»“æ„æ£€ç´¢\n    relevant_convs = tree.get_relevant_conversations(\n        current_message=\"çŒ«çš„è‚ èƒƒé—®é¢˜æ€ä¹ˆåŠï¼Ÿ\",\n        limit=3,\n        strategy='tree'\n    )\n    print(f\"\\nâœ… æ ‘ç»“æ„æ£€ç´¢æ‰¾åˆ°{len(relevant_convs)}ä¸ªç›¸å…³å¯¹è¯:\")\n    for i, conv in enumerate(relevant_convs, 1):\n        print(f\"  {i}. {conv['user'][:30]}...\")\n    \n    print(\"\\nâœ… æµ‹è¯•2é€šè¿‡\")\n\n\nasync def test_topic_detection():\n    \"\"\"æµ‹è¯•è¯é¢˜æ£€æµ‹\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•3: è¯é¢˜æ£€æµ‹\")\n    print(\"=\"*60)\n    \n    from daoyoucode.agents.memory.conversation_tree import ConversationTree\n    tree = ConversationTree(enabled=True)\n    \n    # æ·»åŠ ä¸€ç³»åˆ—å¯¹è¯ï¼Œæµ‹è¯•è¯é¢˜æ£€æµ‹\n    conversations = [\n        (\"æˆ‘çš„çŒ«ä¸åƒé¥­\", \"å¯èƒ½æ˜¯è‚ èƒƒé—®é¢˜...\"),\n        (\"çŒ«ä¸åƒé¥­éœ€è¦å»åŒ»é™¢å—ï¼Ÿ\", \"å»ºè®®è§‚å¯Ÿ2å¤©...\"),  # åŒä¸€è¯é¢˜ï¼ˆåŒ…å«\"çŒ«\"ã€\"åƒé¥­\"ï¼‰\n        (\"ç‹—çš„çš®è‚¤æœ‰çº¢ç‚¹\", \"å¯èƒ½æ˜¯è¿‡æ•...\"),  # è¯é¢˜åˆ‡æ¢\n        (\"ç‹—çš„çš®è‚¤ç”¨ä»€ä¹ˆè¯è†ï¼Ÿ\", \"å¯ä»¥ç”¨çš®ç‚å¹³...\"),  # åŒä¸€è¯é¢˜ï¼ˆåŒ…å«\"ç‹—çš„\"ã€\"çš®è‚¤\"ï¼‰\n        (\"çŒ«éœ€è¦æ‰“ç–«è‹—å—ï¼Ÿ\", \"éœ€è¦å®šæœŸæ¥ç§...\"),  # è¯é¢˜åˆ‡æ¢\n    ]\n    \n    branches = ["
},
{
"path": "tests/test_diff_tools.py",
"start": 1,
"end": 25,
"text": "\"\"\"\nDiffå·¥å…·æµ‹è¯•\n\næµ‹è¯•åŸºäºopencodeçš„9ç§Replacerç­–ç•¥\n\"\"\"\n\nimport pytest\nfrom pathlib import Path\nimport tempfile\nimport shutil\n\nfrom daoyoucode.agents.tools.diff_tools import (\n    levenshtein,\n    SimpleReplacer,\n    LineTrimmedReplacer,\n    BlockAnchorReplacer,\n    WhitespaceNormalizedReplacer,\n    IndentationFlexibleReplacer,\n    replace,\n    SearchReplaceTool\n)\n\n\n# ========== Levenshteinè·ç¦»æµ‹è¯• ==========\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 26,
"end": 30,
"text": "def test_levenshtein_identical():\n    \"\"\"æµ‹è¯•ç›¸åŒå­—ç¬¦ä¸²\"\"\"\n    assert levenshtein(\"hello\", \"hello\") == 0\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 31,
"end": 36,
"text": "def test_levenshtein_empty():\n    \"\"\"æµ‹è¯•ç©ºå­—ç¬¦ä¸²\"\"\"\n    assert levenshtein(\"\", \"hello\") == 5\n    assert levenshtein(\"hello\", \"\") == 5\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 37,
"end": 41,
"text": "def test_levenshtein_one_char_diff():\n    \"\"\"æµ‹è¯•å•å­—ç¬¦å·®å¼‚\"\"\"\n    assert levenshtein(\"hello\", \"hallo\") == 1\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 42,
"end": 48,
"text": "def test_levenshtein_multiple_diff():\n    \"\"\"æµ‹è¯•å¤šå­—ç¬¦å·®å¼‚\"\"\"\n    assert levenshtein(\"kitten\", \"sitting\") == 3\n\n\n# ========== Replacerç­–ç•¥æµ‹è¯• ==========\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 49,
"end": 58,
"text": "def test_simple_replacer():\n    \"\"\"æµ‹è¯•ç­–ç•¥1: ç²¾ç¡®åŒ¹é…\"\"\"\n    content = \"Hello World\\nThis is a test\\n\"\n    find = \"Hello World\"\n    \n    matches = list(SimpleReplacer.find_matches(content, find))\n    assert len(matches) == 1\n    assert matches[0] == \"Hello World\"\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 59,
"end": 68,
"text": "def test_line_trimmed_replacer():\n    \"\"\"æµ‹è¯•ç­–ç•¥2: å¿½ç•¥è¡Œé¦–å°¾ç©ºç™½\"\"\"\n    content = \"  Hello World  \\n  This is a test  \\n\"\n    find = \"Hello World\\nThis is a test\"\n    \n    matches = list(LineTrimmedReplacer.find_matches(content, find))\n    assert len(matches) == 1\n    assert \"Hello World\" in matches[0]\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 69,
"end": 82,
"text": "def test_block_anchor_replacer_single_candidate():\n    \"\"\"æµ‹è¯•ç­–ç•¥3: é¦–å°¾è¡Œé”šå®šï¼ˆå•å€™é€‰ï¼‰\"\"\"\n    content = \"\"\"def hello():\n    print(\"Hello\")\n    return True\n\"\"\"\n    find = \"\"\"def hello():\n    print(\"Hello\")\n    return True\"\"\"\n    \n    matches = list(BlockAnchorReplacer.find_matches(content, find))\n    assert len(matches) == 1\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 83,
"end": 88,
"text": "def test_block_anchor_replacer_multiple_candidates():\n    \"\"\"æµ‹è¯•ç­–ç•¥3: é¦–å°¾è¡Œé”šå®šï¼ˆå¤šå€™é€‰ï¼‰\"\"\"\n    content = \"\"\"def func1():\n    print(\"A\")\n    return 1\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 89,
"end": 101,
"text": "def func2():\n    print(\"B\")\n    return 2\n\"\"\"\n    find = \"\"\"def func1():\n    print(\"A\")\n    return 1\"\"\"\n    \n    matches = list(BlockAnchorReplacer.find_matches(content, find))\n    assert len(matches) == 1\n    assert \"func1\" in matches[0]\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 102,
"end": 110,
"text": "def test_whitespace_normalized_replacer():\n    \"\"\"æµ‹è¯•ç­–ç•¥4: ç©ºç™½å½’ä¸€åŒ–\"\"\"\n    content = \"Hello    World\\n\"\n    find = \"Hello World\"\n    \n    matches = list(WhitespaceNormalizedReplacer.find_matches(content, find))\n    assert len(matches) == 1\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 111,
"end": 124,
"text": "def test_indentation_flexible_replacer():\n    \"\"\"æµ‹è¯•ç­–ç•¥5: ç¼©è¿›çµæ´»åŒ¹é…\"\"\"\n    content = \"\"\"    def hello():\n        print(\"Hello\")\n\"\"\"\n    find = \"\"\"def hello():\n    print(\"Hello\")\"\"\"\n    \n    matches = list(IndentationFlexibleReplacer.find_matches(content, find))\n    assert len(matches) == 1\n\n\n# ========== æ ¸å¿ƒreplaceå‡½æ•°æµ‹è¯• ==========\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 125,
"end": 131,
"text": "def test_replace_simple():\n    \"\"\"æµ‹è¯•ç®€å•æ›¿æ¢\"\"\"\n    content = \"Hello World\"\n    result = replace(content, \"Hello\", \"Hi\")\n    assert result == \"Hi World\"\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 132,
"end": 138,
"text": "def test_replace_with_whitespace():\n    \"\"\"æµ‹è¯•å¸¦ç©ºç™½çš„æ›¿æ¢\"\"\"\n    content = \"  Hello World  \"\n    result = replace(content, \"Hello World\", \"Hi\")\n    assert \"Hi\" in result\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 139,
"end": 156,
"text": "def test_replace_multiline():\n    \"\"\"æµ‹è¯•å¤šè¡Œæ›¿æ¢\"\"\"\n    content = \"\"\"def hello():\n    print(\"Hello\")\n    return True\n\"\"\"\n    find = \"\"\"def hello():\n    print(\"Hello\")\n    return True\"\"\"\n    new = \"\"\"def hello():\n    print(\"Hi\")\n    return False\"\"\"\n    \n    result = replace(content, find, new)\n    assert \"Hi\" in result\n    assert \"False\" in result\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 157,
"end": 170,
"text": "def test_replace_with_indentation():\n    \"\"\"æµ‹è¯•ç¼©è¿›çµæ´»æ›¿æ¢\"\"\"\n    content = \"\"\"    def hello():\n        print(\"Hello\")\n\"\"\"\n    find = \"\"\"def hello():\n    print(\"Hello\")\"\"\"\n    new = \"\"\"def hello():\n    print(\"Hi\")\"\"\"\n    \n    result = replace(content, find, new)\n    assert \"Hi\" in result\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 171,
"end": 177,
"text": "def test_replace_not_found():\n    \"\"\"æµ‹è¯•æ‰¾ä¸åˆ°åŒ¹é…\"\"\"\n    content = \"Hello World\"\n    with pytest.raises(ValueError, match=\"not found\"):\n        replace(content, \"Goodbye\", \"Hi\")\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 178,
"end": 184,
"text": "def test_replace_multiple_matches():\n    \"\"\"æµ‹è¯•å¤šä¸ªåŒ¹é…ï¼ˆåº”è¯¥å¤±è´¥ï¼‰\"\"\"\n    content = \"Hello Hello\"\n    with pytest.raises(ValueError, match=\"multiple matches\"):\n        replace(content, \"Hello\", \"Hi\")\n\n"
},
{
"path": "tests/test_diff_tools.py",
"start": 185,
"end": 194,
"text": "def test_replace_all():\n    \"\"\"æµ‹è¯•æ›¿æ¢æ‰€æœ‰\"\"\"\n    content = \"Hello Hello\"\n    result = replace(content, \"Hello\", \"Hi\", replace_all=True)\n    assert result == \"Hi Hi\"\n\n\n# ========== SearchReplaceToolæµ‹è¯• ==========\n\n@pytest.fixture"
},
{
"path": "tests/test_diff_tools.py",
"start": 195,
"end": 271,
"text": "def temp_dir():\n    \"\"\"åˆ›å»ºä¸´æ—¶ç›®å½•\"\"\"\n    temp_path = Path(tempfile.mkdtemp())\n    yield temp_path\n    if temp_path.exists():\n        shutil.rmtree(temp_path)\n\n\n@pytest.mark.asyncio\nasync def test_search_replace_tool(temp_dir):\n    \"\"\"æµ‹è¯•SearchReplaceTool\"\"\"\n    # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n    test_file = temp_dir / \"test.py\"\n    test_file.write_text(\"\"\"def hello():\n    print(\"Hello\")\n    return True\n\"\"\")\n    \n    # æ‰§è¡Œæ›¿æ¢\n    tool = SearchReplaceTool()\n    result = await tool.execute(\n        file_path=str(test_file),\n        search='print(\"Hello\")',\n        replace='print(\"Hi\")'\n    )\n    \n    if not result.success:\n        print(f\"Error: {result.error}\")\n        import traceback\n        traceback.print_exc()\n    \n    assert result.success\n    \n    # éªŒè¯æ–‡ä»¶å†…å®¹\n    new_content = test_file.read_text()\n    assert \"Hi\" in new_content\n    assert \"Hello\" not in new_content\n\n\n@pytest.mark.asyncio\nasync def test_search_replace_tool_not_found(temp_dir):\n    \"\"\"æµ‹è¯•æ–‡ä»¶ä¸å­˜åœ¨\"\"\"\n    tool = SearchReplaceTool()\n    result = await tool.execute(\n        file_path=str(temp_dir / \"nonexistent.py\"),\n        search=\"test\",\n        replace=\"new\"\n    )\n    \n    assert not result.success\n    assert \"not found\" in result.error.lower()\n\n\n@pytest.mark.asyncio\nasync def test_search_replace_tool_with_indentation(temp_dir):\n    \"\"\"æµ‹è¯•ç¼©è¿›çµæ´»æ›¿æ¢\"\"\"\n    test_file = temp_dir / \"test.py\"\n    test_file.write_text(\"\"\"    def hello():\n        print(\"Hello\")\n\"\"\")\n    \n    tool = SearchReplaceTool()\n    result = await tool.execute(\n        file_path=str(test_file),\n        search=\"\"\"def hello():\n    print(\"Hello\")\"\"\",\n        replace=\"\"\"def hello():\n    print(\"Hi\")\"\"\"\n    )\n    \n    assert result.success\n    new_content = test_file.read_text()\n    assert \"Hi\" in new_content\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\"])"
},
{
"path": "tests/test_execution_planner.py",
"start": 1,
"end": 245,
"text": "\"\"\"\næµ‹è¯•ExecutionPlanner\n\"\"\"\n\nimport asyncio\nfrom daoyoucode.agents.core.planner import get_execution_planner\n\n\nasync def test_simple_task():\n    \"\"\"æµ‹è¯•ç®€å•ä»»åŠ¡è§„åˆ’\"\"\"\n    print(\"\\n=== æµ‹è¯•1: ç®€å•ä»»åŠ¡ ===\")\n    \n    planner = get_execution_planner(use_router=False)\n    \n    plan = await planner.create_plan(\"ç”Ÿæˆä¸€ä¸ªHello Worldå‡½æ•°\")\n    \n    print(f\"âœ“ è®¡åˆ’ID: {plan.plan_id[:8]}...\")\n    print(f\"  å¤æ‚åº¦: {plan.complexity}/5\")\n    print(f\"  ç¼–æ’å™¨: {plan.steps[0].orchestrator}\")\n    print(f\"  æ­¥éª¤æ•°: {len(plan.steps)}\")\n    print(f\"  é¢„ä¼°tokens: {plan.total_estimated_tokens}\")\n    print(f\"  é¢„ä¼°æ—¶é—´: {plan.total_estimated_time:.1f}ç§’\")\n    \n    assert plan.complexity <= 2\n    assert len(plan.steps) == 1\n    assert plan.steps[0].orchestrator == 'simple'\n\n\nasync def test_workflow_task():\n    \"\"\"æµ‹è¯•å·¥ä½œæµä»»åŠ¡è§„åˆ’\"\"\"\n    print(\"\\n=== æµ‹è¯•2: å·¥ä½œæµä»»åŠ¡ ===\")\n    \n    planner = get_execution_planner(use_router=False)\n    \n    plan = await planner.create_plan(\n        \"å…ˆåˆ†æä»£ç ç»“æ„ï¼Œç„¶åç”Ÿæˆé‡æ„è®¡åˆ’ï¼Œæœ€åæ‰§è¡Œé‡æ„\"\n    )\n    \n    print(f\"âœ“ è®¡åˆ’ID: {plan.plan_id[:8]}...\")\n    print(f\"  å¤æ‚åº¦: {plan.complexity}/5\")\n    print(f\"  ç¼–æ’å™¨: workflow\")\n    print(f\"  æ­¥éª¤æ•°: {len(plan.steps)}\")\n    \n    for i, step in enumerate(plan.steps, 1):\n        print(f\"  æ­¥éª¤{i}: {step.description}\")\n        if step.dependencies:\n            print(f\"    ä¾èµ–: {step.dependencies}\")\n    \n    print(f\"  é¢„ä¼°tokens: {plan.total_estimated_tokens}\")\n    print(f\"  é¢„ä¼°æ—¶é—´: {plan.total_estimated_time:.1f}ç§’\")\n    \n    assert len(plan.steps) == 3\n    assert plan.steps[1].dependencies == [1]\n    assert plan.steps[2].dependencies == [2]\n\n\nasync def test_parallel_task():\n    \"\"\"æµ‹è¯•å¹¶è¡Œä»»åŠ¡è§„åˆ’\"\"\"\n    print(\"\\n=== æµ‹è¯•3: å¹¶è¡Œä»»åŠ¡ ===\")\n    \n    planner = get_execution_planner(use_router=False)\n    \n    plan = await planner.create_plan(\"æ‰¹é‡å¤„ç†æ‰€æœ‰Pythonæ–‡ä»¶\")\n    \n    print(f\"âœ“ è®¡åˆ’ID: {plan.plan_id[:8]}...\")\n    print(f\"  å¤æ‚åº¦: {plan.complexity}/5\")\n    print(f\"  ç¼–æ’å™¨: {plan.steps[0].orchestrator if plan.steps else 'N/A'}\")\n    print(f\"  æ­¥éª¤æ•°: {len(plan.steps)}\")\n    print(f\"  é¢„ä¼°tokens: {plan.total_estimated_tokens}\")\n    \n    # å¹¶è¡Œä»»åŠ¡åº”è¯¥ä½¿ç”¨parallelç¼–æ’å™¨\n    # æ³¨æ„ï¼šç”±äºå…³é”®è¯åŒ¹é…ï¼Œå¯èƒ½ä¸ä¼šè¢«è¯†åˆ«ä¸ºparallel\n    # è¿™é‡ŒåªéªŒè¯è®¡åˆ’ç”ŸæˆæˆåŠŸ\n    assert len(plan.steps) >= 1\n\n\nasync def test_complexity_analysis():\n    \"\"\"æµ‹è¯•å¤æ‚åº¦åˆ†æ\"\"\"\n    print(\"\\n=== æµ‹è¯•4: å¤æ‚åº¦åˆ†æ ===\")\n    \n    planner = get_execution_planner(use_router=False)\n    \n    test_cases = [\n        (\"ç®€å•ä»»åŠ¡\", 1),\n        (\"åˆ†æä»£ç ç»“æ„\", 2),\n        (\"è®¾è®¡ä¸€ä¸ªå®Œæ•´çš„ç³»ç»Ÿæ¶æ„\", 4),\n    ]\n    \n    for task, min_complexity in test_cases:\n        plan = await planner.create_plan(task)\n        print(f\"âœ“ '{task}' -> å¤æ‚åº¦: {plan.complexity}/5\")\n        assert plan.complexity >= min_complexity\n\n\nasync def test_cost_estimation():\n    \"\"\"æµ‹è¯•æˆæœ¬é¢„ä¼°\"\"\"\n    print(\"\\n=== æµ‹è¯•5: æˆæœ¬é¢„ä¼° ===\")\n    \n    planner = get_execution_planner(use_router=False)\n    \n    plan = await planner.create_plan(\n        \"å…ˆåˆ†æä»£ç ï¼Œç„¶åç”Ÿæˆæ–‡æ¡£ï¼Œæœ€åè¿›è¡Œæµ‹è¯•\"\n    )\n    \n    print(f\"âœ“ é¢„ä¼°tokens: {plan.total_estimated_tokens}\")\n    print(f\"âœ“ é¢„ä¼°æ—¶é—´: {plan.total_estimated_time:.1f}ç§’\")\n    \n    assert plan.total_estimated_tokens > 0\n    assert plan.total_estimated_time > 0\n\n\nasync def test_risk_identification():\n    \"\"\"æµ‹è¯•é£é™©è¯†åˆ«\"\"\"\n    print(\"\\n=== æµ‹è¯•6: é£é™©è¯†åˆ« ===\")\n    \n    planner = get_execution_planner(use_router=False)\n    \n    plan = await planner.create_plan(\n        \"è®¾è®¡ä¸€ä¸ªå®Œæ•´çš„ç³»ç»Ÿæ¶æ„ï¼ŒåŒ…æ‹¬å‰ç«¯ã€åç«¯ã€æ•°æ®åº“ã€éƒ¨ç½²ç­‰æ‰€æœ‰æ–¹é¢\"\n    )\n    \n    print(f\"âœ“ è¯†åˆ«çš„é£é™©:\")\n    for risk in plan.risks:\n        print(f\"  - {risk}\")\n    \n    assert len(plan.risks) > 0\n\n\nasync def test_recommendations():\n    \"\"\"æµ‹è¯•å»ºè®®ç”Ÿæˆ\"\"\"\n    print(\"\\n=== æµ‹è¯•7: å»ºè®®ç”Ÿæˆ ===\")\n    \n    planner = get_execution_planner(use_router=False)\n    \n    plan = await planner.create_plan(\n        \"é‡æ„æ•´ä¸ªé¡¹ç›®çš„ä»£ç ç»“æ„\"\n    )\n    \n    print(f\"âœ“ ç”Ÿæˆçš„å»ºè®®:\")\n    for rec in plan.recommendations:\n        print(f\"  - {rec}\")\n    \n    assert len(plan.recommendations) > 0\n\n\nasync def test_with_router():\n    \"\"\"æµ‹è¯•ä¸Routeré›†æˆ\"\"\"\n    print(\"\\n=== æµ‹è¯•8: ä¸Routeré›†æˆ ===\")\n    \n    planner = get_execution_planner(use_router=True)\n    \n    plan = await planner.create_plan(\"æŸ¥æ‰¾æ‰€æœ‰Pythonæ–‡ä»¶ä¸­çš„å‡½æ•°å®šä¹‰\")\n    \n    print(f\"âœ“ è®¡åˆ’ID: {plan.plan_id[:8]}...\")\n    print(f\"  ç¼–æ’å™¨: {plan.s"
},
{
"path": "tests/test_feedback_loop.py",
"start": 1,
"end": 126,
"text": "\"\"\"\næµ‹è¯•FeedbackLoop\n\"\"\"\n\nimport asyncio\nfrom daoyoucode.agents.core.feedback import get_feedback_loop\n\n\nasync def test_evaluate_success():\n    \"\"\"æµ‹è¯•æˆåŠŸç»“æœè¯„ä¼°\"\"\"\n    print(\"\\n=== æµ‹è¯•1: æˆåŠŸç»“æœè¯„ä¼° ===\")\n    \n    feedback = get_feedback_loop()\n    \n    result = {\n        'success': True,\n        'content': 'è¿™æ˜¯ä¸€ä¸ªè¯¦ç»†çš„åˆ†æç»“æœï¼ŒåŒ…å«äº†ä»£ç ç»“æ„ã€æ½œåœ¨é—®é¢˜å’Œæ”¹è¿›å»ºè®®ã€‚' * 10,\n        'tokens_used': 800,\n        'tools_used': ['file_reader', 'code_analyzer']\n    }\n    \n    evaluation = await feedback.evaluate(\"åˆ†æä»£ç ç»“æ„\", result)\n    \n    print(f\"âœ“ è´¨é‡åˆ†æ•°: {evaluation.quality_score:.2f}\")\n    print(f\"  é—®é¢˜æ•°: {len(evaluation.issues)}\")\n    print(f\"  ä¼˜ç‚¹æ•°: {len(evaluation.strengths)}\")\n    print(f\"  å»ºè®®æ•°: {len(evaluation.suggestions)}\")\n    \n    assert 0 <= evaluation.quality_score <= 1\n    assert isinstance(evaluation.issues, list)\n    assert isinstance(evaluation.strengths, list)\n\n\nasync def test_evaluate_failure():\n    \"\"\"æµ‹è¯•å¤±è´¥ç»“æœè¯„ä¼°\"\"\"\n    print(\"\\n=== æµ‹è¯•2: å¤±è´¥ç»“æœè¯„ä¼° ===\")\n    \n    feedback = get_feedback_loop()\n    \n    result = {\n        'success': False,\n        'content': '',\n        'error': 'æ‰§è¡Œè¶…æ—¶',\n        'tokens_used': 0\n    }\n    \n    evaluation = await feedback.evaluate(\"å¤æ‚ä»»åŠ¡\", result)\n    \n    print(f\"âœ“ è´¨é‡åˆ†æ•°: {evaluation.quality_score:.2f}\")\n    print(f\"  è¯†åˆ«çš„é—®é¢˜:\")\n    for issue in evaluation.issues:\n        print(f\"    - {issue}\")\n    \n    assert evaluation.quality_score < 0.6  # å¤±è´¥ä»»åŠ¡åˆ†æ•°åº”è¯¥è¾ƒä½\n    assert len(evaluation.issues) > 0\n\n\nasync def test_analyze_failure():\n    \"\"\"æµ‹è¯•å¤±è´¥åˆ†æ\"\"\"\n    print(\"\\n=== æµ‹è¯•3: å¤±è´¥åˆ†æ ===\")\n    \n    feedback = get_feedback_loop()\n    \n    error = Exception(\"Connection timeout: Failed to connect to API\")\n    \n    analysis = await feedback.analyze_failure(\"è°ƒç”¨API\", error)\n    \n    print(f\"âœ“ é”™è¯¯ç±»å‹: {analysis.error_type}\")\n    print(f\"  æ ¹æœ¬åŸå› : {analysis.root_cause}\")\n    print(f\"  æ¢å¤å»ºè®®:\")\n    for sug in analysis.recovery_suggestions:\n        print(f\"    - {sug}\")\n    \n    assert analysis.error_type in ['timeout', 'network', 'unknown']\n    assert len(analysis.recovery_suggestions) > 0\n\n\nasync def test_learning_stats():\n    \"\"\"æµ‹è¯•å­¦ä¹ ç»Ÿè®¡\"\"\"\n    print(\"\\n=== æµ‹è¯•4: å­¦ä¹ ç»Ÿè®¡ ===\")\n    \n    feedback = get_feedback_loop()\n    \n    # è¯„ä¼°å‡ ä¸ªä»»åŠ¡\n    for i in range(5):\n        result = {\n            'success': i % 2 == 0,\n            'content': f'ç»“æœ{i}',\n            'tokens_used': 500\n        }\n        await feedback.evaluate(f\"ä»»åŠ¡{i}\", result)\n    \n    stats = feedback.get_learning_stats()\n    \n    print(f\"âœ“ å­¦ä¹ ç»Ÿè®¡:\")\n    print(f\"  æ€»ä»»åŠ¡æ•°: {stats['total_tasks']}\")\n    print(f\"  æˆåŠŸç‡: {stats['success_rate']:.2%}\")\n    print(f\"  å¹³å‡è´¨é‡: {stats['average_quality']:.2f}\")\n    \n    assert stats['total_tasks'] > 0\n\n\nasync def main():\n    \"\"\"è¿è¡Œæ‰€æœ‰æµ‹è¯•\"\"\"\n    print(\"=\" * 60)\n    print(\"FeedbackLoop æµ‹è¯•\")\n    print(\"=\" * 60)\n    \n    try:\n        await test_evaluate_success()\n        await test_evaluate_failure()\n        await test_analyze_failure()\n        await test_learning_stats()\n        \n        print(\"\\n\" + \"=\" * 60)\n        print(\"âœ“ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼\")\n        print(\"=\" * 60)\n    \n    except Exception as e:\n        print(f\"\\nâœ— æµ‹è¯•é”™è¯¯: {e}\")\n        import traceback\n        traceback.print_exc()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())"
},
{
"path": "tests/test_final_demo.py",
"start": 1,
"end": 171,
"text": "\"\"\"\næœ€ç»ˆæ¼”ç¤ºæµ‹è¯• - å±•ç¤ºå®Œæ•´çš„Agent+å·¥å…·è°ƒç”¨æµç¨‹\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\n# è®¾ç½®API Key\nos.environ['DASHSCOPE_API_KEY'] = 'sk-d2971f2015574377bdf97046b1a03b87'\n\nfrom daoyoucode.agents.builtin import register_builtin_agents\nfrom daoyoucode.agents.core.agent import get_agent_registry\nfrom daoyoucode.agents.llm import get_client_manager\n\n\nasync def demo_1_simple_question():\n    \"\"\"æ¼”ç¤º1: ç®€å•é—®ç­”ï¼ˆæ— å·¥å…·ï¼‰\"\"\"\n    print(\"\\n\" + \"=\"*70)\n    print(\"æ¼”ç¤º1: ç®€å•é—®ç­”ï¼ˆæ— å·¥å…·ï¼‰\")\n    print(\"=\"*70)\n    \n    registry = get_agent_registry()\n    agent = registry.get_agent('programmer')\n    \n    print(\"\\né—®é¢˜: Pythonä¸­çš„è£…é¥°å™¨æ˜¯ä»€ä¹ˆï¼Ÿ\")\n    print(\"-\" * 70)\n    \n    result = await agent.execute(\n        prompt_source={'inline': 'ä½ æ˜¯Pythonç¼–ç¨‹ä¸“å®¶ã€‚ç”¨ç®€æ´çš„è¯­è¨€å›ç­”é—®é¢˜ã€‚'},\n        user_input='Pythonä¸­çš„è£…é¥°å™¨æ˜¯ä»€ä¹ˆï¼Ÿç”¨2-3å¥è¯è§£é‡Šã€‚',\n        llm_config={'model': 'qwen-max', 'temperature': 0.7}\n    )\n    \n    print(f\"\\nå›ç­”:\\n{result.content}\")\n    print(f\"\\nä½¿ç”¨çš„å·¥å…·: {result.tools_used}\")\n\n\nasync def demo_2_file_search():\n    \"\"\"æ¼”ç¤º2: ä½¿ç”¨æœç´¢å·¥å…·æŸ¥æ‰¾ä»£ç \"\"\"\n    print(\"\\n\" + \"=\"*70)\n    print(\"æ¼”ç¤º2: ä½¿ç”¨æœç´¢å·¥å…·æŸ¥æ‰¾ä»£ç \")\n    print(\"=\"*70)\n    \n    registry = get_agent_registry()\n    agent = registry.get_agent('code_explorer')\n    \n    print(\"\\nä»»åŠ¡: åœ¨ä»£ç åº“ä¸­æŸ¥æ‰¾BaseAgentç±»çš„å®šä¹‰\")\n    print(\"-\" * 70)\n    \n    result = await agent.execute(\n        prompt_source={'inline': '''ä½ æ˜¯ä»£ç æ¢ç´¢ä¸“å®¶ã€‚ä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å·¥å…·:\n- grep_search: æ–‡æœ¬æœç´¢\n- find_class: æŸ¥æ‰¾ç±»å®šä¹‰\n- read_file: è¯»å–æ–‡ä»¶\n\nè¯·å¸®åŠ©ç”¨æˆ·æŸ¥æ‰¾ä»£ç ã€‚'''},\n        user_input='åœ¨daoyoucode/agentsç›®å½•ä¸­æŸ¥æ‰¾BaseAgentç±»çš„å®šä¹‰ä½ç½®',\n        llm_config={'model': 'qwen-coder-plus', 'temperature': 0.1},\n        tools=['grep_search', 'find_class', 'read_file'],\n        max_tool_iterations=3\n    )\n    \n    print(f\"\\nå›ç­”:\\n{result.content}\")\n    print(f\"\\nä½¿ç”¨çš„å·¥å…·: {result.tools_used}\")\n\n\nasync def demo_3_file_operations():\n    \"\"\"æ¼”ç¤º3: æ–‡ä»¶æ“ä½œå·¥å…·\"\"\"\n    print(\"\\n\" + \"=\"*70)\n    print(\"æ¼”ç¤º3: æ–‡ä»¶æ“ä½œå·¥å…·\")\n    print(\"=\"*70)\n    \n    registry = get_agent_registry()\n    agent = registry.get_agent('programmer')\n    \n    print(\"\\nä»»åŠ¡: è¯»å–å¹¶åˆ†æagent.pyæ–‡ä»¶çš„ç»“æ„\")\n    print(\"-\" * 70)\n    \n    result = await agent.execute(\n        prompt_source={'inline': '''ä½ æ˜¯Pythonç¼–ç¨‹ä¸“å®¶ã€‚ä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å·¥å…·:\n- read_file: è¯»å–æ–‡ä»¶\n- get_file_content_lines: è¯»å–æŒ‡å®šè¡Œ\n- list_files: åˆ—å‡ºæ–‡ä»¶\n\nè¯·å¸®åŠ©ç”¨æˆ·åˆ†æä»£ç æ–‡ä»¶ã€‚'''},\n        user_input='è¯»å–daoyoucode/agents/core/agent.pyæ–‡ä»¶ï¼Œå‘Šè¯‰æˆ‘è¿™ä¸ªæ–‡ä»¶å®šä¹‰äº†å“ªäº›ä¸»è¦çš„ç±»',\n        llm_config={'model': 'qwen-coder-plus', 'temperature': 0.1},\n        tools=['read_file', 'get_file_content_lines'],\n        max_tool_iterations=3\n    )\n    \n    print(f\"\\nå›ç­”:\\n{result.content[:500]}...\")\n    print(f\"\\nä½¿ç”¨çš„å·¥å…·: {result.tools_used}\")\n\n\nasync def demo_4_git_operations():\n    \"\"\"æ¼”ç¤º4: Gitæ“ä½œå·¥å…·\"\"\"\n    print(\"\\n\" + \"=\"*70)\n    print(\"æ¼”ç¤º4: Gitæ“ä½œå·¥å…·\")\n    print(\"=\"*70)\n    \n    registry = get_agent_registry()\n    agent = registry.get_agent('programmer')\n    \n    print(\"\\nä»»åŠ¡: æŸ¥çœ‹Gitä»“åº“çŠ¶æ€\")\n    print(\"-\" * 70)\n    \n    result = await agent.execute(\n        prompt_source={'inline': '''ä½ æ˜¯Gitä¸“å®¶ã€‚ä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å·¥å…·:\n- git_status: æŸ¥çœ‹GitçŠ¶æ€\n- git_branch: æŸ¥çœ‹åˆ†æ”¯\n- git_log: æŸ¥çœ‹æäº¤å†å²\n\nè¯·å¸®åŠ©ç”¨æˆ·äº†è§£Gitä»“åº“çŠ¶æ€ã€‚'''},\n        user_input='æŸ¥çœ‹å½“å‰Gitä»“åº“çš„çŠ¶æ€å’Œåˆ†æ”¯ä¿¡æ¯',\n        llm_config={'model': 'qwen-max', 'temperature': 0.1},\n        tools=['git_status', 'git_branch', 'git_log'],\n        max_tool_iterations=3\n    )\n    \n    print(f\"\\nå›ç­”:\\n{result.content[:500]}...\")\n    print(f\"\\nä½¿ç”¨çš„å·¥å…·: {result.tools_used}\")\n\n\nasync def main():\n    \"\"\"ä¸»å‡½æ•°\"\"\"\n    print(\"\\n\" + \"=\"*70)\n    print(\"ğŸš€ Agentç³»ç»Ÿå®Œæ•´åŠŸèƒ½æ¼”ç¤º\")\n    print(\"=\"*70)\n    \n    # é…ç½®LLM\n    print(\"\\né…ç½®LLMæä¾›å•†...\")\n    client_manager = get_client_manager()\n    client_manager.configure_provider(\n        provider='qwen',\n        api_key=os.environ['DASHSCOPE_API_KEY'],\n        base_url='https://dashscope.aliyuncs.com/compatible-mode/v1',\n        models=['qwen-max', 'qwen-plus', 'qwen-turbo', 'qwen-coder-plus']\n    )\n    print(\"âœ“ å·²é…ç½®qwenæä¾›å•†\")\n    \n    # æ³¨å†ŒAgent\n    print(\"æ³¨å†ŒAgent...\")\n    register_builtin_agents()\n    print(\"âœ“ å·²æ³¨å†Œæ‰€æœ‰å†…ç½®Agent\")\n    \n    # è¿è¡Œæ¼”ç¤º\n    await demo_1_simple_question()\n    await demo_2_file_search()\n    await demo_3_file_operations()\n    awa"
},
{
"path": "tests/test_function_calling.py",
"start": 1,
"end": 107,
"text": "\"\"\"æµ‹è¯•LLMæ˜¯å¦æ”¯æŒfunction calling\"\"\"\nimport asyncio\nimport sys\nfrom pathlib import Path\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents.llm.client_manager import get_client_manager\nfrom daoyoucode.agents.llm.config_loader import auto_configure\n\nasync def test_function_calling():\n    print(\"=\"*60)\n    print(\"æµ‹è¯•LLM Function Callingæ”¯æŒ\")\n    print(\"=\"*60)\n    \n    # 1. é…ç½®LLM\n    print(\"\\n1. é…ç½®LLM...\")\n    client_manager = get_client_manager()\n    auto_configure(client_manager)\n    \n    if not client_manager.provider_configs:\n        print(\"âŒ æœªé…ç½®LLMæä¾›å•†\")\n        return False\n    \n    print(f\"âœ“ å·²é…ç½®æä¾›å•†: {list(client_manager.provider_configs.keys())}\")\n    \n    # 2. è·å–å®¢æˆ·ç«¯\n    print(\"\\n2. è·å–qwen-maxå®¢æˆ·ç«¯...\")\n    try:\n        client = client_manager.get_client(model=\"qwen-max\")\n        print(f\"âœ“ å®¢æˆ·ç«¯è·å–æˆåŠŸ\")\n    except Exception as e:\n        print(f\"âŒ è·å–å®¢æˆ·ç«¯å¤±è´¥: {e}\")\n        return False\n    \n    # 3. æµ‹è¯•ç®€å•è°ƒç”¨ï¼ˆä¸å¸¦å·¥å…·ï¼‰\n    print(\"\\n3. æµ‹è¯•ç®€å•è°ƒç”¨ï¼ˆä¸å¸¦å·¥å…·ï¼‰...\")\n    try:\n        response = await client.chat(\n            messages=[{\"role\": \"user\", \"content\": \"ä½ å¥½\"}],\n            model=\"qwen-max\"\n        )\n        print(f\"âœ“ ç®€å•è°ƒç”¨æˆåŠŸ\")\n        print(f\"  å“åº”: {response.get('content', '')[:50]}...\")\n    except Exception as e:\n        print(f\"âŒ ç®€å•è°ƒç”¨å¤±è´¥: {e}\")\n        return False\n    \n    # 4. æµ‹è¯•function calling\n    print(\"\\n4. æµ‹è¯•function calling...\")\n    \n    # å®šä¹‰ä¸€ä¸ªç®€å•çš„å·¥å…·\n    tools = [{\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_weather\",\n            \"description\": \"è·å–å¤©æ°”ä¿¡æ¯\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"city\": {\n                        \"type\": \"string\",\n                        \"description\": \"åŸå¸‚åç§°\"\n                    }\n                },\n                \"required\": [\"city\"]\n            }\n        }\n    }]\n    \n    try:\n        response = await client.chat(\n            messages=[{\"role\": \"user\", \"content\": \"åŒ—äº¬çš„å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ\"}],\n            model=\"qwen-max\",\n            tools=tools\n        )\n        \n        print(f\"âœ“ Function callingè°ƒç”¨æˆåŠŸ\")\n        \n        # æ£€æŸ¥æ˜¯å¦æœ‰tool_calls\n        if 'tool_calls' in response or 'function_call' in response:\n            print(f\"âœ“ LLMæ”¯æŒfunction calling\")\n            print(f\"  å“åº”ç±»å‹: {type(response)}\")\n            print(f\"  å“åº”é”®: {list(response.keys())}\")\n            if 'tool_calls' in response:\n                print(f\"  tool_calls: {response['tool_calls']}\")\n            if 'function_call' in response:\n                print(f\"  function_call: {response['function_call']}\")\n            return True\n        else:\n            print(f\"âš  LLMå¯èƒ½ä¸æ”¯æŒfunction calling\")\n            print(f\"  å“åº”: {response}\")\n            return False\n            \n    except Exception as e:\n        print(f\"âŒ Function callingè°ƒç”¨å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\nif __name__ == \"__main__\":\n    success = asyncio.run(test_function_calling())\n    print(\"\\n\" + \"=\"*60)\n    if success:\n        print(\"âœ… LLMæ”¯æŒfunction calling\")\n    else:\n        print(\"âŒ LLMå¯èƒ½ä¸æ”¯æŒfunction callingæˆ–é…ç½®æœ‰é—®é¢˜\")\n    print(\"=\"*60)"
},
{
"path": "tests/test_git_enhancements.py",
"start": 1,
"end": 215,
"text": "\"\"\"\næµ‹è¯• Git å¢å¼ºåŠŸèƒ½\n\néªŒè¯ï¼š\n1. subtree_only è¿‡æ»¤åœ¨ repo_map ä¸­ç”Ÿæ•ˆ\n2. git_status å·¥å…·æ­£å¸¸å·¥ä½œ\n3. è·¯å¾„å¤„ç†ä¸€è‡´æ€§\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport asyncio\n\n# æ·»åŠ  backend åˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\n\nasync def test_subtree_only_filtering():\n    \"\"\"æµ‹è¯• subtree_only è¿‡æ»¤\"\"\"\n    from daoyoucode.agents.tools.base import ToolContext\n    from daoyoucode.agents.tools.repomap_tools import RepoMapTool\n    \n    print(\"=\" * 60)\n    print(\"æµ‹è¯• subtree_only è¿‡æ»¤\")\n    print(\"=\" * 60)\n    \n    # åˆ›å»ºå·¥å…·\n    tool = RepoMapTool()\n    \n    # æµ‹è¯• 1ï¼šä¸ä½¿ç”¨ subtree_only\n    print(\"\\næµ‹è¯• 1ï¼šä¸ä½¿ç”¨ subtree_onlyï¼ˆæ‰«ææ•´ä¸ªé¡¹ç›®ï¼‰\")\n    context1 = ToolContext(\n        repo_path=Path.cwd().parent,  # é¡¹ç›®æ ¹ç›®å½•\n        subtree_only=False\n    )\n    tool.set_context(context1)\n    \n    result1 = await tool.execute(\n        repo_path=\".\",\n        max_tokens=1000\n    )\n    \n    if result1.success:\n        file_count1 = result1.metadata.get('file_count', 0)\n        print(f\"âœ“ æ‰«æäº† {file_count1} ä¸ªæ–‡ä»¶\")\n        # æ˜¾ç¤ºå‰å‡ ä¸ªæ–‡ä»¶\n        lines = result1.content.split('\\n')[:10]\n        print(\"  å‰å‡ ä¸ªæ–‡ä»¶:\")\n        for line in lines:\n            if line.strip():\n                print(f\"    {line}\")\n    else:\n        print(f\"âœ— å¤±è´¥: {result1.error}\")\n    \n    # æµ‹è¯• 2ï¼šä½¿ç”¨ subtree_only\n    print(\"\\næµ‹è¯• 2ï¼šä½¿ç”¨ subtree_onlyï¼ˆåªæ‰«æ backend/ï¼‰\")\n    context2 = ToolContext(\n        repo_path=Path.cwd().parent,  # é¡¹ç›®æ ¹ç›®å½•\n        subtree_only=True,\n        cwd=Path.cwd()  # backend/\n    )\n    tool.set_context(context2)\n    \n    result2 = await tool.execute(\n        repo_path=\".\",\n        max_tokens=1000\n    )\n    \n    if result2.success:\n        file_count2 = result2.metadata.get('file_count', 0)\n        print(f\"âœ“ æ‰«æäº† {file_count2} ä¸ªæ–‡ä»¶\")\n        # æ˜¾ç¤ºå‰å‡ ä¸ªæ–‡ä»¶\n        lines = result2.content.split('\\n')[:10]\n        print(\"  å‰å‡ ä¸ªæ–‡ä»¶:\")\n        for line in lines:\n            if line.strip():\n                print(f\"    {line}\")\n        \n        # éªŒè¯ï¼šsubtree_only åº”è¯¥æ‰«ææ›´å°‘çš„æ–‡ä»¶\n        if file_count2 < file_count1:\n            print(f\"\\nâœ“ subtree_only ç”Ÿæ•ˆ: {file_count1} â†’ {file_count2} æ–‡ä»¶\")\n        else:\n            print(f\"\\nâš  subtree_only å¯èƒ½æœªç”Ÿæ•ˆ: {file_count1} â†’ {file_count2} æ–‡ä»¶\")\n    else:\n        print(f\"âœ— å¤±è´¥: {result2.error}\")\n\n\nasync def test_git_status_tool():\n    \"\"\"æµ‹è¯• git_status å·¥å…·\"\"\"\n    from daoyoucode.agents.tools.base import ToolContext\n    from daoyoucode.agents.tools.git_tools import GitStatusTool\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯• git_status å·¥å…·\")\n    print(\"=\" * 60)\n    \n    # åˆ›å»ºå·¥å…·\n    tool = GitStatusTool()\n    context = ToolContext(repo_path=Path.cwd().parent)\n    tool.set_context(context)\n    \n    # æ‰§è¡Œ\n    result = await tool.execute(repo_path=\".\")\n    \n    if result.success:\n        print(\"\\nâœ“ git_status æ‰§è¡ŒæˆåŠŸ\")\n        print(\"\\nè¾“å‡º:\")\n        print(result.content)\n        \n        # æ˜¾ç¤ºå…ƒæ•°æ®\n        metadata = result.metadata\n        print(\"\\nå…ƒæ•°æ®:\")\n        print(f\"  åˆ†æ”¯: {metadata.get('branch')}\")\n        print(f\"  ä»“åº“æ ¹ç›®å½•: {metadata.get('repo_root')}\")\n        print(f\"  å·²ä¿®æ”¹æ–‡ä»¶æ•°: {len(metadata.get('modified_files', []))}\")\n        print(f\"  å·²æš‚å­˜æ–‡ä»¶æ•°: {len(metadata.get('staged_files', []))}\")\n        print(f\"  æœªè·Ÿè¸ªæ–‡ä»¶æ•°: {len(metadata.get('untracked_files', []))}\")\n        print(f\"  æ˜¯å¦æœ‰æœªæäº¤æ›´æ”¹: {metadata.get('is_dirty')}\")\n    else:\n        print(f\"\\nâœ— å¤±è´¥: {result.error}\")\n\n\nasync def test_path_consistency():\n    \"\"\"æµ‹è¯•è·¯å¾„ä¸€è‡´æ€§\"\"\"\n    from daoyoucode.agents.tools.base import ToolContext\n    from daoyoucode.agents.tools.repomap_tools import RepoMapTool\n    from daoyoucode.agents.tools.file_tools import ReadFileTool\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•è·¯å¾„ä¸€è‡´æ€§\")\n    print(\"=\" * 60)\n    \n    # åˆ›å»ºå·¥å…·\n    repo_map_tool = RepoMapTool()\n    read_file_tool = ReadFileTool()\n    \n    context = ToolContext(repo_path=Path.cwd().parent)\n    repo_map_tool.set_context(context)\n    read_file_tool.set_context(context)\n    \n    # 1. ä½¿ç”¨ repo_map è·å–æ–‡ä»¶åˆ—è¡¨\n    print(\"\\næ­¥éª¤ 1ï¼šä½¿ç”¨ repo_map è·å–æ–‡ä»¶åˆ—è¡¨\")\n    result1 = await repo_map_tool.execute(\n        repo_path=\".\",\n        max_tokens=500\n    )\n    \n    if not result1.success:\n        print(f\"âœ— rep"
},
{
"path": "tests/test_hooks.py",
"start": 1,
"end": 284,
"text": "#!/usr/bin/env python3\n\"\"\"\næµ‹è¯•Hookç³»ç»Ÿ\n\"\"\"\n\nimport asyncio\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents import (\n    register_hook,\n    get_hook_manager,\n    HookContext,\n)\nfrom daoyoucode.agents.hooks import (\n    LoggingHook,\n    MetricsHook,\n    ValidationHook,\n    RetryHook,\n    create_default_hooks,\n)\n\n\nasync def test_basic_hooks():\n    \"\"\"æµ‹è¯•åŸºæœ¬HookåŠŸèƒ½\"\"\"\n    print(\"=\" * 60)\n    print(\"æµ‹è¯•1: åŸºæœ¬HookåŠŸèƒ½\")\n    print(\"=\" * 60)\n    \n    # æ³¨å†ŒHooks\n    register_hook(LoggingHook())\n    register_hook(MetricsHook())\n    \n    manager = get_hook_manager()\n    \n    # åˆ›å»ºæµ‹è¯•ä¸Šä¸‹æ–‡\n    context = HookContext(\n        skill_name=\"test_skill\",\n        user_input=\"Hello World\",\n        session_id=\"test_session\"\n    )\n    \n    # æµ‹è¯•before hooks\n    print(\"\\n1. è¿è¡Œbefore hooks...\")\n    context = await manager.run_before_hooks(context)\n    print(f\"âœ… Before hookså®Œæˆï¼Œmetadata: {context.metadata}\")\n    \n    # æ¨¡æ‹Ÿæ‰§è¡Œ\n    result = {\n        'success': True,\n        'content': 'Test result',\n        'tokens_used': {'input': 100, 'output': 50}\n    }\n    \n    # æµ‹è¯•after hooks\n    print(\"\\n2. è¿è¡Œafter hooks...\")\n    result = await manager.run_after_hooks(context, result)\n    print(f\"âœ… After hookså®Œæˆ\")\n    print(f\"   Metrics: {result.get('metrics', {})}\")\n    \n    print(\"\\nâœ… åŸºæœ¬HookåŠŸèƒ½æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_validation_hook():\n    \"\"\"æµ‹è¯•éªŒè¯Hook\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•2: éªŒè¯Hook\")\n    print(\"=\" * 60)\n    \n    # æ¸…ç©ºä¹‹å‰çš„hooks\n    manager = get_hook_manager()\n    manager.hooks.clear()\n    \n    # æ³¨å†ŒéªŒè¯Hook\n    validation_hook = ValidationHook(\n        min_length=5,\n        max_length=100,\n        forbidden_words=['spam', 'test']\n    )\n    register_hook(validation_hook)\n    \n    # æµ‹è¯•1: æ­£å¸¸è¾“å…¥\n    print(\"\\n1. æµ‹è¯•æ­£å¸¸è¾“å…¥...\")\n    context = HookContext(\n        skill_name=\"test\",\n        user_input=\"Hello World\",\n        session_id=\"test\"\n    )\n    \n    try:\n        context = await manager.run_before_hooks(context)\n        print(\"âœ… æ­£å¸¸è¾“å…¥éªŒè¯é€šè¿‡\")\n    except ValueError as e:\n        print(f\"âŒ éªŒè¯å¤±è´¥: {e}\")\n    \n    # æµ‹è¯•2: è¾“å…¥å¤ªçŸ­\n    print(\"\\n2. æµ‹è¯•è¾“å…¥å¤ªçŸ­...\")\n    context = HookContext(\n        skill_name=\"test\",\n        user_input=\"Hi\",\n        session_id=\"test\"\n    )\n    \n    try:\n        context = await manager.run_before_hooks(context)\n        print(\"âŒ åº”è¯¥æŠ›å‡ºå¼‚å¸¸\")\n    except ValueError as e:\n        print(f\"âœ… æ­£ç¡®æ•è·å¼‚å¸¸: {e}\")\n    \n    # æµ‹è¯•3: åŒ…å«ç¦ç”¨è¯\n    print(\"\\n3. æµ‹è¯•ç¦ç”¨è¯...\")\n    context = HookContext(\n        skill_name=\"test\",\n        user_input=\"This is a test message\",\n        session_id=\"test\"\n    )\n    \n    try:\n        context = await manager.run_before_hooks(context)\n        print(\"âŒ åº”è¯¥æŠ›å‡ºå¼‚å¸¸\")\n    except ValueError as e:\n        print(f\"âœ… æ­£ç¡®æ•è·å¼‚å¸¸: {e}\")\n    \n    print(\"\\nâœ… éªŒè¯Hookæµ‹è¯•é€šè¿‡\")\n\n\nasync def test_retry_hook():\n    \"\"\"æµ‹è¯•é‡è¯•Hook\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•3: é‡è¯•Hook\")\n    print(\"=\" * 60)\n    \n    # æ¸…ç©ºä¹‹å‰çš„hooks\n    manager = get_hook_manager()\n    manager.hooks.clear()\n    \n    # æ³¨å†Œé‡è¯•Hook\n    retry_hook = RetryHook(\n        max_retries=3,\n        retry_delay=0.1,  # å¿«é€Ÿæµ‹è¯•\n        exponential_backoff=False\n    )\n    register_hook(retry_hook)\n    \n    # æµ‹è¯•é”™è¯¯å¤„ç†\n    print(\"\\n1. æµ‹è¯•é”™è¯¯å¤„ç†...\")\n    context = HookContext(\n        skill_name=\"test\",\n        user_input=\"test\",\n        session_id=\"test\"\n    )\n    \n    error = Exception(\"Test error\")\n    result = await manager.run_error_hooks(context, error)\n    \n    if result is None:\n        print(\"âœ… ç¬¬1æ¬¡å¤±è´¥ï¼Œå‡†å¤‡é‡è¯•\")\n    \n    # å†æ¬¡å¤±è´¥\n    result = await manager.run_error_hooks(context, error)\n    if result is None:\n        print(\"âœ… ç¬¬2æ¬¡å¤±è´¥ï¼Œå‡†å¤‡é‡è¯•\")\n    \n    # ç¬¬3æ¬¡å¤±è´¥\n    result = await manager.run_error_hooks(context, error)\n    if result is None:\n        print(\"âœ… ç¬¬3æ¬¡å¤±è´¥ï¼Œå‡†å¤‡é‡è¯•\")\n    \n    # ç¬¬4æ¬¡å¤±è´¥ï¼ˆè¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼‰\n    result = await manager.run_error_hooks(context, error)\n    if result is not None:\n        print(f\"âœ… è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œè¿”å›é”™è¯¯: {result.get('error')}\")\n    \n    print(\"\\nâœ… é‡è¯•Hookæµ‹è¯•é€šè¿‡\")\n\n\nasync def test_default_hooks():\n    \"\"\"æµ‹è¯•é»˜è®¤Hooké›†åˆ\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹"
},
{
"path": "tests/test_import.py",
"start": 1,
"end": 12,
"text": "import sys\nsys.path.insert(0, '.')\n\ntry:\n    import cli.app\n    print(f\"å¯¼å…¥æˆåŠŸ\")\n    print(f\"æœ‰mainå‡½æ•°: {hasattr(cli.app, 'main')}\")\n    print(f\"æ¨¡å—å†…å®¹: {dir(cli.app)}\")\nexcept Exception as e:\n    print(f\"å¯¼å…¥å¤±è´¥: {e}\")\n    import traceback\n    traceback.print_exc()"
},
{
"path": "tests/test_init_system.py",
"start": 1,
"end": 16,
"text": "\"\"\"\næµ‹è¯•Agentç³»ç»Ÿåˆå§‹åŒ–\n\néªŒè¯å·¥å…·æ³¨å†Œã€Agentæ³¨å†Œã€ç¼–æ’å™¨æ³¨å†Œéƒ½æ­£å¸¸å·¥ä½œ\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nbackend_dir = Path(__file__).parent\nsys.path.insert(0, str(backend_dir))\n\nimport logging\nlogging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')\n"
},
{
"path": "tests/test_init_system.py",
"start": 17,
"end": 101,
"text": "def test_initialization():\n    \"\"\"æµ‹è¯•åˆå§‹åŒ–\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•Agentç³»ç»Ÿåˆå§‹åŒ–\")\n    print(\"=\"*60)\n    \n    # 1. ç¬¬ä¸€æ¬¡åˆå§‹åŒ–\n    print(\"\\n1. ç¬¬ä¸€æ¬¡åˆå§‹åŒ–...\")\n    from daoyoucode.agents.init import initialize_agent_system\n    tool_registry = initialize_agent_system()\n    \n    tools = tool_registry.list_tools()\n    print(f\"   âœ“ å·¥å…·æ•°é‡: {len(tools)}\")\n    print(f\"   âœ“ å·¥å…·åˆ—è¡¨: {', '.join(sorted(tools)[:10])}...\")\n    \n    # æ£€æŸ¥repo_mapæ˜¯å¦å­˜åœ¨\n    if 'repo_map' in tools:\n        print(\"   âœ“ repo_mapå·¥å…·å·²æ³¨å†Œ\")\n    else:\n        print(\"   âœ— repo_mapå·¥å…·æœªæ‰¾åˆ°\")\n        return False\n    \n    # 2. ç¬¬äºŒæ¬¡åˆå§‹åŒ–ï¼ˆåº”è¯¥è·³è¿‡ï¼‰\n    print(\"\\n2. ç¬¬äºŒæ¬¡åˆå§‹åŒ–ï¼ˆåº”è¯¥è·³è¿‡ï¼‰...\")\n    tool_registry2 = initialize_agent_system()\n    \n    # éªŒè¯æ˜¯åŒä¸€ä¸ªå®ä¾‹\n    if id(tool_registry) == id(tool_registry2):\n        print(\"   âœ“ è¿”å›äº†ç›¸åŒçš„å®ä¾‹ï¼ˆå•ä¾‹æ¨¡å¼æ­£ç¡®ï¼‰\")\n    else:\n        print(\"   âœ— è¿”å›äº†ä¸åŒçš„å®ä¾‹ï¼ˆå•ä¾‹æ¨¡å¼å¤±è´¥ï¼‰\")\n        return False\n    \n    # 3. æ£€æŸ¥Agentæ³¨å†Œ\n    print(\"\\n3. æ£€æŸ¥Agentæ³¨å†Œ...\")\n    from daoyoucode.agents.core.agent import get_agent_registry\n    agent_registry = get_agent_registry()\n    agents = agent_registry.list_agents()\n    print(f\"   âœ“ Agentæ•°é‡: {len(agents)}\")\n    print(f\"   âœ“ Agentåˆ—è¡¨: {', '.join(agents)}\")\n    \n    if 'MainAgent' in agents:\n        print(\"   âœ“ MainAgentå·²æ³¨å†Œ\")\n    else:\n        print(\"   âœ— MainAgentæœªæ‰¾åˆ°\")\n        return False\n    \n    # 4. æ£€æŸ¥ç¼–æ’å™¨æ³¨å†Œ\n    print(\"\\n4. æ£€æŸ¥ç¼–æ’å™¨æ³¨å†Œ...\")\n    from daoyoucode.agents.core.orchestrator import get_orchestrator_registry\n    orchestrator_registry = get_orchestrator_registry()\n    orchestrators = orchestrator_registry.list_orchestrators()\n    print(f\"   âœ“ ç¼–æ’å™¨æ•°é‡: {len(orchestrators)}\")\n    print(f\"   âœ“ ç¼–æ’å™¨åˆ—è¡¨: {', '.join(orchestrators)}\")\n    \n    # 5. æµ‹è¯•å·¥å…·æ‰§è¡Œ\n    print(\"\\n5. æµ‹è¯•å·¥å…·æ‰§è¡Œ...\")\n    import asyncio\n    \n    async def test_tool():\n        try:\n            result = await tool_registry.execute_tool(\n                'list_files',\n                directory='.',\n                recursive=False\n            )\n            print(f\"   âœ“ list_fileså·¥å…·æ‰§è¡ŒæˆåŠŸ\")\n            return True\n        except Exception as e:\n            print(f\"   âœ— å·¥å…·æ‰§è¡Œå¤±è´¥: {e}\")\n            return False\n    \n    success = asyncio.run(test_tool())\n    if not success:\n        return False\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"âœ“ æ‰€æœ‰æµ‹è¯•é€šè¿‡\")\n    print(\"=\"*60)\n    return True\n\n\nif __name__ == '__main__':\n    success = test_initialization()\n    sys.exit(0 if success else 1)"
},
{
"path": "tests/test_integration.py",
"start": 1,
"end": 24,
"text": "\"\"\"\né›†æˆæµ‹è¯• - éªŒè¯æ‰€æœ‰ç»„ä»¶æ­£ç¡®è¿æ¥\n\næµ‹è¯•èŒƒå›´ï¼š\n1. Agent + å·¥å…·ç³»ç»Ÿ\n2. Agent + è®°å¿†ç³»ç»Ÿ\n3. Agent + ä¸Šä¸‹æ–‡ç®¡ç†\n4. Agent + RepoMap\n5. Agent + LSPå·¥å…·\n6. å®Œæ•´å·¥ä½œæµ\n\"\"\"\n\nimport pytest\nimport asyncio\nfrom pathlib import Path\nimport tempfile\nimport shutil\n\nfrom daoyoucode.agents.core.agent import BaseAgent, AgentConfig, AgentResult\nfrom daoyoucode.agents.tools import get_tool_registry\nfrom daoyoucode.agents.memory import get_memory_manager\nfrom daoyoucode.agents.core.context import ContextManager\n\n"
},
{
"path": "tests/test_integration.py",
"start": 25,
"end": 110,
"text": "class TestIntegration:\n    \"\"\"é›†æˆæµ‹è¯•\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_agent_with_tools(self):\n        \"\"\"æµ‹è¯•Agent + å·¥å…·ç³»ç»Ÿé›†æˆ\"\"\"\n        # åˆ›å»ºAgent\n        config = AgentConfig(\n            name=\"test_agent\",\n            description=\"æµ‹è¯•Agent\",\n            model=\"gpt-3.5-turbo\",\n            system_prompt=\"ä½ æ˜¯ä¸€ä¸ªæµ‹è¯•åŠ©æ‰‹\"\n        )\n        agent = BaseAgent(config)\n        \n        # è·å–å·¥å…·æ³¨å†Œè¡¨\n        registry = get_tool_registry()\n        tools = registry.list_tools()\n        \n        # éªŒè¯å·¥å…·å·²æ³¨å†Œ\n        assert len(tools) == 25  # 6æ–‡ä»¶+2æœç´¢+4Git+2å‘½ä»¤+1Diff+2RepoMap+6LSP+2AST\n        assert \"read_file\" in tools\n        assert \"write_file\" in tools\n        assert \"repo_map\" in tools\n        assert \"lsp_diagnostics\" in tools\n        assert \"ast_grep_search\" in tools\n        assert \"ast_grep_replace\" in tools\n        \n        print(f\"\\nâœ… å·¥å…·ç³»ç»Ÿé›†æˆæˆåŠŸ: {len(tools)}ä¸ªå·¥å…·å·²æ³¨å†Œ\")\n    \n    @pytest.mark.asyncio\n    async def test_agent_with_memory(self):\n        \"\"\"æµ‹è¯•Agent + è®°å¿†ç³»ç»Ÿé›†æˆ\"\"\"\n        # åˆ›å»ºAgent\n        config = AgentConfig(\n            name=\"test_agent\",\n            description=\"æµ‹è¯•Agent\",\n            model=\"gpt-3.5-turbo\",\n            system_prompt=\"ä½ æ˜¯ä¸€ä¸ªæµ‹è¯•åŠ©æ‰‹\"\n        )\n        agent = BaseAgent(config)\n        \n        # éªŒè¯è®°å¿†ç³»ç»Ÿå·²è¿æ¥\n        assert agent.memory is not None\n        \n        # æµ‹è¯•è®°å¿†åŠŸèƒ½\n        session_id = \"test_session\"\n        agent.memory.add_conversation(session_id, \"ä½ å¥½\", \"ä½ å¥½ï¼æœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©ä½ çš„ï¼Ÿ\")\n        \n        history = agent.memory.get_conversation_history(session_id)\n        assert len(history) > 0\n        \n        print(f\"\\nâœ… è®°å¿†ç³»ç»Ÿé›†æˆæˆåŠŸ: å¯¹è¯å†å²å·²ä¿å­˜\")\n    \n    @pytest.mark.asyncio\n    async def test_agent_with_context(self):\n        \"\"\"æµ‹è¯•Agent + ä¸Šä¸‹æ–‡ç®¡ç†é›†æˆ\"\"\"\n        # åˆ›å»ºä¸Šä¸‹æ–‡ç®¡ç†å™¨\n        context_manager = ContextManager()\n        \n        session_id = \"test_session\"\n        context = context_manager.create_context(session_id)\n        \n        # è®¾ç½®å˜é‡\n        context.set(\"user_name\", \"Alice\")\n        context.set(\"task\", \"ä»£ç å®¡æŸ¥\")\n        \n        # è·å–å˜é‡\n        user_name = context.get(\"user_name\")\n        assert user_name == \"Alice\"\n        \n        # åˆ›å»ºå¿«ç…§\n        snapshot_id = context.create_snapshot(\"åˆå§‹çŠ¶æ€\")\n        assert snapshot_id is not None\n        \n        print(f\"\\nâœ… ä¸Šä¸‹æ–‡ç®¡ç†é›†æˆæˆåŠŸ: å˜é‡å’Œå¿«ç…§åŠŸèƒ½æ­£å¸¸\")\n    \n    @pytest.mark.asyncio\n    async def test_repomap_integration(self):\n        \"\"\"æµ‹è¯•RepoMapé›†æˆ\"\"\"\n        # åˆ›å»ºä¸´æ—¶ä»“åº“\n        with tempfile.TemporaryDirectory() as tmpdir:\n            repo_path = Path(tmpdir)\n            \n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            (repo_path / \"test.py\").write_text(\"\"\""
},
{
"path": "tests/test_integration.py",
"start": 111,
"end": 111,
"text": "class Calculator:"
},
{
"path": "tests/test_integration.py",
"start": 112,
"end": 114,
"text": "    def add(self, a, b):\n        return a + b\n    "
},
{
"path": "tests/test_integration.py",
"start": 115,
"end": 117,
"text": "    def subtract(self, a, b):\n        return a - b\n"
},
{
"path": "tests/test_integration.py",
"start": 118,
"end": 146,
"text": "def main():\n    calc = Calculator()\n    print(calc.add(1, 2))\n\"\"\")\n            \n            # è·å–å·¥å…·æ³¨å†Œè¡¨\n            registry = get_tool_registry()\n            \n            # æ‰§è¡ŒRepoMap\n            result = await registry.execute_tool(\n                \"repo_map\",\n                repo_path=str(repo_path),\n                max_tokens=500\n            )\n            \n            assert result.success\n            # RepoMapå¯èƒ½è¿”å›ç©ºï¼ˆå¦‚æœæ²¡æœ‰å¼•ç”¨å…³ç³»ï¼‰ï¼Œè¿™æ˜¯æ­£å¸¸çš„\n            print(f\"\\nâœ… RepoMapé›†æˆæˆåŠŸ:\")\n            print(f\"   å†…å®¹: {result.content[:200] if result.content else '(ç©º)'}\")\n    \n    @pytest.mark.asyncio\n    async def test_context_with_repomap(self):\n        \"\"\"æµ‹è¯•ä¸Šä¸‹æ–‡ç®¡ç†å™¨ + RepoMapé›†æˆ\"\"\"\n        # åˆ›å»ºä¸´æ—¶ä»“åº“\n        with tempfile.TemporaryDirectory() as tmpdir:\n            repo_path = Path(tmpdir)\n            \n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            (repo_path / \"utils.py\").write_text(\"\"\""
},
{
"path": "tests/test_integration.py",
"start": 147,
"end": 149,
"text": "def format_date(date):\n    return date.strftime(\"%Y-%m-%d\")\n"
},
{
"path": "tests/test_integration.py",
"start": 150,
"end": 305,
"text": "def parse_date(date_str):\n    from datetime import datetime\n    return datetime.strptime(date_str, \"%Y-%m-%d\")\n\"\"\")\n            \n            # åˆ›å»ºä¸Šä¸‹æ–‡ç®¡ç†å™¨\n            context_manager = ContextManager()\n            session_id = \"test_session\"\n            context = context_manager.create_context(session_id)\n            \n            # æ·»åŠ RepoMapåˆ°ä¸Šä¸‹æ–‡\n            await context_manager.add_repo_map(\n                session_id,\n                repo_path=str(repo_path),\n                chat_files=[],\n                mentioned_idents=[\"format_date\"],\n                max_tokens=500\n            )\n            \n            # éªŒè¯RepoMapå·²æ·»åŠ \n            repo_map = context.get(\"repo_map\")\n            assert repo_map is not None\n            \n            print(f\"\\nâœ… ä¸Šä¸‹æ–‡+RepoMapé›†æˆæˆåŠŸ:\")\n            print(f\"   RepoMap: {repo_map[:200] if repo_map else '(ç©º)'}...\")\n    \n    @pytest.mark.asyncio\n    async def test_token_budget_control(self):\n        \"\"\"æµ‹è¯•Tokené¢„ç®—æ§åˆ¶\"\"\"\n        context_manager = ContextManager()\n        session_id = \"test_session\"\n        context = context_manager.create_context(session_id)\n        \n        # æ·»åŠ å¤§é‡å†…å®¹ï¼ˆç¡®ä¿è¶…å‡ºé¢„ç®—ï¼‰\n        for i in range(20):\n            context.set(f\"file_{i}\", \"x\" * 2000)  # æ¯ä¸ªæ–‡ä»¶2000å­—ç¬¦\n        \n        # æ‰§è¡ŒTokené¢„ç®—æ§åˆ¶ï¼ˆè®¾ç½®è¾ƒå°çš„é¢„ç®—ç¡®ä¿ä¼šå‰ªæï¼‰\n        result = context_manager.enforce_token_budget(\n            session_id,\n            token_budget=5000,  # 5000 tokens â‰ˆ 20000å­—ç¬¦ï¼Œä½†æˆ‘ä»¬æœ‰40000å­—ç¬¦\n            priority_keys=[]\n        )\n        \n        assert result['success']\n        assert result['pruned']  # åº”è¯¥å‘ç”Ÿå‰ªæ\n        assert result['final_tokens'] <= result['budget']\n        \n        print(f\"\\nâœ… Tokené¢„ç®—æ§åˆ¶æˆåŠŸ: {result['original_tokens']} -> {result['final_tokens']} tokens\")\n    \n    @pytest.mark.skip(reason=\"Requires real LLM client\")\n    @pytest.mark.asyncio\n    async def test_intelligent_summary(self):\n        \"\"\"æµ‹è¯•æ™ºèƒ½æ‘˜è¦\"\"\"\n        context_manager = ContextManager()\n        session_id = \"test_session\"\n        context = context_manager.create_context(session_id)\n        \n        # æ·»åŠ é•¿æ–‡æœ¬\n        long_text = \"\"\"\n        è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„æ–‡æœ¬ï¼ŒåŒ…å«äº†å¾ˆå¤šä¿¡æ¯ã€‚\n        ç¬¬ä¸€éƒ¨åˆ†è®²è¿°äº†é¡¹ç›®çš„èƒŒæ™¯å’Œç›®æ ‡ã€‚\n        ç¬¬äºŒéƒ¨åˆ†ä»‹ç»äº†æŠ€æœ¯æ¶æ„å’Œå®ç°ç»†èŠ‚ã€‚\n        ç¬¬ä¸‰éƒ¨åˆ†è®¨è®ºäº†æµ‹è¯•ç­–ç•¥å’Œè´¨é‡ä¿è¯ã€‚\n        ç¬¬å››éƒ¨åˆ†å±•æœ›äº†æœªæ¥çš„å‘å±•æ–¹å‘ã€‚\n        \"\"\" * 10\n        \n        context.set(\"long_doc\", long_text)\n        \n        # æ‰§è¡Œæ™ºèƒ½æ‘˜è¦ï¼ˆéœ€è¦çœŸå®LLMï¼‰\n        success = await context_manager.summarize_content(\n            session_id,\n            \"long_doc\",\n            target_ratio=0.33,\n            model=\"gpt-4o-mini\"\n        )\n        \n        assert success\n        \n        # è·å–æ‘˜è¦åçš„å†…å®¹\n        summarized = context.get(\"long_doc\")\n        assert summarized\n        assert len(summarized) < len(long_text)\n        \n        print(f\"\\nâœ… æ™ºèƒ½æ‘˜è¦æˆåŠŸ: {len(long_text)} -> {len(summarized)} å­—ç¬¦\")\n    \n    @pytest.mark.asyncio\n    async def test_file_tools_integration(self):\n        \"\"\"æµ‹è¯•æ–‡ä»¶å·¥å…·é›†æˆ\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            test_file = Path(tmpdir) / \"test.txt\"\n            \n            registry = get_tool_registry()\n            \n            # æµ‹è¯•write_file\n            result = await registry.execute_tool(\n                \"write_file\",\n                file_path=str(test_file),\n                content=\"Hello, World!\"\n            )\n            assert result.success\n            \n            # æµ‹è¯•read_file\n            result = await registry.execute_tool(\n                \"read_file\",\n                file_path=str(test_file)\n            )\n            assert result.success\n            assert result.content == \"Hello, World!\"\n            \n            # æµ‹è¯•list_files\n            result = await registry.execute_tool(\n                \"list_files\",\n                directory=str(tmpdir)\n            )\n            assert result.success\n            assert len(result.content) > 0\n            \n            print(f\"\\nâœ… æ–‡ä»¶å·¥å…·é›†æˆæˆåŠŸ: write/read/list åŠŸèƒ½æ­£å¸¸\")\n    \n    @pytest.mark.asyncio\n    async def test_search_tools_integration(self):\n        \"\"\"æµ‹è¯•æœç´¢å·¥å…·é›†æˆ\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n            (Path(t"
},
{
"path": "tests/test_integration.py",
"start": 306,
"end": 334,
"text": "def hello():\n    print(\"Hello\")\n    return True\n\"\"\")\n            \n            registry = get_tool_registry()\n            \n            # æµ‹è¯•search_replace\n            result = await registry.execute_tool(\n                \"search_replace\",\n                file_path=str(test_file),\n                search='print(\"Hello\")',\n                replace='print(\"Hi there!\")'\n            )\n            assert result.success\n            \n            # éªŒè¯æ›¿æ¢æˆåŠŸ\n            content = test_file.read_text()\n            assert \"Hi there!\" in content\n            \n            print(f\"\\nâœ… Diffå·¥å…·é›†æˆæˆåŠŸ: search_replace åŠŸèƒ½æ­£å¸¸\")\n    \n    @pytest.mark.asyncio\n    async def test_full_workflow(self):\n        \"\"\"æµ‹è¯•å®Œæ•´å·¥ä½œæµï¼šAgent + æ‰€æœ‰ç³»ç»Ÿ\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # 1. åˆ›å»ºæµ‹è¯•ç¯å¢ƒ\n            repo_path = Path(tmpdir)\n            (repo_path / \"main.py\").write_text(\"\"\""
},
{
"path": "tests/test_integration.py",
"start": 335,
"end": 337,
"text": "def calculate(a, b):\n    return a + b\n"
},
{
"path": "tests/test_integration.py",
"start": 338,
"end": 381,
"text": "def main():\n    result = calculate(1, 2)\n    print(result)\n\"\"\")\n            \n            # 2. åˆ›å»ºAgent\n            config = AgentConfig(\n                name=\"code_assistant\",\n                description=\"ä»£ç åŠ©æ‰‹\",\n                model=\"gpt-3.5-turbo\",\n                system_prompt=\"ä½ æ˜¯ä¸€ä¸ªä»£ç åŠ©æ‰‹ï¼Œå¸®åŠ©ç”¨æˆ·åˆ†æå’Œä¿®æ”¹ä»£ç \"\n            )\n            agent = BaseAgent(config)\n            \n            # 3. åˆ›å»ºä¸Šä¸‹æ–‡\n            context_manager = ContextManager()\n            session_id = \"workflow_test\"\n            context_manager.create_context(session_id)\n            \n            # 4. æ·»åŠ RepoMapåˆ°ä¸Šä¸‹æ–‡\n            await context_manager.add_repo_map(\n                session_id,\n                repo_path=str(repo_path),\n                chat_files=[],\n                mentioned_idents=[\"calculate\"],\n                max_tokens=1000\n            )\n            \n            # 5. è·å–ä¸Šä¸‹æ–‡\n            context = context_manager.get_context(session_id)\n            \n            # 6. éªŒè¯é›†æˆ\n            assert agent.memory is not None  # è®°å¿†ç³»ç»Ÿ\n            assert context.get(\"repo_map\") is not None  # RepoMap\n            assert len(get_tool_registry().list_tools()) == 25  # å·¥å…·ç³»ç»Ÿ\n            \n            print(f\"\\nâœ… å®Œæ•´å·¥ä½œæµé›†æˆæˆåŠŸ:\")\n            print(f\"   - Agent: {agent.name}\")\n            print(f\"   - è®°å¿†ç³»ç»Ÿ: å·²è¿æ¥\")\n            print(f\"   - ä¸Šä¸‹æ–‡ç®¡ç†: å·²åˆ›å»º\")\n            print(f\"   - RepoMap: å·²æ·»åŠ \")\n            print(f\"   - å·¥å…·ç³»ç»Ÿ: {len(get_tool_registry().list_tools())}ä¸ªå·¥å…·\")\n\n"
},
{
"path": "tests/test_integration.py",
"start": 382,
"end": 384,
"text": "class TestToolRegistry:\n    \"\"\"å·¥å…·æ³¨å†Œè¡¨æµ‹è¯•\"\"\"\n    "
},
{
"path": "tests/test_integration.py",
"start": 385,
"end": 435,
"text": "    def test_all_tools_registered(self):\n        \"\"\"æµ‹è¯•æ‰€æœ‰å·¥å…·å·²æ³¨å†Œ\"\"\"\n        registry = get_tool_registry()\n        tools = registry.list_tools()\n        \n        # éªŒè¯å·¥å…·æ•°é‡\n        assert len(tools) == 25\n        \n        # éªŒè¯æ–‡ä»¶å·¥å…·ï¼ˆ6ä¸ªï¼‰\n        assert \"read_file\" in tools\n        assert \"write_file\" in tools\n        assert \"list_files\" in tools\n        assert \"get_file_info\" in tools\n        assert \"create_directory\" in tools\n        assert \"delete_file\" in tools\n        \n        # éªŒè¯æœç´¢å·¥å…·ï¼ˆ2ä¸ªï¼‰\n        assert \"text_search\" in tools\n        assert \"regex_search\" in tools\n        \n        # éªŒè¯Gitå·¥å…·ï¼ˆ4ä¸ªï¼‰\n        assert \"git_status\" in tools\n        assert \"git_diff\" in tools\n        assert \"git_commit\" in tools\n        assert \"git_log\" in tools\n        \n        # éªŒè¯å‘½ä»¤å·¥å…·ï¼ˆ2ä¸ªï¼‰\n        assert \"run_command\" in tools\n        assert \"run_test\" in tools\n        \n        # éªŒè¯Diffå·¥å…·ï¼ˆ1ä¸ªï¼‰\n        assert \"search_replace\" in tools\n        \n        # éªŒè¯RepoMapå·¥å…·ï¼ˆ2ä¸ªï¼‰\n        assert \"repo_map\" in tools\n        assert \"get_repo_structure\" in tools\n        \n        # éªŒè¯LSPå·¥å…·ï¼ˆ6ä¸ªï¼‰\n        assert \"lsp_diagnostics\" in tools\n        assert \"lsp_goto_definition\" in tools\n        assert \"lsp_find_references\" in tools\n        assert \"lsp_symbols\" in tools\n        assert \"lsp_rename\" in tools\n        assert \"lsp_code_actions\" in tools\n        \n        # éªŒè¯ASTå·¥å…·ï¼ˆ2ä¸ªï¼‰\n        assert \"ast_grep_search\" in tools\n        assert \"ast_grep_replace\" in tools\n        \n        print(f\"\\nâœ… æ‰€æœ‰25ä¸ªå·¥å…·å·²æ­£ç¡®æ³¨å†Œ\")\n    "
},
{
"path": "tests/test_integration.py",
"start": 436,
"end": 457,
"text": "    def test_get_function_schemas(self):\n        \"\"\"æµ‹è¯•è·å–Function schemas\"\"\"\n        registry = get_tool_registry()\n        \n        # è·å–éƒ¨åˆ†å·¥å…·çš„schemas\n        schemas = registry.get_function_schemas([\n            \"read_file\",\n            \"write_file\",\n            \"repo_map\"\n        ])\n        \n        assert len(schemas) == 3\n        \n        # éªŒè¯schemaæ ¼å¼\n        for schema in schemas:\n            assert \"name\" in schema\n            assert \"description\" in schema\n            assert \"parameters\" in schema\n        \n        print(f\"\\nâœ… Function schemas æ ¼å¼æ­£ç¡®\")\n\n"
},
{
"path": "tests/test_integration.py",
"start": 458,
"end": 460,
"text": "class TestMemoryIntegration:\n    \"\"\"è®°å¿†ç³»ç»Ÿé›†æˆæµ‹è¯•\"\"\"\n    "
},
{
"path": "tests/test_integration.py",
"start": 461,
"end": 471,
"text": "    def test_memory_singleton(self):\n        \"\"\"æµ‹è¯•è®°å¿†ç³»ç»Ÿå•ä¾‹\"\"\"\n        from daoyoucode.agents.memory import get_memory_manager\n        \n        manager1 = get_memory_manager()\n        manager2 = get_memory_manager()\n        \n        assert manager1 is manager2\n        \n        print(f\"\\nâœ… è®°å¿†ç³»ç»Ÿå•ä¾‹æ¨¡å¼æ­£å¸¸\")\n    "
},
{
"path": "tests/test_integration.py",
"start": 472,
"end": 488,
"text": "    def test_conversation_memory(self):\n        \"\"\"æµ‹è¯•å¯¹è¯è®°å¿†\"\"\"\n        from daoyoucode.agents.memory import get_memory_manager\n        \n        manager = get_memory_manager()\n        session_id = \"test_conv\"\n        \n        # æ·»åŠ å¯¹è¯\n        manager.add_conversation(session_id, \"ä½ å¥½\", \"ä½ å¥½ï¼\")\n        manager.add_conversation(session_id, \"å¤©æ°”å¦‚ä½•\", \"ä»Šå¤©å¤©æ°”ä¸é”™\")\n        \n        # è·å–å†å²\n        history = manager.get_conversation_history(session_id)\n        assert len(history) >= 2\n        \n        print(f\"\\nâœ… å¯¹è¯è®°å¿†åŠŸèƒ½æ­£å¸¸: {len(history)}è½®å¯¹è¯\")\n    "
},
{
"path": "tests/test_integration.py",
"start": 489,
"end": 512,
"text": "    def test_task_memory(self):\n        \"\"\"æµ‹è¯•ä»»åŠ¡è®°å¿†\"\"\"\n        from daoyoucode.agents.memory import get_memory_manager\n        \n        manager = get_memory_manager()\n        user_id = \"test_user\"\n        \n        # æ·»åŠ ä»»åŠ¡\n        manager.add_task(user_id, {\n            'agent': 'test_agent',\n            'input': 'åˆ†æä»£ç ',\n            'result': 'åˆ†æå®Œæˆ',\n            'success': True\n        })\n        \n        # è·å–å†å²\n        history = manager.get_task_history(user_id)\n        assert len(history) > 0\n        \n        print(f\"\\nâœ… ä»»åŠ¡è®°å¿†åŠŸèƒ½æ­£å¸¸: {len(history)}ä¸ªä»»åŠ¡\")\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\", \"-s\"])"
},
{
"path": "tests/test_intelligence_features.py",
"start": 1,
"end": 18,
"text": "\"\"\"\næµ‹è¯•æ™ºèƒ½åŒ–åŠŸèƒ½ï¼šæ¨¡å‹é€‰æ‹©ã€ä¸Šä¸‹æ–‡é€‰æ‹©ã€å§”æ‰˜ã€è¡Œä¸ºæŒ‡å—ç­‰\n\"\"\"\n\nimport pytest\nimport asyncio\nfrom pathlib import Path\nfrom daoyoucode.agents.core.model_selector import ModelSelector, get_model_selector\nfrom daoyoucode.agents.core.context_selector import ContextSelector\nfrom daoyoucode.agents.core.delegation import DelegationPrompt, DelegationManager, create_delegation_prompt\nfrom daoyoucode.agents.core.behavior_guide import BehaviorGuide, Phase, RequestType, CodebaseState\nfrom daoyoucode.agents.core.codebase_assessor import CodebaseAssessor\nfrom daoyoucode.agents.core.parallel_executor import ParallelExecutor, get_parallel_executor\nfrom daoyoucode.agents.core.session import SessionManager, get_session_manager\n\n\n# ==================== æ¨¡å‹é€‰æ‹©å™¨æµ‹è¯• ====================\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 19,
"end": 25,
"text": "def test_model_selector_singleton():\n    \"\"\"æµ‹è¯•æ¨¡å‹é€‰æ‹©å™¨å•ä¾‹\"\"\"\n    selector1 = ModelSelector()\n    selector2 = ModelSelector()\n    assert selector1 is selector2\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 26,
"end": 39,
"text": "def test_model_selector_configure():\n    \"\"\"æµ‹è¯•æ¨¡å‹é…ç½®\"\"\"\n    selector = get_model_selector()\n    selector.configure(\n        main_model='gpt-4',\n        weak_model='gpt-3.5-turbo',\n        editor_model='gpt-4-turbo'\n    )\n    \n    assert selector.main_model == 'gpt-4'\n    assert selector.weak_model == 'gpt-3.5-turbo'\n    assert selector.editor_model == 'gpt-4-turbo'\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 40,
"end": 49,
"text": "def test_model_selector_simple_task():\n    \"\"\"æµ‹è¯•ç®€å•ä»»åŠ¡é€‰æ‹©\"\"\"\n    selector = get_model_selector()\n    selector.configure('gpt-4', 'gpt-3.5-turbo', 'gpt-4-turbo')\n    \n    model, task_type = selector.select_model('æ·»åŠ æ³¨é‡Š', context_size=5000)\n    assert task_type == 'weak'\n    assert model == 'gpt-3.5-turbo'\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 50,
"end": 59,
"text": "def test_model_selector_complex_task():\n    \"\"\"æµ‹è¯•å¤æ‚ä»»åŠ¡é€‰æ‹©\"\"\"\n    selector = get_model_selector()\n    selector.configure('gpt-4', 'gpt-3.5-turbo', 'gpt-4-turbo')\n    \n    model, task_type = selector.select_model('é‡æ„æ•´ä¸ªç³»ç»Ÿæ¶æ„', context_size=100000)\n    assert task_type == 'main'\n    assert model == 'gpt-4'\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 60,
"end": 71,
"text": "def test_model_selector_edit_task():\n    \"\"\"æµ‹è¯•ç¼–è¾‘ä»»åŠ¡é€‰æ‹©\"\"\"\n    selector = get_model_selector()\n    selector.configure('gpt-4', 'gpt-3.5-turbo', 'gpt-4-turbo')\n    \n    model, task_type = selector.select_model('ä¿®æ”¹ä»£ç å®ç°', context_size=20000)\n    assert task_type == 'editor'\n    assert model == 'gpt-4-turbo'\n\n\n# ==================== ä¸Šä¸‹æ–‡é€‰æ‹©å™¨æµ‹è¯• ====================\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 72,
"end": 82,
"text": "def test_context_selector_extract_files():\n    \"\"\"æµ‹è¯•æå–æ–‡ä»¶è·¯å¾„\"\"\"\n    selector = ContextSelector(Path('.'))\n    \n    instruction = \"ä¿®æ”¹ `src/main.py` å’Œ 'tests/test_main.py' æ–‡ä»¶\"\n    references = selector._extract_references(instruction)\n    \n    assert 'src/main.py' in references['files']\n    assert 'tests/test_main.py' in references['files']\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 83,
"end": 93,
"text": "def test_context_selector_extract_functions():\n    \"\"\"æµ‹è¯•æå–å‡½æ•°å\"\"\"\n    selector = ContextSelector(Path('.'))\n    \n    instruction = \"ä¿®æ”¹å‡½æ•° `calculate_total` å’Œæ–¹æ³• process_data\"\n    references = selector._extract_references(instruction)\n    \n    assert 'calculate_total' in references['functions']\n    assert 'process_data' in references['functions']\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 94,
"end": 106,
"text": "def test_context_selector_extract_classes():\n    \"\"\"æµ‹è¯•æå–ç±»å\"\"\"\n    selector = ContextSelector(Path('.'))\n    \n    instruction = \"ä¿®æ”¹ç±» `UserManager` å’Œ DataProcessor\"\n    references = selector._extract_references(instruction)\n    \n    assert 'UserManager' in references['classes']\n    assert 'DataProcessor' in references['classes']\n\n\n# ==================== å§”æ‰˜ç³»ç»Ÿæµ‹è¯• ====================\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 107,
"end": 123,
"text": "def test_delegation_prompt_creation():\n    \"\"\"æµ‹è¯•å§”æ‰˜æç¤ºåˆ›å»º\"\"\"\n    prompt = DelegationPrompt(\n        task=\"å®ç°ç”¨æˆ·è®¤è¯åŠŸèƒ½\",\n        expected_outcome=\"å®Œæ•´çš„è®¤è¯ç³»ç»Ÿï¼ŒåŒ…æ‹¬ç™»å½•ã€æ³¨å†Œã€å¯†ç é‡ç½®\",\n        required_skills=[\"authentication\", \"security\"],\n        required_tools=[\"read_file\", \"write_file\"],\n        must_do=[\"ä½¿ç”¨bcryptåŠ å¯†å¯†ç \", \"å®ç°JWT token\"],\n        must_not_do=[\"æ˜æ–‡å­˜å‚¨å¯†ç \", \"ä½¿ç”¨å¼±åŠ å¯†ç®—æ³•\"],\n        context={'framework': 'FastAPI', 'database': 'PostgreSQL'}\n    )\n    \n    assert prompt.task == \"å®ç°ç”¨æˆ·è®¤è¯åŠŸèƒ½\"\n    assert len(prompt.required_skills) == 2\n    assert len(prompt.must_do) == 2\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 124,
"end": 142,
"text": "def test_delegation_prompt_to_prompt():\n    \"\"\"æµ‹è¯•å§”æ‰˜æç¤ºè½¬æ¢\"\"\"\n    prompt = create_delegation_prompt(\n        task=\"æµ‹è¯•ä»»åŠ¡\",\n        expected_outcome=\"æµ‹è¯•ç»“æœ\",\n        required_skills=[\"skill1\"],\n        must_do=[\"do this\"],\n        must_not_do=[\"don't do that\"]\n    )\n    \n    prompt_text = prompt.to_prompt()\n    \n    assert \"## TASK\" in prompt_text\n    assert \"## EXPECTED OUTCOME\" in prompt_text\n    assert \"## REQUIRED SKILLS\" in prompt_text\n    assert \"## MUST DO\" in prompt_text\n    assert \"## MUST NOT DO\" in prompt_text\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 143,
"end": 161,
"text": "def test_delegation_prompt_validate():\n    \"\"\"æµ‹è¯•å§”æ‰˜æç¤ºéªŒè¯\"\"\"\n    # å®Œæ•´æç¤º\n    valid_prompt = DelegationPrompt(\n        task=\"ä»»åŠ¡\",\n        expected_outcome=\"ç»“æœ\"\n    )\n    assert valid_prompt.validate() is True\n    \n    # ç¼ºå°‘ä»»åŠ¡\n    invalid_prompt = DelegationPrompt(\n        task=\"\",\n        expected_outcome=\"ç»“æœ\"\n    )\n    assert invalid_prompt.validate() is False\n\n\n# ==================== è¡Œä¸ºæŒ‡å—æµ‹è¯• ====================\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 162,
"end": 177,
"text": "def test_behavior_guide_classify_request():\n    \"\"\"æµ‹è¯•è¯·æ±‚åˆ†ç±»\"\"\"\n    # æµ‹è¯•é—²èŠ\n    assert BehaviorGuide.classify_request(\"ä½ å¥½\") == RequestType.CHAT\n    assert BehaviorGuide.classify_request(\"Hello\") == RequestType.CHAT\n    assert BehaviorGuide.classify_request(\"How are you?\") == RequestType.CHAT\n    assert BehaviorGuide.classify_request(\"è°¢è°¢\") == RequestType.CHAT\n    assert BehaviorGuide.classify_request(\"ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ\") == RequestType.CHAT\n    \n    # æµ‹è¯•ä»£ç ç›¸å…³\n    assert BehaviorGuide.classify_request(\"æ·»åŠ æ³¨é‡Š\") == RequestType.TRIVIAL\n    assert BehaviorGuide.classify_request(\"å¦‚ä½•å®ç°è®¤è¯åŠŸèƒ½\") == RequestType.EXPLORATORY\n    assert BehaviorGuide.classify_request(\"é‡æ„æ•´ä¸ªç³»ç»Ÿ\") == RequestType.OPEN_ENDED\n    assert BehaviorGuide.classify_request(\"look into this bug and create PR\") == RequestType.GITHUB_WORK\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 178,
"end": 193,
"text": "def test_behavior_guide_get_action():\n    \"\"\"æµ‹è¯•è·å–è¡ŒåŠ¨\"\"\"\n    # æµ‹è¯•é—²èŠ\n    action = BehaviorGuide.get_action(RequestType.CHAT)\n    assert action['action'] == 'respond_directly'\n    assert action['use_simple_flow'] is True\n    assert 'ä»£ç åº“è¯„ä¼°' in action['skip_steps']\n    \n    # æµ‹è¯•ä»£ç ä»»åŠ¡\n    action = BehaviorGuide.get_action_for_request(RequestType.TRIVIAL)\n    assert action == 'use_direct_tools'\n    \n    action = BehaviorGuide.get_action_for_request(RequestType.EXPLORATORY)\n    assert action == 'fire_explore_parallel'\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 194,
"end": 217,
"text": "def test_behavior_guide_should_ask_clarification():\n    \"\"\"æµ‹è¯•æ˜¯å¦éœ€è¦æ¾„æ¸…\"\"\"\n    # ç¼ºå°‘å…³é”®ä¿¡æ¯\n    assert BehaviorGuide.should_ask_clarification(\n        \"åšç‚¹ä»€ä¹ˆ\",\n        missing_critical_info=True\n    ) is True\n    \n    # å·¥ä½œé‡å·®å¼‚å¤§\n    assert BehaviorGuide.should_ask_clarification(\n        \"å®ç°åŠŸèƒ½\",\n        multiple_interpretations=True,\n        effort_difference=3.0\n    ) is True\n    \n    # æ­£å¸¸æƒ…å†µ\n    assert BehaviorGuide.should_ask_clarification(\n        \"æ·»åŠ æ³¨é‡Šåˆ°main.py\",\n        multiple_interpretations=False\n    ) is False\n\n\n# ==================== ä»£ç åº“è¯„ä¼°å™¨æµ‹è¯• ====================\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 218,
"end": 223,
"text": "def test_codebase_assessor_creation():\n    \"\"\"æµ‹è¯•ä»£ç åº“è¯„ä¼°å™¨åˆ›å»º\"\"\"\n    assessor = CodebaseAssessor(Path('.'))\n    assert assessor.repo_path == Path('.')\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 224,
"end": 236,
"text": "def test_codebase_assessor_get_behavior_guide():\n    \"\"\"æµ‹è¯•è·å–è¡Œä¸ºæŒ‡å—\"\"\"\n    assessor = CodebaseAssessor(Path('.'))\n    \n    guide = assessor.get_behavior_guide(CodebaseState.DISCIPLINED)\n    assert guide['approach'] == 'follow_existing_patterns'\n    \n    guide = assessor.get_behavior_guide(CodebaseState.CHAOTIC)\n    assert guide['approach'] == 'propose_standards'\n\n\n# ==================== å¹¶è¡Œæ‰§è¡Œå™¨æµ‹è¯• ====================\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 237,
"end": 291,
"text": "def test_parallel_executor_singleton():\n    \"\"\"æµ‹è¯•å¹¶è¡Œæ‰§è¡Œå™¨å•ä¾‹\"\"\"\n    executor1 = ParallelExecutor()\n    executor2 = ParallelExecutor()\n    assert executor1 is executor2\n\n\n@pytest.mark.asyncio\nasync def test_parallel_executor_submit():\n    \"\"\"æµ‹è¯•æäº¤ä»»åŠ¡\"\"\"\n    executor = get_parallel_executor()\n    \n    async def dummy_task():\n        await asyncio.sleep(0.1)\n        return {'status': 'success', 'data': 'test'}\n    \n    task_id = await executor.submit('test_task', dummy_task())\n    assert task_id == 'test_task'\n    assert executor.get_status('test_task') == 'running'\n\n\n@pytest.mark.asyncio\nasync def test_parallel_executor_get_result():\n    \"\"\"æµ‹è¯•è·å–ç»“æœ\"\"\"\n    executor = get_parallel_executor()\n    \n    async def dummy_task():\n        await asyncio.sleep(0.1)\n        return {'status': 'success', 'data': 'test'}\n    \n    task_id = await executor.submit('test_task_2', dummy_task())\n    result = await executor.get_result(task_id)\n    \n    assert result['status'] == 'success'\n    assert result['data'] == 'test'\n\n\n@pytest.mark.asyncio\nasync def test_parallel_executor_cancel():\n    \"\"\"æµ‹è¯•å–æ¶ˆä»»åŠ¡\"\"\"\n    executor = get_parallel_executor()\n    \n    async def long_task():\n        await asyncio.sleep(10)\n        return {'status': 'success'}\n    \n    task_id = await executor.submit('test_task_3', long_task())\n    success = executor.cancel(task_id)\n    \n    assert success is True\n    assert executor.get_status(task_id) == 'cancelled'\n\n\n# ==================== ä¼šè¯ç®¡ç†å™¨æµ‹è¯• ====================\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 292,
"end": 298,
"text": "def test_session_manager_singleton():\n    \"\"\"æµ‹è¯•ä¼šè¯ç®¡ç†å™¨å•ä¾‹\"\"\"\n    manager1 = SessionManager()\n    manager2 = SessionManager()\n    assert manager1 is manager2\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 299,
"end": 302,
"text": "def test_session_manager_create_session():\n    \"\"\"æµ‹è¯•åˆ›å»ºä¼šè¯\"\"\"\n    manager = get_session_manager()\n    "
},
{
"path": "tests/test_intelligence_features.py",
"start": 303,
"end": 318,
"text": "    class DummyAgent:\n        async def execute(self, instruction, **kwargs):\n            return {'status': 'success'}\n    \n    agent = DummyAgent()\n    session_id = manager.create_session(agent)\n    \n    assert session_id.startswith('ses_')\n    assert manager.get_session(session_id) is not None\n\n\n@pytest.mark.asyncio\nasync def test_session_manager_execute():\n    \"\"\"æµ‹è¯•ä¼šè¯æ‰§è¡Œ\"\"\"\n    manager = get_session_manager()\n    "
},
{
"path": "tests/test_intelligence_features.py",
"start": 319,
"end": 331,
"text": "    class DummyAgent:\n        async def execute(self, instruction, **kwargs):\n            return {'status': 'success', 'instruction': instruction}\n    \n    agent = DummyAgent()\n    session_id = manager.create_session(agent, 'test_session')\n    \n    result = await manager.execute(session_id, 'test instruction')\n    \n    assert result['status'] == 'success'\n    assert result['instruction'] == 'test instruction'\n\n"
},
{
"path": "tests/test_intelligence_features.py",
"start": 332,
"end": 335,
"text": "def test_session_manager_delete_session():\n    \"\"\"æµ‹è¯•åˆ é™¤ä¼šè¯\"\"\"\n    manager = get_session_manager()\n    "
},
{
"path": "tests/test_intelligence_features.py",
"start": 336,
"end": 349,
"text": "    class DummyAgent:\n        async def execute(self, instruction, **kwargs):\n            return {'status': 'success'}\n    \n    agent = DummyAgent()\n    session_id = manager.create_session(agent, 'test_session_delete')\n    \n    success = manager.delete_session(session_id)\n    assert success is True\n    assert manager.get_session(session_id) is None\n\n\nif __name__ == '__main__':\n    pytest.main([__file__, '-v'])"
},
{
"path": "tests/test_intelligent_router.py",
"start": 1,
"end": 220,
"text": "\"\"\"\næµ‹è¯•IntelligentRouter\n\"\"\"\n\nimport asyncio\nfrom daoyoucode.agents.core.router import get_intelligent_router\n\n\nasync def test_exploration_task():\n    \"\"\"æµ‹è¯•æ¢ç´¢ä»»åŠ¡è·¯ç”±\"\"\"\n    print(\"\\n=== æµ‹è¯•1: æ¢ç´¢ä»»åŠ¡ ===\")\n    \n    router = get_intelligent_router()\n    \n    decision = await router.route(\"æŸ¥æ‰¾æ‰€æœ‰Pythonæ–‡ä»¶ä¸­çš„å‡½æ•°å®šä¹‰\")\n    \n    print(f\"âœ“ ç”¨æˆ·è¾“å…¥: æŸ¥æ‰¾æ‰€æœ‰Pythonæ–‡ä»¶ä¸­çš„å‡½æ•°å®šä¹‰\")\n    print(f\"  ç¼–æ’å™¨: {decision.orchestrator}\")\n    print(f\"  Agent: {decision.agent}\")\n    print(f\"  ç½®ä¿¡åº¦: {decision.confidence:.2f}\")\n    print(f\"  ç†ç”±: {decision.reasoning}\")\n    \n    assert decision.orchestrator == \"parallel_explore\"\n    assert decision.agent == \"code_analyzer\"\n\n\nasync def test_workflow_task():\n    \"\"\"æµ‹è¯•å·¥ä½œæµä»»åŠ¡è·¯ç”±\"\"\"\n    print(\"\\n=== æµ‹è¯•2: å·¥ä½œæµä»»åŠ¡ ===\")\n    \n    router = get_intelligent_router()\n    \n    decision = await router.route(\n        \"å…ˆåˆ†æä»£ç ç»“æ„ï¼Œç„¶åç”Ÿæˆé‡æ„è®¡åˆ’ï¼Œæœ€åæ‰§è¡Œé‡æ„\"\n    )\n    \n    print(f\"âœ“ ç”¨æˆ·è¾“å…¥: å…ˆåˆ†æä»£ç ç»“æ„ï¼Œç„¶åç”Ÿæˆé‡æ„è®¡åˆ’ï¼Œæœ€åæ‰§è¡Œé‡æ„\")\n    print(f\"  ç¼–æ’å™¨: {decision.orchestrator}\")\n    print(f\"  Agent: {decision.agent}\")\n    print(f\"  ç½®ä¿¡åº¦: {decision.confidence:.2f}\")\n    print(f\"  ç†ç”±: {decision.reasoning}\")\n    \n    assert decision.orchestrator == \"workflow\"\n\n\nasync def test_conditional_task():\n    \"\"\"æµ‹è¯•æ¡ä»¶ä»»åŠ¡è·¯ç”±\"\"\"\n    print(\"\\n=== æµ‹è¯•3: æ¡ä»¶ä»»åŠ¡ ===\")\n    \n    router = get_intelligent_router()\n    \n    decision = await router.route(\n        \"å¦‚æœä»£ç æœ‰bugå°±ä¿®å¤ï¼Œå¦åˆ™è¿›è¡Œä¼˜åŒ–\"\n    )\n    \n    print(f\"âœ“ ç”¨æˆ·è¾“å…¥: å¦‚æœä»£ç æœ‰bugå°±ä¿®å¤ï¼Œå¦åˆ™è¿›è¡Œä¼˜åŒ–\")\n    print(f\"  ç¼–æ’å™¨: {decision.orchestrator}\")\n    print(f\"  Agent: {decision.agent}\")\n    print(f\"  ç½®ä¿¡åº¦: {decision.confidence:.2f}\")\n    print(f\"  ç†ç”±: {decision.reasoning}\")\n    \n    assert decision.orchestrator == \"conditional\"\n\n\nasync def test_debate_task():\n    \"\"\"æµ‹è¯•è¾©è®ºä»»åŠ¡è·¯ç”±\"\"\"\n    print(\"\\n=== æµ‹è¯•4: è¾©è®ºä»»åŠ¡ ===\")\n    \n    router = get_intelligent_router()\n    \n    decision = await router.route(\n        \"ä»å¤šè§’åº¦è®¨è®ºè¿™ä¸ªè®¾è®¡æ–¹æ¡ˆçš„ä¼˜ç¼ºç‚¹\"\n    )\n    \n    print(f\"âœ“ ç”¨æˆ·è¾“å…¥: ä»å¤šè§’åº¦è®¨è®ºè¿™ä¸ªè®¾è®¡æ–¹æ¡ˆçš„ä¼˜ç¼ºç‚¹\")\n    print(f\"  ç¼–æ’å™¨: {decision.orchestrator}\")\n    print(f\"  Agent: {decision.agent}\")\n    print(f\"  ç½®ä¿¡åº¦: {decision.confidence:.2f}\")\n    print(f\"  ç†ç”±: {decision.reasoning}\")\n    \n    assert decision.orchestrator == \"multi_agent\"\n\n\nasync def test_parallel_task():\n    \"\"\"æµ‹è¯•å¹¶è¡Œä»»åŠ¡è·¯ç”±\"\"\"\n    print(\"\\n=== æµ‹è¯•5: å¹¶è¡Œä»»åŠ¡ ===\")\n    \n    router = get_intelligent_router()\n    \n    decision = await router.route(\n        \"æ‰¹é‡å¤„ç†æ‰€æœ‰æµ‹è¯•æ–‡ä»¶\"\n    )\n    \n    print(f\"âœ“ ç”¨æˆ·è¾“å…¥: æ‰¹é‡å¤„ç†æ‰€æœ‰æµ‹è¯•æ–‡ä»¶\")\n    print(f\"  ç¼–æ’å™¨: {decision.orchestrator}\")\n    print(f\"  Agent: {decision.agent}\")\n    print(f\"  ç½®ä¿¡åº¦: {decision.confidence:.2f}\")\n    print(f\"  ç†ç”±: {decision.reasoning}\")\n    \n    # å¯èƒ½æ˜¯parallelæˆ–parallel_explore\n    assert decision.orchestrator in [\"parallel\", \"parallel_explore\"]\n\n\nasync def test_simple_task():\n    \"\"\"æµ‹è¯•ç®€å•ä»»åŠ¡è·¯ç”±\"\"\"\n    print(\"\\n=== æµ‹è¯•6: ç®€å•ä»»åŠ¡ ===\")\n    \n    router = get_intelligent_router()\n    \n    decision = await router.route(\"ç”Ÿæˆä¸€ä¸ªHello Worldå‡½æ•°\")\n    \n    print(f\"âœ“ ç”¨æˆ·è¾“å…¥: ç”Ÿæˆä¸€ä¸ªHello Worldå‡½æ•°\")\n    print(f\"  ç¼–æ’å™¨: {decision.orchestrator}\")\n    print(f\"  Agent: {decision.agent}\")\n    print(f\"  ç½®ä¿¡åº¦: {decision.confidence:.2f}\")\n    print(f\"  ç†ç”±: {decision.reasoning}\")\n    \n    assert decision.orchestrator == \"simple\"\n    assert decision.agent == \"code_writer\"\n\n\nasync def test_agent_selection():\n    \"\"\"æµ‹è¯•Agenté€‰æ‹©\"\"\"\n    print(\"\\n=== æµ‹è¯•7: Agenté€‰æ‹© ===\")\n    \n    router = get_intelligent_router()\n    \n    test_cases = [\n        (\"åˆ†æä»£ç ç»“æ„\", \"code_analyzer\"),\n        (\"ç¼–å†™æµ‹è¯•ç”¨ä¾‹\", \"test_writer\"),\n        (\"ç”ŸæˆAPIæ–‡æ¡£\", \"doc_writer\"),\n        (\"ä¿®å¤è¿™ä¸ªbug\", \"debugger\"),\n        (\"é‡æ„è¿™æ®µä»£ç \", \"code_reviewer\"),\n    ]\n    \n    for user_input, expected_agent in test_cases:\n        decision = await router.route(user_input)\n        print(f\"âœ“ '{user_input}' -> {decision.agent}\")\n        assert decision.agent == expected_agent\n\n\nasync def test_complexity_calculation():\n    \"\"\"æµ‹è¯•å¤æ‚åº¦è®¡ç®—\"\"\"\n    print(\"\\n=== æµ‹è¯•8: å¤æ‚åº¦è®¡ç®— ===\")\n    \n    router = get_intelligent_router()\n    \n    test_cases = [\n        (\"ç®€å•ä»»åŠ¡\", 1),\n        (\"å…ˆåšAï¼Œç„¶ååšBï¼Œæœ€ååšC\", 2),\n        (\"å¦‚æœæ¡ä»¶æ»¡è¶³ï¼Œå°±æ‰§è¡Œæ­¥éª¤1ã€æ­¥éª¤2ã€æ­¥éª¤3ï¼Œå¦åˆ™æ‰§è¡Œæ­¥éª¤4ã€æ­¥éª¤5\", 3),\n    ]\n    \n    for user_input, min_complexity in test_cases:\n        decision = await router.route(user_inp"
},
{
"path": "tests/test_llm_config.py",
"start": 1,
"end": 13,
"text": "\"\"\"\næµ‹è¯•LLMé…ç½®åŠ è½½\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents.llm.client_manager import get_client_manager\nfrom daoyoucode.agents.llm.config_loader import auto_configure\n"
},
{
"path": "tests/test_llm_config.py",
"start": 14,
"end": 62,
"text": "def test_config():\n    print(\"=\"*60)\n    print(\"æµ‹è¯•LLMé…ç½®åŠ è½½\")\n    print(\"=\"*60)\n    \n    # è·å–å®¢æˆ·ç«¯ç®¡ç†å™¨\n    client_manager = get_client_manager()\n    \n    # è‡ªåŠ¨é…ç½®\n    print(\"\\n1. è‡ªåŠ¨é…ç½®...\")\n    auto_configure(client_manager)\n    \n    # æ£€æŸ¥é…ç½®\n    print(\"\\n2. æ£€æŸ¥é…ç½®...\")\n    if not client_manager.provider_configs:\n        print(\"âŒ æœªæ‰¾åˆ°ä»»ä½•æä¾›å•†é…ç½®\")\n        return False\n    \n    print(f\"âœ“ æ‰¾åˆ° {len(client_manager.provider_configs)} ä¸ªæä¾›å•†:\")\n    for provider, config in client_manager.provider_configs.items():\n        print(f\"  â€¢ {provider}\")\n        if isinstance(config, dict):\n            print(f\"    - API Key: {config.get('api_key', '')[:10]}...\" if config.get('api_key') else \"    - API Key: æœªé…ç½®\")\n            print(f\"    - Base URL: {config.get('base_url', 'N/A')}\")\n            print(f\"    - æ¨¡å‹æ•°é‡: {len(config.get('models', []))}\")\n        else:\n            print(f\"    - API Key: {config.api_key[:10]}...\" if config.api_key else \"    - API Key: æœªé…ç½®\")\n            print(f\"    - Base URL: {config.base_url}\")\n            print(f\"    - æ¨¡å‹æ•°é‡: {len(config.models)}\")\n    \n    # æµ‹è¯•è·å–å®¢æˆ·ç«¯\n    print(\"\\n3. æµ‹è¯•è·å–å®¢æˆ·ç«¯...\")\n    try:\n        client = client_manager.get_client(model=\"qwen-max\")\n        print(f\"âœ“ æˆåŠŸè·å–qwen-maxå®¢æˆ·ç«¯\")\n        print(f\"  â€¢ æä¾›å•†: {client_manager._get_provider_for_model('qwen-max')}\")\n        return True\n    except Exception as e:\n        print(f\"âŒ è·å–å®¢æˆ·ç«¯å¤±è´¥: {e}\")\n        return False\n\nif __name__ == \"__main__\":\n    success = test_config()\n    print(\"\\n\" + \"=\"*60)\n    if success:\n        print(\"âœ… é…ç½®æµ‹è¯•é€šè¿‡\")\n    else:\n        print(\"âŒ é…ç½®æµ‹è¯•å¤±è´¥\")\n    print(\"=\"*60)"
},
{
"path": "tests/test_load_strategy_config.py",
"start": 1,
"end": 15,
"text": "\"\"\"\næµ‹è¯•MemoryåŠ è½½ç­–ç•¥é…ç½®åŠŸèƒ½\n\néªŒè¯é…ç½®åŠ è½½ã€éªŒè¯ã€çƒ­é‡è½½ç­‰åŠŸèƒ½\n\"\"\"\n\nimport asyncio\nimport tempfile\nfrom pathlib import Path\nfrom daoyoucode.agents.memory.load_strategy_config import (\n    LoadStrategyConfig, get_load_strategy_config, DEFAULT_STRATEGIES\n)\nfrom daoyoucode.agents.memory.smart_loader import SmartLoader\n\n"
},
{
"path": "tests/test_load_strategy_config.py",
"start": 16,
"end": 40,
"text": "def test_default_config():\n    \"\"\"æµ‹è¯•é»˜è®¤é…ç½®\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šé»˜è®¤é…ç½®\")\n    print(\"=\"*60)\n    \n    config = LoadStrategyConfig()\n    \n    # æ£€æŸ¥é»˜è®¤ç­–ç•¥\n    strategies = config.get_all_strategies()\n    print(f\"\\né»˜è®¤ç­–ç•¥æ•°é‡: {len(strategies)}\")\n    \n    for name, strategy in strategies.items():\n        cost = strategy.get('cost', 0)\n        desc = strategy.get('description', 'æ— æè¿°')\n        print(f\"  - {name}: cost={cost}, {desc}\")\n    \n    # éªŒè¯å¿…éœ€ç­–ç•¥å­˜åœ¨\n    required = ['new_conversation', 'simple_followup', 'medium_followup', 'complex_followup']\n    for name in required:\n        assert name in strategies, f\"ç¼ºå°‘å¿…éœ€ç­–ç•¥: {name}\"\n    \n    print(\"\\nâœ… é»˜è®¤é…ç½®æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_load_strategy_config.py",
"start": 41,
"end": 91,
"text": "def test_load_from_yaml():\n    \"\"\"æµ‹è¯•ä»YAMLæ–‡ä»¶åŠ è½½\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šä»YAMLæ–‡ä»¶åŠ è½½\")\n    print(\"=\"*60)\n    \n    # åˆ›å»ºä¸´æ—¶é…ç½®æ–‡ä»¶\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False, encoding='utf-8') as f:\n        f.write(\"\"\"\nstrategies:\n  custom_strategy:\n    load_history: true\n    history_limit: 5\n    load_summary: true\n    cost: 4\n    description: \"è‡ªå®šä¹‰ç­–ç•¥\"\n  \n  simple_followup:\n    load_history: true\n    history_limit: 1  # è¦†ç›–é»˜è®¤å€¼\n    cost: 0.5\n\"\"\")\n        temp_path = f.name\n    \n    try:\n        # åŠ è½½é…ç½®\n        config = LoadStrategyConfig(temp_path)\n        \n        # æ£€æŸ¥è‡ªå®šä¹‰ç­–ç•¥\n        custom = config.get_strategy('custom_strategy')\n        assert custom is not None, \"è‡ªå®šä¹‰ç­–ç•¥æœªåŠ è½½\"\n        assert custom['history_limit'] == 5, \"è‡ªå®šä¹‰ç­–ç•¥å‚æ•°é”™è¯¯\"\n        print(f\"âœ“ è‡ªå®šä¹‰ç­–ç•¥: {custom}\")\n        \n        # æ£€æŸ¥è¦†ç›–çš„ç­–ç•¥\n        simple = config.get_strategy('simple_followup')\n        assert simple['history_limit'] == 1, \"ç­–ç•¥è¦†ç›–å¤±è´¥\"\n        assert simple['cost'] == 0.5, \"ç­–ç•¥è¦†ç›–å¤±è´¥\"\n        print(f\"âœ“ è¦†ç›–ç­–ç•¥: {simple}\")\n        \n        # æ£€æŸ¥é»˜è®¤ç­–ç•¥ä»ç„¶å­˜åœ¨\n        medium = config.get_strategy('medium_followup')\n        assert medium is not None, \"é»˜è®¤ç­–ç•¥ä¸¢å¤±\"\n        print(f\"âœ“ é»˜è®¤ç­–ç•¥ä¿ç•™: {medium}\")\n        \n        print(\"\\nâœ… YAMLåŠ è½½æµ‹è¯•é€šè¿‡\")\n    \n    finally:\n        Path(temp_path).unlink()\n\n"
},
{
"path": "tests/test_load_strategy_config.py",
"start": 92,
"end": 127,
"text": "def test_load_from_json():\n    \"\"\"æµ‹è¯•ä»JSONæ–‡ä»¶åŠ è½½\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šä»JSONæ–‡ä»¶åŠ è½½\")\n    print(\"=\"*60)\n    \n    # åˆ›å»ºä¸´æ—¶é…ç½®æ–‡ä»¶\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False, encoding='utf-8') as f:\n        f.write(\"\"\"{\n  \"strategies\": {\n    \"json_strategy\": {\n      \"load_history\": true,\n      \"history_limit\": 7,\n      \"cost\": 6,\n      \"description\": \"JSONç­–ç•¥\"\n    }\n  }\n}\"\"\")\n        temp_path = f.name\n    \n    try:\n        # åŠ è½½é…ç½®\n        config = LoadStrategyConfig(temp_path)\n        \n        # æ£€æŸ¥JSONç­–ç•¥\n        json_strategy = config.get_strategy('json_strategy')\n        assert json_strategy is not None, \"JSONç­–ç•¥æœªåŠ è½½\"\n        assert json_strategy['history_limit'] == 7, \"JSONç­–ç•¥å‚æ•°é”™è¯¯\"\n        print(f\"âœ“ JSONç­–ç•¥: {json_strategy}\")\n        \n        print(\"\\nâœ… JSONåŠ è½½æµ‹è¯•é€šè¿‡\")\n    \n    finally:\n        Path(temp_path).unlink()\n\n"
},
{
"path": "tests/test_load_strategy_config.py",
"start": 128,
"end": 161,
"text": "def test_add_and_remove_strategy():\n    \"\"\"æµ‹è¯•æ·»åŠ å’Œåˆ é™¤ç­–ç•¥\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šæ·»åŠ å’Œåˆ é™¤ç­–ç•¥\")\n    print(\"=\"*60)\n    \n    config = LoadStrategyConfig()\n    \n    # æ·»åŠ ç­–ç•¥\n    new_strategy = {\n        'load_history': True,\n        'history_limit': 8,\n        'cost': 7\n    }\n    config.add_strategy('test_strategy', new_strategy)\n    \n    # éªŒè¯æ·»åŠ \n    strategy = config.get_strategy('test_strategy')\n    assert strategy is not None, \"ç­–ç•¥æ·»åŠ å¤±è´¥\"\n    assert strategy['history_limit'] == 8, \"ç­–ç•¥å‚æ•°é”™è¯¯\"\n    print(f\"âœ“ æ·»åŠ ç­–ç•¥æˆåŠŸ: {strategy}\")\n    \n    # åˆ é™¤ç­–ç•¥\n    success = config.remove_strategy('test_strategy')\n    assert success, \"ç­–ç•¥åˆ é™¤å¤±è´¥\"\n    \n    # éªŒè¯åˆ é™¤\n    strategy = config.get_strategy('test_strategy')\n    assert strategy is None, \"ç­–ç•¥åˆ é™¤åä»å­˜åœ¨\"\n    print(f\"âœ“ åˆ é™¤ç­–ç•¥æˆåŠŸ\")\n    \n    print(\"\\nâœ… æ·»åŠ åˆ é™¤æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_load_strategy_config.py",
"start": 162,
"end": 200,
"text": "def test_save_and_reload():\n    \"\"\"æµ‹è¯•ä¿å­˜å’Œé‡è½½\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šä¿å­˜å’Œé‡è½½\")\n    print(\"=\"*60)\n    \n    # åˆ›å»ºä¸´æ—¶æ–‡ä»¶è·¯å¾„\n    with tempfile.NamedTemporaryFile(suffix='.yaml', delete=False) as f:\n        temp_path = f.name\n    \n    try:\n        # åˆ›å»ºé…ç½®å¹¶æ·»åŠ è‡ªå®šä¹‰ç­–ç•¥\n        config = LoadStrategyConfig()\n        config.add_strategy('saved_strategy', {\n            'load_history': True,\n            'history_limit': 9,\n            'cost': 8\n        })\n        \n        # ä¿å­˜åˆ°æ–‡ä»¶\n        success = config.save_to_file(temp_path)\n        assert success, \"ä¿å­˜å¤±è´¥\"\n        print(f\"âœ“ ä¿å­˜æˆåŠŸ: {temp_path}\")\n        \n        # åˆ›å»ºæ–°é…ç½®å®ä¾‹å¹¶åŠ è½½\n        config2 = LoadStrategyConfig(temp_path)\n        \n        # éªŒè¯åŠ è½½\n        strategy = config2.get_strategy('saved_strategy')\n        assert strategy is not None, \"é‡è½½åç­–ç•¥ä¸¢å¤±\"\n        assert strategy['history_limit'] == 9, \"é‡è½½åç­–ç•¥å‚æ•°é”™è¯¯\"\n        print(f\"âœ“ é‡è½½æˆåŠŸ: {strategy}\")\n        \n        print(\"\\nâœ… ä¿å­˜é‡è½½æµ‹è¯•é€šè¿‡\")\n    \n    finally:\n        Path(temp_path).unlink()\n\n"
},
{
"path": "tests/test_load_strategy_config.py",
"start": 201,
"end": 237,
"text": "def test_export_default_config():\n    \"\"\"æµ‹è¯•å¯¼å‡ºé»˜è®¤é…ç½®\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šå¯¼å‡ºé»˜è®¤é…ç½®\")\n    print(\"=\"*60)\n    \n    # åˆ›å»ºä¸´æ—¶æ–‡ä»¶è·¯å¾„\n    with tempfile.NamedTemporaryFile(suffix='.yaml', delete=False) as f:\n        temp_path = f.name\n    \n    try:\n        config = LoadStrategyConfig()\n        \n        # å¯¼å‡ºé»˜è®¤é…ç½®\n        success = config.export_default_config(temp_path)\n        assert success, \"å¯¼å‡ºå¤±è´¥\"\n        print(f\"âœ“ å¯¼å‡ºæˆåŠŸ: {temp_path}\")\n        \n        # éªŒè¯æ–‡ä»¶å­˜åœ¨\n        assert Path(temp_path).exists(), \"å¯¼å‡ºæ–‡ä»¶ä¸å­˜åœ¨\"\n        \n        # åŠ è½½å¹¶éªŒè¯\n        config2 = LoadStrategyConfig(temp_path)\n        strategies = config2.get_all_strategies()\n        \n        # åº”è¯¥åŒ…å«æ‰€æœ‰é»˜è®¤ç­–ç•¥\n        for name in DEFAULT_STRATEGIES.keys():\n            assert name in strategies, f\"é»˜è®¤ç­–ç•¥ {name} ä¸¢å¤±\"\n        \n        print(f\"âœ“ éªŒè¯æˆåŠŸ: {len(strategies)} ä¸ªç­–ç•¥\")\n        \n        print(\"\\nâœ… å¯¼å‡ºé»˜è®¤é…ç½®æµ‹è¯•é€šè¿‡\")\n    \n    finally:\n        Path(temp_path).unlink()\n\n"
},
{
"path": "tests/test_load_strategy_config.py",
"start": 238,
"end": 283,
"text": "def test_smart_loader_integration():\n    \"\"\"æµ‹è¯•SmartLoaderé›†æˆ\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šSmartLoaderé›†æˆ\")\n    print(\"=\"*60)\n    \n    # åˆ›å»ºä¸´æ—¶é…ç½®æ–‡ä»¶\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False, encoding='utf-8') as f:\n        f.write(\"\"\"\nstrategies:\n  custom_simple:\n    load_history: true\n    history_limit: 1\n    cost: 0.5\n    description: \"è‡ªå®šä¹‰ç®€å•ç­–ç•¥\"\n\"\"\")\n        temp_path = f.name\n    \n    try:\n        # åˆ›å»ºSmartLoaderï¼ˆä½¿ç”¨è‡ªå®šä¹‰é…ç½®ï¼‰\n        loader = SmartLoader(enable_tree=False, config_path=temp_path)\n        \n        # æ£€æŸ¥ç­–ç•¥æ˜¯å¦åŠ è½½\n        strategies = loader.list_strategies()\n        print(f\"âœ“ åŠ è½½çš„ç­–ç•¥: {strategies}\")\n        \n        assert 'custom_simple' in strategies, \"è‡ªå®šä¹‰ç­–ç•¥æœªåŠ è½½åˆ°SmartLoader\"\n        \n        # è·å–ç­–ç•¥ä¿¡æ¯\n        info = loader.get_strategy_info('custom_simple')\n        assert info is not None, \"æ— æ³•è·å–ç­–ç•¥ä¿¡æ¯\"\n        assert info['history_limit'] == 1, \"ç­–ç•¥å‚æ•°é”™è¯¯\"\n        print(f\"âœ“ ç­–ç•¥ä¿¡æ¯: {info}\")\n        \n        # æµ‹è¯•çƒ­é‡è½½\n        print(\"\\næµ‹è¯•çƒ­é‡è½½...\")\n        success = loader.reload_config()\n        assert success, \"çƒ­é‡è½½å¤±è´¥\"\n        print(f\"âœ“ çƒ­é‡è½½æˆåŠŸ\")\n        \n        print(\"\\nâœ… SmartLoaderé›†æˆæµ‹è¯•é€šè¿‡\")\n    \n    finally:\n        Path(temp_path).unlink()\n\n"
},
{
"path": "tests/test_load_strategy_config.py",
"start": 284,
"end": 321,
"text": "def test_config_stats():\n    \"\"\"æµ‹è¯•é…ç½®ç»Ÿè®¡\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šé…ç½®ç»Ÿè®¡\")\n    print(\"=\"*60)\n    \n    config = LoadStrategyConfig()\n    \n    # è·å–ç»Ÿè®¡ä¿¡æ¯\n    stats = config.get_stats()\n    \n    print(\"\\né…ç½®ç»Ÿè®¡:\")\n    for key, value in stats.items():\n        print(f\"  {key}: {value}\")\n    \n    assert stats['total_strategies'] > 0, \"ç­–ç•¥æ•°é‡ä¸º0\"\n    assert len(stats['strategy_names']) == stats['total_strategies'], \"ç­–ç•¥åç§°æ•°é‡ä¸åŒ¹é…\"\n    \n    print(\"\\nâœ… é…ç½®ç»Ÿè®¡æµ‹è¯•é€šè¿‡\")\n\n\nif __name__ == \"__main__\":\n    print(\"=\"*60)\n    print(\"MemoryåŠ è½½ç­–ç•¥é…ç½®æµ‹è¯•å¥—ä»¶\")\n    print(\"=\"*60)\n    \n    test_default_config()\n    test_load_from_yaml()\n    test_load_from_json()\n    test_add_and_remove_strategy()\n    test_save_and_reload()\n    test_export_default_config()\n    test_smart_loader_integration()\n    test_config_stats()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"âœ… æ‰€æœ‰æµ‹è¯•å®Œæˆ\")\n    print(\"=\"*60)"
},
{
"path": "tests/test_lsp_tools.py",
"start": 1,
"end": 29,
"text": "\"\"\"\næµ‹è¯•LSPå·¥å…·\n\næµ‹è¯•ï¼š\n1. LSPè¯Šæ–­å·¥å…·\n2. LSPè·³è½¬å®šä¹‰å·¥å…·\n3. LSPæŸ¥æ‰¾å¼•ç”¨å·¥å…·\n4. LSPç¬¦å·å·¥å…·\n5. LSPé‡å‘½åå·¥å…·\n6. LSPä»£ç æ“ä½œå·¥å…·\n7. å·¥å…·æ³¨å†Œ\n\"\"\"\n\nimport pytest\nimport tempfile\nimport shutil\nfrom pathlib import Path\n\nfrom daoyoucode.agents.tools.lsp_tools import (\n    LSPDiagnosticsTool,\n    LSPGotoDefinitionTool,\n    LSPFindReferencesTool,\n    LSPSymbolsTool,\n    LSPRenameTool,\n    LSPCodeActionsTool,\n    get_lsp_manager\n)\n\n"
},
{
"path": "tests/test_lsp_tools.py",
"start": 30,
"end": 33,
"text": "class TestLSPDiagnosticsTool:\n    \"\"\"æµ‹è¯•LSPè¯Šæ–­å·¥å…·\"\"\"\n    \n    @pytest.fixture"
},
{
"path": "tests/test_lsp_tools.py",
"start": 34,
"end": 82,
"text": "    def temp_file(self):\n        \"\"\"åˆ›å»ºä¸´æ—¶æ–‡ä»¶\"\"\"\n        temp_dir = tempfile.mkdtemp()\n        file_path = Path(temp_dir) / \"test.py\"\n        file_path.write_text(\"def hello():\\n    print('Hello')\\n\")\n        \n        yield file_path\n        \n        shutil.rmtree(temp_dir)\n    \n    @pytest.mark.asyncio\n    async def test_diagnostics_basic(self, temp_file):\n        \"\"\"æµ‹è¯•åŸºç¡€è¯Šæ–­\"\"\"\n        tool = LSPDiagnosticsTool()\n        \n        result = await tool.execute(\n            file_path=str(temp_file)\n        )\n        \n        assert result.success\n        assert result.content is not None\n        assert 'LSP diagnostics' in result.content\n    \n    @pytest.mark.asyncio\n    async def test_diagnostics_with_severity(self, temp_file):\n        \"\"\"æµ‹è¯•å¸¦ä¸¥é‡æ€§è¿‡æ»¤çš„è¯Šæ–­\"\"\"\n        tool = LSPDiagnosticsTool()\n        \n        result = await tool.execute(\n            file_path=str(temp_file),\n            severity=\"error\"\n        )\n        \n        assert result.success\n        assert result.metadata['severity'] == 'error'\n    \n    @pytest.mark.asyncio\n    async def test_diagnostics_nonexistent_file(self):\n        \"\"\"æµ‹è¯•ä¸å­˜åœ¨çš„æ–‡ä»¶\"\"\"\n        tool = LSPDiagnosticsTool()\n        \n        result = await tool.execute(\n            file_path=\"/nonexistent/file.py\"\n        )\n        \n        assert not result.success\n        assert 'not found' in result.error.lower()\n\n"
},
{
"path": "tests/test_lsp_tools.py",
"start": 83,
"end": 86,
"text": "class TestLSPGotoDefinitionTool:\n    \"\"\"æµ‹è¯•LSPè·³è½¬å®šä¹‰å·¥å…·\"\"\"\n    \n    @pytest.fixture"
},
{
"path": "tests/test_lsp_tools.py",
"start": 87,
"end": 126,
"text": "    def temp_file(self):\n        \"\"\"åˆ›å»ºä¸´æ—¶æ–‡ä»¶\"\"\"\n        temp_dir = tempfile.mkdtemp()\n        file_path = Path(temp_dir) / \"test.py\"\n        file_path.write_text(\"def hello():\\n    print('Hello')\\n\")\n        \n        yield file_path\n        \n        shutil.rmtree(temp_dir)\n    \n    @pytest.mark.asyncio\n    async def test_goto_definition_basic(self, temp_file):\n        \"\"\"æµ‹è¯•åŸºç¡€è·³è½¬å®šä¹‰\"\"\"\n        tool = LSPGotoDefinitionTool()\n        \n        result = await tool.execute(\n            file_path=str(temp_file),\n            line=1,\n            character=4\n        )\n        \n        assert result.success\n        assert result.content is not None\n        assert 'goto definition' in result.content.lower()\n    \n    @pytest.mark.asyncio\n    async def test_goto_definition_metadata(self, temp_file):\n        \"\"\"æµ‹è¯•å…ƒæ•°æ®\"\"\"\n        tool = LSPGotoDefinitionTool()\n        \n        result = await tool.execute(\n            file_path=str(temp_file),\n            line=1,\n            character=4\n        )\n        \n        assert result.metadata['line'] == 1\n        assert result.metadata['character'] == 4\n\n"
},
{
"path": "tests/test_lsp_tools.py",
"start": 127,
"end": 130,
"text": "class TestLSPFindReferencesTool:\n    \"\"\"æµ‹è¯•LSPæŸ¥æ‰¾å¼•ç”¨å·¥å…·\"\"\"\n    \n    @pytest.fixture"
},
{
"path": "tests/test_lsp_tools.py",
"start": 131,
"end": 171,
"text": "    def temp_file(self):\n        \"\"\"åˆ›å»ºä¸´æ—¶æ–‡ä»¶\"\"\"\n        temp_dir = tempfile.mkdtemp()\n        file_path = Path(temp_dir) / \"test.py\"\n        file_path.write_text(\"def hello():\\n    print('Hello')\\n\")\n        \n        yield file_path\n        \n        shutil.rmtree(temp_dir)\n    \n    @pytest.mark.asyncio\n    async def test_find_references_basic(self, temp_file):\n        \"\"\"æµ‹è¯•åŸºç¡€æŸ¥æ‰¾å¼•ç”¨\"\"\"\n        tool = LSPFindReferencesTool()\n        \n        result = await tool.execute(\n            file_path=str(temp_file),\n            line=1,\n            character=4\n        )\n        \n        assert result.success\n        assert result.content is not None\n        assert 'find references' in result.content.lower()\n    \n    @pytest.mark.asyncio\n    async def test_find_references_with_declaration(self, temp_file):\n        \"\"\"æµ‹è¯•åŒ…å«å£°æ˜çš„æŸ¥æ‰¾å¼•ç”¨\"\"\"\n        tool = LSPFindReferencesTool()\n        \n        result = await tool.execute(\n            file_path=str(temp_file),\n            line=1,\n            character=4,\n            include_declaration=False\n        )\n        \n        assert result.success\n        assert result.metadata['include_declaration'] == False\n\n"
},
{
"path": "tests/test_lsp_tools.py",
"start": 172,
"end": 175,
"text": "class TestLSPSymbolsTool:\n    \"\"\"æµ‹è¯•LSPç¬¦å·å·¥å…·\"\"\"\n    \n    @pytest.fixture"
},
{
"path": "tests/test_lsp_tools.py",
"start": 176,
"end": 227,
"text": "    def temp_file(self):\n        \"\"\"åˆ›å»ºä¸´æ—¶æ–‡ä»¶\"\"\"\n        temp_dir = tempfile.mkdtemp()\n        file_path = Path(temp_dir) / \"test.py\"\n        file_path.write_text(\"def hello():\\n    print('Hello')\\n\")\n        \n        yield file_path\n        \n        shutil.rmtree(temp_dir)\n    \n    @pytest.mark.asyncio\n    async def test_symbols_document_scope(self, temp_file):\n        \"\"\"æµ‹è¯•æ–‡æ¡£èŒƒå›´ç¬¦å·\"\"\"\n        tool = LSPSymbolsTool()\n        \n        result = await tool.execute(\n            file_path=str(temp_file),\n            scope=\"document\"\n        )\n        \n        assert result.success\n        assert result.content is not None\n        assert 'document' in result.content.lower()\n    \n    @pytest.mark.asyncio\n    async def test_symbols_workspace_scope(self, temp_file):\n        \"\"\"æµ‹è¯•å·¥ä½œåŒºèŒƒå›´ç¬¦å·\"\"\"\n        tool = LSPSymbolsTool()\n        \n        result = await tool.execute(\n            file_path=str(temp_file),\n            scope=\"workspace\",\n            query=\"hello\"\n        )\n        \n        assert result.success\n        assert result.metadata['query'] == 'hello'\n    \n    @pytest.mark.asyncio\n    async def test_symbols_workspace_without_query(self, temp_file):\n        \"\"\"æµ‹è¯•å·¥ä½œåŒºèŒƒå›´ä½†æ²¡æœ‰æŸ¥è¯¢\"\"\"\n        tool = LSPSymbolsTool()\n        \n        result = await tool.execute(\n            file_path=str(temp_file),\n            scope=\"workspace\"\n        )\n        \n        assert not result.success\n        assert 'required' in result.error.lower()\n\n"
},
{
"path": "tests/test_lsp_tools.py",
"start": 228,
"end": 231,
"text": "class TestLSPRenameTool:\n    \"\"\"æµ‹è¯•LSPé‡å‘½åå·¥å…·\"\"\"\n    \n    @pytest.fixture"
},
{
"path": "tests/test_lsp_tools.py",
"start": 232,
"end": 259,
"text": "    def temp_file(self):\n        \"\"\"åˆ›å»ºä¸´æ—¶æ–‡ä»¶\"\"\"\n        temp_dir = tempfile.mkdtemp()\n        file_path = Path(temp_dir) / \"test.py\"\n        file_path.write_text(\"def hello():\\n    print('Hello')\\n\")\n        \n        yield file_path\n        \n        shutil.rmtree(temp_dir)\n    \n    @pytest.mark.asyncio\n    async def test_rename_basic(self, temp_file):\n        \"\"\"æµ‹è¯•åŸºç¡€é‡å‘½å\"\"\"\n        tool = LSPRenameTool()\n        \n        result = await tool.execute(\n            file_path=str(temp_file),\n            line=1,\n            character=4,\n            new_name=\"greet\"\n        )\n        \n        assert result.success\n        assert result.content is not None\n        assert 'rename' in result.content.lower()\n        assert result.metadata['new_name'] == 'greet'\n\n"
},
{
"path": "tests/test_lsp_tools.py",
"start": 260,
"end": 263,
"text": "class TestLSPCodeActionsTool:\n    \"\"\"æµ‹è¯•LSPä»£ç æ“ä½œå·¥å…·\"\"\"\n    \n    @pytest.fixture"
},
{
"path": "tests/test_lsp_tools.py",
"start": 264,
"end": 289,
"text": "    def temp_file(self):\n        \"\"\"åˆ›å»ºä¸´æ—¶æ–‡ä»¶\"\"\"\n        temp_dir = tempfile.mkdtemp()\n        file_path = Path(temp_dir) / \"test.py\"\n        file_path.write_text(\"def hello():\\n    print('Hello')\\n\")\n        \n        yield file_path\n        \n        shutil.rmtree(temp_dir)\n    \n    @pytest.mark.asyncio\n    async def test_code_actions_basic(self, temp_file):\n        \"\"\"æµ‹è¯•åŸºç¡€ä»£ç æ“ä½œ\"\"\"\n        tool = LSPCodeActionsTool()\n        \n        result = await tool.execute(\n            file_path=str(temp_file),\n            line=1,\n            character=4\n        )\n        \n        assert result.success\n        assert result.content is not None\n        assert 'code actions' in result.content.lower()\n\n"
},
{
"path": "tests/test_lsp_tools.py",
"start": 290,
"end": 292,
"text": "class TestLSPManager:\n    \"\"\"æµ‹è¯•LSPç®¡ç†å™¨\"\"\"\n    "
},
{
"path": "tests/test_lsp_tools.py",
"start": 293,
"end": 299,
"text": "    def test_manager_singleton(self):\n        \"\"\"æµ‹è¯•ç®¡ç†å™¨å•ä¾‹\"\"\"\n        manager1 = get_lsp_manager()\n        manager2 = get_lsp_manager()\n        \n        assert manager1 is manager2\n    "
},
{
"path": "tests/test_lsp_tools.py",
"start": 300,
"end": 310,
"text": "    def test_find_server_for_python(self):\n        \"\"\"æµ‹è¯•æŸ¥æ‰¾PythonæœåŠ¡å™¨\"\"\"\n        manager = get_lsp_manager()\n        \n        server = manager.find_server_for_extension(\".py\")\n        \n        # å¯èƒ½æ‰¾åˆ°ä¹Ÿå¯èƒ½æ‰¾ä¸åˆ°ï¼ˆå–å†³äºæ˜¯å¦å®‰è£…ï¼‰\n        if server:\n            assert server.id in [\"pyright\", \"pylsp\"]\n            assert \".py\" in server.extensions\n    "
},
{
"path": "tests/test_lsp_tools.py",
"start": 311,
"end": 321,
"text": "    def test_find_server_for_javascript(self):\n        \"\"\"æµ‹è¯•æŸ¥æ‰¾JavaScriptæœåŠ¡å™¨\"\"\"\n        manager = get_lsp_manager()\n        \n        server = manager.find_server_for_extension(\".js\")\n        \n        if server:\n            assert server.id == \"typescript-language-server\"\n            assert \".js\" in server.extensions\n\n"
},
{
"path": "tests/test_lsp_tools.py",
"start": 322,
"end": 324,
"text": "class TestToolIntegration:\n    \"\"\"æµ‹è¯•å·¥å…·é›†æˆ\"\"\"\n    "
},
{
"path": "tests/test_lsp_tools.py",
"start": 325,
"end": 344,
"text": "    def test_tool_registry(self):\n        \"\"\"æµ‹è¯•å·¥å…·æ³¨å†Œ\"\"\"\n        from daoyoucode.agents.tools import get_tool_registry\n        \n        registry = get_tool_registry()\n        tools = registry.list_tools()\n        \n        # æ£€æŸ¥LSPå·¥å…·æ˜¯å¦å·²æ³¨å†Œ\n        lsp_tools = [\n            'lsp_diagnostics',\n            'lsp_goto_definition',\n            'lsp_find_references',\n            'lsp_symbols',\n            'lsp_rename',\n            'lsp_code_actions'\n        ]\n        \n        for tool_name in lsp_tools:\n            assert tool_name in tools\n    "
},
{
"path": "tests/test_lsp_tools.py",
"start": 345,
"end": 371,
"text": "    def test_function_schemas(self):\n        \"\"\"æµ‹è¯•Function schemas\"\"\"\n        from daoyoucode.agents.tools import get_tool_registry\n        \n        registry = get_tool_registry()\n        \n        lsp_tools = [\n            'lsp_diagnostics',\n            'lsp_goto_definition',\n            'lsp_find_references',\n            'lsp_symbols',\n            'lsp_rename',\n            'lsp_code_actions'\n        ]\n        \n        schemas = registry.get_function_schemas(lsp_tools)\n        \n        assert len(schemas) == 6\n        \n        for schema in schemas:\n            assert 'name' in schema\n            assert 'description' in schema\n            assert 'parameters' in schema\n\n\nif __name__ == '__main__':\n    pytest.main([__file__, '-v'])"
},
{
"path": "tests/test_memory_debug.py",
"start": 1,
"end": 273,
"text": "\"\"\"\nMemoryç³»ç»Ÿå®æˆ˜è°ƒè¯•è„šæœ¬\n\nç”¨äºåœ¨å®é™…ä½¿ç”¨ä¸­è¿½è¸ªMemoryç³»ç»Ÿçš„è¡Œä¸º\n\"\"\"\n\nimport asyncio\nimport logging\nfrom daoyoucode.agents.memory import get_memory_manager\n\n# é…ç½®æ—¥å¿— - å¯ä»¥è°ƒæ•´çº§åˆ«\nlogging.basicConfig(\n    level=logging.INFO,  # æ”¹ä¸º DEBUG å¯ä»¥çœ‹åˆ°æ›´è¯¦ç»†çš„ä¿¡æ¯\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nlogger = logging.getLogger(__name__)\n\n\nasync def simulate_conversation():\n    \"\"\"æ¨¡æ‹Ÿä¸€ä¸ªå®Œæ•´çš„å¯¹è¯æµç¨‹\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"Memoryç³»ç»Ÿå®æˆ˜è°ƒè¯•\")\n    print(\"=\"*60)\n    \n    memory = get_memory_manager()\n    session_id = \"debug-session\"\n    user_id = \"debug-user\"\n    \n    # æ¨¡æ‹Ÿå¯¹è¯åœºæ™¯\n    conversations = [\n        (\"è¿™ä¸ªé¡¹ç›®æ˜¯åšä»€ä¹ˆçš„ï¼Ÿ\", \"è¿™æ˜¯ä¸€ä¸ªAIä»£ç åŠ©æ‰‹é¡¹ç›®ï¼Œåä¸ºDaoyouCode...\"),\n        (\"æœ‰å“ªäº›æ ¸å¿ƒåŠŸèƒ½ï¼Ÿ\", \"æ ¸å¿ƒåŠŸèƒ½åŒ…æ‹¬ï¼šä»£ç ç¼–è¾‘ã€é‡æ„ã€æµ‹è¯•ç”Ÿæˆã€æ–‡æ¡£ç”Ÿæˆ...\"),\n        (\"Agentç³»ç»Ÿæ˜¯æ€ä¹ˆå·¥ä½œçš„ï¼Ÿ\", \"Agentç³»ç»Ÿä½¿ç”¨å¯æ’æ‹”æ¶æ„ï¼ŒåŒ…å«ç¼–æ’å™¨ã€å·¥å…·ã€è®°å¿†ç­‰æ¨¡å—...\"),\n        (\"èƒ½è¯¦ç»†è¯´è¯´ç¼–æ’å™¨å—ï¼Ÿ\", \"ç¼–æ’å™¨æœ‰ä¸‰ç§ç±»å‹ï¼šSimpleã€ReActã€Parallel...\"),\n        (\"å·¥å…·ç³»ç»Ÿæœ‰å“ªäº›å·¥å…·ï¼Ÿ\", \"å·¥å…·ç³»ç»Ÿæœ‰25ä¸ªå·¥å…·ï¼ŒåŒ…æ‹¬æ–‡ä»¶æ“ä½œã€ä»£ç åˆ†æã€æµ‹è¯•æ‰§è¡Œç­‰...\"),\n        (\"Memoryç³»ç»Ÿæœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Ÿ\", \"Memoryç³»ç»Ÿæ”¯æŒæ™ºèƒ½åŠ è½½ã€æ‘˜è¦ç”Ÿæˆã€ç”¨æˆ·ç”»åƒç­‰åŠŸèƒ½...\"),\n        (\"èƒ½å†è¯¦ç»†è¯´è¯´æ™ºèƒ½åŠ è½½å—ï¼Ÿ\", \"æ™ºèƒ½åŠ è½½æœ‰5ç§ç­–ç•¥ï¼Œå¯ä»¥èŠ‚çœ50-70%çš„tokenæˆæœ¬...\"),\n    ]\n    \n    for idx, (user_msg, ai_msg) in enumerate(conversations, 1):\n        print(f\"\\n{'='*60}\")\n        print(f\"ç¬¬{idx}è½®å¯¹è¯\")\n        print(f\"{'='*60}\")\n        print(f\"ğŸ‘¤ ç”¨æˆ·: {user_msg}\")\n        \n        # åˆ¤æ–­è¿½é—®\n        if idx > 1:\n            is_followup, confidence, reason = await memory.is_followup(\n                session_id, user_msg\n            )\n            print(f\"\\nğŸ” è¿½é—®åˆ¤æ–­:\")\n            print(f\"   ç»“æœ: {'æ˜¯è¿½é—®' if is_followup else 'æ–°è¯é¢˜'}\")\n            print(f\"   ç½®ä¿¡åº¦: {confidence:.2f}\")\n            print(f\"   åŸå› : {reason}\")\n        else:\n            is_followup, confidence = False, 0.0\n            print(f\"\\nğŸ” è¿½é—®åˆ¤æ–­: é¦–è½®å¯¹è¯ï¼Œæ— éœ€åˆ¤æ–­\")\n        \n        # æ™ºèƒ½åŠ è½½\n        print(f\"\\nğŸ“š æ™ºèƒ½åŠ è½½:\")\n        context = await memory.load_context_smart(\n            session_id=session_id,\n            user_id=user_id,\n            user_input=user_msg,\n            is_followup=is_followup,\n            confidence=confidence\n        )\n        \n        print(f\"   ç­–ç•¥: {context['strategy']}\")\n        print(f\"   å†å²è½®æ•°: {len(context['history'])}\")\n        print(f\"   æˆæœ¬: {context['cost']}\")\n        print(f\"   æ™ºèƒ½ç­›é€‰: {'æ˜¯' if context.get('filtered') else 'å¦'}\")\n        \n        if context['history']:\n            print(f\"   åŠ è½½çš„å¯¹è¯:\")\n            for h_idx, h in enumerate(context['history'], 1):\n                print(f\"     {h_idx}. {h['user'][:50]}...\")\n        \n        if context.get('summary'):\n            print(f\"   æ‘˜è¦: {context['summary'][:100]}...\")\n        \n        # æ¨¡æ‹ŸAIå“åº”\n        print(f\"\\nğŸ¤– AI: {ai_msg[:80]}...\")\n        \n        # æ·»åŠ åˆ°è®°å¿†\n        memory.add_conversation(session_id, user_msg, ai_msg)\n        \n        # æ£€æŸ¥æ‘˜è¦è§¦å‘\n        history = memory.get_conversation_history(session_id)\n        if memory.long_term_memory.should_generate_summary(session_id, len(history)):\n            print(f\"\\nğŸ”„ è§¦å‘æ‘˜è¦ç”Ÿæˆæ¡ä»¶ï¼ˆå½“å‰{len(history)}è½®ï¼‰\")\n            print(f\"   ğŸ’¡ åœ¨å®é™…ä½¿ç”¨ä¸­ï¼ŒAgentä¼šè‡ªåŠ¨è°ƒç”¨LLMç”Ÿæˆæ‘˜è¦\")\n        \n        # æš‚åœä¸€ä¸‹ï¼Œæ–¹ä¾¿è§‚å¯Ÿ\n        await asyncio.sleep(0.1)\n    \n    # æœ€ç»ˆç»Ÿè®¡\n    print(f\"\\n{'='*60}\")\n    print(\"æœ€ç»ˆç»Ÿè®¡\")\n    print(f\"{'='*60}\")\n    \n    # æ™ºèƒ½åŠ è½½ç»Ÿè®¡\n    loader_stats = memory.smart_loader.get_stats()\n    print(f\"\\nğŸ“Š æ™ºèƒ½åŠ è½½ç»Ÿè®¡:\")\n    print(f\"   æ€»åŠ è½½æ¬¡æ•°: {loader_stats['total_loads']}\")\n    print(f\"   å¹³å‡æˆæœ¬: {loader_stats['average_cost']:.2f}\")\n    print(f\"   ç­–ç•¥åˆ†å¸ƒ:\")\n    for strategy in ['new_conversation', 'simple_followup', 'medium_followup', \n                     'complex_followup', 'cross_session']:\n        count = loader_stats.get(strategy, 0)\n        if count > 0:\n            percentage = count / loader_stats['total_loads'] * 100\n            print(f\"     - {strategy}: {count} ({percentage:.1f}%)\")\n    \n    # å­˜å‚¨ç»Ÿè®¡\n    storage_stats = memory.storage.get_stats()\n    print(f\"\\nğŸ“¦ å­˜å‚¨ç»Ÿè®¡:\")\n    print(f\"   æ€»ä¼šè¯æ•°: {storage_stats['total_sessions']}\")\n    print(f\"   æ€»å¯¹è¯æ•°: {storage_stats['total_conversations']}\")\n    print(f\"   æ‘˜è¦æ•°: {storage_stats['summaries']}\")\n    print(f\"   ç”¨æˆ·ç”»åƒæ•°: {storage_stats['user_profiles']}\")\n    \n    print(f\"\\nâœ… è°ƒè¯•å®Œæˆï¼\")\n\n\nasync def test_specific_scenario():\n    \"\"\"æµ‹è¯•ç‰¹å®šåœºæ™¯\""
},
{
"path": "tests/test_memory_integration.py",
"start": 1,
"end": 323,
"text": "\"\"\"\nMemoryç³»ç»Ÿé›†æˆæµ‹è¯•\n\næµ‹è¯•æ™ºèƒ½åŠ è½½ã€æ‘˜è¦ç”Ÿæˆã€ç”¨æˆ·ç”»åƒç­‰åŠŸèƒ½\n\"\"\"\n\nimport asyncio\nimport logging\nfrom daoyoucode.agents.memory import get_memory_manager\nfrom daoyoucode.agents.core.agent import BaseAgent, AgentConfig, AgentResult\nfrom daoyoucode.agents.llm import get_client_manager\nfrom daoyoucode.agents.llm.config_loader import auto_configure\n\n# é…ç½®æ—¥å¿—\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nlogger = logging.getLogger(__name__)\n\n\nasync def test_basic_memory():\n    \"\"\"æµ‹è¯•1ï¼šåŸºç¡€è®°å¿†åŠŸèƒ½\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•1ï¼šåŸºç¡€è®°å¿†åŠŸèƒ½\")\n    print(\"=\"*60)\n    \n    memory = get_memory_manager()\n    \n    # æ·»åŠ å¯¹è¯\n    memory.add_conversation(\n        session_id=\"test-1\",\n        user_message=\"ä½ å¥½\",\n        ai_response=\"ä½ å¥½ï¼æˆ‘æ˜¯DaoyouCodeã€‚\"\n    )\n    \n    memory.add_conversation(\n        session_id=\"test-1\",\n        user_message=\"è¿™ä¸ªé¡¹ç›®çš„ç»“æ„æ˜¯ä»€ä¹ˆï¼Ÿ\",\n        ai_response=\"é¡¹ç›®åŒ…å«ä»¥ä¸‹æ¨¡å—...\"\n    )\n    \n    # è·å–å†å²\n    history = memory.get_conversation_history(\"test-1\")\n    \n    print(f\"âœ… æ·»åŠ äº† {len(history)} è½®å¯¹è¯\")\n    for idx, h in enumerate(history, 1):\n        print(f\"  ç¬¬{idx}è½®: {h['user'][:30]}...\")\n    \n    return True\n\n\nasync def test_smart_loading():\n    \"\"\"æµ‹è¯•2ï¼šæ™ºèƒ½åŠ è½½ç­–ç•¥\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•2ï¼šæ™ºèƒ½åŠ è½½ç­–ç•¥\")\n    print(\"=\"*60)\n    \n    memory = get_memory_manager()\n    \n    # å‡†å¤‡æµ‹è¯•æ•°æ®\n    session_id = \"test-smart-loading\"\n    user_id = \"user-123\"\n    \n    # æ·»åŠ å¤šè½®å¯¹è¯\n    conversations = [\n        (\"è¿™ä¸ªé¡¹ç›®çš„ç»“æ„æ˜¯ä»€ä¹ˆï¼Ÿ\", \"é¡¹ç›®åŒ…å«ä»¥ä¸‹æ¨¡å—...\"),\n        (\"æœ‰å“ªäº›æ ¸å¿ƒç»„ä»¶ï¼Ÿ\", \"æ ¸å¿ƒç»„ä»¶åŒ…æ‹¬...\"),\n        (\"Agentç³»ç»Ÿåœ¨å“ªé‡Œï¼Ÿ\", \"Agentç³»ç»Ÿåœ¨backend/daoyoucode/agents/...\"),\n        (\"å·¥å…·æ³¨å†Œè¡¨æ€ä¹ˆå·¥ä½œçš„ï¼Ÿ\", \"å·¥å…·æ³¨å†Œè¡¨ä½¿ç”¨å•ä¾‹æ¨¡å¼...\"),\n        (\"ç¼–æ’å™¨æœ‰å“ªäº›ç±»å‹ï¼Ÿ\", \"ç¼–æ’å™¨æœ‰Simpleã€ReActã€Parallel...\"),\n        (\"Memoryç³»ç»Ÿåœ¨å“ªé‡Œï¼Ÿ\", \"Memoryç³»ç»Ÿåœ¨backend/daoyoucode/agents/memory/...\"),\n    ]\n    \n    for user_msg, ai_msg in conversations:\n        memory.add_conversation(session_id, user_msg, ai_msg)\n    \n    print(f\"âœ… æ·»åŠ äº† {len(conversations)} è½®å¯¹è¯\")\n    \n    # æµ‹è¯•ä¸åŒçš„åŠ è½½ç­–ç•¥\n    test_cases = [\n        (\"æ–°å¯¹è¯\", \"å®Œå…¨ä¸ç›¸å…³çš„é—®é¢˜ï¼šä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ\", False, 0.0),\n        (\"ç®€å•è¿½é—®\", \"èƒ½è¯¦ç»†è¯´è¯´å—ï¼Ÿ\", True, 0.9),\n        (\"ç›¸å…³é—®é¢˜\", \"Memoryç³»ç»Ÿæœ‰å“ªäº›åŠŸèƒ½ï¼Ÿ\", True, 0.7),\n    ]\n    \n    for test_name, user_input, is_followup, confidence in test_cases:\n        print(f\"\\n--- {test_name} ---\")\n        print(f\"ç”¨æˆ·è¾“å…¥: {user_input}\")\n        print(f\"è¿½é—®åˆ¤æ–­: {is_followup} (ç½®ä¿¡åº¦: {confidence})\")\n        \n        # æ™ºèƒ½åŠ è½½\n        context = await memory.load_context_smart(\n            session_id=session_id,\n            user_id=user_id,\n            user_input=user_input,\n            is_followup=is_followup,\n            confidence=confidence\n        )\n        \n        print(f\"âœ… åŠ è½½ç­–ç•¥: {context['strategy']}\")\n        print(f\"   å†å²è½®æ•°: {len(context['history'])}\")\n        print(f\"   æˆæœ¬: {context['cost']}\")\n        print(f\"   æ™ºèƒ½ç­›é€‰: {'æ˜¯' if context.get('filtered') else 'å¦'}\")\n        \n        if context['history']:\n            print(f\"   åŠ è½½çš„å¯¹è¯:\")\n            for idx, h in enumerate(context['history'], 1):\n                print(f\"     {idx}. {h['user'][:40]}...\")\n    \n    return True\n\n\nasync def test_summary_generation():\n    \"\"\"æµ‹è¯•3ï¼šæ‘˜è¦ç”Ÿæˆ\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•3ï¼šæ‘˜è¦ç”Ÿæˆ\")\n    print(\"=\"*60)\n    \n    memory = get_memory_manager()\n    \n    # å‡†å¤‡æµ‹è¯•æ•°æ®\n    session_id = \"test-summary\"\n    \n    # æ·»åŠ 5è½®å¯¹è¯ï¼ˆè§¦å‘æ‘˜è¦ï¼‰\n    conversations = [\n        (\"è¿™ä¸ªé¡¹ç›®æ˜¯åšä»€ä¹ˆçš„ï¼Ÿ\", \"è¿™æ˜¯ä¸€ä¸ªAIä»£ç åŠ©æ‰‹é¡¹ç›®...\"),\n        (\"æœ‰å“ªäº›æ ¸å¿ƒåŠŸèƒ½ï¼Ÿ\", \"æ ¸å¿ƒåŠŸèƒ½åŒ…æ‹¬ä»£ç ç¼–è¾‘ã€é‡æ„ã€æµ‹è¯•...\"),\n        (\"Agentç³»ç»Ÿæ˜¯æ€ä¹ˆå·¥ä½œçš„ï¼Ÿ\", \"Agentç³»ç»Ÿä½¿ç”¨å¯æ’æ‹”æ¶æ„...\"),\n        (\"å·¥å…·ç³»ç»Ÿæœ‰å“ªäº›å·¥å…·ï¼Ÿ\", \"å·¥å…·ç³»ç»Ÿæœ‰25ä¸ªå·¥å…·...\"),\n        (\"Memoryç³»ç»Ÿæœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Ÿ\", \"Memoryç³»ç»Ÿæ”¯æŒæ™ºèƒ½åŠ è½½...\"),\n    ]\n    \n    for user_msg, ai_msg in conversations:\n        memory.add_conversation(session_id, user_msg, ai_msg)\n    \n    print(f\"âœ… æ·»åŠ äº† {len(conversations)} è½®å¯¹è¯\")\n    \n    # æ£€æŸ¥æ˜¯å¦åº”è¯¥ç”Ÿæˆæ‘˜è¦\n    history = memory.get_conversation_history(session_id)\n    should_generate = memory.long_term_memory.should_generate_summary(\n        session_id, len(history)\n    )\n    \n    print(f\"æ˜¯å¦åº”è¯¥ç”Ÿæˆæ‘˜è¦: {should_generate}\")\n    \n    if should_generate:\n        print(\"âš ï¸ éœ€è¦LLMå®¢æˆ·ç«¯æ‰èƒ½ç”Ÿæˆæ‘˜è¦\")\n        print(\"ğŸ’¡ åœ¨å®é™…ä½¿ç”¨ä¸­ï¼ŒAgentä¼šè‡ªåŠ¨è°ƒç”¨LLMç”Ÿæˆæ‘˜è¦\")\n    \n   "
},
{
"path": "tests/test_multi_branch.py",
"start": 1,
"end": 11,
"text": "\"\"\"\næµ‹è¯•å¤šè·¯åˆ†æ”¯ConditionalOrchestrator\n\"\"\"\n\nimport asyncio\nfrom dataclasses import dataclass\nfrom typing import Dict, Any, Optional\n\n\n# æ¨¡æ‹ŸSkillConfig\n@dataclass"
},
{
"path": "tests/test_multi_branch.py",
"start": 12,
"end": 33,
"text": "class SkillConfig:\n    name: str\n    orchestrator: str\n    conditions: list = None\n    condition: str = None\n    if_path: dict = None\n    else_path: dict = None\n    middleware: list = None\n    tools: list = None\n\n\n# å¯¼å…¥ConditionalOrchestrator\nimport sys\nimport os\nsys.path.insert(0, os.path.dirname(__file__))\n\nfrom daoyoucode.agents.orchestrators.conditional import ConditionalOrchestrator\nfrom daoyoucode.agents.core.agent import BaseAgent, AgentConfig\nfrom daoyoucode.agents.registry import register_agent\n\n\n# åˆ›å»ºMock Agentså¹¶æ³¨å†Œ"
},
{
"path": "tests/test_multi_branch.py",
"start": 34,
"end": 34,
"text": "class MockAgent(BaseAgent):"
},
{
"path": "tests/test_multi_branch.py",
"start": 35,
"end": 253,
"text": "    def __init__(self, name: str):\n        config = AgentConfig(\n            name=name,\n            description=f\"Mock {name}\",\n            model=\"mock-model\"\n        )\n        super().__init__(config)\n    \n    async def execute(self, prompt_source, user_input, context, llm_config=None, tools=None, max_tool_iterations=5):\n        from daoyoucode.agents.core.agent import AgentResult\n        return AgentResult(\n            success=True,\n            content=f'{self.name} å¤„ç†: {user_input}',\n            metadata={'agent': self.name}\n        )\n\n\n# æ³¨å†ŒMock Agents\nregister_agent(MockAgent('python_expert'))\nregister_agent(MockAgent('js_expert'))\nregister_agent(MockAgent('java_expert'))\nregister_agent(MockAgent('general_editor'))\n\n\nasync def test_simple_branch():\n    \"\"\"æµ‹è¯•ç®€å•çš„if/elseåˆ†æ”¯ï¼ˆå‘åå…¼å®¹ï¼‰\"\"\"\n    print(\"\\n=== æµ‹è¯•1: ç®€å•åˆ†æ”¯ï¼ˆif/elseï¼‰===\")\n    \n    # åˆ›å»ºSkillé…ç½®\n    skill = SkillConfig(\n        name='simple-edit',\n        orchestrator='conditional',\n        condition='${language} == \"python\"',  # ç›´æ¥å¼•ç”¨contextä¸­çš„key\n        if_path={\n            'agent': 'python_expert'\n        },\n        else_path={\n            'agent': 'general_editor'\n        }\n    )\n    \n    # åˆ›å»ºç¼–æ’å™¨\n    orchestrator = ConditionalOrchestrator()\n    orchestrator._agent_registry = MockAgentRegistry()\n    \n    # æµ‹è¯•1: Pythonæ–‡ä»¶\n    print(\"\\næµ‹è¯•1.1: Pythonæ–‡ä»¶\")\n    context = {'language': 'python'}\n    result = await orchestrator.execute(skill, 'ä¿®æ”¹æ–‡ä»¶', context)\n    print(f\"ç»“æœ: {result['content']}\")\n    print(f\"å…ƒæ•°æ®: {result['metadata']}\")\n    assert 'python_expert' in result['content']\n    \n    # æµ‹è¯•2: JavaScriptæ–‡ä»¶\n    print(\"\\næµ‹è¯•1.2: JavaScriptæ–‡ä»¶\")\n    context = {'language': 'javascript'}\n    result = await orchestrator.execute(skill, 'ä¿®æ”¹æ–‡ä»¶', context)\n    print(f\"ç»“æœ: {result['content']}\")\n    print(f\"å…ƒæ•°æ®: {result['metadata']}\")\n    assert 'general_editor' in result['content']\n    \n    print(\"\\nâœ… ç®€å•åˆ†æ”¯æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_multi_branch():\n    \"\"\"æµ‹è¯•å¤šè·¯åˆ†æ”¯\"\"\"\n    print(\"\\n=== æµ‹è¯•2: å¤šè·¯åˆ†æ”¯ ===\")\n    \n    # åˆ›å»ºSkillé…ç½®\n    skill = SkillConfig(\n        name='smart-edit',\n        orchestrator='conditional',\n        conditions=[\n            {\n                'condition': '${language} == \"python\"',\n                'path': {\n                    'agent': 'python_expert'\n                }\n            },\n            {\n                'condition': '${language} == \"javascript\"',\n                'path': {\n                    'agent': 'js_expert'\n                }\n            },\n            {\n                'condition': '${language} == \"java\"',\n                'path': {\n                    'agent': 'java_expert'\n                }\n            },\n            {\n                'default': True,\n                'path': {\n                    'agent': 'general_editor'\n                }\n            }\n        ]\n    )\n    \n    # åˆ›å»ºç¼–æ’å™¨\n    orchestrator = ConditionalOrchestrator()\n    orchestrator._agent_registry = MockAgentRegistry()\n    \n    # æµ‹è¯•1: Python\n    print(\"\\næµ‹è¯•2.1: Pythonæ–‡ä»¶\")\n    context = {'language': 'python'}\n    result = await orchestrator.execute(skill, 'ä¿®æ”¹æ–‡ä»¶', context)\n    print(f\"ç»“æœ: {result['content']}\")\n    print(f\"å…ƒæ•°æ®: {result['metadata']}\")\n    assert 'python_expert' in result['content']\n    assert result['metadata']['branch_index'] == 0\n    \n    # æµ‹è¯•2: JavaScript\n    print(\"\\næµ‹è¯•2.2: JavaScriptæ–‡ä»¶\")\n    context = {'language': 'javascript'}\n    result = await orchestrator.execute(skill, 'ä¿®æ”¹æ–‡ä»¶', context)\n    print(f\"ç»“æœ: {result['content']}\")\n    print(f\"å…ƒæ•°æ®: {result['metadata']}\")\n    assert 'js_expert' in result['content']\n    assert result['metadata']['branch_index'] == 1\n    \n    # æµ‹è¯•3: Java\n    print(\"\\næµ‹è¯•2.3: Javaæ–‡ä»¶\")\n    context = {'language': 'java'}\n    result = await orchestrator.execute(skill, 'ä¿®æ”¹æ–‡ä»¶', context)\n    print(f\"ç»“æœ: {result['content']}\")\n    print(f\"å…ƒæ•°æ®: {result['metadata']}\")\n    assert 'java_expert' in result['content']\n    assert result['metadata']['branch_index'] == 2\n    \n    # æµ‹è¯•4: å…¶ä»–è¯­è¨€ï¼ˆdefaultï¼‰\n    print(\"\\næµ‹è¯•2.4: å…¶ä»–è¯­è¨€ï¼ˆdefaultï¼‰\")\n    context = {'language': 'rust'}\n    result "
},
{
"path": "tests/test_multi_branch_simple.py",
"start": 1,
"end": 16,
"text": "\"\"\"\næµ‹è¯•å¤šè·¯åˆ†æ”¯ConditionalOrchestrator - ç®€åŒ–ç‰ˆ\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\nsys.path.insert(0, os.path.dirname(__file__))\n\nfrom dataclasses import dataclass\nfrom daoyoucode.agents.orchestrators.conditional import ConditionalOrchestrator\nfrom daoyoucode.agents.core.agent import BaseAgent, AgentConfig, AgentResult, register_agent\n\n\n# æ¨¡æ‹ŸSkillConfig\n@dataclass"
},
{
"path": "tests/test_multi_branch_simple.py",
"start": 17,
"end": 28,
"text": "class SkillConfig:\n    name: str\n    orchestrator: str\n    conditions: list = None\n    condition: str = None\n    if_path: dict = None\n    else_path: dict = None\n    middleware: list = None\n    tools: list = None\n\n\n# åˆ›å»ºMock Agent"
},
{
"path": "tests/test_multi_branch_simple.py",
"start": 29,
"end": 179,
"text": "class MockAgent(BaseAgent):\n    async def execute(self, prompt_source, user_input, context, llm_config=None, tools=None, max_tool_iterations=5):\n        return AgentResult(\n            success=True,\n            content=f'{self.name} å¤„ç†: {user_input}',\n            metadata={'agent': self.name}\n        )\n\n\n# æ³¨å†ŒAgents\nfor name in ['python_expert', 'js_expert', 'java_expert', 'general_editor']:\n    config = AgentConfig(name=name, description=f\"Mock {name}\", model=\"mock\")\n    agent = MockAgent(config)\n    register_agent(agent)\n\n\nasync def test_simple_branch():\n    \"\"\"æµ‹è¯•ç®€å•åˆ†æ”¯\"\"\"\n    print(\"\\n=== æµ‹è¯•1: ç®€å•åˆ†æ”¯ï¼ˆif/elseï¼‰===\")\n    \n    skill = SkillConfig(\n        name='simple-edit',\n        orchestrator='conditional',\n        condition='${language} == \"python\"',\n        if_path={'agent': 'python_expert'},\n        else_path={'agent': 'general_editor'}\n    )\n    \n    orchestrator = ConditionalOrchestrator()\n    \n    # Pythonæ–‡ä»¶\n    print(\"\\næµ‹è¯•1.1: Pythonæ–‡ä»¶\")\n    result = await orchestrator.execute(skill, 'ä¿®æ”¹æ–‡ä»¶', {'language': 'python'})\n    print(f\"ç»“æœ: {result['content']}\")\n    print(f\"è·¯å¾„: {result['metadata']['path_executed']}\")\n    assert 'python_expert' in result['content']\n    \n    # JavaScriptæ–‡ä»¶\n    print(\"\\næµ‹è¯•1.2: JavaScriptæ–‡ä»¶\")\n    result = await orchestrator.execute(skill, 'ä¿®æ”¹æ–‡ä»¶', {'language': 'javascript'})\n    print(f\"ç»“æœ: {result['content']}\")\n    print(f\"è·¯å¾„: {result['metadata']['path_executed']}\")\n    assert 'general_editor' in result['content']\n    \n    print(\"âœ… ç®€å•åˆ†æ”¯æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_multi_branch():\n    \"\"\"æµ‹è¯•å¤šè·¯åˆ†æ”¯\"\"\"\n    print(\"\\n=== æµ‹è¯•2: å¤šè·¯åˆ†æ”¯ ===\")\n    \n    skill = SkillConfig(\n        name='smart-edit',\n        orchestrator='conditional',\n        conditions=[\n            {'condition': '${language} == \"python\"', 'path': {'agent': 'python_expert'}},\n            {'condition': '${language} == \"javascript\"', 'path': {'agent': 'js_expert'}},\n            {'condition': '${language} == \"java\"', 'path': {'agent': 'java_expert'}},\n            {'default': True, 'path': {'agent': 'general_editor'}}\n        ]\n    )\n    \n    orchestrator = ConditionalOrchestrator()\n    \n    # Python\n    print(\"\\næµ‹è¯•2.1: Python\")\n    result = await orchestrator.execute(skill, 'ä¿®æ”¹æ–‡ä»¶', {'language': 'python'})\n    print(f\"ç»“æœ: {result['content']}\")\n    print(f\"åˆ†æ”¯: {result['metadata']['branch_index']}\")\n    assert 'python_expert' in result['content']\n    assert result['metadata']['branch_index'] == 0\n    \n    # JavaScript\n    print(\"\\næµ‹è¯•2.2: JavaScript\")\n    result = await orchestrator.execute(skill, 'ä¿®æ”¹æ–‡ä»¶', {'language': 'javascript'})\n    print(f\"ç»“æœ: {result['content']}\")\n    print(f\"åˆ†æ”¯: {result['metadata']['branch_index']}\")\n    assert 'js_expert' in result['content']\n    assert result['metadata']['branch_index'] == 1\n    \n    # Java\n    print(\"\\næµ‹è¯•2.3: Java\")\n    result = await orchestrator.execute(skill, 'ä¿®æ”¹æ–‡ä»¶', {'language': 'java'})\n    print(f\"ç»“æœ: {result['content']}\")\n    print(f\"åˆ†æ”¯: {result['metadata']['branch_index']}\")\n    assert 'java_expert' in result['content']\n    assert result['metadata']['branch_index'] == 2\n    \n    # å…¶ä»–ï¼ˆdefaultï¼‰\n    print(\"\\næµ‹è¯•2.4: Rust (default)\")\n    result = await orchestrator.execute(skill, 'ä¿®æ”¹æ–‡ä»¶', {'language': 'rust'})\n    print(f\"ç»“æœ: {result['content']}\")\n    print(f\"æ¡ä»¶: {result['metadata']['matched_condition']}\")\n    assert 'general_editor' in result['content']\n    assert result['metadata']['matched_condition'] == 'default'\n    \n    print(\"âœ… å¤šè·¯åˆ†æ”¯æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_complex_conditions():\n    \"\"\"æµ‹è¯•å¤æ‚æ¡ä»¶\"\"\"\n    print(\"\\n=== æµ‹è¯•3: å¤æ‚æ¡ä»¶ ===\")\n    \n    skill = SkillConfig(\n        name='smart-analysis',\n        orchestrator='conditional',\n        conditions=[\n            {'condition': '${file_size} < 1000 and ${language} == \"python\"', 'path': {'agent': 'python_expert'}},\n            {'condition': '${file_size} >= 1000', 'path': {'agent': 'general_editor'}},\n            {'default': True, 'path': {'agent': 'general_editor'}}\n        ]\n    )\n    \n    orchestrator = ConditionalOrchestrator()\n    \n    # å°Pythonæ–‡ä»¶\n    print(\"\\næµ‹è¯•3.1:"
},
{
"path": "tests/test_new_agents.py",
"start": 1,
"end": 19,
"text": "\"\"\"\næµ‹è¯•æ–°å¢çš„Agentï¼ˆSisyphus, Oracle, Librarianï¼‰\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nbackend_dir = Path(__file__).parent.parent\nsys.path.insert(0, str(backend_dir))\n\nfrom daoyoucode.agents.builtin import register_builtin_agents\nfrom daoyoucode.agents.core.agent import get_agent_registry\nfrom daoyoucode.agents.tools.tool_groups import (\n    get_tools_for_agent,\n    AGENT_TOOL_MAPPING\n)\n\n"
},
{
"path": "tests/test_new_agents.py",
"start": 20,
"end": 53,
"text": "def test_agent_registration():\n    \"\"\"æµ‹è¯•Agentæ³¨å†Œ\"\"\"\n    print(\"=\" * 80)\n    print(\"æµ‹è¯•Agentæ³¨å†Œ\")\n    print(\"=\" * 80)\n    \n    # æ³¨å†Œæ‰€æœ‰å†…ç½®Agent\n    register_builtin_agents()\n    \n    # è·å–æ³¨å†Œè¡¨\n    registry = get_agent_registry()\n    \n    # æµ‹è¯•æ–°Agent\n    new_agents = ['sisyphus', 'oracle', 'librarian']\n    \n    for agent_name in new_agents:\n        print(f\"\\næµ‹è¯• {agent_name}...\")\n        \n        # è·å–Agentå®ä¾‹\n        agent = registry.get_agent(agent_name)\n        assert agent is not None, f\"Agent {agent_name} æœªæ³¨å†Œ\"\n        \n        # æ£€æŸ¥é…ç½®\n        print(f\"  âœ“ Agentå·²æ³¨å†Œ\")\n        print(f\"  - åç§°: {agent.config.name}\")\n        print(f\"  - æè¿°: {agent.config.description}\")\n        print(f\"  - æ¨¡å‹: {agent.config.model}\")\n        print(f\"  - æ¸©åº¦: {agent.config.temperature}\")\n    \n    print(\"\\n\" + \"=\" * 80)\n    print(\"âœ“ æ‰€æœ‰æ–°Agentæ³¨å†ŒæˆåŠŸ\")\n    print(\"=\" * 80)\n\n"
},
{
"path": "tests/test_new_agents.py",
"start": 54,
"end": 84,
"text": "def test_tool_mapping():\n    \"\"\"æµ‹è¯•å·¥å…·æ˜ å°„\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"æµ‹è¯•å·¥å…·æ˜ å°„\")\n    print(\"=\" * 80)\n    \n    new_agents = {\n        'sisyphus': 4,      # åº”è¯¥æœ‰4ä¸ªå·¥å…·\n        'oracle': 10,       # åº”è¯¥æœ‰10ä¸ªå·¥å…·\n        'librarian': 8      # åº”è¯¥æœ‰8ä¸ªå·¥å…·\n    }\n    \n    for agent_name, expected_count in new_agents.items():\n        print(f\"\\næµ‹è¯• {agent_name} çš„å·¥å…·...\")\n        \n        # è·å–å·¥å…·åˆ—è¡¨\n        tools = get_tools_for_agent(agent_name)\n        assert len(tools) > 0, f\"Agent {agent_name} æ²¡æœ‰é…ç½®å·¥å…·\"\n        \n        print(f\"  âœ“ å·¥å…·æ•°é‡: {len(tools)} (é¢„æœŸ: {expected_count})\")\n        print(f\"  - å·¥å…·åˆ—è¡¨: {', '.join(tools)}\")\n        \n        # éªŒè¯å·¥å…·æ•°é‡\n        if len(tools) != expected_count:\n            print(f\"  âš  è­¦å‘Š: å·¥å…·æ•°é‡ä¸åŒ¹é… (å®é™…: {len(tools)}, é¢„æœŸ: {expected_count})\")\n    \n    print(\"\\n\" + \"=\" * 80)\n    print(\"âœ“ å·¥å…·æ˜ å°„æµ‹è¯•å®Œæˆ\")\n    print(\"=\" * 80)\n\n"
},
{
"path": "tests/test_new_agents.py",
"start": 85,
"end": 106,
"text": "def test_agent_tool_mapping_table():\n    \"\"\"æµ‹è¯•Agentå·¥å…·æ˜ å°„è¡¨\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"Agentå·¥å…·æ˜ å°„è¡¨\")\n    print(\"=\" * 80)\n    \n    print(\"\\næ‰€æœ‰AgentåŠå…¶å·¥å…·æ•°é‡:\")\n    for agent_name, tools in sorted(AGENT_TOOL_MAPPING.items()):\n        print(f\"  {agent_name:20s}: {len(tools):2d} ä¸ªå·¥å…·\")\n    \n    print(\"\\næ–°å¢Agentè¯¦æƒ…:\")\n    new_agents = ['sisyphus', 'oracle', 'librarian']\n    for agent_name in new_agents:\n        if agent_name in AGENT_TOOL_MAPPING:\n            tools = AGENT_TOOL_MAPPING[agent_name]\n            print(f\"\\n{agent_name}:\")\n            for i, tool in enumerate(tools, 1):\n                print(f\"  {i:2d}. {tool}\")\n    \n    print(\"\\n\" + \"=\" * 80)\n\n"
},
{
"path": "tests/test_new_agents.py",
"start": 107,
"end": 142,
"text": "def test_skill_files():\n    \"\"\"æµ‹è¯•Skillé…ç½®æ–‡ä»¶\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"æµ‹è¯•Skillé…ç½®æ–‡ä»¶\")\n    print(\"=\" * 80)\n    \n    skills_dir = backend_dir.parent / \"skills\"\n    \n    new_skills = {\n        'sisyphus-orchestrator': ['skill.yaml', 'prompts/sisyphus.md'],\n        'oracle': ['skill.yaml', 'prompts/oracle.md'],\n        'librarian': ['skill.yaml', 'prompts/librarian.md']\n    }\n    \n    for skill_name, files in new_skills.items():\n        print(f\"\\næµ‹è¯• {skill_name}...\")\n        skill_dir = skills_dir / skill_name\n        \n        if not skill_dir.exists():\n            print(f\"  âœ— Skillç›®å½•ä¸å­˜åœ¨: {skill_dir}\")\n            continue\n        \n        print(f\"  âœ“ Skillç›®å½•å­˜åœ¨\")\n        \n        for file_path in files:\n            full_path = skill_dir / file_path\n            if full_path.exists():\n                print(f\"  âœ“ {file_path} å­˜åœ¨\")\n            else:\n                print(f\"  âœ— {file_path} ä¸å­˜åœ¨\")\n    \n    print(\"\\n\" + \"=\" * 80)\n    print(\"âœ“ Skillé…ç½®æ–‡ä»¶æµ‹è¯•å®Œæˆ\")\n    print(\"=\" * 80)\n\n"
},
{
"path": "tests/test_new_agents.py",
"start": 143,
"end": 169,
"text": "def main():\n    \"\"\"è¿è¡Œæ‰€æœ‰æµ‹è¯•\"\"\"\n    try:\n        test_agent_registration()\n        test_tool_mapping()\n        test_agent_tool_mapping_table()\n        test_skill_files()\n        \n        print(\"\\n\" + \"=\" * 80)\n        print(\"âœ“âœ“âœ“ æ‰€æœ‰æµ‹è¯•é€šè¿‡ âœ“âœ“âœ“\")\n        print(\"=\" * 80)\n        print(\"\\næ–°å¢Agentæ€»ç»“:\")\n        print(\"  1. Sisyphus - ä¸»ç¼–æ’Agent (4ä¸ªå·¥å…·)\")\n        print(\"  2. Oracle - é«˜IQå’¨è¯¢Agent (10ä¸ªå·¥å…·)\")\n        print(\"  3. Librarian - æ–‡æ¡£æœç´¢Agent (8ä¸ªå·¥å…·)\")\n        print(\"\\næ‰€æœ‰Agentå·²æ­£ç¡®æ³¨å†Œï¼Œå·¥å…·æ˜ å°„å·²é…ç½®ï¼ŒSkillæ–‡ä»¶å·²åˆ›å»ºã€‚\")\n        print(\"=\" * 80)\n        \n    except Exception as e:\n        print(f\"\\nâœ— æµ‹è¯•å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main()"
},
{
"path": "tests/test_new_tools.py",
"start": 1,
"end": 175,
"text": "\"\"\"\næµ‹è¯•æ–°å¢å·¥å…·ï¼ˆæœç´¢å·¥å…·å’ŒGitå·¥å…·ï¼‰\n\"\"\"\n\nimport asyncio\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents.tools import get_tool_registry\n\n\nasync def test_search_tools():\n    \"\"\"æµ‹è¯•æœç´¢å·¥å…·\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•æœç´¢å·¥å…·\")\n    print(\"=\"*60)\n    \n    registry = get_tool_registry()\n    \n    # 1. æµ‹è¯•grep_search\n    print(\"\\n1. æµ‹è¯• grep_search\")\n    print(\"-\" * 40)\n    \n    result = await registry.execute_tool(\n        'grep_search',\n        pattern='class.*Agent',\n        directory='daoyoucode/agents',\n        file_pattern='*.py',\n        recursive=True,\n        max_results=5\n    )\n    print(result)\n    \n    # 2. æµ‹è¯•find_function\n    print(\"\\n2. æµ‹è¯• find_function\")\n    print(\"-\" * 40)\n    \n    result = await registry.execute_tool(\n        'find_function',\n        function_name='execute',\n        directory='daoyoucode/agents',\n        language='python'\n    )\n    print(result[:500] + \"...\" if len(result) > 500 else result)\n    \n    # 3. æµ‹è¯•find_class\n    print(\"\\n3. æµ‹è¯• find_class\")\n    print(\"-\" * 40)\n    \n    result = await registry.execute_tool(\n        'find_class',\n        class_name='BaseAgent',\n        directory='daoyoucode/agents',\n        language='python'\n    )\n    print(result)\n\n\nasync def test_git_tools():\n    \"\"\"æµ‹è¯•Gitå·¥å…·\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•Gitå·¥å…·\")\n    print(\"=\"*60)\n    \n    registry = get_tool_registry()\n    \n    # 1. æµ‹è¯•git_status\n    print(\"\\n1. æµ‹è¯• git_status\")\n    print(\"-\" * 40)\n    \n    try:\n        result = await registry.execute_tool('git_status', directory='.')\n        print(result)\n    except Exception as e:\n        print(f\"Error: {e}\")\n    \n    # 2. æµ‹è¯•git_branch\n    print(\"\\n2. æµ‹è¯• git_branch\")\n    print(\"-\" * 40)\n    \n    try:\n        result = await registry.execute_tool('git_branch', directory='.')\n        print(result)\n    except Exception as e:\n        print(f\"Error: {e}\")\n    \n    # 3. æµ‹è¯•git_log\n    print(\"\\n3. æµ‹è¯• git_log\")\n    print(\"-\" * 40)\n    \n    try:\n        result = await registry.execute_tool(\n            'git_log',\n            max_count=5,\n            directory='.'\n        )\n        print(result)\n    except Exception as e:\n        print(f\"Error: {e}\")\n    \n    # 4. æµ‹è¯•git_diff\n    print(\"\\n4. æµ‹è¯• git_diff\")\n    print(\"-\" * 40)\n    \n    try:\n        result = await registry.execute_tool('git_diff', directory='.')\n        print(result[:500] + \"...\" if len(result) > 500 else result)\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n\nasync def test_tool_registry():\n    \"\"\"æµ‹è¯•å·¥å…·æ³¨å†Œè¡¨\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•å·¥å…·æ³¨å†Œè¡¨\")\n    print(\"=\"*60)\n    \n    registry = get_tool_registry()\n    \n    # 1. åˆ—å‡ºæ‰€æœ‰å·¥å…·\n    print(\"\\n1. æ‰€æœ‰å·¥å…·\")\n    print(\"-\" * 40)\n    all_tools = registry.list_tools()\n    print(f\"æ€»å…± {len(all_tools)} ä¸ªå·¥å…·:\")\n    for tool_name in sorted(all_tools):\n        print(f\"  - {tool_name}\")\n    \n    # 2. æŒ‰åˆ†ç±»åˆ—å‡º\n    print(\"\\n2. æŒ‰åˆ†ç±»åˆ—å‡º\")\n    print(\"-\" * 40)\n    \n    categories = ['file', 'search', 'git']\n    for category in categories:\n        tools = registry.list_tools(category=category)\n        print(f\"\\n{category.upper()} å·¥å…· ({len(tools)}ä¸ª):\")\n        for tool_name in tools:\n            tool = registry.get_tool(tool_name)\n            print(f\"  - {tool_name}: {tool.description}\")\n    \n    # 3. è·å–Function Schemas\n    print(\"\\n3. Function Schemas (å‰3ä¸ª)\")\n    print(\"-\" * 40)\n    \n    schemas = registry.get_function_schemas()\n    for schema in schemas[:3]:\n        print(f\"\\n{schema['name']}:\")\n        print(f\"  æè¿°: {schema['description']}\")\n        print(f\"  å‚æ•°: {list(schema['parameters']['properties'].keys())}\")\n\n\nasync def main():\n    \"\"\"ä¸»å‡½æ•°\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æ–°å¢å·¥å…·æµ‹è¯•\")\n    print(\"=\"*60)\n    \n    # æµ‹è¯•å·¥å…·æ³¨å†Œè¡¨\n    await test_tool_registry()\n    \n    # æµ‹è¯•æœç´¢å·¥å…·\n    await test_search_tools()\n    \n    # æµ‹è¯•Gitå·¥å…·\n    await test_git_tools()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"æ‰€æœ‰æµ‹è¯•å®Œæˆï¼\")\n    print(\"=\"*60)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())"
},
{
"path": "tests/test_orchestration.py",
"start": 1,
"end": 272,
"text": "\"\"\"\næµ‹è¯•ç¼–æ’æµç¨‹\n\næµ‹è¯•ä¸åŒçš„ç¼–æ’å™¨å’Œå·¥å…·è°ƒç”¨\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents import execute_skill\nfrom daoyoucode.agents.core.skill import get_skill_loader\nfrom daoyoucode.agents.builtin import register_builtin_agents\n\n\nasync def test_simple_orchestrator_with_tools():\n    \"\"\"æµ‹è¯•ç®€å•ç¼–æ’å™¨ + å·¥å…·è°ƒç”¨\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•1: ç®€å•ç¼–æ’å™¨ + å·¥å…·è°ƒç”¨\")\n    print(\"=\"*60)\n    \n    # æ³¨å†ŒAgent\n    register_builtin_agents()\n    \n    # æµ‹è¯•ä»£ç æ¢ç´¢Skillï¼ˆå¸¦å·¥å…·ï¼‰\n    print(\"\\nåœºæ™¯: ä½¿ç”¨ä»£ç æ¢ç´¢AgentæŸ¥æ‰¾BaseAgentç±»\")\n    print(\"-\" * 40)\n    \n    try:\n        result = await execute_skill(\n            skill_name='code-exploration',\n            user_input='æŸ¥æ‰¾BaseAgentç±»çš„å®šä¹‰ä½ç½®',\n            context={\n                'search_scope': 'daoyoucode/agents',\n                'thoroughness': 'quick'\n            }\n        )\n        \n        print(f\"\\næ‰§è¡Œç»“æœ:\")\n        print(f\"  æˆåŠŸ: {result.get('success')}\")\n        print(f\"  ä½¿ç”¨çš„å·¥å…·: {result.get('tools_used', [])}\")\n        print(f\"  å“åº”å†…å®¹: {result.get('content', '')[:500]}...\")\n        \n    except Exception as e:\n        print(f\"é”™è¯¯: {e}\")\n        import traceback\n        traceback.print_exc()\n\n\nasync def test_multi_agent_orchestrator():\n    \"\"\"æµ‹è¯•å¤šAgentç¼–æ’å™¨\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•2: å¤šAgentç¼–æ’å™¨\")\n    print(\"=\"*60)\n    \n    # æ³¨å†ŒAgent\n    register_builtin_agents()\n    \n    # åˆ›å»ºä¸€ä¸ªéœ€è¦å¤šAgentåä½œçš„Skillé…ç½®\n    print(\"\\nåœºæ™¯: ä»£ç åˆ†æ + é‡æ„å»ºè®®\")\n    print(\"-\" * 40)\n    \n    # è¿™é‡Œéœ€è¦å…ˆåˆ›å»ºä¸€ä¸ªmulti-agentçš„skillé…ç½®\n    print(\"æç¤º: éœ€è¦åˆ›å»ºmulti-agent skillé…ç½®æ–‡ä»¶\")\n    print(\"æš‚æ—¶è·³è¿‡æ­¤æµ‹è¯•\")\n\n\nasync def test_workflow_orchestrator():\n    \"\"\"æµ‹è¯•å·¥ä½œæµç¼–æ’å™¨\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•3: å·¥ä½œæµç¼–æ’å™¨\")\n    print(\"=\"*60)\n    \n    # æ³¨å†ŒAgent\n    register_builtin_agents()\n    \n    print(\"\\nåœºæ™¯: åˆ†æ -> é‡æ„ -> æµ‹è¯• å·¥ä½œæµ\")\n    print(\"-\" * 40)\n    \n    # è¿™é‡Œéœ€è¦å…ˆåˆ›å»ºä¸€ä¸ªworkflowçš„skillé…ç½®\n    print(\"æç¤º: éœ€è¦åˆ›å»ºworkflow skillé…ç½®æ–‡ä»¶\")\n    print(\"æš‚æ—¶è·³è¿‡æ­¤æµ‹è¯•\")\n\n\nasync def test_programming_with_tools():\n    \"\"\"æµ‹è¯•ç¼–ç¨‹Agent + å·¥å…·\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•4: ç¼–ç¨‹Agent + å·¥å…·è°ƒç”¨\")\n    print(\"=\"*60)\n    \n    # æ³¨å†ŒAgent\n    register_builtin_agents()\n    \n    print(\"\\nåœºæ™¯: è¯»å–æ–‡ä»¶å¹¶åˆ†æä»£ç \")\n    print(\"-\" * 40)\n    \n    try:\n        result = await execute_skill(\n            skill_name='programming',\n            user_input='è¯»å–daoyoucode/agents/core/agent.pyæ–‡ä»¶ï¼Œåˆ†æBaseAgentç±»çš„ä¸»è¦åŠŸèƒ½',\n            context={\n                'language': 'python'\n            }\n        )\n        \n        print(f\"\\næ‰§è¡Œç»“æœ:\")\n        print(f\"  æˆåŠŸ: {result.get('success')}\")\n        print(f\"  ä½¿ç”¨çš„å·¥å…·: {result.get('tools_used', [])}\")\n        print(f\"  å“åº”å†…å®¹: {result.get('content', '')[:500]}...\")\n        \n    except Exception as e:\n        print(f\"é”™è¯¯: {e}\")\n        import traceback\n        traceback.print_exc()\n\n\nasync def test_skill_loading():\n    \"\"\"æµ‹è¯•SkillåŠ è½½\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•5: Skillé…ç½®åŠ è½½\")\n    print(\"=\"*60)\n    \n    # è·å–SkillåŠ è½½å™¨\n    skill_loader = get_skill_loader()\n    \n    # æµ‹è¯•åŠ è½½code-exploration skill\n    print(\"\\nåŠ è½½ code-exploration skill\")\n    print(\"-\" * 40)\n    \n    try:\n        skill = skill_loader.get_skill('code-exploration')\n        \n        if skill:\n            print(f\"Skillåç§°: {skill.name}\")\n            print(f\"ç‰ˆæœ¬: {skill.version}\")\n            print(f\"æè¿°: {skill.description}\")\n            print(f\"ç¼–æ’å™¨: {skill.orchestrator}\")\n            print(f\"Agent: {skill.agent}\")\n            print(f\"æ¨¡å‹: {skill.llm.get('model')}\")\n            print(f\"å¯ç”¨å·¥å…·: {getattr(skill, 'tools', [])}\")\n        else:\n            print(\"æœªæ‰¾åˆ° code-exploration skill\")\n        \n    except Exception as e:\n        print(f\"é”™è¯¯: {e}\")\n        import traceback\n        traceback.print_exc()\n    \n    # æµ‹è¯•åŠ è½½programming skill\n    print(\"\\nåŠ è½½ programming skill\")\n    print(\"-\" * 40)\n    \n    try:\n        skill = skill_loader.get_skill('programming')\n        \n        if skill:\n            print(f\"Skillåç§°: {skill.name}\")\n            print(f\"ç‰ˆæœ¬: {skill.version}\")\n            print(f\"æè¿°: {skill.description}\")\n            print(f\"ç¼–æ’å™¨: {skill.orchestrator"
},
{
"path": "tests/test_orchestrator_enhancements.py",
"start": 1,
"end": 17,
"text": "\"\"\"\næµ‹è¯•ç¼–æ’å™¨å¢å¼ºåŠŸèƒ½\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\nsys.path.insert(0, os.path.dirname(__file__))\n\nfrom dataclasses import dataclass\nfrom daoyoucode.agents.orchestrators.simple import SimpleOrchestrator\nfrom daoyoucode.agents.orchestrators.multi_agent import MultiAgentOrchestrator\nfrom daoyoucode.agents.core.agent import BaseAgent, AgentConfig, AgentResult, register_agent\n\n\n# æ¨¡æ‹ŸSkillConfig\n@dataclass"
},
{
"path": "tests/test_orchestrator_enhancements.py",
"start": 18,
"end": 32,
"text": "class SkillConfig:\n    name: str\n    orchestrator: str\n    agent: str = None\n    agents: list = None\n    collaboration_mode: str = None\n    max_retries: int = 3\n    retry_delay: float = 0.1\n    middleware: list = None\n    tools: list = None\n    llm: dict = None\n    prompt: dict = None\n\n\n# åˆ›å»ºMock Agent"
},
{
"path": "tests/test_orchestrator_enhancements.py",
"start": 33,
"end": 33,
"text": "class MockAgent(BaseAgent):"
},
{
"path": "tests/test_orchestrator_enhancements.py",
"start": 34,
"end": 260,
"text": "    def __init__(self, name: str, fail_count: int = 0):\n        config = AgentConfig(name=name, description=f\"Mock {name}\", model=\"mock\")\n        super().__init__(config)\n        self.fail_count = fail_count\n        self.call_count = 0\n    \n    async def execute(self, prompt_source, user_input, context, llm_config=None, tools=None, max_tool_iterations=5):\n        self.call_count += 1\n        \n        # æ¨¡æ‹Ÿå‰Næ¬¡å¤±è´¥\n        if self.call_count <= self.fail_count:\n            return AgentResult(\n                success=False,\n                content=\"\",\n                error=f\"æ¨¡æ‹Ÿå¤±è´¥ {self.call_count}\",\n                metadata={'agent': self.name}\n            )\n        \n        # æˆåŠŸ\n        return AgentResult(\n            success=True,\n            content=f'{self.name} å¤„ç†: {user_input}',\n            metadata={'agent': self.name},\n            tokens_used=100\n        )\n\n\n# æ³¨å†ŒAgents\nregister_agent(MockAgent('agent1'))\nregister_agent(MockAgent('agent2'))\nregister_agent(MockAgent('agent3'))\nregister_agent(MockAgent('failing_agent', fail_count=2))  # å‰2æ¬¡å¤±è´¥\n\n\nasync def test_simple_retry():\n    \"\"\"æµ‹è¯•SimpleOrchestratorçš„é‡è¯•æœºåˆ¶\"\"\"\n    print(\"\\n=== æµ‹è¯•1: SimpleOrchestratoré‡è¯•æœºåˆ¶ ===\")\n    \n    # æµ‹è¯•1.1: æ­£å¸¸æ‰§è¡Œï¼ˆæ— éœ€é‡è¯•ï¼‰\n    print(\"\\næµ‹è¯•1.1: æ­£å¸¸æ‰§è¡Œ\")\n    skill = SkillConfig(\n        name='test-skill',\n        orchestrator='simple',\n        agent='agent1'\n    )\n    \n    orchestrator = SimpleOrchestrator()\n    result = await orchestrator.execute(skill, 'æµ‹è¯•è¾“å…¥', {})\n    \n    print(f\"æˆåŠŸ: {result['success']}\")\n    print(f\"å†…å®¹: {result['content']}\")\n    print(f\"é‡è¯•æ¬¡æ•°: {result['metadata']['retries']}\")\n    print(f\"è€—æ—¶: {result['metadata']['duration']:.3f}s\")\n    \n    assert result['success']\n    assert result['metadata']['retries'] == 0\n    \n    # æµ‹è¯•1.2: å¤±è´¥åé‡è¯•æˆåŠŸ\n    print(\"\\næµ‹è¯•1.2: å¤±è´¥åé‡è¯•æˆåŠŸ\")\n    skill = SkillConfig(\n        name='test-skill',\n        orchestrator='simple',\n        agent='failing_agent',\n        max_retries=3\n    )\n    \n    # é‡ç½®failing_agentçš„è®¡æ•°\n    from daoyoucode.agents.core.agent import get_agent_registry\n    registry = get_agent_registry()\n    failing_agent = registry.get_agent('failing_agent')\n    failing_agent.call_count = 0\n    \n    orchestrator = SimpleOrchestrator()\n    result = await orchestrator.execute(skill, 'æµ‹è¯•è¾“å…¥', {})\n    \n    print(f\"æˆåŠŸ: {result['success']}\")\n    print(f\"å†…å®¹: {result['content']}\")\n    print(f\"é‡è¯•æ¬¡æ•°: {result['metadata']['retries']}\")\n    print(f\"è°ƒç”¨æ¬¡æ•°: {failing_agent.call_count}\")\n    \n    assert result['success']\n    assert result['metadata']['retries'] == 2  # å‰2æ¬¡å¤±è´¥ï¼Œç¬¬3æ¬¡æˆåŠŸ\n    assert failing_agent.call_count == 3\n    \n    print(\"\\nâœ… SimpleOrchestratoré‡è¯•æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_multi_agent_sequential():\n    \"\"\"æµ‹è¯•MultiAgentOrchestratorçš„é¡ºåºæ‰§è¡Œæ¨¡å¼\"\"\"\n    print(\"\\n=== æµ‹è¯•2: MultiAgentOrchestratoré¡ºåºæ‰§è¡Œ ===\")\n    \n    skill = SkillConfig(\n        name='multi-agent-skill',\n        orchestrator='multi_agent',\n        agents=['agent1', 'agent2', 'agent3'],\n        collaboration_mode='sequential'\n    )\n    \n    orchestrator = MultiAgentOrchestrator()\n    result = await orchestrator.execute(skill, 'åˆå§‹è¾“å…¥', {})\n    \n    print(f\"æˆåŠŸ: {result['success']}\")\n    print(f\"åä½œæ¨¡å¼: {result['metadata']['collaboration_mode']}\")\n    print(f\"Agentæ•°é‡: {result['metadata']['agents_count']}\")\n    print(f\"é¡ºåºç»“æœæ•°: {len(result['sequential_results'])}\")\n    \n    # éªŒè¯é¡ºåºæ‰§è¡Œ\n    for i, r in enumerate(result['sequential_results']):\n        print(f\"  Agent {i+1}: {r['agent']} - {r['content'][:50]}\")\n    \n    assert result['success']\n    assert len(result['sequential_results']) == 3\n    assert result['metadata']['collaboration_mode'] == 'sequential'\n    \n    print(\"\\nâœ… é¡ºåºæ‰§è¡Œæµ‹è¯•é€šè¿‡\")\n\n\nasync def test_multi_agent_parallel():\n    \"\"\"æµ‹è¯•MultiAgentOrchestratorçš„å¹¶è¡Œæ‰§è¡Œæ¨¡å¼\"\"\"\n    print(\"\\n=== æµ‹è¯•3: MultiAgentOrchestratorå¹¶è¡Œæ‰§è¡Œ ===\")\n    \n    skill = SkillConfig(\n        name='multi-agent-skill',\n        orchestrator='multi_agent',\n        agents=['agent1', 'agent2', 'agent3'],\n        collaboration_mode='parallel'\n    )\n    \n    orchestrator = MultiAgentOrchestrator()\n    result = await orchestrat"
},
{
"path": "tests/test_parallel_llm.py",
"start": 1,
"end": 16,
"text": "\"\"\"\næµ‹è¯•ParallelOrchestratorçš„LLMå¢å¼ºåŠŸèƒ½\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\nsys.path.insert(0, os.path.dirname(__file__))\n\nfrom dataclasses import dataclass\nfrom daoyoucode.agents.orchestrators.parallel import ParallelOrchestrator\nfrom daoyoucode.agents.core.agent import BaseAgent, AgentConfig, AgentResult, register_agent\n\n\n# æ¨¡æ‹ŸSkillConfig\n@dataclass"
},
{
"path": "tests/test_parallel_llm.py",
"start": 17,
"end": 28,
"text": "class SkillConfig:\n    name: str\n    orchestrator: str\n    agents: list = None\n    use_llm_split: bool = False\n    use_llm_aggregate: bool = False\n    middleware: list = None\n    tools: list = None\n    llm: dict = None\n\n\n# åˆ›å»ºMock Agent"
},
{
"path": "tests/test_parallel_llm.py",
"start": 29,
"end": 186,
"text": "class MockAgent(BaseAgent):\n    async def execute(self, prompt_source, user_input, context, llm_config=None, tools=None, max_tool_iterations=5):\n        return AgentResult(\n            success=True,\n            content=f'{self.name} åˆ†æ: {user_input[:50]}...',\n            metadata={'agent': self.name},\n            tokens_used=100\n        )\n\n\n# æ³¨å†Œå¤šä¸ªAgents\nfor name in ['code_explorer', 'translator', 'code_analyzer', 'test_expert']:\n    config = AgentConfig(name=name, description=f\"Mock {name}\", model=\"mock\")\n    agent = MockAgent(config)\n    register_agent(agent)\n\n\nasync def test_config_mode():\n    \"\"\"æµ‹è¯•é…ç½®æ¨¡å¼ï¼ˆä¸ä½¿ç”¨LLMï¼‰\"\"\"\n    print(\"\\n=== æµ‹è¯•1: é…ç½®æ¨¡å¼ ===\")\n    \n    skill = SkillConfig(\n        name='parallel-skill',\n        orchestrator='parallel',\n        agents=[\n            {'name': 'search', 'agent': 'code_explorer', 'task': 'æœç´¢ä»£ç ', 'priority': 8},\n            {'name': 'analyze', 'agent': 'code_analyzer', 'task': 'åˆ†æä»£ç ', 'priority': 5},\n            {'name': 'test', 'agent': 'test_expert', 'task': 'æµ‹è¯•ä»£ç ', 'priority': 3}\n        ]\n    )\n    \n    orchestrator = ParallelOrchestrator(batch_size=2)\n    result = await orchestrator.execute(skill, 'å¤„ç†ä»£ç ', {})\n    \n    print(f\"æˆåŠŸ: {result['success']}\")\n    print(f\"æ€»ä»»åŠ¡: {result['metadata']['total_tasks']}\")\n    print(f\"æˆåŠŸä»»åŠ¡: {result['metadata']['successful_tasks']}\")\n    print(f\"æ‰¹é‡å¤§å°: {result['metadata']['batch_size']}\")\n    print(f\"ä½¿ç”¨LLMæ‹†åˆ†: {result['metadata']['use_llm_split']}\")\n    \n    assert result['success']\n    assert result['metadata']['total_tasks'] == 3\n    assert result['metadata']['successful_tasks'] == 3\n    \n    print(\"âœ… é…ç½®æ¨¡å¼æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_keyword_split():\n    \"\"\"æµ‹è¯•å…³é”®è¯æ‹†åˆ†æ¨¡å¼\"\"\"\n    print(\"\\n=== æµ‹è¯•2: å…³é”®è¯æ‹†åˆ† ===\")\n    \n    skill = SkillConfig(\n        name='parallel-skill',\n        orchestrator='parallel',\n        use_llm_split=False  # ä¸ä½¿ç”¨LLM\n    )\n    \n    orchestrator = ParallelOrchestrator()\n    result = await orchestrator.execute(skill, 'æŸ¥æ‰¾å’Œæœç´¢ç›¸å…³ä»£ç æ–‡æ¡£', {})\n    \n    print(f\"æˆåŠŸ: {result['success']}\")\n    print(f\"æ€»ä»»åŠ¡: {result['metadata']['total_tasks']}\")\n    print(f\"ä»»åŠ¡åˆ—è¡¨:\")\n    for r in result['parallel_results']:\n        if not isinstance(r, Exception):\n            print(f\"  - {r.get('task_name')}: {r.get('agent_name')}\")\n    \n    assert result['success']\n    assert result['metadata']['total_tasks'] >= 1\n    \n    print(\"âœ… å…³é”®è¯æ‹†åˆ†æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_priority_scheduling():\n    \"\"\"æµ‹è¯•ä¼˜å…ˆçº§è°ƒåº¦\"\"\"\n    print(\"\\n=== æµ‹è¯•3: ä¼˜å…ˆçº§è°ƒåº¦ ===\")\n    \n    skill = SkillConfig(\n        name='parallel-skill',\n        orchestrator='parallel',\n        agents=[\n            {'name': 'low', 'agent': 'translator', 'task': 'ä½ä¼˜å…ˆçº§', 'priority': 2},\n            {'name': 'high', 'agent': 'code_explorer', 'task': 'é«˜ä¼˜å…ˆçº§', 'priority': 9},\n            {'name': 'medium', 'agent': 'code_analyzer', 'task': 'ä¸­ä¼˜å…ˆçº§', 'priority': 5}\n        ]\n    )\n    \n    orchestrator = ParallelOrchestrator(batch_size=2)\n    result = await orchestrator.execute(skill, 'æµ‹è¯•', {})\n    \n    print(f\"æˆåŠŸ: {result['success']}\")\n    print(f\"æ‰§è¡Œé¡ºåºï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰:\")\n    for i, r in enumerate(result['parallel_results']):\n        if not isinstance(r, Exception):\n            print(f\"  {i+1}. {r.get('task_name')} (Agent: {r.get('agent_name')})\")\n    \n    # éªŒè¯é«˜ä¼˜å…ˆçº§ä»»åŠ¡å…ˆæ‰§è¡Œï¼ˆåœ¨å‰2ä¸ªæ‰¹æ¬¡ä¸­ï¼‰\n    first_two = result['parallel_results'][:2]\n    task_names = [r.get('task_name') for r in first_two if not isinstance(r, Exception)]\n    \n    assert 'high' in task_names  # é«˜ä¼˜å…ˆçº§åº”è¯¥åœ¨å‰é¢\n    \n    print(\"âœ… ä¼˜å…ˆçº§è°ƒåº¦æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_batch_execution():\n    \"\"\"æµ‹è¯•æ‰¹é‡æ‰§è¡Œ\"\"\"\n    print(\"\\n=== æµ‹è¯•4: æ‰¹é‡æ‰§è¡Œ ===\")\n    \n    # åˆ›å»º5ä¸ªä»»åŠ¡ï¼Œæ‰¹é‡å¤§å°ä¸º2\n    skill = SkillConfig(\n        name='parallel-skill',\n        orchestrator='parallel',\n        agents=[\n            {'name': f'task{i}', 'agent': 'translator', 'task': f'ä»»åŠ¡{i}'}\n            for i in range(5)\n        ]\n    )\n    \n    orchestrator = ParallelOrchestrator(batch_size=2)\n    result = await orchestrator.execute(skill, 'æµ‹è¯•', {})\n    \n    print(f\"æˆåŠŸ: {result['success']}\")\n    print(f\"æ€»ä»»åŠ¡: {result['metadata']['total_tasks']}\")\n    print(f\"æ‰¹é‡å¤§å°: {result['me"
},
{
"path": "tests/test_path_handling.py",
"start": 1,
"end": 360,
"text": "\"\"\"\næµ‹è¯•è·¯å¾„å¤„ç†ä¿®å¤\n\néªŒè¯æ‰€æœ‰å·¥å…·è¿”å›çš„è·¯å¾„éƒ½æ˜¯ç›¸å¯¹äº repo_path çš„æ ‡å‡†è·¯å¾„\n\"\"\"\n\nimport asyncio\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ é¡¹ç›®è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents.tools.base import ToolContext\nfrom daoyoucode.agents.tools.registry import get_tool_registry\nfrom daoyoucode.agents.tools.repomap_tools import RepoMapTool, GetRepoStructureTool\nfrom daoyoucode.agents.tools.file_tools import ListFilesTool, ReadFileTool\nfrom daoyoucode.agents.tools.search_tools import TextSearchTool\n\n\nasync def test_tool_context():\n    \"\"\"æµ‹è¯• ToolContext åŸºç¡€åŠŸèƒ½\"\"\"\n    print(\"\\n=== æµ‹è¯• ToolContext ===\")\n    \n    # åˆ›å»ºä¸Šä¸‹æ–‡\n    repo_path = Path(__file__).parent.parent  # é¡¹ç›®æ ¹ç›®å½•\n    context = ToolContext(repo_path=repo_path)\n    \n    print(f\"âœ“ repo_path: {context.repo_path}\")\n    \n    # æµ‹è¯• abs_path\n    abs_path = context.abs_path(\"backend/test.py\")\n    print(f\"âœ“ abs_path('backend/test.py'): {abs_path}\")\n    assert abs_path == repo_path / \"backend/test.py\"\n    \n    # æµ‹è¯• rel_path\n    rel_path = context.rel_path(str(repo_path / \"backend/test.py\"))\n    print(f\"âœ“ rel_path('{repo_path}/backend/test.py'): {rel_path}\")\n    assert rel_path == \"backend/test.py\" or rel_path == \"backend\\\\test.py\"\n    \n    # æµ‹è¯• normalize_path\n    norm_path = context.normalize_path(str(repo_path / \"backend/test.py\"))\n    print(f\"âœ“ normalize_path('{repo_path}/backend/test.py'): {norm_path}\")\n    \n    print(\"âœ“ ToolContext æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_repo_map_paths():\n    \"\"\"æµ‹è¯• repo_map è¿”å›çš„è·¯å¾„\"\"\"\n    print(\"\\n=== æµ‹è¯• repo_map è·¯å¾„ ===\")\n    \n    # è®¾ç½®ä¸Šä¸‹æ–‡\n    repo_path = Path(__file__).parent.parent\n    context = ToolContext(repo_path=repo_path)\n    \n    # åˆ›å»ºå·¥å…·\n    tool = RepoMapTool()\n    tool.set_context(context)\n    \n    # æ‰§è¡Œ\n    result = await tool.execute(\n        repo_path=\".\",\n        max_tokens=1000\n    )\n    \n    if not result.success:\n        print(f\"âœ— repo_map æ‰§è¡Œå¤±è´¥: {result.error}\")\n        return False\n    \n    print(f\"âœ“ repo_map æ‰§è¡ŒæˆåŠŸ\")\n    \n    # æ£€æŸ¥è¿”å›çš„è·¯å¾„\n    content = result.content\n    lines = content.split('\\n')\n    \n    file_paths = []\n    for line in lines:\n        if line and not line.startswith('#') and not line.startswith(' ') and line.endswith(':'):\n            file_path = line.rstrip(':')\n            file_paths.append(file_path)\n    \n    print(f\"âœ“ æ‰¾åˆ° {len(file_paths)} ä¸ªæ–‡ä»¶è·¯å¾„\")\n    \n    # éªŒè¯è·¯å¾„æ ¼å¼\n    for file_path in file_paths[:5]:  # åªæ£€æŸ¥å‰5ä¸ª\n        print(f\"  â€¢ {file_path}\")\n        \n        # è·¯å¾„åº”è¯¥æ˜¯ç›¸å¯¹è·¯å¾„\n        if Path(file_path).is_absolute():\n            print(f\"âœ— è·¯å¾„æ˜¯ç»å¯¹è·¯å¾„: {file_path}\")\n            return False\n        \n        # è·¯å¾„åº”è¯¥å¯ä»¥ç›´æ¥ç”¨äº read_file\n        full_path = repo_path / file_path\n        if not full_path.exists():\n            print(f\"âœ— è·¯å¾„ä¸å­˜åœ¨: {file_path} (resolved to {full_path})\")\n            return False\n    \n    print(\"âœ“ repo_map è·¯å¾„æµ‹è¯•é€šè¿‡\")\n    return True\n\n\nasync def test_list_files_paths():\n    \"\"\"æµ‹è¯• list_files è¿”å›çš„è·¯å¾„\"\"\"\n    print(\"\\n=== æµ‹è¯• list_files è·¯å¾„ ===\")\n    \n    # è®¾ç½®ä¸Šä¸‹æ–‡\n    repo_path = Path(__file__).parent.parent\n    context = ToolContext(repo_path=repo_path)\n    \n    # åˆ›å»ºå·¥å…·\n    tool = ListFilesTool()\n    tool.set_context(context)\n    \n    # æ‰§è¡Œ\n    result = await tool.execute(\n        directory=\"backend\",\n        recursive=True,\n        pattern=\"*.py\",\n        max_depth=2\n    )\n    \n    if not result.success:\n        print(f\"âœ— list_files æ‰§è¡Œå¤±è´¥: {result.error}\")\n        return False\n    \n    print(f\"âœ“ list_files æ‰§è¡ŒæˆåŠŸ\")\n    \n    # æ£€æŸ¥è¿”å›çš„è·¯å¾„\n    files = result.content\n    print(f\"âœ“ æ‰¾åˆ° {len(files)} ä¸ªæ–‡ä»¶\")\n    \n    # éªŒè¯è·¯å¾„æ ¼å¼\n    for file_info in files[:5]:  # åªæ£€æŸ¥å‰5ä¸ª\n        file_path = file_info['path']\n        print(f\"  â€¢ {file_path}\")\n        \n        # è·¯å¾„åº”è¯¥æ˜¯ç›¸å¯¹è·¯å¾„\n        if Path(file_path).is_absolute():\n            print(f\"âœ— è·¯å¾„æ˜¯ç»å¯¹è·¯å¾„: {file_path}\")\n            return False\n        \n        # è·¯å¾„åº”è¯¥ä»¥ backend å¼€å¤´\n        if not file_path.startswith('backend'):\n            print(f\"âœ— è·¯å¾„ä¸ä»¥ backend å¼€å¤´: {file_path}\")\n            return False\n        \n        # è·¯å¾„åº”è¯¥å¯ä»¥ç›´æ¥ç”¨äº read_file\n        full_path = repo_path / file_path\n        if not full_path.exists():\n   "
},
{
"path": "tests/test_permissions.py",
"start": 1,
"end": 258,
"text": "#!/usr/bin/env python3\n\"\"\"\næµ‹è¯•æƒé™ç³»ç»Ÿ\n\"\"\"\n\nimport asyncio\nimport sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents.core.permission import (\n    get_permission_manager,\n    apply_default_permissions,\n    apply_strict_permissions,\n    PermissionAction,\n)\nfrom daoyoucode.agents.core.decorators import require_permission\n\n\nasync def test_basic_permissions():\n    \"\"\"æµ‹è¯•åŸºæœ¬æƒé™åŠŸèƒ½\"\"\"\n    print(\"=\" * 60)\n    print(\"æµ‹è¯•1: åŸºæœ¬æƒé™åŠŸèƒ½\")\n    print(\"=\" * 60)\n    \n    manager = get_permission_manager()\n    manager.clear_rules()\n    \n    # æ·»åŠ è§„åˆ™\n    manager.add_rule(\"read\", \"*\", \"allow\")\n    manager.add_rule(\"read\", \"*.env\", \"deny\")\n    manager.add_rule(\"write\", \"*.py\", \"allow\")\n    manager.add_rule(\"write\", \"*.txt\", \"allow\")\n    manager.add_rule(\"write\", \"*.env\", \"deny\")\n    \n    # æµ‹è¯•è¯»å–æƒé™\n    print(\"\\n1. æµ‹è¯•è¯»å–æƒé™...\")\n    \n    allowed = await manager.check_permission(\"read\", \"test.py\")\n    print(f\"   read test.py: {'âœ… å…è®¸' if allowed else 'âŒ æ‹’ç»'}\")\n    assert allowed\n    \n    allowed = await manager.check_permission(\"read\", \".env\")\n    print(f\"   read .env: {'âœ… å…è®¸' if allowed else 'âŒ æ‹’ç»'}\")\n    assert not allowed\n    \n    # æµ‹è¯•å†™å…¥æƒé™\n    print(\"\\n2. æµ‹è¯•å†™å…¥æƒé™...\")\n    \n    allowed = await manager.check_permission(\"write\", \"test.py\")\n    print(f\"   write test.py: {'âœ… å…è®¸' if allowed else 'âŒ æ‹’ç»'}\")\n    assert allowed\n    \n    allowed = await manager.check_permission(\"write\", \".env\")\n    print(f\"   write .env: {'âœ… å…è®¸' if allowed else 'âŒ æ‹’ç»'}\")\n    assert not allowed\n    \n    print(\"\\nâœ… åŸºæœ¬æƒé™åŠŸèƒ½æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_default_permissions():\n    \"\"\"æµ‹è¯•é»˜è®¤æƒé™é…ç½®\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•2: é»˜è®¤æƒé™é…ç½®\")\n    print(\"=\" * 60)\n    \n    apply_default_permissions()\n    manager = get_permission_manager()\n    \n    # æµ‹è¯•å„ç§æ–‡ä»¶ç±»å‹\n    test_cases = [\n        (\"read\", \"test.py\", True),\n        (\"read\", \"test.txt\", True),\n        (\"read\", \".env\", False),  # ask -> æ²¡æœ‰å›è°ƒ -> deny\n        (\"write\", \"test.py\", True),\n        (\"write\", \"test.md\", True),\n        (\"write\", \".env\", False),\n        (\"write\", \"secret.key\", False),\n        (\"execute\", \"script.sh\", False),  # ask -> deny\n        (\"delete\", \"test.py\", False),  # ask -> deny\n    ]\n    \n    print(\"\\næµ‹è¯•é»˜è®¤æƒé™:\")\n    for action, path, expected in test_cases:\n        allowed = await manager.check_permission(action, path)\n        status = \"âœ…\" if allowed == expected else \"âŒ\"\n        print(f\"   {status} {action} {path}: {allowed}\")\n        assert allowed == expected, f\"Expected {expected}, got {allowed}\"\n    \n    print(\"\\nâœ… é»˜è®¤æƒé™é…ç½®æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_strict_permissions():\n    \"\"\"æµ‹è¯•ä¸¥æ ¼æƒé™é…ç½®\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•3: ä¸¥æ ¼æƒé™é…ç½®\")\n    print(\"=\" * 60)\n    \n    apply_strict_permissions()\n    manager = get_permission_manager()\n    \n    # æµ‹è¯•å„ç§æ–‡ä»¶ç±»å‹\n    test_cases = [\n        (\"read\", \"test.py\", True),\n        (\"read\", \"test.md\", True),\n        (\"read\", \"test.txt\", True),\n        (\"read\", \"unknown.xyz\", False),  # ask -> deny\n        (\"write\", \"test.md\", True),\n        (\"write\", \"test.py\", False),  # ask -> deny\n        (\"write\", \"test.txt\", False),\n        (\"execute\", \"script.sh\", False),\n        (\"delete\", \"test.py\", False),\n    ]\n    \n    print(\"\\næµ‹è¯•ä¸¥æ ¼æƒé™:\")\n    for action, path, expected in test_cases:\n        allowed = await manager.check_permission(action, path)\n        status = \"âœ…\" if allowed == expected else \"âŒ\"\n        print(f\"   {status} {action} {path}: {allowed}\")\n        assert allowed == expected, f\"Expected {expected}, got {allowed}\"\n    \n    print(\"\\nâœ… ä¸¥æ ¼æƒé™é…ç½®æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_permission_decorator():\n    \"\"\"æµ‹è¯•æƒé™è£…é¥°å™¨\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•4: æƒé™è£…é¥°å™¨\")\n    print(\"=\" * 60)\n    \n    apply_default_permissions()\n    \n    # å®šä¹‰æµ‹è¯•å‡½æ•°\n    @require_permission('write', 'file_path')\n    async def write_file(file_path: str, content: str):\n        return f\"å†™å…¥ {file_path}: {content}\"\n    \n    # æµ‹è¯•å…è®¸çš„æ“ä½œ\n    print(\"\\n1. æµ‹è¯•å…è®¸çš„æ“ä½œ...\")\n    try:\n        result = await write_file(\"test.py\", \"print('hello')\")\n        print(f\"   âœ… æˆåŠŸ: {result}\")\n    except PermissionE"
},
{
"path": "tests/test_persistence.py",
"start": 1,
"end": 15,
"text": "\"\"\"\næµ‹è¯•æŒä¹…åŒ–åŠŸèƒ½\n\néªŒè¯æ•°æ®åœ¨ç¨‹åºé‡å¯åæ˜¯å¦ä¿ç•™\n\"\"\"\n\nimport asyncio\nimport logging\nfrom pathlib import Path\nfrom daoyoucode.agents.memory import get_memory_manager\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "tests/test_persistence.py",
"start": 16,
"end": 158,
"text": "def test_persistence():\n    \"\"\"æµ‹è¯•æŒä¹…åŒ–åŠŸèƒ½\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æŒä¹…åŒ–åŠŸèƒ½æµ‹è¯•\")\n    print(\"=\"*60)\n    \n    # ç¬¬ä¸€æ¬¡è¿è¡Œï¼šå†™å…¥æ•°æ®\n    print(\"\\nç¬¬ä¸€æ­¥ï¼šå†™å…¥æ•°æ®...\")\n    memory1 = get_memory_manager()\n    \n    # æ·»åŠ ç”¨æˆ·åå¥½\n    memory1.remember_preference('test-user', 'language', 'python')\n    memory1.remember_preference('test-user', 'style', 'functional')\n    print(\"âœ… æ·»åŠ äº†ç”¨æˆ·åå¥½\")\n    \n    # æ·»åŠ ä»»åŠ¡\n    memory1.add_task('test-user', {\n        'agent': 'TestAgent',\n        'input': 'æµ‹è¯•ä»»åŠ¡1',\n        'result': 'æµ‹è¯•ç»“æœ1',\n        'success': True\n    })\n    memory1.add_task('test-user', {\n        'agent': 'TestAgent',\n        'input': 'æµ‹è¯•ä»»åŠ¡2',\n        'result': 'æµ‹è¯•ç»“æœ2',\n        'success': True\n    })\n    print(\"âœ… æ·»åŠ äº†2ä¸ªä»»åŠ¡\")\n    \n    # ä¿å­˜æ‘˜è¦\n    memory1.long_term_memory.storage.save_summary(\n        'test-session',\n        'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ‘˜è¦ï¼Œç”¨äºéªŒè¯æŒä¹…åŒ–åŠŸèƒ½ã€‚'\n    )\n    print(\"âœ… ä¿å­˜äº†æ‘˜è¦\")\n    \n    # ä¿å­˜ç”¨æˆ·ç”»åƒ\n    memory1.long_term_memory.storage.save_user_profile(\n        'test-user',\n        {\n            'common_topics': ['python', 'testing', 'memory'],\n            'total_conversations': 10,\n            'preferred_style': 'functional'\n        }\n    )\n    print(\"âœ… ä¿å­˜äº†ç”¨æˆ·ç”»åƒ\")\n    \n    # è·å–å­˜å‚¨è·¯å¾„\n    storage_dir = memory1.storage.storage_dir\n    print(f\"\\nå­˜å‚¨ä½ç½®: {storage_dir}\")\n    \n    # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨\n    files = [\n        'preferences.json',\n        'tasks.json',\n        'summaries.json',\n        'profiles.json'\n    ]\n    \n    print(\"\\næ£€æŸ¥æ–‡ä»¶:\")\n    for filename in files:\n        filepath = storage_dir / filename\n        if filepath.exists():\n            size = filepath.stat().st_size\n            print(f\"  âœ… {filename} ({size} bytes)\")\n        else:\n            print(f\"  âŒ {filename} (ä¸å­˜åœ¨)\")\n    \n    # æ¨¡æ‹Ÿç¨‹åºé‡å¯ï¼šæ¸…é™¤å†…å­˜ä¸­çš„å•ä¾‹\n    print(\"\\nç¬¬äºŒæ­¥ï¼šæ¨¡æ‹Ÿç¨‹åºé‡å¯...\")\n    import daoyoucode.agents.memory.manager as manager_module\n    manager_module._memory_manager_instance = None\n    print(\"âœ… æ¸…é™¤äº†å†…å­˜ä¸­çš„å•ä¾‹\")\n    \n    # é‡æ–°åˆ›å»ºç®¡ç†å™¨ï¼ˆä¼šè‡ªåŠ¨åŠ è½½æŒä¹…åŒ–æ•°æ®ï¼‰\n    print(\"\\nç¬¬ä¸‰æ­¥ï¼šé‡æ–°åŠ è½½æ•°æ®...\")\n    memory2 = get_memory_manager()\n    \n    # éªŒè¯ç”¨æˆ·åå¥½\n    prefs = memory2.get_preferences('test-user')\n    print(f\"\\nç”¨æˆ·åå¥½:\")\n    for key, value in prefs.items():\n        print(f\"  {key}: {value}\")\n    \n    if prefs.get('language') == 'python' and prefs.get('style') == 'functional':\n        print(\"âœ… ç”¨æˆ·åå¥½åŠ è½½æˆåŠŸ\")\n    else:\n        print(\"âŒ ç”¨æˆ·åå¥½åŠ è½½å¤±è´¥\")\n    \n    # éªŒè¯ä»»åŠ¡å†å²\n    tasks = memory2.get_task_history('test-user')\n    print(f\"\\nä»»åŠ¡å†å²: {len(tasks)} ä¸ªä»»åŠ¡\")\n    for idx, task in enumerate(tasks, 1):\n        print(f\"  {idx}. {task.get('input', 'N/A')}\")\n    \n    if len(tasks) == 2:\n        print(\"âœ… ä»»åŠ¡å†å²åŠ è½½æˆåŠŸ\")\n    else:\n        print(\"âŒ ä»»åŠ¡å†å²åŠ è½½å¤±è´¥\")\n    \n    # éªŒè¯æ‘˜è¦\n    summary = memory2.long_term_memory.get_summary('test-session')\n    print(f\"\\næ‘˜è¦: {summary}\")\n    \n    if summary and 'æµ‹è¯•æ‘˜è¦' in summary:\n        print(\"âœ… æ‘˜è¦åŠ è½½æˆåŠŸ\")\n    else:\n        print(\"âŒ æ‘˜è¦åŠ è½½å¤±è´¥\")\n    \n    # éªŒè¯ç”¨æˆ·ç”»åƒ\n    profile = memory2.long_term_memory.get_user_profile('test-user')\n    print(f\"\\nç”¨æˆ·ç”»åƒ:\")\n    if profile:\n        for key, value in profile.items():\n            print(f\"  {key}: {value}\")\n        print(\"âœ… ç”¨æˆ·ç”»åƒåŠ è½½æˆåŠŸ\")\n    else:\n        print(\"âŒ ç”¨æˆ·ç”»åƒåŠ è½½å¤±è´¥\")\n    \n    # æ€»ç»“\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•æ€»ç»“\")\n    print(\"=\"*60)\n    \n    all_passed = (\n        prefs.get('language') == 'python' and\n        len(tasks) == 2 and\n        summary and 'æµ‹è¯•æ‘˜è¦' in summary and\n        profile is not None\n    )\n    \n    if all_passed:\n        print(\"ğŸ‰ æ‰€æœ‰æŒä¹…åŒ–æµ‹è¯•é€šè¿‡ï¼\")\n        print(\"\\næ•°æ®å·²æˆåŠŸä¿å­˜åˆ°ç£ç›˜ï¼Œç¨‹åºé‡å¯åä¼šè‡ªåŠ¨åŠ è½½ã€‚\")\n    else:\n        print(\"âš ï¸ éƒ¨åˆ†æµ‹è¯•å¤±è´¥\")\n    \n    return all_passed\n\n\nif __name__ == \"__main__\":\n    test_persistence()"
},
{
"path": "tests/test_phase2.py",
"start": 1,
"end": 232,
"text": "\"\"\"\nPhase 2åŠŸèƒ½æµ‹è¯•\n\næµ‹è¯•ï¼š\n1. åå°ä»»åŠ¡ç®¡ç†å™¨\n2. å¹¶è¡Œæ¢ç´¢ç¼–æ’å™¨\n3. åŠ¨æ€Promptæ„å»ºå™¨\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\n\n# æ·»åŠ è·¯å¾„\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))\n\nfrom daoyoucode.agents.core.background import get_background_manager, TaskStatus\nfrom daoyoucode.agents.core.prompt_builder import (\n    DynamicPromptBuilder,\n    PromptOptimizer,\n    is_followup,\n    has_tools,\n    ROLE_TEMPLATE,\n    HISTORY_TEMPLATE,\n    TOOLS_TEMPLATE\n)\n\n\nasync def test_background_manager():\n    \"\"\"æµ‹è¯•åå°ä»»åŠ¡ç®¡ç†å™¨\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•1: åå°ä»»åŠ¡ç®¡ç†å™¨\")\n    print(\"=\"*60)\n    \n    manager = get_background_manager()\n    \n    # æ¨¡æ‹ŸAgentæ‰§è¡Œå‡½æ•°\n    async def mock_agent_execute(task_id: str, delay: float):\n        \"\"\"æ¨¡æ‹ŸAgentæ‰§è¡Œ\"\"\"\n        await asyncio.sleep(delay)\n        return {\n            'success': True,\n            'content': f'ä»»åŠ¡ {task_id} å®Œæˆ',\n            'delay': delay\n        }\n    \n    # æäº¤ä»»åŠ¡ï¼ˆéœ€è¦å…ˆæ³¨å†Œä¸€ä¸ªmock agentï¼‰\n    # è¿™é‡Œç®€åŒ–æµ‹è¯•ï¼Œç›´æ¥æµ‹è¯•ä»»åŠ¡ç®¡ç†\n    \n    print(\"\\nâœ“ åå°ä»»åŠ¡ç®¡ç†å™¨åˆå§‹åŒ–æˆåŠŸ\")\n    print(f\"  - å½“å‰ä»»åŠ¡æ•°: {len(manager.tasks)}\")\n    \n    # æµ‹è¯•ä»»åŠ¡åˆ—è¡¨\n    tasks = manager.list_tasks()\n    print(f\"  - ä»»åŠ¡åˆ—è¡¨: {tasks}\")\n    \n    return True\n\n\nasync def test_prompt_builder():\n    \"\"\"æµ‹è¯•åŠ¨æ€Promptæ„å»ºå™¨\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•2: åŠ¨æ€Promptæ„å»ºå™¨\")\n    print(\"=\"*60)\n    \n    builder = DynamicPromptBuilder()\n    \n    # æ·»åŠ æ®µè½\n    builder.add_section(\n        name=\"role\",\n        content=ROLE_TEMPLATE,\n        priority=10  # é«˜ä¼˜å…ˆçº§\n    )\n    \n    builder.add_section(\n        name=\"history\",\n        content=HISTORY_TEMPLATE,\n        condition=is_followup,\n        priority=5\n    )\n    \n    builder.add_section(\n        name=\"tools\",\n        content=TOOLS_TEMPLATE,\n        condition=has_tools,\n        priority=3\n    )\n    \n    # æµ‹è¯•1: éè¿½é—®ï¼Œæ— å·¥å…·\n    print(\"\\nåœºæ™¯1: éè¿½é—®ï¼Œæ— å·¥å…·\")\n    context1 = {\n        'agent_name': 'Translator',\n        'domain': 'ç¿»è¯‘',\n        'is_followup': False\n    }\n    \n    prompt1 = builder.build(context1)\n    print(f\"ç”Ÿæˆçš„Prompt:\\n{prompt1}\")\n    print(f\"Tokenæ•°: {builder._count_tokens(prompt1)}\")\n    \n    # æµ‹è¯•2: è¿½é—®ï¼Œæœ‰å·¥å…·\n    print(\"\\nåœºæ™¯2: è¿½é—®ï¼Œæœ‰å·¥å…·\")\n    context2 = {\n        'agent_name': 'CodeExplorer',\n        'domain': 'ä»£ç æ¢ç´¢',\n        'is_followup': True,\n        'summary': 'ç”¨æˆ·ä¹‹å‰è¯¢é—®äº†BaseAgentç±»çš„ä½ç½®',\n        'tools': [\n            {'name': 'grep_search', 'description': 'æœç´¢ä»£ç '},\n            {'name': 'read_file', 'description': 'è¯»å–æ–‡ä»¶'}\n        ]\n    }\n    \n    prompt2 = builder.build(context2)\n    print(f\"ç”Ÿæˆçš„Prompt:\\n{prompt2}\")\n    print(f\"Tokenæ•°: {builder._count_tokens(prompt2)}\")\n    \n    # æµ‹è¯•3: Tokené™åˆ¶\n    print(\"\\nåœºæ™¯3: Tokené™åˆ¶\")\n    prompt3 = builder.build(context2, max_tokens=50)\n    print(f\"ä¼˜åŒ–åçš„Prompt:\\n{prompt3}\")\n    print(f\"Tokenæ•°: {builder._count_tokens(prompt3)}\")\n    \n    print(\"\\nâœ“ åŠ¨æ€Promptæ„å»ºå™¨æµ‹è¯•é€šè¿‡\")\n    \n    return True\n\n\nasync def test_prompt_optimizer():\n    \"\"\"æµ‹è¯•Promptä¼˜åŒ–å™¨\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•3: Promptä¼˜åŒ–å™¨\")\n    print(\"=\"*60)\n    \n    optimizer = PromptOptimizer()\n    \n    # åˆ›å»ºä¸€ä¸ªé•¿Prompt\n    long_prompt = \"\"\"ä½ æ˜¯ä¸€ä¸ªAIåŠ©æ‰‹ã€‚\n\n<example>\nè¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹1...\n</example>\n\n<example>\nè¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹2...\n</example>\n\nè¿™æ˜¯ä¸»è¦å†…å®¹ï¼ŒåŒ…å«å¾ˆå¤šè¯¦ç»†çš„è¯´æ˜å’ŒæŒ‡å¯¼...\n\"\"\" * 10  # é‡å¤10æ¬¡\n    \n    print(f\"åŸå§‹Prompté•¿åº¦: {len(long_prompt)} å­—ç¬¦\")\n    print(f\"åŸå§‹Tokenæ•°: {optimizer._count_tokens(long_prompt)}\")\n    \n    # ä¼˜åŒ–\n    context = {\n        'conversation_history': [\n            {'role': 'user', 'content': 'é—®é¢˜1'},\n            {'role': 'assistant', 'content': 'å›ç­”1'},\n            {'role': 'user', 'content': 'é—®é¢˜2'},\n            {'role': 'assistant', 'content': 'å›ç­”2'},\n        ] * 5  # 10è½®å¯¹è¯\n    }\n    \n    optimized = await optimizer.optimize(\n        prompt=long_prompt,\n        context=context,\n        max_tokens=200\n    )\n    \n    print(f\"\\nä¼˜åŒ–åPrompté•¿åº¦: {len(optimized)} å­—ç¬¦\")\n    print(f\"ä¼˜åŒ–åTokenæ•°: {optimizer._count_tokens(optimized)}\")\n    print(f\"å‹ç¼©ç‡: {(1 - len(optimized)/len(long_prompt)) * 100:.1f}%\")\n    \n    print(\"\\nâœ“ Promptä¼˜åŒ–å™¨æµ‹è¯•é€šè¿‡\")\n    \n    return True\n\n\nasync def main():\n    \"\"\"ä¸»æµ‹è¯•å‡½æ•°\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"Phase 2 åŠŸèƒ½æµ‹è¯•\")\n    print(\"=\"*60)\n    \n    results = []\n "
},
{
"path": "tests/test_postprocessing.py",
"start": 1,
"end": 162,
"text": "\"\"\"\næµ‹è¯•å·¥å…·åå¤„ç†åŠŸèƒ½\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport asyncio\n\nsys.path.insert(0, str(Path(__file__).parent))\n\n\nasync def test_postprocessing():\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•å·¥å…·åå¤„ç†åŠŸèƒ½\")\n    print(\"=\"*60)\n    \n    from daoyoucode.agents.tools import get_tool_registry\n    from daoyoucode.agents.tools.postprocessor import get_tool_postprocessor\n    \n    # è·å–å·¥å…·æ³¨å†Œè¡¨å’Œåå¤„ç†å™¨\n    registry = get_tool_registry()\n    postprocessor = get_tool_postprocessor()\n    \n    # æµ‹è¯•1: RepoMapåå¤„ç†\n    print(\"\\n1. æµ‹è¯•RepoMapåå¤„ç†\")\n    print(\"-\"*60)\n    \n    user_query = \"Agentç³»ç»Ÿæ˜¯æ€ä¹ˆå®ç°çš„ï¼Ÿ\"\n    print(f\"ç”¨æˆ·é—®é¢˜: {user_query}\")\n    \n    # æ‰§è¡Œå·¥å…·\n    result = await registry.execute_tool(\n        \"repo_map\",\n        repo_path=\".\",\n        chat_files=[],\n        mentioned_idents=[],\n        max_tokens=5000\n    )\n    \n    if result.success:\n        print(f\"\\nåŸå§‹ç»“æœ: {len(result.content)} å­—ç¬¦\")\n        print(f\"å‰200å­—ç¬¦:\\n{result.content[:200]}\")\n        \n        # åå¤„ç†\n        processed = await postprocessor.process(\n            tool_name=\"repo_map\",\n            result=result,\n            user_query=user_query,\n            context={}\n        )\n        \n        print(f\"\\nåå¤„ç†ç»“æœ: {len(processed.content)} å­—ç¬¦\")\n        print(f\"å‡å°‘: {len(result.content) - len(processed.content)} å­—ç¬¦ \"\n              f\"({(1 - len(processed.content)/len(result.content))*100:.1f}%)\")\n        \n        if processed.metadata.get('post_processed'):\n            print(f\"å…³é”®è¯: {processed.metadata.get('keywords')}\")\n            print(f\"åŸå§‹æ–‡ä»¶æ•°: {processed.metadata.get('original_files')}\")\n            print(f\"è¿‡æ»¤åæ–‡ä»¶æ•°: {processed.metadata.get('filtered_files')}\")\n        \n        print(f\"\\nå‰300å­—ç¬¦:\\n{processed.content[:300]}\")\n    \n    # æµ‹è¯•2: ä¸åŒçš„ç”¨æˆ·é—®é¢˜\n    print(\"\\n\\n2. æµ‹è¯•ä¸åŒç”¨æˆ·é—®é¢˜çš„åå¤„ç†\")\n    print(\"-\"*60)\n    \n    queries = [\n        \"Memoryç³»ç»Ÿåœ¨å“ªé‡Œï¼Ÿ\",\n        \"å·¥å…·æ³¨å†Œæ˜¯æ€ä¹ˆå®ç°çš„ï¼Ÿ\",\n        \"LLMå®¢æˆ·ç«¯çš„é…ç½®\",\n        \"ç¼–æ’å™¨æœ‰å“ªäº›ç±»å‹ï¼Ÿ\",\n    ]\n    \n    for query in queries:\n        print(f\"\\né—®é¢˜: {query}\")\n        \n        result = await registry.execute_tool(\n            \"repo_map\",\n            repo_path=\".\",\n            chat_files=[],\n            mentioned_idents=[],\n            max_tokens=3000\n        )\n        \n        if result.success:\n            processed = await postprocessor.process(\n                tool_name=\"repo_map\",\n                result=result,\n                user_query=query,\n                context={}\n            )\n            \n            reduction = (1 - len(processed.content)/len(result.content)) * 100\n            print(f\"  åŸå§‹: {len(result.content)} å­—ç¬¦\")\n            print(f\"  å¤„ç†å: {len(processed.content)} å­—ç¬¦ (å‡å°‘ {reduction:.1f}%)\")\n            \n            if processed.metadata.get('post_processed'):\n                print(f\"  å…³é”®è¯: {processed.metadata.get('keywords')}\")\n                print(f\"  æ–‡ä»¶: {processed.metadata.get('original_files')} -> \"\n                      f\"{processed.metadata.get('filtered_files')}\")\n    \n    # æµ‹è¯•3: æœç´¢ç»“æœåå¤„ç†\n    print(\"\\n\\n3. æµ‹è¯•æœç´¢ç»“æœåå¤„ç†\")\n    print(\"-\"*60)\n    \n    user_query = \"Agentçš„executeæ–¹æ³•\"\n    print(f\"ç”¨æˆ·é—®é¢˜: {user_query}\")\n    \n    result = await registry.execute_tool(\n        \"text_search\",\n        query=\"execute\",\n        directory=\"daoyoucode/agents\",\n        max_results=50\n    )\n    \n    if result.success:\n        print(f\"\\nåŸå§‹ç»“æœ: {len(result.content)} å­—ç¬¦\")\n        \n        processed = await postprocessor.process(\n            tool_name=\"text_search\",\n            result=result,\n            user_query=user_query,\n            context={}\n        )\n        \n        print(f\"åå¤„ç†ç»“æœ: {len(processed.content)} å­—ç¬¦\")\n        print(f\"å‡å°‘: {len(result.content) - len(processed.content)} å­—ç¬¦ \"\n              f\"({(1 - len(processed.content)/len(result.content))*100:.1f}%)\")\n        \n        if processed.metadata.get('post_processed'):\n            print(f\"å…³é”®è¯: {processed.metadata.get('keywords')}\")\n            print(f\"åŸå§‹åŒ¹é…: {processed.metadata.get('original_matches')}\")\n            print(f\"è¿‡æ»¤ååŒ¹é…: {processed.metadata.get('filtered_matches')}\")\n    \n    # æµ‹è¯•4: å…³é”®è¯æå–\n    print(\"\\n\\n4. æµ‹è¯•å…³é”®è¯æå–\")\n    print"
},
{
"path": "tests/test_profile_check_optimization.py",
"start": 1,
"end": 131,
"text": "\"\"\"\næµ‹è¯•ç”¨æˆ·ç”»åƒæ£€æŸ¥ä¼˜åŒ–\n\néªŒè¯æ—¶é—´çª—å£ç¼“å­˜æ˜¯å¦ç”Ÿæ•ˆ\n\"\"\"\n\nimport asyncio\nimport time\nfrom daoyoucode.agents.core.agent import BaseAgent, AgentConfig\n\n\nasync def test_profile_check_frequency():\n    \"\"\"æµ‹è¯•ç”»åƒæ£€æŸ¥é¢‘ç‡ä¼˜åŒ–\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šç”¨æˆ·ç”»åƒæ£€æŸ¥é¢‘ç‡ä¼˜åŒ–\")\n    print(\"=\"*60)\n    \n    # åˆ›å»ºAgent\n    config = AgentConfig(\n        name=\"test_agent\",\n        description=\"æµ‹è¯•Agent\",\n        model=\"gpt-4\",\n        temperature=0.7\n    )\n    agent = BaseAgent(config)\n    \n    user_id = \"test_user_123\"\n    session_id = \"test_session\"\n    \n    # ç¬¬1æ¬¡æ£€æŸ¥ï¼ˆåº”è¯¥æ‰§è¡Œï¼‰\n    print(\"\\nç¬¬1æ¬¡æ£€æŸ¥ï¼ˆåº”è¯¥æ‰§è¡Œï¼‰...\")\n    start = time.time()\n    await agent._check_and_update_profile(user_id, session_id)\n    duration1 = time.time() - start\n    print(f\"âœ“ ç¬¬1æ¬¡æ£€æŸ¥å®Œæˆï¼Œè€—æ—¶: {duration1*1000:.2f}ms\")\n    \n    # ç¬¬2æ¬¡æ£€æŸ¥ï¼ˆåº”è¯¥è·³è¿‡ï¼Œå› ä¸ºåœ¨1å°æ—¶å†…ï¼‰\n    print(\"\\nç¬¬2æ¬¡æ£€æŸ¥ï¼ˆåº”è¯¥è·³è¿‡ï¼‰...\")\n    start = time.time()\n    await agent._check_and_update_profile(user_id, session_id)\n    duration2 = time.time() - start\n    print(f\"âœ“ ç¬¬2æ¬¡æ£€æŸ¥å®Œæˆï¼Œè€—æ—¶: {duration2*1000:.2f}ms\")\n    \n    # ç¬¬3æ¬¡æ£€æŸ¥ï¼ˆåº”è¯¥è·³è¿‡ï¼‰\n    print(\"\\nç¬¬3æ¬¡æ£€æŸ¥ï¼ˆåº”è¯¥è·³è¿‡ï¼‰...\")\n    start = time.time()\n    await agent._check_and_update_profile(user_id, session_id)\n    duration3 = time.time() - start\n    print(f\"âœ“ ç¬¬3æ¬¡æ£€æŸ¥å®Œæˆï¼Œè€—æ—¶: {duration3*1000:.2f}ms\")\n    \n    # éªŒè¯ä¼˜åŒ–æ•ˆæœ\n    print(\"\\n\" + \"=\"*60)\n    print(\"ä¼˜åŒ–æ•ˆæœåˆ†æï¼š\")\n    print(\"=\"*60)\n    print(f\"ç¬¬1æ¬¡æ£€æŸ¥: {duration1*1000:.2f}msï¼ˆæ­£å¸¸æ‰§è¡Œï¼‰\")\n    print(f\"ç¬¬2æ¬¡æ£€æŸ¥: {duration2*1000:.2f}msï¼ˆåº”è¯¥å¾ˆå¿«ï¼Œå› ä¸ºè·³è¿‡äº†ï¼‰\")\n    print(f\"ç¬¬3æ¬¡æ£€æŸ¥: {duration3*1000:.2f}msï¼ˆåº”è¯¥å¾ˆå¿«ï¼Œå› ä¸ºè·³è¿‡äº†ï¼‰\")\n    \n    # ç¬¬2ã€3æ¬¡åº”è¯¥æ¯”ç¬¬1æ¬¡å¿«å¾ˆå¤šï¼ˆè‡³å°‘å¿«50%ï¼‰\n    if duration2 < duration1 * 0.5 and duration3 < duration1 * 0.5:\n        print(\"\\nâœ… ä¼˜åŒ–ç”Ÿæ•ˆï¼åç»­æ£€æŸ¥é€Ÿåº¦æå‡ 50%+\")\n        speedup = duration1 / ((duration2 + duration3) / 2)\n        print(f\"   å¹³å‡åŠ é€Ÿ: {speedup:.1f}x\")\n    else:\n        print(\"\\nâš ï¸ ä¼˜åŒ–æ•ˆæœä¸æ˜æ˜¾ï¼Œå¯èƒ½éœ€è¦è¿›ä¸€æ­¥è°ƒæŸ¥\")\n    \n    # æµ‹è¯•ä¸åŒç”¨æˆ·ï¼ˆåº”è¯¥ç‹¬ç«‹ç¼“å­˜ï¼‰\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šä¸åŒç”¨æˆ·ç‹¬ç«‹ç¼“å­˜\")\n    print(\"=\"*60)\n    \n    user_id2 = \"test_user_456\"\n    print(f\"\\næ£€æŸ¥ç”¨æˆ·2: {user_id2}ï¼ˆåº”è¯¥æ‰§è¡Œï¼‰...\")\n    start = time.time()\n    await agent._check_and_update_profile(user_id2, session_id)\n    duration_user2 = time.time() - start\n    print(f\"âœ“ ç”¨æˆ·2æ£€æŸ¥å®Œæˆï¼Œè€—æ—¶: {duration_user2*1000:.2f}ms\")\n    \n    print(f\"\\nå†æ¬¡æ£€æŸ¥ç”¨æˆ·1: {user_id}ï¼ˆåº”è¯¥è·³è¿‡ï¼‰...\")\n    start = time.time()\n    await agent._check_and_update_profile(user_id, session_id)\n    duration_user1_again = time.time() - start\n    print(f\"âœ“ ç”¨æˆ·1å†æ¬¡æ£€æŸ¥å®Œæˆï¼Œè€—æ—¶: {duration_user1_again*1000:.2f}ms\")\n    \n    if duration_user1_again < duration_user2 * 0.5:\n        print(\"\\nâœ… ä¸åŒç”¨æˆ·ç¼“å­˜ç‹¬ç«‹å·¥ä½œæ­£å¸¸\")\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"âœ… æµ‹è¯•å®Œæˆ\")\n    print(\"=\"*60)\n\n\nasync def test_cache_expiry():\n    \"\"\"æµ‹è¯•ç¼“å­˜è¿‡æœŸï¼ˆæ¨¡æ‹Ÿï¼‰\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šç¼“å­˜è¿‡æœŸæœºåˆ¶\")\n    print(\"=\"*60)\n    \n    config = AgentConfig(\n        name=\"test_agent\",\n        description=\"æµ‹è¯•Agent\",\n        model=\"gpt-4\",\n        temperature=0.7\n    )\n    agent = BaseAgent(config)\n    \n    user_id = \"test_user_expiry\"\n    session_id = \"test_session\"\n    \n    # ç¬¬1æ¬¡æ£€æŸ¥\n    print(\"\\nç¬¬1æ¬¡æ£€æŸ¥...\")\n    await agent._check_and_update_profile(user_id, session_id)\n    print(\"âœ“ å®Œæˆ\")\n    \n    # æ‰‹åŠ¨ä¿®æ”¹ç¼“å­˜æ—¶é—´ï¼ˆæ¨¡æ‹Ÿ1å°æ—¶åï¼‰\n    print(\"\\næ¨¡æ‹Ÿ1å°æ—¶å...\")\n    agent._profile_check_cache[user_id] = time.time() - 3601  # 3601ç§’å‰\n    \n    # ç¬¬2æ¬¡æ£€æŸ¥ï¼ˆåº”è¯¥é‡æ–°æ‰§è¡Œï¼‰\n    print(\"ç¬¬2æ¬¡æ£€æŸ¥ï¼ˆç¼“å­˜å·²è¿‡æœŸï¼Œåº”è¯¥é‡æ–°æ‰§è¡Œï¼‰...\")\n    start = time.time()\n    await agent._check_and_update_profile(user_id, session_id)\n    duration = time.time() - start\n    print(f\"âœ“ å®Œæˆï¼Œè€—æ—¶: {duration*1000:.2f}ms\")\n    \n    print(\"\\nâœ… ç¼“å­˜è¿‡æœŸæœºåˆ¶æ­£å¸¸\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(test_profile_check_frequency())\n    asyncio.run(test_cache_expiry())"
},
{
"path": "tests/test_recovery.py",
"start": 1,
"end": 23,
"text": "\"\"\"\næµ‹è¯•å¤±è´¥æ¢å¤ç³»ç»Ÿ\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\n\n# æ·»åŠ è·¯å¾„\nsys.path.insert(0, os.path.join(os.path.dirname(__file__)))\n\nfrom daoyoucode.agents.core.recovery import (\n    RecoveryManager,\n    RecoveryConfig,\n    MaxRetriesExceeded,\n    validate_non_empty,\n    validate_success_flag,\n    validate_no_error,\n    simple_analyzer\n)\n\n\n# æµ‹è¯•å‡½æ•°"
},
{
"path": "tests/test_recovery.py",
"start": 24,
"end": 26,
"text": "class TestFunction:\n    \"\"\"æµ‹è¯•å‡½æ•°ç±»\"\"\"\n    "
},
{
"path": "tests/test_recovery.py",
"start": 27,
"end": 252,
"text": "    def __init__(self):\n        self.call_count = 0\n    \n    async def success_on_first(self, user_input: str) -> dict:\n        \"\"\"ç¬¬ä¸€æ¬¡å°±æˆåŠŸ\"\"\"\n        self.call_count += 1\n        return {'success': True, 'content': f'å¤„ç†: {user_input}'}\n    \n    async def success_on_third(self, user_input: str) -> dict:\n        \"\"\"ç¬¬ä¸‰æ¬¡æ‰æˆåŠŸ\"\"\"\n        self.call_count += 1\n        if self.call_count < 3:\n            raise ValueError(f\"æ¨¡æ‹Ÿé”™è¯¯ (ç¬¬{self.call_count}æ¬¡)\")\n        return {'success': True, 'content': f'å¤„ç†: {user_input}'}\n    \n    async def always_fail(self, user_input: str) -> dict:\n        \"\"\"æ€»æ˜¯å¤±è´¥\"\"\"\n        self.call_count += 1\n        raise ValueError(f\"æ€»æ˜¯å¤±è´¥ (ç¬¬{self.call_count}æ¬¡)\")\n    \n    async def invalid_result(self, user_input: str) -> dict:\n        \"\"\"è¿”å›æ— æ•ˆç»“æœ\"\"\"\n        self.call_count += 1\n        if self.call_count < 2:\n            return {'success': False, 'content': ''}\n        return {'success': True, 'content': f'ä¿®å¤å: {user_input}'}\n\n\nasync def test_basic_recovery():\n    \"\"\"æµ‹è¯•åŸºæœ¬æ¢å¤åŠŸèƒ½\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•1: åŸºæœ¬æ¢å¤åŠŸèƒ½\")\n    print(\"=\"*60)\n    \n    # 1. ç¬¬ä¸€æ¬¡å°±æˆåŠŸ\n    print(\"\\n1. æµ‹è¯•ç¬¬ä¸€æ¬¡å°±æˆåŠŸ...\")\n    test_func = TestFunction()\n    manager = RecoveryManager()\n    \n    result = await manager.execute_with_recovery(\n        test_func.success_on_first,\n        user_input=\"æµ‹è¯•è¾“å…¥\"\n    )\n    \n    print(f\"   ç»“æœ: {result}\")\n    print(f\"   è°ƒç”¨æ¬¡æ•°: {test_func.call_count}\")\n    assert test_func.call_count == 1, \"åº”è¯¥åªè°ƒç”¨1æ¬¡\"\n    assert result['success'], \"åº”è¯¥æˆåŠŸ\"\n    print(\"   âœ… é€šè¿‡\")\n    \n    # 2. ç¬¬ä¸‰æ¬¡æ‰æˆåŠŸ\n    print(\"\\n2. æµ‹è¯•ç¬¬ä¸‰æ¬¡æ‰æˆåŠŸ...\")\n    test_func = TestFunction()\n    manager = RecoveryManager(RecoveryConfig(max_retries=5))\n    \n    result = await manager.execute_with_recovery(\n        test_func.success_on_third,\n        user_input=\"æµ‹è¯•è¾“å…¥\"\n    )\n    \n    print(f\"   ç»“æœ: {result}\")\n    print(f\"   è°ƒç”¨æ¬¡æ•°: {test_func.call_count}\")\n    assert test_func.call_count == 3, \"åº”è¯¥è°ƒç”¨3æ¬¡\"\n    assert result['success'], \"åº”è¯¥æˆåŠŸ\"\n    print(\"   âœ… é€šè¿‡\")\n    \n    # 3. æ€»æ˜¯å¤±è´¥\n    print(\"\\n3. æµ‹è¯•æ€»æ˜¯å¤±è´¥...\")\n    test_func = TestFunction()\n    manager = RecoveryManager(RecoveryConfig(max_retries=3))\n    \n    try:\n        result = await manager.execute_with_recovery(\n            test_func.always_fail,\n            user_input=\"æµ‹è¯•è¾“å…¥\"\n        )\n        print(\"   âŒ åº”è¯¥æŠ›å‡ºå¼‚å¸¸\")\n        assert False, \"åº”è¯¥æŠ›å‡ºMaxRetriesExceeded\"\n    except MaxRetriesExceeded as e:\n        print(f\"   æ­£ç¡®æŠ›å‡ºå¼‚å¸¸: {e}\")\n        print(f\"   è°ƒç”¨æ¬¡æ•°: {test_func.call_count}\")\n        assert test_func.call_count == 3, \"åº”è¯¥è°ƒç”¨3æ¬¡\"\n        print(\"   âœ… é€šè¿‡\")\n    \n    print(\"\\nâœ… åŸºæœ¬æ¢å¤åŠŸèƒ½æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_validators():\n    \"\"\"æµ‹è¯•éªŒè¯å™¨\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•2: éªŒè¯å™¨\")\n    print(\"=\"*60)\n    \n    # 1. validate_non_empty\n    print(\"\\n1. æµ‹è¯• validate_non_empty...\")\n    assert validate_non_empty({'content': 'test'}), \"æœ‰å†…å®¹åº”è¯¥é€šè¿‡\"\n    assert not validate_non_empty({'content': ''}), \"ç©ºå†…å®¹åº”è¯¥å¤±è´¥\"\n    assert not validate_non_empty({}), \"ç©ºå­—å…¸åº”è¯¥å¤±è´¥\"\n    print(\"   âœ… é€šè¿‡\")\n    \n    # 2. validate_success_flag\n    print(\"\\n2. æµ‹è¯• validate_success_flag...\")\n    assert validate_success_flag({'success': True}), \"success=Trueåº”è¯¥é€šè¿‡\"\n    assert not validate_success_flag({'success': False}), \"success=Falseåº”è¯¥å¤±è´¥\"\n    assert not validate_success_flag({}), \"æ— successåº”è¯¥å¤±è´¥\"\n    print(\"   âœ… é€šè¿‡\")\n    \n    # 3. validate_no_error\n    print(\"\\n3. æµ‹è¯• validate_no_error...\")\n    assert validate_no_error({'content': 'test'}), \"æ— erroråº”è¯¥é€šè¿‡\"\n    assert not validate_no_error({'error': 'test'}), \"æœ‰erroråº”è¯¥å¤±è´¥\"\n    print(\"   âœ… é€šè¿‡\")\n    \n    print(\"\\nâœ… éªŒè¯å™¨æµ‹è¯•é€šè¿‡\")\n\n\nasync def test_with_validator():\n    \"\"\"æµ‹è¯•å¸¦éªŒè¯å™¨çš„æ¢å¤\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•3: å¸¦éªŒè¯å™¨çš„æ¢å¤\")\n    print(\"=\"*60)\n    \n    print(\"\\n1. æµ‹è¯•æ— æ•ˆç»“æœè‡ªåŠ¨ä¿®å¤...\")\n    test_func = TestFunction()\n    manager = RecoveryManager(RecoveryConfig(max_retries=5))\n    \n    result = await manager.execute_with_recovery(\n        test_func.invalid_result,\n        user_input=\"æµ‹è¯•è¾“å…¥\",\n        validator=validate_success_flag,\n        analyzer=simple_analyzer\n    )\n    \n    print(f\"   ç»“æœ: {result}\")\n    print(f\"   è°ƒç”¨æ¬¡æ•°: {test_func.call_coun"
},
{
"path": "tests/test_reload.py",
"start": 1,
"end": 23,
"text": "#!/usr/bin/env python\n\"\"\"æµ‹è¯•é‡æ–°åŠ è½½\"\"\"\n\nimport sys\nimport importlib\nsys.path.insert(0, '.')\n\n# æ¸…é™¤ç¼“å­˜\nif 'cli' in sys.modules:\n    del sys.modules['cli']\nif 'cli.app' in sys.modules:\n    del sys.modules['cli.app']\n\nprint(\"å¯¼å…¥cli.app...\")\nimport cli.app\n\nprint(f\"æ¨¡å—å†…å®¹: {[x for x in dir(cli.app) if not x.startswith('_')]}\")\nprint(f\"æœ‰main: {hasattr(cli.app, 'main')}\")\nprint(f\"æœ‰app: {hasattr(cli.app, 'app')}\")\n\nif hasattr(cli.app, 'app'):\n    print(f\"appç±»å‹: {type(cli.app.app)}\")\n    print(f\"appå‘½ä»¤æ•°: {len(cli.app.app.registered_commands)}\")"
},
{
"path": "tests/test_repomap_generation.py",
"start": 1,
"end": 272,
"text": "#!/usr/bin/env python3\n\"\"\"\næµ‹è¯• RepoMap ç”ŸæˆåŠŸèƒ½\n\næµ‹è¯•ç‚¹ï¼š\n1. åŸºæœ¬ç”Ÿæˆï¼ˆé»˜è®¤5000 tokensï¼‰\n2. ç”Ÿæˆé€Ÿåº¦\n3. è¾“å‡ºå†…å®¹è´¨é‡\n4. ç¼“å­˜æœºåˆ¶\n\"\"\"\n\nimport asyncio\nimport time\nfrom pathlib import Path\nfrom daoyoucode.agents.tools.repomap_tools import RepoMapTool\n\n\nasync def test_basic_generation():\n    \"\"\"æµ‹è¯•åŸºæœ¬ç”Ÿæˆ\"\"\"\n    print(\"=\" * 60)\n    print(\"æµ‹è¯•1: åŸºæœ¬ç”Ÿæˆï¼ˆé»˜è®¤max_tokens=5000ï¼‰\")\n    print(\"=\" * 60)\n    \n    tool = RepoMapTool()\n    \n    # ç¬¬ä¸€æ¬¡ç”Ÿæˆï¼ˆæ— ç¼“å­˜ï¼‰\n    print(\"\\nç¬¬ä¸€æ¬¡ç”Ÿæˆï¼ˆæ— ç¼“å­˜ï¼‰...\")\n    start_time = time.time()\n    \n    result = await tool.execute(\n        repo_path=\".\",\n        chat_files=[],\n        mentioned_idents=[]\n    )\n    \n    elapsed = time.time() - start_time\n    \n    if result.success:\n        print(f\"âœ“ ç”ŸæˆæˆåŠŸ\")\n        print(f\"âœ“ è€—æ—¶: {elapsed:.2f}ç§’\")\n        \n        # æ£€æŸ¥å†…å®¹\n        content = result.content\n        lines = content.split('\\n')\n        print(f\"âœ“ è¾“å‡ºè¡Œæ•°: {len(lines)}\")\n        \n        # ç»Ÿè®¡æ–‡ä»¶æ•°\n        file_count = len([l for l in lines if l.strip() and not l.startswith(' ') and ':' in l])\n        print(f\"âœ“ åŒ…å«æ–‡ä»¶æ•°: {file_count}\")\n        \n        # ç»Ÿè®¡å®šä¹‰æ•°\n        def_count = len([l for l in lines if l.strip().startswith('class ') or \n                         l.strip().startswith('def ') or \n                         l.strip().startswith('function ') or\n                         l.strip().startswith('method ')])\n        print(f\"âœ“ åŒ…å«å®šä¹‰æ•°: {def_count}\")\n        \n        # æ˜¾ç¤ºå‰20è¡Œ\n        print(\"\\nå‰20è¡Œé¢„è§ˆ:\")\n        print(\"-\" * 60)\n        for line in lines[:20]:\n            print(line)\n        print(\"-\" * 60)\n        \n        # æ£€æŸ¥metadata\n        if result.metadata:\n            print(f\"\\nMetadata:\")\n            print(f\"  - repo_path: {result.metadata.get('repo_path')}\")\n            print(f\"  - file_count: {result.metadata.get('file_count')}\")\n            print(f\"  - definition_count: {result.metadata.get('definition_count')}\")\n        \n        return True\n    else:\n        print(f\"âœ— ç”Ÿæˆå¤±è´¥: {result.error}\")\n        return False\n\n\nasync def test_cached_generation():\n    \"\"\"æµ‹è¯•ç¼“å­˜ç”Ÿæˆ\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•2: ç¼“å­˜ç”Ÿæˆï¼ˆç¬¬äºŒæ¬¡åº”è¯¥æ›´å¿«ï¼‰\")\n    print(\"=\" * 60)\n    \n    tool = RepoMapTool()\n    \n    print(\"\\nç¬¬äºŒæ¬¡ç”Ÿæˆï¼ˆæœ‰ç¼“å­˜ï¼‰...\")\n    start_time = time.time()\n    \n    result = await tool.execute(\n        repo_path=\".\",\n        chat_files=[],\n        mentioned_idents=[]\n    )\n    \n    elapsed = time.time() - start_time\n    \n    if result.success:\n        print(f\"âœ“ ç”ŸæˆæˆåŠŸ\")\n        print(f\"âœ“ è€—æ—¶: {elapsed:.2f}ç§’ï¼ˆåº”è¯¥æ¯”ç¬¬ä¸€æ¬¡å¿«ï¼‰\")\n        return True\n    else:\n        print(f\"âœ— ç”Ÿæˆå¤±è´¥: {result.error}\")\n        return False\n\n\nasync def test_with_personalization():\n    \"\"\"æµ‹è¯•ä¸ªæ€§åŒ–æƒé‡\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•3: ä¸ªæ€§åŒ–æƒé‡ï¼ˆæåˆ°BaseAgentï¼‰\")\n    print(\"=\" * 60)\n    \n    tool = RepoMapTool()\n    \n    print(\"\\nç”Ÿæˆæ—¶æåˆ° 'BaseAgent'...\")\n    start_time = time.time()\n    \n    result = await tool.execute(\n        repo_path=\".\",\n        chat_files=[\"daoyoucode/agents/core/agent.py\"],\n        mentioned_idents=[\"BaseAgent\", \"execute\"]\n    )\n    \n    elapsed = time.time() - start_time\n    \n    if result.success:\n        print(f\"âœ“ ç”ŸæˆæˆåŠŸ\")\n        print(f\"âœ“ è€—æ—¶: {elapsed:.2f}ç§’\")\n        \n        content = result.content\n        lines = content.split('\\n')\n        \n        # æ£€æŸ¥agent.pyæ˜¯å¦åœ¨å‰é¢\n        agent_line = None\n        for i, line in enumerate(lines):\n            if 'agent.py' in line.lower():\n                agent_line = i\n                break\n        \n        if agent_line is not None and agent_line < 10:\n            print(f\"âœ“ agent.py åœ¨ç¬¬ {agent_line} è¡Œï¼ˆæƒé‡ç”Ÿæ•ˆï¼‰\")\n        else:\n            print(f\"âš  agent.py åœ¨ç¬¬ {agent_line} è¡Œï¼ˆå¯èƒ½æƒé‡æœªç”Ÿæ•ˆï¼‰\")\n        \n        # æ˜¾ç¤ºå‰15è¡Œ\n        print(\"\\nå‰15è¡Œé¢„è§ˆ:\")\n        print(\"-\" * 60)\n        for line in lines[:15]:\n            print(line)\n        print(\"-\" * 60)\n        \n        return True\n    else:\n        print(f\"âœ— ç”Ÿæˆå¤±è´¥: {result.error}\")\n        return False\n\n\nasync def test_different_token_limits():\n    \"\"\"æµ‹è¯•ä¸åŒtokené™åˆ¶\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•4: ä¸åŒtokené™åˆ¶\")\n    print(\"=\" * 60)\n    \n    tool = RepoMapTool()\n    \n    for max_tokens in [1000, 3000, 5000, 8000]"
},
{
"path": "tests/test_repomap_tools.py",
"start": 1,
"end": 21,
"text": "\"\"\"\nRepoMapå·¥å…·æµ‹è¯•\n\næµ‹è¯•åœºæ™¯ï¼š\n1. åŸºæœ¬RepoMapç”Ÿæˆ\n2. ä¸ªæ€§åŒ–æƒé‡ï¼ˆå¯¹è¯æ–‡ä»¶ã€æåˆ°çš„æ ‡è¯†ç¬¦ï¼‰\n3. Tokené¢„ç®—æ§åˆ¶\n4. ç¼“å­˜æœºåˆ¶\n5. ä»“åº“ç»“æ„è·å–\n\"\"\"\n\nimport pytest\nimport asyncio\nfrom pathlib import Path\nimport tempfile\nimport shutil\n\nfrom daoyoucode.agents.tools.repomap_tools import RepoMapTool, GetRepoStructureTool\n\n\n@pytest.fixture"
},
{
"path": "tests/test_repomap_tools.py",
"start": 22,
"end": 29,
"text": "def temp_repo():\n    \"\"\"åˆ›å»ºä¸´æ—¶æµ‹è¯•ä»“åº“\"\"\"\n    temp_dir = tempfile.mkdtemp()\n    repo_path = Path(temp_dir)\n    \n    # åˆ›å»ºæµ‹è¯•æ–‡ä»¶\n    # file1.py\n    (repo_path / \"file1.py\").write_text(\"\"\""
},
{
"path": "tests/test_repomap_tools.py",
"start": 30,
"end": 30,
"text": "class UserManager:"
},
{
"path": "tests/test_repomap_tools.py",
"start": 31,
"end": 33,
"text": "    def create_user(self, name):\n        pass\n    "
},
{
"path": "tests/test_repomap_tools.py",
"start": 34,
"end": 36,
"text": "    def delete_user(self, user_id):\n        pass\n"
},
{
"path": "tests/test_repomap_tools.py",
"start": 37,
"end": 44,
"text": "def get_user(user_id):\n    return UserManager().get_user(user_id)\n\"\"\")\n    \n    # file2.py\n    (repo_path / \"file2.py\").write_text(\"\"\"\nfrom file1 import UserManager\n"
},
{
"path": "tests/test_repomap_tools.py",
"start": 45,
"end": 45,
"text": "class AuthService:"
},
{
"path": "tests/test_repomap_tools.py",
"start": 46,
"end": 48,
"text": "    def __init__(self):\n        self.user_manager = UserManager()\n    "
},
{
"path": "tests/test_repomap_tools.py",
"start": 49,
"end": 57,
"text": "    def login(self, username, password):\n        user = self.user_manager.get_user(username)\n        return user\n\"\"\")\n    \n    # subdir/file3.js\n    subdir = repo_path / \"subdir\"\n    subdir.mkdir()\n    (subdir / \"file3.js\").write_text(\"\"\""
},
{
"path": "tests/test_repomap_tools.py",
"start": 58,
"end": 77,
"text": "class ApiClient {\n    constructor() {}\n    \n    fetchUser(userId) {\n        return fetch(`/api/users/${userId}`)\n    }\n}\n\nfunction getUserData(userId) {\n    const client = new ApiClient()\n    return client.fetchUser(userId)\n}\n\"\"\")\n    \n    yield repo_path\n    \n    # æ¸…ç†\n    shutil.rmtree(temp_dir)\n\n"
},
{
"path": "tests/test_repomap_tools.py",
"start": 78,
"end": 222,
"text": "class TestRepoMapTool:\n    \"\"\"RepoMapå·¥å…·æµ‹è¯•\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_basic_repomap(self, temp_repo):\n        \"\"\"æµ‹è¯•åŸºæœ¬RepoMapç”Ÿæˆ\"\"\"\n        tool = RepoMapTool()\n        result = await tool.execute(\n            repo_path=str(temp_repo),\n            max_tokens=1000\n        )\n        \n        print(\"\\n=== åŸºæœ¬RepoMap ===\")\n        print(f\"Success: {result.success}\")\n        print(f\"Content:\\n{result.content}\")\n        \n        assert result.success\n        assert \"ä»£ç åœ°å›¾\" in result.content\n        assert \"file1.py\" in result.content or \"file2.py\" in result.content\n        assert \"class\" in result.content or \"function\" in result.content\n    \n    @pytest.mark.asyncio\n    async def test_chat_files_weight(self, temp_repo):\n        \"\"\"æµ‹è¯•å¯¹è¯æ–‡ä»¶æƒé‡ï¼ˆÃ—50ï¼‰\"\"\"\n        tool = RepoMapTool()\n        \n        # ä¸æŒ‡å®šchat_files\n        result1 = await tool.execute(\n            repo_path=str(temp_repo),\n            max_tokens=1000\n        )\n        \n        # æŒ‡å®šchat_files\n        result2 = await tool.execute(\n            repo_path=str(temp_repo),\n            chat_files=[\"file2.py\"],\n            max_tokens=1000\n        )\n        \n        print(\"\\n=== æ— chat_files ===\")\n        print(result1.content)\n        print(\"\\n=== æœ‰chat_files (file2.py) ===\")\n        print(result2.content)\n        \n        # file2.pyåº”è¯¥æ’åœ¨å‰é¢\n        assert result2.success\n        assert \"file2.py\" in result2.content\n    \n    @pytest.mark.asyncio\n    async def test_mentioned_idents_weight(self, temp_repo):\n        \"\"\"æµ‹è¯•æåˆ°çš„æ ‡è¯†ç¬¦æƒé‡ï¼ˆÃ—10ï¼‰\"\"\"\n        tool = RepoMapTool()\n        \n        result = await tool.execute(\n            repo_path=str(temp_repo),\n            mentioned_idents=[\"UserManager\", \"AuthService\"],\n            max_tokens=1000\n        )\n        \n        print(\"\\n=== æåˆ°æ ‡è¯†ç¬¦ (UserManager, AuthService) ===\")\n        print(result.content)\n        \n        # åº”è¯¥åŒ…å«ç›¸å…³æ–‡ä»¶\n        assert result.success\n        assert \"file1.py\" in result.content or \"file2.py\" in result.content\n    \n    @pytest.mark.asyncio\n    async def test_token_budget(self, temp_repo):\n        \"\"\"æµ‹è¯•Tokené¢„ç®—æ§åˆ¶\"\"\"\n        tool = RepoMapTool()\n        \n        # å°é¢„ç®—\n        result_small = await tool.execute(\n            repo_path=str(temp_repo),\n            max_tokens=50\n        )\n        \n        # å¤§é¢„ç®—\n        result_large = await tool.execute(\n            repo_path=str(temp_repo),\n            max_tokens=1000\n        )\n        \n        print(\"\\n=== å°é¢„ç®— (50 tokens) ===\")\n        print(result_small.content)\n        print(f\"é•¿åº¦: {len(result_small.content)}\")\n        \n        print(\"\\n=== å¤§é¢„ç®— (1000 tokens) ===\")\n        print(result_large.content)\n        print(f\"é•¿åº¦: {len(result_large.content)}\")\n        \n        # ä¸¤ä¸ªéƒ½åº”è¯¥æˆåŠŸ\n        assert result_small.success\n        assert result_large.success\n        # å°é¢„ç®—åº”è¯¥ä¸è¶…è¿‡å¤§é¢„ç®—ï¼ˆæµ‹è¯•ä»“åº“å¤ªå°ï¼Œå¯èƒ½ç›¸ç­‰ï¼‰\n        assert len(result_small.content) <= len(result_large.content)\n    \n    @pytest.mark.asyncio\n    async def test_cache_mechanism(self, temp_repo):\n        \"\"\"æµ‹è¯•ç¼“å­˜æœºåˆ¶\"\"\"\n        tool = RepoMapTool()\n        \n        # ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼ˆæ— ç¼“å­˜ï¼‰\n        import time\n        start1 = time.time()\n        result1 = await tool.execute(\n            repo_path=str(temp_repo),\n            max_tokens=1000\n        )\n        time1 = time.time() - start1\n        \n        # ç¬¬äºŒæ¬¡è°ƒç”¨ï¼ˆæœ‰ç¼“å­˜ï¼‰\n        start2 = time.time()\n        result2 = await tool.execute(\n            repo_path=str(temp_repo),\n            max_tokens=1000\n        )\n        time2 = time.time() - start2\n        \n        print(f\"\\n=== ç¼“å­˜æµ‹è¯• ===\")\n        print(f\"ç¬¬ä¸€æ¬¡: {time1:.4f}s\")\n        print(f\"ç¬¬äºŒæ¬¡: {time2:.4f}s\")\n        print(f\"åŠ é€Ÿ: {time1/time2:.2f}x\" if time2 > 0 else \"N/A\")\n        \n        # ç»“æœåº”è¯¥ç›¸åŒ\n        assert result1.success\n        assert result2.success\n        assert result1.content == result2.content\n    \n    @pytest.mark.asyncio\n    async def test_nonexistent_repo(self):\n        \"\"\"æµ‹è¯•ä¸å­˜åœ¨çš„ä»“åº“\"\"\"\n        tool = RepoMapTool()\n        result = await tool.execute(\n            repo_path=\"/nonexistent/path\"\n        )\n        \n        print(\"\\n=== "
},
{
"path": "tests/test_repomap_tools.py",
"start": 223,
"end": 292,
"text": "class TestGetRepoStructureTool:\n    \"\"\"ä»“åº“ç»“æ„å·¥å…·æµ‹è¯•\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_basic_structure(self, temp_repo):\n        \"\"\"æµ‹è¯•åŸºæœ¬ç»“æ„è·å–\"\"\"\n        tool = GetRepoStructureTool()\n        result = await tool.execute(\n            repo_path=str(temp_repo)\n        )\n        \n        print(\"\\n=== ä»“åº“ç»“æ„ ===\")\n        print(result.content)\n        \n        assert result.success\n        assert \"file1.py\" in result.content\n        assert \"file2.py\" in result.content\n        assert \"subdir\" in result.content\n        assert \"file3.js\" in result.content\n    \n    @pytest.mark.asyncio\n    async def test_max_depth(self, temp_repo):\n        \"\"\"æµ‹è¯•æœ€å¤§æ·±åº¦é™åˆ¶\"\"\"\n        tool = GetRepoStructureTool()\n        \n        # æ·±åº¦1ï¼ˆåªæ˜¾ç¤ºæ ¹ç›®å½•ï¼‰\n        result1 = await tool.execute(\n            repo_path=str(temp_repo),\n            max_depth=1\n        )\n        \n        # æ·±åº¦2ï¼ˆæ˜¾ç¤ºå­ç›®å½•ï¼‰\n        result2 = await tool.execute(\n            repo_path=str(temp_repo),\n            max_depth=2\n        )\n        \n        print(\"\\n=== æ·±åº¦1 ===\")\n        print(result1.content)\n        \n        print(\"\\n=== æ·±åº¦2 ===\")\n        print(result2.content)\n        \n        # æ·±åº¦1åº”è¯¥æ›´çŸ­\n        assert result1.success\n        assert result2.success\n        assert len(result1.content) < len(result2.content)\n        # æ·±åº¦2åº”è¯¥åŒ…å«å­ç›®å½•æ–‡ä»¶\n        assert \"file3.js\" in result2.content\n    \n    @pytest.mark.asyncio\n    async def test_show_files_false(self, temp_repo):\n        \"\"\"æµ‹è¯•åªæ˜¾ç¤ºç›®å½•\"\"\"\n        tool = GetRepoStructureTool()\n        result = await tool.execute(\n            repo_path=str(temp_repo),\n            show_files=False\n        )\n        \n        print(\"\\n=== åªæ˜¾ç¤ºç›®å½• ===\")\n        print(result.content)\n        \n        # åº”è¯¥åŒ…å«ç›®å½•\n        assert result.success\n        assert \"subdir\" in result.content\n        # ä¸åº”è¯¥åŒ…å«æ–‡ä»¶\n        assert \"file1.py\" not in result.content\n        assert \"file2.py\" not in result.content\n\n"
},
{
"path": "tests/test_repomap_tools.py",
"start": 293,
"end": 345,
"text": "class TestToolIntegration:\n    \"\"\"å·¥å…·é›†æˆæµ‹è¯•\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_tool_registry(self):\n        \"\"\"æµ‹è¯•å·¥å…·æ³¨å†Œ\"\"\"\n        from daoyoucode.agents.tools import get_tool_registry\n        \n        registry = get_tool_registry()\n        tools = registry.list_tools()\n        \n        print(f\"\\n=== å·²æ³¨å†Œå·¥å…· ({len(tools)}ä¸ª) ===\")\n        for tool_name in tools:\n            print(f\"  - {tool_name}\")\n        \n        # åº”è¯¥åŒ…å«RepoMapå·¥å…·\n        assert \"repo_map\" in tools\n        assert \"get_repo_structure\" in tools\n        \n        # æ€»å…±23ä¸ªå·¥å…·ï¼ˆåŒ…æ‹¬6ä¸ªLSPå·¥å…·ï¼‰\n        assert len(tools) == 23\n    \n    @pytest.mark.asyncio\n    async def test_function_schemas(self):\n        \"\"\"æµ‹è¯•Function schemas\"\"\"\n        from daoyoucode.agents.tools import get_tool_registry\n        \n        registry = get_tool_registry()\n        schemas = registry.get_function_schemas()\n        \n        print(f\"\\n=== Function Schemas ({len(schemas)}ä¸ª) ===\")\n        \n        # æ‰¾åˆ°repo_mapçš„schema\n        repo_map_schema = None\n        for schema in schemas:\n            if schema[\"name\"] == \"repo_map\":\n                repo_map_schema = schema\n                break\n        \n        assert repo_map_schema is not None\n        print(\"\\n=== repo_map schema ===\")\n        import json\n        print(json.dumps(repo_map_schema, indent=2, ensure_ascii=False))\n        \n        # æ£€æŸ¥schemaç»“æ„\n        assert \"name\" in repo_map_schema\n        assert \"description\" in repo_map_schema\n        assert \"parameters\" in repo_map_schema\n        assert \"repo_path\" in repo_map_schema[\"parameters\"][\"properties\"]\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\", \"-s\"])"
},
{
"path": "tests/test_repo_map.py",
"start": 1,
"end": 53,
"text": "\"\"\"æµ‹è¯•repo_mapå·¥å…·\"\"\"\nimport asyncio\nimport sys\nfrom pathlib import Path\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents.tools import get_tool_registry\n\nasync def test_repo_map():\n    print(\"=\"*60)\n    print(\"æµ‹è¯•repo_mapå·¥å…·\")\n    print(\"=\"*60)\n    \n    # è·å–å·¥å…·\n    tool_registry = get_tool_registry()\n    tool = tool_registry.get_tool(\"repo_map\")\n    \n    if not tool:\n        print(\"âŒ repo_mapå·¥å…·æœªæ‰¾åˆ°\")\n        return False\n    \n    print(f\"\\nâœ“ æ‰¾åˆ°repo_mapå·¥å…·\")\n    print(f\"  â€¢ æè¿°: {tool.description}\")\n    \n    # æµ‹è¯•æ‰§è¡Œ\n    print(f\"\\næ‰§è¡Œrepo_map(repo_path='.')...\")\n    try:\n        result = await tool.execute(repo_path=\".\", max_tokens=500)\n        \n        print(f\"\\nâœ“ æ‰§è¡Œå®Œæˆ\")\n        print(f\"  â€¢ æˆåŠŸ: {result.success}\")\n        if result.success:\n            content_preview = str(result.content)[:200]\n            print(f\"  â€¢ å†…å®¹é¢„è§ˆ: {content_preview}...\")\n        else:\n            print(f\"  â€¢ é”™è¯¯: {result.error}\")\n        \n        return result.success\n    \n    except Exception as e:\n        print(f\"\\nâŒ æ‰§è¡Œå¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\nif __name__ == \"__main__\":\n    success = asyncio.run(test_repo_map())\n    print(\"\\n\" + \"=\"*60)\n    if success:\n        print(\"âœ… repo_mapå·¥å…·æµ‹è¯•é€šè¿‡\")\n    else:\n        print(\"âŒ repo_mapå·¥å…·æµ‹è¯•å¤±è´¥\")\n    print(\"=\"*60)"
},
{
"path": "tests/test_repo_map_simple.py",
"start": 1,
"end": 72,
"text": "\"\"\"\nç®€å•æµ‹è¯•repo_mapå·¥å…·\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport asyncio\n\nsys.path.insert(0, str(Path(__file__).parent))\n\nasync def test_repo_map():\n    \"\"\"æµ‹è¯•repo_mapå·¥å…·\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•repo_mapå·¥å…·\")\n    print(\"=\"*60)\n    \n    from daoyoucode.agents.tools import get_tool_registry\n    \n    registry = get_tool_registry()\n    \n    # æµ‹è¯•repo_map\n    print(\"\\n1. æµ‹è¯•repo_map...\")\n    result = await registry.execute_tool(\n        'repo_map',\n        repo_path='.',  # å½“å‰ç›®å½•å°±æ˜¯backend\n        chat_files=[],\n        mentioned_idents=[],\n        max_tokens=1000\n    )\n    \n    if result.success:\n        print(\"   âœ“ æ‰§è¡ŒæˆåŠŸ\")\n        print(f\"\\n   ç»“æœé¢„è§ˆï¼ˆå‰500å­—ç¬¦ï¼‰:\")\n        print(\"   \" + \"-\"*56)\n        content = result.content[:500]\n        for line in content.split('\\n'):\n            print(f\"   {line}\")\n        print(\"   \" + \"-\"*56)\n        print(f\"\\n   å…ƒæ•°æ®: {result.metadata}\")\n    else:\n        print(f\"   âœ— æ‰§è¡Œå¤±è´¥: {result.error}\")\n        return False\n    \n    # æµ‹è¯•get_repo_structure\n    print(\"\\n2. æµ‹è¯•get_repo_structure...\")\n    result = await registry.execute_tool(\n        'get_repo_structure',\n        repo_path='.',  # å½“å‰ç›®å½•å°±æ˜¯backend\n        max_depth=2,\n        show_files=True\n    )\n    \n    if result.success:\n        print(\"   âœ“ æ‰§è¡ŒæˆåŠŸ\")\n        print(f\"\\n   ç»“æœé¢„è§ˆï¼ˆå‰500å­—ç¬¦ï¼‰:\")\n        print(\"   \" + \"-\"*56)\n        content = result.content[:500]\n        for line in content.split('\\n'):\n            print(f\"   {line}\")\n        print(\"   \" + \"-\"*56)\n    else:\n        print(f\"   âœ— æ‰§è¡Œå¤±è´¥: {result.error}\")\n        return False\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"âœ“ æµ‹è¯•é€šè¿‡\")\n    print(\"=\"*60)\n    return True\n\nif __name__ == '__main__':\n    success = asyncio.run(test_repo_map())\n    sys.exit(0 if success else 1)"
},
{
"path": "tests/test_repo_path_determination.py",
"start": 1,
"end": 14,
"text": "\"\"\"\næµ‹è¯• repo_path ç¡®å®šé€»è¾‘\n\néªŒè¯ determine_repo_path() å‡½æ•°çš„å„ç§åœºæ™¯\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport tempfile\nimport shutil\n\n# æ·»åŠ  backend åˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n"
},
{
"path": "tests/test_repo_path_determination.py",
"start": 15,
"end": 64,
"text": "def test_determine_repo_path():\n    \"\"\"æµ‹è¯• repo_path ç¡®å®šé€»è¾‘\"\"\"\n    \n    # å¯¼å…¥å‡½æ•°ï¼ˆéœ€è¦æ¨¡æ‹Ÿ typer ç¯å¢ƒï¼‰\n    import os\n    os.chdir(Path(__file__).parent)\n    \n    # æ¨¡æ‹Ÿå¯¼å…¥\n    from cli.commands.chat import determine_repo_path\n    \n    print(\"=\" * 60)\n    print(\"æµ‹è¯• repo_path ç¡®å®šé€»è¾‘\")\n    print(\"=\" * 60)\n    \n    # æµ‹è¯• 1ï¼šæ²¡æœ‰æ–‡ä»¶ï¼Œä½¿ç”¨å½“å‰ç›®å½•\n    print(\"\\næµ‹è¯• 1ï¼šæ²¡æœ‰æ–‡ä»¶ï¼Œä½¿ç”¨å½“å‰ç›®å½•\")\n    try:\n        result = determine_repo_path(files=None, repo_arg=Path(\".\"))\n        print(f\"âœ“ ç»“æœ: {result}\")\n        print(f\"  æ˜¯å¦ä¸ºç»å¯¹è·¯å¾„: {result.is_absolute()}\")\n    except Exception as e:\n        print(f\"âœ— é”™è¯¯: {e}\")\n    \n    # æµ‹è¯• 2ï¼šæŒ‡å®š repo å‚æ•°\n    print(\"\\næµ‹è¯• 2ï¼šæŒ‡å®š repo å‚æ•°\")\n    try:\n        test_repo = Path(__file__).parent\n        result = determine_repo_path(files=None, repo_arg=test_repo)\n        print(f\"âœ“ ç»“æœ: {result}\")\n        print(f\"  æ˜¯å¦ä¸ºç»å¯¹è·¯å¾„: {result.is_absolute()}\")\n        print(f\"  æ˜¯å¦ç­‰äºæŒ‡å®šè·¯å¾„: {result == test_repo.resolve()}\")\n    except Exception as e:\n        print(f\"âœ— é”™è¯¯: {e}\")\n    \n    # æµ‹è¯• 3ï¼šä»æ–‡ä»¶æ¨æ–­ï¼ˆä½¿ç”¨å½“å‰æ–‡ä»¶ï¼‰\n    print(\"\\næµ‹è¯• 3ï¼šä»æ–‡ä»¶æ¨æ–­\")\n    try:\n        current_file = Path(__file__)\n        result = determine_repo_path(files=[current_file], repo_arg=Path(\".\"))\n        print(f\"âœ“ ç»“æœ: {result}\")\n        print(f\"  æ˜¯å¦ä¸ºç»å¯¹è·¯å¾„: {result.is_absolute()}\")\n        print(f\"  æ–‡ä»¶æ˜¯å¦åœ¨ repo ä¸‹: {current_file.resolve().is_relative_to(result)}\")\n    except Exception as e:\n        print(f\"âœ— é”™è¯¯: {e}\")\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•å®Œæˆ\")\n    print(\"=\" * 60)\n\n"
},
{
"path": "tests/test_repo_path_determination.py",
"start": 65,
"end": 135,
"text": "def test_tool_context():\n    \"\"\"æµ‹è¯• ToolContext çš„ subtree_only åŠŸèƒ½\"\"\"\n    from daoyoucode.agents.tools.base import ToolContext\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯• ToolContext subtree_only åŠŸèƒ½\")\n    print(\"=\" * 60)\n    \n    # åˆ›å»ºæµ‹è¯•ç›®å½•ç»“æ„\n    repo_path = Path(\"/project\")\n    cwd = Path(\"/project/backend\")\n    \n    # æµ‹è¯• 1ï¼šsubtree_only = False\n    print(\"\\næµ‹è¯• 1ï¼šsubtree_only = Falseï¼ˆåŒ…å«æ‰€æœ‰è·¯å¾„ï¼‰\")\n    ctx = ToolContext(repo_path=repo_path, subtree_only=False)\n    \n    test_paths = [\n        \"backend/main.py\",\n        \"frontend/app.tsx\",\n        \"README.md\"\n    ]\n    \n    for path in test_paths:\n        included = ctx.should_include_path(path)\n        print(f\"  {path}: {'âœ“ åŒ…å«' if included else 'âœ— æ’é™¤'}\")\n    \n    # æµ‹è¯• 2ï¼šsubtree_only = True\n    print(\"\\næµ‹è¯• 2ï¼šsubtree_only = Trueï¼ˆåªåŒ…å« backend/ï¼‰\")\n    ctx = ToolContext(\n        repo_path=repo_path,\n        subtree_only=True,\n        cwd=cwd\n    )\n    \n    for path in test_paths:\n        included = ctx.should_include_path(path)\n        print(f\"  {path}: {'âœ“ åŒ…å«' if included else 'âœ— æ’é™¤'}\")\n    \n    # æµ‹è¯• 3ï¼šè·¯å¾„æ ‡å‡†åŒ–\n    print(\"\\næµ‹è¯• 3ï¼šè·¯å¾„æ ‡å‡†åŒ–\")\n    ctx = ToolContext(repo_path=Path.cwd())\n    \n    test_cases = [\n        (\"backend/main.py\", \"ç›¸å¯¹è·¯å¾„\"),\n        (str(Path.cwd() / \"backend/main.py\"), \"ç»å¯¹è·¯å¾„\"),\n    ]\n    \n    for path, desc in test_cases:\n        normalized = ctx.normalize_path(path)\n        print(f\"  {desc}: {path}\")\n        print(f\"    â†’ {normalized}\")\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•å®Œæˆ\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    try:\n        test_determine_repo_path()\n    except Exception as e:\n        print(f\"\\næµ‹è¯•å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n    \n    try:\n        test_tool_context()\n    except Exception as e:\n        print(f\"\\næµ‹è¯•å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()"
},
{
"path": "tests/test_router_dynamic.py",
"start": 1,
"end": 59,
"text": "\"\"\"\næµ‹è¯•IntelligentRouterçš„åŠ¨æ€é€‚é…èƒ½åŠ›\n\"\"\"\n\nimport asyncio\nfrom daoyoucode.agents.core.router import get_intelligent_router\nfrom daoyoucode.agents.core.agent import BaseAgent, AgentConfig, register_agent\n\n\nasync def test_dynamic_registration():\n    \"\"\"æµ‹è¯•åŠ¨æ€æ³¨å†ŒAgent\"\"\"\n    print(\"\\n=== æµ‹è¯•1: åŠ¨æ€æ³¨å†ŒAgent ===\")\n    \n    router = get_intelligent_router(auto_discover=False)\n    \n    # åˆå§‹Agentæ•°é‡\n    initial_count = len(router.list_registered_agents())\n    print(f\"âœ“ åˆå§‹Agentæ•°é‡: {initial_count}\")\n    \n    # åŠ¨æ€æ³¨å†Œæ–°Agent\n    router.register_agent_keywords(\n        'data_scientist',\n        ['æ•°æ®', 'åˆ†æ', 'ç»Ÿè®¡', 'æœºå™¨å­¦ä¹ ', 'æ¨¡å‹']\n    )\n    \n    # éªŒè¯æ³¨å†ŒæˆåŠŸ\n    agents = router.list_registered_agents()\n    print(f\"âœ“ æ³¨å†ŒåAgentæ•°é‡: {len(agents)}\")\n    assert 'data_scientist' in agents\n    assert len(agents) == initial_count + 1\n    \n    # æµ‹è¯•è·¯ç”±åˆ°æ–°Agent\n    decision = await router.route(\"åˆ†æè¿™ä¸ªæ•°æ®é›†çš„ç»Ÿè®¡ç‰¹å¾\")\n    print(f\"âœ“ è·¯ç”±ç»“æœ: {decision.agent}\")\n    assert decision.agent == 'data_scientist'\n\n\nasync def test_unregister_agent():\n    \"\"\"æµ‹è¯•å–æ¶ˆæ³¨å†ŒAgent\"\"\"\n    print(\"\\n=== æµ‹è¯•2: å–æ¶ˆæ³¨å†ŒAgent ===\")\n    \n    router = get_intelligent_router(auto_discover=False)\n    \n    # æ³¨å†Œä¸€ä¸ªä¸´æ—¶Agent\n    router.register_agent_keywords('temp_agent', ['ä¸´æ—¶', 'æµ‹è¯•'])\n    assert 'temp_agent' in router.list_registered_agents()\n    print(f\"âœ“ æ³¨å†Œä¸´æ—¶AgentæˆåŠŸ\")\n    \n    # å–æ¶ˆæ³¨å†Œ\n    router.unregister_agent('temp_agent')\n    assert 'temp_agent' not in router.list_registered_agents()\n    print(f\"âœ“ å–æ¶ˆæ³¨å†ŒæˆåŠŸ\")\n\n\nasync def test_auto_discover():\n    \"\"\"æµ‹è¯•è‡ªåŠ¨å‘ç°Agent\"\"\"\n    print(\"\\n=== æµ‹è¯•3: è‡ªåŠ¨å‘ç°Agent ===\")\n    \n    # åˆ›å»ºä¸€ä¸ªæ–°çš„Agentå¹¶æ³¨å†Œ"
},
{
"path": "tests/test_router_dynamic.py",
"start": 60,
"end": 60,
"text": "    class DataScientistAgent(BaseAgent):"
},
{
"path": "tests/test_router_dynamic.py",
"start": 61,
"end": 181,
"text": "        def __init__(self):\n            config = AgentConfig(\n                name=\"data_scientist_auto\",\n                description=\"æ•°æ®ç§‘å­¦ä¸“å®¶ï¼Œæ“…é•¿æ•°æ®åˆ†æã€ç»Ÿè®¡å»ºæ¨¡å’Œæœºå™¨å­¦ä¹ \",\n                model=\"qwen-max\",\n                temperature=0.7\n            )\n            super().__init__(config)\n    \n    # æ³¨å†Œåˆ°AgentRegistry\n    agent = DataScientistAgent()\n    register_agent(agent)\n    print(f\"âœ“ åˆ›å»ºå¹¶æ³¨å†Œæ–°Agent: data_scientist_auto\")\n    \n    # åˆ›å»ºæ–°çš„Routerå®ä¾‹ï¼ˆä¼šè‡ªåŠ¨å‘ç°ï¼‰\n    # æ³¨æ„ï¼šè¿™é‡Œéœ€è¦é‡ç½®å•ä¾‹\n    import daoyoucode.agents.core.router as router_module\n    router_module._router_instance = None\n    \n    router = get_intelligent_router(auto_discover=True)\n    \n    # éªŒè¯è‡ªåŠ¨å‘ç°\n    agents = router.list_registered_agents()\n    print(f\"âœ“ å‘ç°çš„Agent: {agents}\")\n    \n    if 'data_scientist_auto' in agents:\n        print(f\"âœ“ è‡ªåŠ¨å‘ç°æˆåŠŸï¼\")\n        keywords = router.agent_domains.get('data_scientist_auto', [])\n        print(f\"  æå–çš„å…³é”®è¯: {keywords}\")\n    else:\n        print(f\"âš ï¸ æœªè‡ªåŠ¨å‘ç°ï¼ˆå¯èƒ½Agentæ³¨å†Œæ—¶æœºé—®é¢˜ï¼‰\")\n\n\nasync def test_config_file():\n    \"\"\"æµ‹è¯•ä»é…ç½®æ–‡ä»¶åŠ è½½\"\"\"\n    print(\"\\n=== æµ‹è¯•4: ä»é…ç½®æ–‡ä»¶åŠ è½½ ===\")\n    \n    # é‡ç½®å•ä¾‹\n    import daoyoucode.agents.core.router as router_module\n    router_module._router_instance = None\n    \n    # ä»é…ç½®æ–‡ä»¶åŠ è½½\n    router = get_intelligent_router(\n        config_path='config/agent_router_config.yaml',\n        auto_discover=False\n    )\n    \n    agents = router.list_registered_agents()\n    print(f\"âœ“ ä»é…ç½®æ–‡ä»¶åŠ è½½çš„Agent: {agents}\")\n    \n    # éªŒè¯é…ç½®æ–‡ä»¶ä¸­çš„Agent\n    assert 'code_analyzer' in agents\n    assert 'test_writer' in agents\n    print(f\"âœ“ é…ç½®æ–‡ä»¶åŠ è½½æˆåŠŸ\")\n\n\nasync def test_multiple_agents():\n    \"\"\"æµ‹è¯•å¤šä¸ªæ–°Agentçš„è·¯ç”±\"\"\"\n    print(\"\\n=== æµ‹è¯•5: å¤šä¸ªæ–°Agentè·¯ç”± ===\")\n    \n    router = get_intelligent_router(auto_discover=False)\n    \n    # æ³¨å†Œå¤šä¸ªæ–°Agent\n    new_agents = {\n        'security_expert': ['å®‰å…¨', 'æ¼æ´', 'åŠ å¯†', 'æƒé™'],\n        'performance_optimizer': ['æ€§èƒ½', 'ä¼˜åŒ–', 'åŠ é€Ÿ', 'ç¼“å­˜'],\n        'ui_designer': ['ç•Œé¢', 'è®¾è®¡', 'ui', 'ux', 'ç”¨æˆ·ä½“éªŒ']\n    }\n    \n    for agent_name, keywords in new_agents.items():\n        router.register_agent_keywords(agent_name, keywords)\n    \n    print(f\"âœ“ æ³¨å†Œäº† {len(new_agents)} ä¸ªæ–°Agent\")\n    \n    # æµ‹è¯•è·¯ç”±\n    test_cases = [\n        (\"æ£€æŸ¥ä»£ç ä¸­çš„å®‰å…¨æ¼æ´\", \"security_expert\"),\n        (\"ä¼˜åŒ–è¿™ä¸ªå‡½æ•°çš„æ€§èƒ½\", \"performance_optimizer\"),\n        (\"è®¾è®¡ä¸€ä¸ªç”¨æˆ·å‹å¥½çš„ç•Œé¢\", \"ui_designer\"),\n    ]\n    \n    for user_input, expected_agent in test_cases:\n        decision = await router.route(user_input)\n        print(f\"âœ“ '{user_input}' -> {decision.agent}\")\n        assert decision.agent == expected_agent\n\n\nasync def main():\n    \"\"\"è¿è¡Œæ‰€æœ‰æµ‹è¯•\"\"\"\n    print(\"=\" * 60)\n    print(\"IntelligentRouter åŠ¨æ€é€‚é…æµ‹è¯•\")\n    print(\"=\" * 60)\n    \n    try:\n        await test_dynamic_registration()\n        await test_unregister_agent()\n        await test_auto_discover()\n        await test_config_file()\n        await test_multiple_agents()\n        \n        print(\"\\n\" + \"=\" * 60)\n        print(\"âœ“ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼\")\n        print(\"=\" * 60)\n        \n        print(\"\\næ€»ç»“:\")\n        print(\"âœ“ æ”¯æŒåŠ¨æ€æ³¨å†ŒAgent\")\n        print(\"âœ“ æ”¯æŒå–æ¶ˆæ³¨å†ŒAgent\")\n        print(\"âœ“ æ”¯æŒè‡ªåŠ¨å‘ç°å·²æ³¨å†Œçš„Agent\")\n        print(\"âœ“ æ”¯æŒä»é…ç½®æ–‡ä»¶åŠ è½½\")\n        print(\"âœ“ æ–°å¢Agentæ— éœ€ä¿®æ”¹Routerä»£ç \")\n    \n    except AssertionError as e:\n        print(f\"\\nâœ— æµ‹è¯•å¤±è´¥: {e}\")\n        raise\n    except Exception as e:\n        print(f\"\\nâœ— æµ‹è¯•é”™è¯¯: {e}\")\n        raise\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())"
},
{
"path": "tests/test_simple_llm.py",
"start": 1,
"end": 112,
"text": "\"\"\"\nç®€å•çš„LLMæµ‹è¯•ï¼ˆä¸ä½¿ç”¨ä¸­é—´ä»¶ï¼‰\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\n# è®¾ç½®API Key\nos.environ['DASHSCOPE_API_KEY'] = 'sk-d2971f2015574377bdf97046b1a03b87'\n\nfrom daoyoucode.agents.builtin import register_builtin_agents\nfrom daoyoucode.agents.core.agent import get_agent_registry\nfrom daoyoucode.agents.core.skill import get_skill_loader\nfrom daoyoucode.agents.llm import get_client_manager\n\n\nasync def test_direct_agent_call():\n    \"\"\"ç›´æ¥è°ƒç”¨Agentï¼ˆä¸é€šè¿‡Skillï¼‰\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•: ç›´æ¥è°ƒç”¨Agent\")\n    print(\"=\"*60)\n    \n    # é…ç½®LLMæä¾›å•†\n    print(\"\\né…ç½®LLMæä¾›å•†...\")\n    client_manager = get_client_manager()\n    client_manager.configure_provider(\n        provider='qwen',\n        api_key=os.environ['DASHSCOPE_API_KEY'],\n        base_url='https://dashscope.aliyuncs.com/compatible-mode/v1',\n        models=['qwen-max', 'qwen-plus', 'qwen-turbo', 'qwen-coder-plus']\n    )\n    print(\"âœ“ å·²é…ç½®qwenæä¾›å•†\")\n    \n    # æ³¨å†ŒAgent\n    register_builtin_agents()\n    \n    # è·å–Agent\n    registry = get_agent_registry()\n    agent = registry.get_agent('programmer')\n    \n    if not agent:\n        print(\"âŒ Agent 'programmer' æœªæ‰¾åˆ°\")\n        return\n    \n    print(f\"âœ“ æ‰¾åˆ°Agent: {agent.name}\")\n    \n    # ç›´æ¥è°ƒç”¨ï¼ˆä¸ä½¿ç”¨å·¥å…·ï¼‰\n    print(\"\\nåœºæ™¯1: ç®€å•é—®ç­”ï¼ˆæ— å·¥å…·ï¼‰\")\n    print(\"-\" * 40)\n    \n    try:\n        result = await agent.execute(\n            prompt_source={'inline': 'ä½ æ˜¯ä¸€ä¸ªPythonç¼–ç¨‹ä¸“å®¶ã€‚è¯·ç®€çŸ­å›ç­”ç”¨æˆ·çš„é—®é¢˜ã€‚'},\n            user_input='ä»€ä¹ˆæ˜¯è£…é¥°å™¨ï¼Ÿç”¨ä¸€å¥è¯è§£é‡Šã€‚',\n            llm_config={'model': 'qwen-max', 'temperature': 0.7}\n        )\n        \n        print(f\"\\næ‰§è¡Œç»“æœ:\")\n        print(f\"  æˆåŠŸ: {result.success}\")\n        print(f\"  å“åº”: {result.content}\")\n        print(f\"  ä½¿ç”¨çš„å·¥å…·: {result.tools_used}\")\n        \n    except Exception as e:\n        print(f\"âŒ é”™è¯¯: {e}\")\n        import traceback\n        traceback.print_exc()\n    \n    # ä½¿ç”¨å·¥å…·\n    print(\"\\nåœºæ™¯2: ä½¿ç”¨å·¥å…·\")\n    print(\"-\" * 40)\n    \n    try:\n        result = await agent.execute(\n            prompt_source={'inline': 'ä½ æ˜¯ä¸€ä¸ªPythonç¼–ç¨‹ä¸“å®¶ã€‚ä½ å¯ä»¥ä½¿ç”¨å·¥å…·æ¥è¯»å–æ–‡ä»¶ã€‚'},\n            user_input='è¯»å–daoyoucode/agents/core/agent.pyæ–‡ä»¶çš„å‰50è¡Œ',\n            llm_config={'model': 'qwen-max', 'temperature': 0.7},\n            tools=['read_file', 'get_file_content_lines'],\n            max_tool_iterations=3\n        )\n        \n        print(f\"\\næ‰§è¡Œç»“æœ:\")\n        print(f\"  æˆåŠŸ: {result.success}\")\n        print(f\"  å“åº”é•¿åº¦: {len(result.content)} å­—ç¬¦\")\n        print(f\"  ä½¿ç”¨çš„å·¥å…·: {result.tools_used}\")\n        print(f\"  å“åº”é¢„è§ˆ: {result.content[:200]}...\")\n        \n    except Exception as e:\n        print(f\"âŒ é”™è¯¯: {e}\")\n        import traceback\n        traceback.print_exc()\n\n\nasync def main():\n    \"\"\"ä¸»å‡½æ•°\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"ç®€å•LLMæµ‹è¯•\")\n    print(\"=\"*60)\n    \n    await test_direct_agent_call()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•å®Œæˆï¼\")\n    print(\"=\"*60)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())"
},
{
"path": "tests/test_skill_architecture.py",
"start": 1,
"end": 220,
"text": "\"\"\"\næµ‹è¯•æ–°çš„Skillæ¶æ„\n\néªŒè¯ï¼š\n1. SkillåŠ è½½\n2. Executorè°ƒç”¨\n3. ReActç¼–æ’å™¨\n4. Agentæ‰§è¡Œ\n5. å·¥å…·è°ƒç”¨\n\"\"\"\n\nimport asyncio\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents.executor import execute_skill, list_skills, get_skill_info\nfrom daoyoucode.agents.core.skill import get_skill_loader\n\n\nasync def test_skill_loading():\n    \"\"\"æµ‹è¯•SkillåŠ è½½\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•1: SkillåŠ è½½\")\n    print(\"=\"*60)\n    \n    # è·å–SkillåŠ è½½å™¨\n    loader = get_skill_loader()\n    \n    # åˆ—å‡ºæ‰€æœ‰Skill\n    skills = list_skills()\n    print(f\"\\nâœ“ æ‰¾åˆ° {len(skills)} ä¸ªSkill:\")\n    for skill in skills:\n        print(f\"  â€¢ {skill['name']} v{skill['version']}\")\n        print(f\"    {skill['description']}\")\n        print(f\"    ç¼–æ’å™¨: {skill['orchestrator']}\")\n    \n    # æ£€æŸ¥chat_assistant\n    if any(s['name'] == 'chat_assistant' for s in skills):\n        print(\"\\nâœ“ chat_assistant Skillå·²åŠ è½½\")\n        \n        # è·å–è¯¦ç»†ä¿¡æ¯\n        info = get_skill_info('chat_assistant')\n        print(f\"\\nè¯¦ç»†ä¿¡æ¯:\")\n        print(f\"  â€¢ Agent: {info['agent']}\")\n        print(f\"  â€¢ ç¼–æ’å™¨: {info['orchestrator']}\")\n        print(f\"  â€¢ ä¸­é—´ä»¶: {info['middleware']}\")\n        \n        return True\n    else:\n        print(\"\\nâœ— chat_assistant Skillæœªæ‰¾åˆ°\")\n        return False\n\n\nasync def test_skill_config():\n    \"\"\"æµ‹è¯•Skillé…ç½®\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•2: Skillé…ç½®\")\n    print(\"=\"*60)\n    \n    loader = get_skill_loader()\n    skill = loader.get_skill('chat_assistant')\n    \n    if not skill:\n        print(\"âœ— æ— æ³•åŠ è½½chat_assistant\")\n        return False\n    \n    print(f\"\\nâœ“ Skillé…ç½®:\")\n    print(f\"  â€¢ åç§°: {skill.name}\")\n    print(f\"  â€¢ ç‰ˆæœ¬: {skill.version}\")\n    print(f\"  â€¢ ç¼–æ’å™¨: {skill.orchestrator}\")\n    print(f\"  â€¢ Agent: {skill.agent}\")\n    print(f\"  â€¢ å·¥å…·æ•°é‡: {len(skill.tools)}\")\n    print(f\"  â€¢ å·¥å…·åˆ—è¡¨: {', '.join(skill.tools)}\")\n    print(f\"  â€¢ Promptæ–‡ä»¶: {skill.prompt.get('file', 'N/A')}\")\n    print(f\"  â€¢ LLMæ¨¡å‹: {skill.llm.get('model', 'N/A')}\")\n    \n    # æ£€æŸ¥Promptæ–‡ä»¶æ˜¯å¦å­˜åœ¨\n    if 'file' in skill.prompt:\n        prompt_file = Path(skill.prompt['file'])\n        if prompt_file.exists():\n            print(f\"\\nâœ“ Promptæ–‡ä»¶å­˜åœ¨: {prompt_file}\")\n            # è¯»å–å‰å‡ è¡Œ\n            with open(prompt_file, 'r', encoding='utf-8') as f:\n                lines = f.readlines()[:5]\n            print(f\"  å‰5è¡Œ:\")\n            for line in lines:\n                print(f\"    {line.rstrip()}\")\n        else:\n            print(f\"\\nâœ— Promptæ–‡ä»¶ä¸å­˜åœ¨: {prompt_file}\")\n            return False\n    \n    return True\n\n\nasync def test_executor_call():\n    \"\"\"æµ‹è¯•Executorè°ƒç”¨ï¼ˆä¸è°ƒç”¨çœŸå®LLMï¼‰\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•3: Executorè°ƒç”¨ï¼ˆæ¨¡æ‹Ÿæ¨¡å¼ï¼‰\")\n    print(\"=\"*60)\n    \n    # æ³¨å†Œå†…ç½®Agent\n    from daoyoucode.agents.builtin import register_builtin_agents\n    register_builtin_agents()\n    print(\"\\nâœ“ å·²æ³¨å†Œå†…ç½®Agent\")\n    \n    # å‡†å¤‡ä¸Šä¸‹æ–‡\n    context = {\n        \"session_id\": \"test-session\",\n        \"repo\": \".\",\n        \"model\": \"qwen-max\"\n    }\n    \n    print(\"\\nå‡†å¤‡è°ƒç”¨execute_skill...\")\n    print(f\"  â€¢ Skill: chat_assistant\")\n    print(f\"  â€¢ è¾“å…¥: ä½ å¥½\")\n    print(f\"  â€¢ ä¼šè¯ID: {context['session_id']}\")\n    \n    try:\n        # æ³¨æ„ï¼šè¿™ä¼šå°è¯•è°ƒç”¨çœŸå®çš„ç¼–æ’å™¨å’ŒAgent\n        # å¦‚æœæ²¡æœ‰é…ç½®LLMï¼Œä¼šå¤±è´¥\n        result = await execute_skill(\n            skill_name=\"chat_assistant\",\n            user_input=\"ä½ å¥½\",\n            session_id=context[\"session_id\"],\n            context=context\n        )\n        \n        print(f\"\\nâœ“ è°ƒç”¨æˆåŠŸ\")\n        print(f\"  â€¢ æˆåŠŸ: {result.get('success')}\")\n        print(f\"  â€¢ å†…å®¹: {result.get('content', '')[:100]}\")\n        print(f\"  â€¢ é”™è¯¯: {result.get('error', 'N/A')}\")\n        print(f\"  â€¢ ä»»åŠ¡ID: {result.get('task_id', 'N/A')}\")\n        \n        return result.get('success', False)\n    \n    except Exception as e:\n        print(f\"\\nâœ— è°ƒç”¨å¤±è´¥: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n\nasync def test_architecture_flow():\n    \"\"\"æµ‹è¯•æ¶æ„æµç¨‹ï¼ˆä¸è°ƒç”¨LLMï¼‰\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•4: æ¶æ„æµç¨‹éªŒè¯\")\n    print(\"=\"*60)\n    \n    print(\"\\næ­£ç¡®çš„æ¶æ„æµç¨‹:\")\n    print(\"  ç”¨æˆ·è¾“å…¥\")\n    print(\"    â†“\")\n    print(\"  CLI (chat.py)\")\n"
},
{
"path": "tests/test_stream_output.py",
"start": 1,
"end": 276,
"text": "\"\"\"\næµ‹è¯•æµå¼è¾“å‡ºåŠŸèƒ½\n\néªŒè¯Agentçš„æµå¼æ‰§è¡Œæ˜¯å¦æ­£å¸¸å·¥ä½œ\n\"\"\"\n\nimport asyncio\nimport sys\nfrom unittest.mock import AsyncMock, patch\nfrom daoyoucode.agents.core.agent import BaseAgent, AgentConfig\n\n\nasync def test_stream_basic():\n    \"\"\"æµ‹è¯•åŸºç¡€æµå¼è¾“å‡º\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šåŸºç¡€æµå¼è¾“å‡º\")\n    print(\"=\"*60)\n    \n    config = AgentConfig(\n        name=\"test_agent\",\n        description=\"æµ‹è¯•Agent\",\n        model=\"qwen-turbo\",\n        temperature=0.7,\n        system_prompt=\"You are a helpful assistant.\"\n    )\n    agent = BaseAgent(config)\n    \n    # Mock memory\n    with patch.object(agent.memory, 'load_context_smart', new_callable=AsyncMock) as mock_load:\n        mock_load.return_value = {\n            'history': [],\n            'strategy': 'new_conversation',\n            'cost': 0,\n            'filtered': False\n        }\n        \n        with patch.object(agent.memory, 'is_followup', new_callable=AsyncMock) as mock_followup:\n            mock_followup.return_value = (False, 0.0, \"æ–°å¯¹è¯\")\n            \n            # Mockæµå¼LLMè°ƒç”¨\n            async def mock_stream(*args, **kwargs):\n                test_response = \"è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•å“åº”ï¼Œç”¨äºéªŒè¯æµå¼è¾“å‡ºåŠŸèƒ½ã€‚\"\n                for char in test_response:\n                    yield char\n                    await asyncio.sleep(0.01)  # æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ\n            \n            with patch.object(agent, '_stream_llm', side_effect=mock_stream):\n                print(\"\\nå¼€å§‹æµå¼è¾“å‡ºï¼š\")\n                print(\"-\" * 60)\n                \n                token_count = 0\n                full_response = \"\"\n                \n                async for event in agent.execute_stream(\n                    prompt_source={'use_agent_default': True},\n                    user_input=\"ä½ å¥½\",\n                    context={'session_id': 'test', 'user_id': 'test_user'}\n                ):\n                    if event['type'] == 'token':\n                        content = event['content']\n                        full_response += content\n                        print(content, end='', flush=True)\n                        token_count += 1\n                    elif event['type'] == 'metadata':\n                        data = event['data']\n                        if data.get('status') == 'started':\n                            print(\"[æµå¼å¼€å§‹]\")\n                        elif data.get('done'):\n                            print(f\"\\n[æµå¼å®Œæˆ]\")\n                    elif event['type'] == 'error':\n                        print(f\"\\n[é”™è¯¯] {event['error']}\")\n                \n                print(\"-\" * 60)\n                print(f\"\\nâœ… æµå¼è¾“å‡ºæµ‹è¯•å®Œæˆ\")\n                print(f\"   æ¥æ”¶tokenæ•°: {token_count}\")\n                print(f\"   å®Œæ•´å“åº”: {full_response}\")\n\n\nasync def test_stream_with_tools_fallback():\n    \"\"\"æµ‹è¯•å¸¦å·¥å…·çš„æµå¼è¾“å‡ºï¼ˆåº”è¯¥é™çº§åˆ°æ™®é€šæ¨¡å¼ï¼‰\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šå¸¦å·¥å…·çš„æµå¼è¾“å‡ºï¼ˆé™çº§ï¼‰\")\n    print(\"=\"*60)\n    \n    config = AgentConfig(\n        name=\"test_agent\",\n        description=\"æµ‹è¯•Agent\",\n        model=\"qwen-turbo\",\n        temperature=0.7,\n        system_prompt=\"You are a helpful assistant.\"\n    )\n    agent = BaseAgent(config)\n    \n    with patch.object(agent.memory, 'load_context_smart', new_callable=AsyncMock) as mock_load:\n        mock_load.return_value = {\n            'history': [],\n            'strategy': 'new_conversation',\n            'cost': 0,\n            'filtered': False\n        }\n        \n        with patch.object(agent.memory, 'is_followup', new_callable=AsyncMock) as mock_followup:\n            mock_followup.return_value = (False, 0.0, \"æ–°å¯¹è¯\")\n            \n            # Mock executeæ–¹æ³•ï¼ˆæ™®é€šæ¨¡å¼ï¼‰\n            from daoyoucode.agents.core.agent import AgentResult\n            mock_result = AgentResult(\n                success=True,\n                content=\"è¿™æ˜¯æ™®é€šæ¨¡å¼çš„å“åº”\",\n                metadata={'agent': 'test_agent'},\n                tools_used=['test_tool']\n            )\n            \n            with patch.object(agent, 'execute', new_callable=AsyncMock) as mock_execute:\n                mock_execute.return_value = mock_result\n                \n                print(\"\\nå°è¯•æµå¼è¾“å‡ºï¼ˆå¸¦å·¥å…·ï¼‰ï¼š\")\n                print(\"-\" * 60)\n  "
},
{
"path": "tests/test_task_manager.py",
"start": 1,
"end": 260,
"text": "\"\"\"\næµ‹è¯•TaskManager\n\"\"\"\n\nimport asyncio\nfrom daoyoucode.agents.core.task import get_task_manager, TaskStatus\n\n\nasync def test_task_creation():\n    \"\"\"æµ‹è¯•ä»»åŠ¡åˆ›å»º\"\"\"\n    print(\"\\n=== æµ‹è¯•1: ä»»åŠ¡åˆ›å»º ===\")\n    \n    task_manager = get_task_manager()\n    \n    # åˆ›å»ºä»»åŠ¡\n    task = task_manager.create_task(\n        description=\"åˆ†æä»£ç ç»“æ„\",\n        orchestrator=\"parallel_explore\",\n        agent=\"code_analyzer\"\n    )\n    \n    print(f\"âœ“ åˆ›å»ºä»»åŠ¡: {task.id}\")\n    print(f\"  æè¿°: {task.description}\")\n    print(f\"  çŠ¶æ€: {task.status.value}\")\n    print(f\"  ç¼–æ’å™¨: {task.orchestrator}\")\n    print(f\"  Agent: {task.agent}\")\n    \n    assert task.status == TaskStatus.PENDING\n    assert task.orchestrator == \"parallel_explore\"\n    assert task.agent == \"code_analyzer\"\n\n\nasync def test_task_status_update():\n    \"\"\"æµ‹è¯•ä»»åŠ¡çŠ¶æ€æ›´æ–°\"\"\"\n    print(\"\\n=== æµ‹è¯•2: ä»»åŠ¡çŠ¶æ€æ›´æ–° ===\")\n    \n    task_manager = get_task_manager()\n    \n    # åˆ›å»ºä»»åŠ¡\n    task = task_manager.create_task(\n        description=\"é‡æ„å‡½æ•°\",\n        orchestrator=\"workflow\"\n    )\n    \n    print(f\"âœ“ åˆ›å»ºä»»åŠ¡: {task.id}\")\n    print(f\"  åˆå§‹çŠ¶æ€: {task.status.value}\")\n    \n    # æ›´æ–°ä¸ºè¿è¡Œä¸­\n    task_manager.update_status(task.id, TaskStatus.RUNNING)\n    print(f\"  æ›´æ–°çŠ¶æ€: {task.status.value}\")\n    assert task.status == TaskStatus.RUNNING\n    assert task.started_at is not None\n    \n    # æ¨¡æ‹Ÿæ‰§è¡Œ\n    await asyncio.sleep(0.1)\n    \n    # æ›´æ–°ä¸ºå®Œæˆ\n    task_manager.update_status(\n        task.id,\n        TaskStatus.COMPLETED,\n        result=\"é‡æ„å®Œæˆ\"\n    )\n    print(f\"  æœ€ç»ˆçŠ¶æ€: {task.status.value}\")\n    print(f\"  ç»“æœ: {task.result}\")\n    \n    assert task.status == TaskStatus.COMPLETED\n    assert task.completed_at is not None\n    assert task.result == \"é‡æ„å®Œæˆ\"\n    \n    # è®¡ç®—æ‰§è¡Œæ—¶é•¿\n    duration = task_manager.get_task_duration(task.id)\n    print(f\"  æ‰§è¡Œæ—¶é•¿: {duration:.3f}ç§’\")\n    assert duration is not None\n    assert duration > 0\n\n\nasync def test_task_hierarchy():\n    \"\"\"æµ‹è¯•ä»»åŠ¡å±‚æ¬¡ç»“æ„\"\"\"\n    print(\"\\n=== æµ‹è¯•3: ä»»åŠ¡å±‚æ¬¡ç»“æ„ ===\")\n    \n    task_manager = get_task_manager()\n    \n    # åˆ›å»ºçˆ¶ä»»åŠ¡\n    parent = task_manager.create_task(\n        description=\"å®Œæ•´çš„ä»£ç é‡æ„\",\n        orchestrator=\"workflow\"\n    )\n    \n    print(f\"âœ“ åˆ›å»ºçˆ¶ä»»åŠ¡: {parent.id}\")\n    \n    # åˆ›å»ºå­ä»»åŠ¡\n    subtask1 = task_manager.create_task(\n        description=\"åˆ†æä»£ç \",\n        orchestrator=\"simple\",\n        parent_id=parent.id\n    )\n    \n    subtask2 = task_manager.create_task(\n        description=\"ç”Ÿæˆé‡æ„è®¡åˆ’\",\n        orchestrator=\"simple\",\n        parent_id=parent.id\n    )\n    \n    subtask3 = task_manager.create_task(\n        description=\"æ‰§è¡Œé‡æ„\",\n        orchestrator=\"simple\",\n        parent_id=parent.id\n    )\n    \n    print(f\"  å­ä»»åŠ¡1: {subtask1.id}\")\n    print(f\"  å­ä»»åŠ¡2: {subtask2.id}\")\n    print(f\"  å­ä»»åŠ¡3: {subtask3.id}\")\n    \n    # éªŒè¯çˆ¶å­å…³ç³»\n    assert len(parent.subtasks) == 3\n    assert subtask1.parent_id == parent.id\n    assert subtask2.parent_id == parent.id\n    assert subtask3.parent_id == parent.id\n    \n    # è·å–ä»»åŠ¡æ ‘\n    tree = task_manager.get_task_tree(parent.id)\n    print(f\"\\nä»»åŠ¡æ ‘:\")\n    print(f\"  æ ¹ä»»åŠ¡: {tree['description']}\")\n    print(f\"  å­ä»»åŠ¡æ•°: {len(tree['subtasks'])}\")\n    \n    for i, st in enumerate(tree['subtasks'], 1):\n        print(f\"    {i}. {st['description']}\")\n    \n    assert len(tree['subtasks']) == 3\n\n\nasync def test_task_queries():\n    \"\"\"æµ‹è¯•ä»»åŠ¡æŸ¥è¯¢\"\"\"\n    print(\"\\n=== æµ‹è¯•4: ä»»åŠ¡æŸ¥è¯¢ ===\")\n    \n    task_manager = get_task_manager()\n    \n    # æ¸…ç†ä¹‹å‰çš„ä»»åŠ¡\n    task_manager.clear_completed()\n    \n    # åˆ›å»ºå¤šä¸ªä»»åŠ¡\n    task1 = task_manager.create_task(\n        description=\"æŸ¥è¯¢æµ‹è¯•ä»»åŠ¡1\",\n        orchestrator=\"simple\",\n        agent=\"agent1\"\n    )\n    \n    task2 = task_manager.create_task(\n        description=\"æŸ¥è¯¢æµ‹è¯•ä»»åŠ¡2\",\n        orchestrator=\"workflow\",\n        agent=\"agent2\"\n    )\n    \n    task3 = task_manager.create_task(\n        description=\"æŸ¥è¯¢æµ‹è¯•ä»»åŠ¡3\",\n        orchestrator=\"simple\",\n        agent=\"agent1\"\n    )\n    \n    # æ›´æ–°çŠ¶æ€\n    task_manager.update_status(task1.id, TaskStatus.RUNNING)\n    task_manager.update_status(task2.id, TaskStatus.COMPLETED, result=\"å®Œæˆ\")\n    \n    # æŸ¥è¯¢æ´»è·ƒä»»åŠ¡ï¼ˆåªåŒ…å«è¿™3ä¸ªä»»åŠ¡ä¸­çš„æ´»è·ƒä»»åŠ¡ï¼‰\n    active = task_manager.get_active_tasks()\n    print(f\"âœ“ æ´»è·ƒä»»åŠ¡æ•°: "
},
{
"path": "tests/test_temp.py",
"start": 1,
"end": 1,
"text": "# TODO: Add code here"
},
{
"path": "tests/test_timeout_integration.py",
"start": 1,
"end": 287,
"text": "\"\"\"\næµ‹è¯•è¶…æ—¶æ¢å¤é›†æˆåˆ° executor\n\"\"\"\n\nimport asyncio\nimport logging\nfrom unittest.mock import AsyncMock, patch, MagicMock\nfrom daoyoucode.agents.executor import execute_skill\nfrom daoyoucode.agents.llm.exceptions import LLMTimeoutError\n\n# é…ç½®æ—¥å¿—\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nlogger = logging.getLogger(__name__)\n\n\nasync def test_timeout_recovery_integration():\n    \"\"\"æµ‹è¯•è¶…æ—¶æ¢å¤é›†æˆ\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•: è¶…æ—¶æ¢å¤é›†æˆåˆ° executor\")\n    print(\"=\"*60)\n    \n    # Mock skill loader\n    mock_skill = MagicMock()\n    mock_skill.name = \"test-skill\"\n    mock_skill.orchestrator = \"react\"\n    mock_skill.agent = \"test-agent\"\n    \n    # Mock orchestrator\n    mock_orchestrator = MagicMock()\n    \n    # æ¨¡æ‹Ÿç¬¬ä¸€æ¬¡è¶…æ—¶ï¼Œç¬¬äºŒæ¬¡æˆåŠŸ\n    call_count = [0]\n    \n    async def mock_execute(skill, user_input, context):\n        call_count[0] += 1\n        if call_count[0] == 1:\n            raise LLMTimeoutError(\"æ¨¡æ‹Ÿè¶…æ—¶\")\n        return {\n            'success': True,\n            'content': 'æˆåŠŸå“åº”',\n            'error': None\n        }\n    \n    mock_orchestrator.execute = mock_execute\n    \n    with patch('daoyoucode.agents.executor.get_skill_loader') as mock_get_skill_loader, \\\n         patch('daoyoucode.agents.executor.get_orchestrator') as mock_get_orchestrator, \\\n         patch('daoyoucode.agents.executor.get_hook_manager') as mock_get_hook_manager, \\\n         patch('daoyoucode.agents.executor.get_task_manager') as mock_get_task_manager:\n        \n        # è®¾ç½® mocks\n        mock_skill_loader = MagicMock()\n        mock_skill_loader.get_skill.return_value = mock_skill\n        mock_get_skill_loader.return_value = mock_skill_loader\n        \n        mock_get_orchestrator.return_value = mock_orchestrator\n        \n        # Mock hook manager - æ·»åŠ æ‰€æœ‰éœ€è¦çš„æ–¹æ³•\n        mock_hook_mgr = MagicMock()\n        \n        async def mock_run_before_hooks(ctx):\n            return ctx\n        \n        async def mock_run_after_hooks(ctx, result):\n            return result\n        \n        async def mock_run_error_hooks(ctx, error):\n            return None\n        \n        mock_hook_mgr.run_before_hooks = mock_run_before_hooks\n        mock_hook_mgr.run_after_hooks = mock_run_after_hooks\n        mock_hook_mgr.run_error_hooks = mock_run_error_hooks\n        mock_get_hook_manager.return_value = mock_hook_mgr\n        \n        # Mock task manager\n        mock_task_mgr = MagicMock()\n        mock_task = MagicMock()\n        mock_task.id = \"test-task-123\"\n        mock_task_mgr.create_task.return_value = mock_task\n        mock_get_task_manager.return_value = mock_task_mgr\n        \n        # æ‰§è¡Œæµ‹è¯•\n        result = await execute_skill(\n            skill_name=\"test-skill\",\n            user_input=\"æµ‹è¯•è¾“å…¥\",\n            context={'test': True},\n            enable_timeout_recovery=True\n        )\n        \n        print(f\"\\næ‰§è¡Œç»“æœ:\")\n        print(f\"  æˆåŠŸ: {result.get('success')}\")\n        print(f\"  å†…å®¹: {result.get('content')}\")\n        print(f\"  é”™è¯¯: {result.get('error')}\")\n        print(f\"  è°ƒç”¨æ¬¡æ•°: {call_count[0]}\")\n        \n        if result.get('success') and call_count[0] == 2:\n            print(\"\\nâœ… æµ‹è¯•é€šè¿‡ï¼šè¶…æ—¶æ¢å¤æˆåŠŸ\")\n            return True\n        else:\n            print(\"\\nâŒ æµ‹è¯•å¤±è´¥\")\n            return False\n\n\nasync def test_timeout_recovery_disabled():\n    \"\"\"æµ‹è¯•ç¦ç”¨è¶…æ—¶æ¢å¤\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•: ç¦ç”¨è¶…æ—¶æ¢å¤\")\n    print(\"=\"*60)\n    \n    # Mock skill loader\n    mock_skill = MagicMock()\n    mock_skill.name = \"test-skill\"\n    mock_skill.orchestrator = \"react\"\n    mock_skill.agent = \"test-agent\"\n    \n    # Mock orchestrator - æ€»æ˜¯è¶…æ—¶\n    mock_orchestrator = MagicMock()\n    \n    async def mock_execute(skill, user_input, context):\n        raise LLMTimeoutError(\"æ¨¡æ‹Ÿè¶…æ—¶\")\n    \n    mock_orchestrator.execute = mock_execute\n    \n    with patch('daoyoucode.agents.executor.get_skill_loader') as mock_get_skill_loader, \\\n         patch('daoyoucode.agents.executor.get_orchestrator') as mock_get_orchestrator, \\\n         patch('daoyoucode.agents.executor.get_hook_"
},
{
"path": "tests/test_timeout_recovery.py",
"start": 1,
"end": 216,
"text": "\"\"\"\næµ‹è¯•è¶…æ—¶æ¢å¤ç­–ç•¥\n\"\"\"\n\nimport asyncio\nimport logging\nfrom daoyoucode.agents.core.timeout_recovery import (\n    TimeoutRecoveryStrategy,\n    TimeoutRecoveryConfig,\n    get_user_friendly_timeout_message\n)\nfrom daoyoucode.agents.llm.exceptions import LLMTimeoutError\n\n# é…ç½®æ—¥å¿—\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nlogger = logging.getLogger(__name__)\n\n\n# æ¨¡æ‹Ÿå‡½æ•°\nasync def mock_llm_call_always_timeout():\n    \"\"\"æ¨¡æ‹Ÿæ€»æ˜¯è¶…æ—¶çš„ LLM è°ƒç”¨\"\"\"\n    await asyncio.sleep(0.1)\n    raise LLMTimeoutError(\"æ¨¡æ‹Ÿè¶…æ—¶\")\n\n\nasync def mock_llm_call_timeout_then_success(attempt_count: list):\n    \"\"\"æ¨¡æ‹Ÿå‰å‡ æ¬¡è¶…æ—¶ï¼Œæœ€åæˆåŠŸçš„ LLM è°ƒç”¨\"\"\"\n    attempt_count[0] += 1\n    \n    if attempt_count[0] < 3:\n        await asyncio.sleep(0.1)\n        raise LLMTimeoutError(f\"æ¨¡æ‹Ÿè¶…æ—¶ï¼ˆç¬¬ {attempt_count[0]} æ¬¡ï¼‰\")\n    \n    return {\"success\": True, \"content\": \"æˆåŠŸå“åº”\"}\n\n\nasync def test_timeout_recovery_all_fail():\n    \"\"\"æµ‹è¯•æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥çš„æƒ…å†µ\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•1: æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥\")\n    print(\"=\"*60)\n    \n    config = TimeoutRecoveryConfig(\n        max_retries=3,\n        initial_timeout=60.0,\n        retry_delay=0.5  # ç¼©çŸ­å»¶è¿Ÿä»¥åŠ å¿«æµ‹è¯•\n    )\n    \n    strategy = TimeoutRecoveryStrategy(config)\n    \n    try:\n        result = await strategy.execute_with_timeout_recovery(\n            mock_llm_call_always_timeout\n        )\n        print(\"âŒ æµ‹è¯•å¤±è´¥ï¼šåº”è¯¥æŠ›å‡º LLMTimeoutError\")\n    except LLMTimeoutError as e:\n        print(f\"âœ… æµ‹è¯•é€šè¿‡ï¼šæ­£ç¡®æŠ›å‡ºè¶…æ—¶é”™è¯¯\")\n        print(f\"   é”™è¯¯æ¶ˆæ¯: {e}\")\n        print(f\"   é‡è¯•æ¬¡æ•°: {strategy.retry_count}\")\n        \n        # æµ‹è¯•ç”¨æˆ·å‹å¥½æ¶ˆæ¯\n        friendly_message = get_user_friendly_timeout_message(strategy.retry_count)\n        print(f\"\\nç”¨æˆ·å‹å¥½æ¶ˆæ¯:\\n{friendly_message}\")\n\n\nasync def test_timeout_recovery_eventually_success():\n    \"\"\"æµ‹è¯•æœ€ç»ˆæˆåŠŸçš„æƒ…å†µ\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•2: å‰å‡ æ¬¡è¶…æ—¶ï¼Œæœ€åæˆåŠŸ\")\n    print(\"=\"*60)\n    \n    config = TimeoutRecoveryConfig(\n        max_retries=3,\n        initial_timeout=60.0,\n        retry_delay=0.5\n    )\n    \n    strategy = TimeoutRecoveryStrategy(config)\n    attempt_count = [0]\n    \n    try:\n        result = await strategy.execute_with_timeout_recovery(\n            mock_llm_call_timeout_then_success,\n            attempt_count\n        )\n        print(f\"âœ… æµ‹è¯•é€šè¿‡ï¼šæœ€ç»ˆæˆåŠŸ\")\n        print(f\"   ç»“æœ: {result}\")\n        print(f\"   æ€»å°è¯•æ¬¡æ•°: {attempt_count[0]}\")\n        print(f\"   é‡è¯•æ¬¡æ•°: {strategy.retry_count}\")\n    except LLMTimeoutError as e:\n        print(f\"âŒ æµ‹è¯•å¤±è´¥ï¼šä¸åº”è¯¥æŠ›å‡ºé”™è¯¯\")\n        print(f\"   é”™è¯¯: {e}\")\n\n\nasync def test_prompt_simplification():\n    \"\"\"æµ‹è¯• prompt ç®€åŒ–\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•3: Prompt ç®€åŒ–\")\n    print(\"=\"*60)\n    \n    strategy = TimeoutRecoveryStrategy()\n    \n    # åˆ›å»ºä¸€ä¸ªé•¿ prompt\n    long_prompt = \"\\n\".join([f\"Line {i}: Some content here\" for i in range(100)])\n    print(f\"åŸå§‹ prompt é•¿åº¦: {len(long_prompt)} å­—ç¬¦, {len(long_prompt.split(chr(10)))} è¡Œ\")\n    \n    # ç®€åŒ–\n    simplified = strategy._simplify_prompt(long_prompt)\n    print(f\"ç®€åŒ–å prompt é•¿åº¦: {len(simplified)} å­—ç¬¦, {len(simplified.split(chr(10)))} è¡Œ\")\n    print(f\"å‹ç¼©ç‡: {(1 - len(simplified) / len(long_prompt)) * 100:.1f}%\")\n    \n    # çŸ­ prompt ä¸åº”è¯¥è¢«ç®€åŒ–\n    short_prompt = \"\\n\".join([f\"Line {i}\" for i in range(30)])\n    simplified_short = strategy._simplify_prompt(short_prompt)\n    \n    if simplified_short == short_prompt:\n        print(\"âœ… çŸ­ prompt ä¸è¢«ç®€åŒ–\")\n    else:\n        print(\"âŒ çŸ­ prompt è¢«é”™è¯¯ç®€åŒ–\")\n\n\nasync def test_fallback_model():\n    \"\"\"æµ‹è¯•å¤‡ç”¨æ¨¡å‹\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•4: å¤‡ç”¨æ¨¡å‹\")\n    print(\"=\"*60)\n    \n    strategy = TimeoutRecoveryStrategy()\n    \n    test_cases = [\n        ('qwen-max', 'qwen-plus'),\n        ('qwen-plus', 'qwen-turbo'),\n        ('gpt-4', 'gpt-3.5-turbo'),\n        ('deepseek-coder', 'deepseek-chat'),\n        ('unknown-model', None),\n    ]\n    \n    for original, expected in test_cases:\n        fallback = strategy._get_fallback_model(original)\n        if fallback == expected:\n            print(f\"âœ… {original} â†’ {fallback}\")\n        else:\n            print(f\"âŒ {original} â†’ {fallback} (æœŸæœ›: {expected})\")\n\n\nasync def test_recovery_strategy_ap"
},
{
"path": "tests/test_tools.py",
"start": 1,
"end": 12,
"text": "\"\"\"\næµ‹è¯•å·¥å…·æ³¨å†Œ\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents.tools import get_tool_registry\n"
},
{
"path": "tests/test_tools.py",
"start": 13,
"end": 65,
"text": "def test_tools():\n    print(\"=\"*60)\n    print(\"æµ‹è¯•å·¥å…·æ³¨å†Œ\")\n    print(\"=\"*60)\n    \n    # è·å–å·¥å…·æ³¨å†Œè¡¨\n    tool_registry = get_tool_registry()\n    \n    # åˆ—å‡ºæ‰€æœ‰å·¥å…·\n    tools = tool_registry.list_tools()\n    print(f\"\\nâœ“ å·²æ³¨å†Œ {len(tools)} ä¸ªå·¥å…·:\")\n    for tool in sorted(tools):\n        print(f\"  â€¢ {tool}\")\n    \n    # æ£€æŸ¥å…³é”®å·¥å…·\n    key_tools = [\n        \"repo_map\",\n        \"get_repo_structure\", \n        \"read_file\",\n        \"write_file\",\n        \"list_files\",\n        \"text_search\",\n        \"regex_search\"\n    ]\n    \n    print(f\"\\næ£€æŸ¥å…³é”®å·¥å…·:\")\n    for tool_name in key_tools:\n        if tool_name in tools:\n            print(f\"  âœ“ {tool_name}\")\n        else:\n            print(f\"  âœ— {tool_name} - æœªæ‰¾åˆ°\")\n    \n    # è·å–repo_mapçš„schema\n    print(f\"\\nrepo_mapå·¥å…·çš„schema:\")\n    tool = tool_registry.get_tool(\"repo_map\")\n    if tool:\n        schema = tool.get_function_schema()\n        print(f\"  â€¢ åç§°: {schema['name']}\")\n        print(f\"  â€¢ æè¿°: {schema['description']}\")\n        print(f\"  â€¢ å‚æ•°: {list(schema['parameters']['properties'].keys())}\")\n    else:\n        print(\"  âœ— repo_mapå·¥å…·æœªæ‰¾åˆ°\")\n    \n    return len(tools) > 0\n\nif __name__ == \"__main__\":\n    success = test_tools()\n    print(\"\\n\" + \"=\"*60)\n    if success:\n        print(\"âœ… å·¥å…·æ³¨å†Œæµ‹è¯•é€šè¿‡\")\n    else:\n        print(\"âŒ å·¥å…·æ³¨å†Œæµ‹è¯•å¤±è´¥\")\n    print(\"=\"*60)"
},
{
"path": "tests/test_tool_display.py",
"start": 1,
"end": 87,
"text": "\"\"\"\næµ‹è¯•å·¥å…·æ˜¾ç¤ºUI\n\"\"\"\n\nimport asyncio\nimport time\nfrom daoyoucode.agents.ui import get_tool_display\n\n\nasync def test_tool_display():\n    \"\"\"æµ‹è¯•å·¥å…·æ˜¾ç¤º\"\"\"\n    display = get_tool_display()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•å·¥å…·æ˜¾ç¤ºUI\")\n    print(\"=\"*60)\n    \n    # æµ‹è¯•1: æˆåŠŸçš„å·¥å…·æ‰§è¡Œ\n    print(\"\\næµ‹è¯•1: æˆåŠŸçš„å·¥å…·æ‰§è¡Œ\")\n    tool_name = \"repo_map\"\n    args = {\n        'repo_path': '/path/to/repo',\n        'chat_files': ['file1.py', 'file2.py'],\n        'mentioned_idents': ['MyClass', 'my_function']\n    }\n    \n    display.show_tool_start(tool_name, args)\n    \n    with display.show_progress(tool_name) as progress:\n        task = progress.add_task(f\"æ­£åœ¨æ‰§è¡Œ {tool_name}...\", total=100)\n        \n        # æ¨¡æ‹Ÿå·¥ä½œ\n        await asyncio.sleep(0.5)\n        progress.update(task, advance=30, description=\"åˆ†ææ–‡ä»¶ç»“æ„...\")\n        \n        await asyncio.sleep(0.5)\n        progress.update(task, advance=40, description=\"ç”Ÿæˆä»£ç åœ°å›¾...\")\n        \n        await asyncio.sleep(0.5)\n        progress.update(task, advance=30, description=\"å®Œæˆ\")\n    \n    display.show_success(tool_name, 1.5)\n    \n    # æµ‹è¯•2: å¤±è´¥çš„å·¥å…·æ‰§è¡Œ\n    print(\"\\næµ‹è¯•2: å¤±è´¥çš„å·¥å…·æ‰§è¡Œ\")\n    tool_name = \"search_files\"\n    args = {'pattern': '*.py', 'path': '/invalid/path'}\n    \n    display.show_tool_start(tool_name, args)\n    \n    with display.show_progress(tool_name) as progress:\n        task = progress.add_task(f\"æ­£åœ¨æ‰§è¡Œ {tool_name}...\", total=100)\n        await asyncio.sleep(0.3)\n        progress.update(task, advance=50)\n    \n    error = FileNotFoundError(\"è·¯å¾„ä¸å­˜åœ¨: /invalid/path\")\n    display.show_error(tool_name, error, 0.3)\n    \n    # æµ‹è¯•3: è­¦å‘Š\n    print(\"\\næµ‹è¯•3: è­¦å‘Šä¿¡æ¯\")\n    display.show_warning(\"read_file\", \"æ–‡ä»¶å†…å®¹è¿‡å¤§ï¼Œå·²æˆªæ–­\")\n    \n    # æµ‹è¯•4: ç»“æœé¢„è§ˆ\n    print(\"\\næµ‹è¯•4: ç»“æœé¢„è§ˆ\")\n    result = \"\"\"# ä»£ç åœ°å›¾\n\n## æ–‡ä»¶1: main.py\n- class MyClass\n- def my_function()\n\n## æ–‡ä»¶2: utils.py\n- def helper()\n- def process()\n\n## æ–‡ä»¶3: config.py\n- CONFIG = {}\n- def load_config()\n\"\"\"\n    display.show_result_preview(result, max_lines=5)\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"âœ“ æµ‹è¯•å®Œæˆ\")\n    print(\"=\"*60)\n\n\nif __name__ == '__main__':\n    asyncio.run(test_tool_display())"
},
{
"path": "tests/test_tool_history_optimization.py",
"start": 1,
"end": 257,
"text": "\"\"\"\næµ‹è¯•å·¥å…·è°ƒç”¨å†å²ä¼ é€’ä¼˜åŒ–\n\néªŒè¯å†å²æˆªæ–­æ˜¯å¦æ­£ç¡®å·¥ä½œï¼Œä»¥åŠtokenèŠ‚çœæ•ˆæœ\n\"\"\"\n\nimport asyncio\nfrom unittest.mock import Mock, AsyncMock, patch\nfrom daoyoucode.agents.core.agent import BaseAgent, AgentConfig\n\n\nasync def test_history_truncation():\n    \"\"\"æµ‹è¯•å†å²æˆªæ–­åŠŸèƒ½\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šå·¥å…·è°ƒç”¨å†å²æˆªæ–­\")\n    print(\"=\"*60)\n    \n    # åˆ›å»ºAgent\n    config = AgentConfig(\n        name=\"test_agent\",\n        description=\"æµ‹è¯•Agent\",\n        model=\"gpt-4\",\n        temperature=0.7,\n        system_prompt=\"You are a helpful assistant.\"\n    )\n    agent = BaseAgent(config)\n    \n    # æ¨¡æ‹Ÿé•¿å¯¹è¯å†å²ï¼ˆ10è½®ï¼‰\n    long_history = []\n    for i in range(10):\n        long_history.append({\n            'user': f'ç”¨æˆ·é—®é¢˜ {i+1}',\n            'ai': f'AIå›ç­” {i+1}'\n        })\n    \n    print(f\"\\nåŸå§‹å†å²: {len(long_history)} è½®å¯¹è¯\")\n    \n    # Mock memory manager\n    with patch.object(agent.memory, 'load_context_smart', new_callable=AsyncMock) as mock_load:\n        mock_load.return_value = {\n            'history': long_history,\n            'strategy': 'test',\n            'cost': 10,\n            'filtered': False\n        }\n        \n        # Mock LLMè°ƒç”¨\n        with patch.object(agent, '_call_llm_with_tools', new_callable=AsyncMock) as mock_llm:\n            mock_llm.return_value = (\"æµ‹è¯•å“åº”\", [])\n            \n            # æ‰§è¡Œ\n            await agent.execute(\n                prompt_source={'use_agent_default': True},\n                user_input=\"æµ‹è¯•é—®é¢˜\",\n                context={'session_id': 'test', 'user_id': 'test_user'},\n                tools=['test_tool']\n            )\n            \n            # æ£€æŸ¥ä¼ é€’ç»™LLMçš„æ¶ˆæ¯\n            call_args = mock_llm.call_args\n            initial_messages = call_args[0][0]  # ç¬¬ä¸€ä¸ªä½ç½®å‚æ•°\n            \n            # è®¡ç®—å®é™…ä¼ é€’çš„å†å²è½®æ•°\n            # æ¯è½®å¯¹è¯ = 1æ¡useræ¶ˆæ¯ + 1æ¡assistantæ¶ˆæ¯\n            # æœ€åè¿˜æœ‰1æ¡å½“å‰useræ¶ˆæ¯\n            history_messages = [m for m in initial_messages if m['role'] in ['user', 'assistant']]\n            actual_rounds = (len(history_messages) - 1) // 2  # å‡å»å½“å‰è½®\n            \n            print(f\"\\nä¼ é€’ç»™LLMçš„æ¶ˆæ¯æ•°: {len(initial_messages)}\")\n            print(f\"å†å²è½®æ•°: {actual_rounds} è½®\")\n            print(f\"å½“å‰è½®: 1 è½®\")\n            \n            # éªŒè¯æˆªæ–­\n            MAX_HISTORY_ROUNDS = 5\n            if actual_rounds <= MAX_HISTORY_ROUNDS:\n                print(f\"\\nâœ… å†å²æˆªæ–­æˆåŠŸï¼\")\n                print(f\"   åŸå§‹: {len(long_history)} è½®\")\n                print(f\"   æˆªæ–­å: {actual_rounds} è½®\")\n                print(f\"   èŠ‚çœ: {len(long_history) - actual_rounds} è½®\")\n                \n                # ä¼°ç®—tokenèŠ‚çœ\n                # å‡è®¾æ¯è½®å¯¹è¯å¹³å‡100 tokens\n                tokens_saved = (len(long_history) - actual_rounds) * 100\n                print(f\"   ä¼°ç®—èŠ‚çœtoken: ~{tokens_saved} tokens\")\n            else:\n                print(f\"\\nâŒ å†å²æˆªæ–­å¤±è´¥ï¼å®é™…ä¼ é€’äº† {actual_rounds} è½®\")\n\n\nasync def test_short_history_no_truncation():\n    \"\"\"æµ‹è¯•çŸ­å†å²ä¸æˆªæ–­\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šçŸ­å†å²ä¸æˆªæ–­\")\n    print(\"=\"*60)\n    \n    config = AgentConfig(\n        name=\"test_agent\",\n        description=\"æµ‹è¯•Agent\",\n        model=\"gpt-4\",\n        temperature=0.7,\n        system_prompt=\"You are a helpful assistant.\"\n    )\n    agent = BaseAgent(config)\n    \n    # æ¨¡æ‹ŸçŸ­å¯¹è¯å†å²ï¼ˆ3è½®ï¼‰\n    short_history = []\n    for i in range(3):\n        short_history.append({\n            'user': f'ç”¨æˆ·é—®é¢˜ {i+1}',\n            'ai': f'AIå›ç­” {i+1}'\n        })\n    \n    print(f\"\\nåŸå§‹å†å²: {len(short_history)} è½®å¯¹è¯\")\n    \n    with patch.object(agent.memory, 'load_context_smart', new_callable=AsyncMock) as mock_load:\n        mock_load.return_value = {\n            'history': short_history,\n            'strategy': 'test',\n            'cost': 3,\n            'filtered': False\n        }\n        \n        with patch.object(agent, '_call_llm_with_tools', new_callable=AsyncMock) as mock_llm:\n            mock_llm.return_value = (\"æµ‹è¯•å“åº”\", [])\n            \n            await agent.execute(\n                prompt_source={'use_agent_default': True},\n                user_input=\"æµ‹è¯•é—®é¢˜\",\n                context={'session_id': 'test', 'user_id': 'test_user'},\n                tools=['test_tool']\n            )\n     "
},
{
"path": "tests/test_tool_names.py",
"start": 1,
"end": 117,
"text": "\"\"\"\næµ‹è¯•å·¥å…·åç§°æ˜¯å¦æ­£ç¡®\n\"\"\"\n\nimport asyncio\nfrom daoyoucode.agents.tools.registry import get_tool_registry\n\n\nasync def test_tool_names():\n    \"\"\"æµ‹è¯•æ‰€æœ‰å·¥å…·åç§°\"\"\"\n    import os\n    \n    registry = get_tool_registry()\n    \n    # è®¾ç½®å·¥ä½œç›®å½•ä¸ºé¡¹ç›®æ ¹ç›®å½•\n    project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    registry.set_working_directory(project_root)\n    print(f\"å·¥ä½œç›®å½•: {project_root}\\n\")\n    \n    print(\"=\" * 60)\n    print(\"å·²æ³¨å†Œçš„å·¥å…·åˆ—è¡¨\")\n    print(\"=\" * 60)\n    \n    tools = registry.list_tools()\n    for i, tool_name in enumerate(tools, 1):\n        print(f\"{i:2d}. {tool_name}\")\n    \n    print(f\"\\næ€»è®¡: {len(tools)} ä¸ªå·¥å…·\")\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"éªŒè¯å…³é”®å·¥å…·\")\n    print(\"=\" * 60)\n    \n    # éªŒè¯å…³é”®å·¥å…·å­˜åœ¨\n    critical_tools = [\n        \"text_search\",      # ä¸æ˜¯ grep_search\n        \"list_files\",       # ä¸æ˜¯ list_directory\n        \"read_file\",\n        \"write_file\",\n        \"repo_map\",\n        \"get_repo_structure\",\n        \"discover_project_docs\",\n    ]\n    \n    for tool_name in critical_tools:\n        exists = tool_name in tools\n        status = \"âœ…\" if exists else \"âŒ\"\n        print(f\"{status} {tool_name}\")\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•å·¥å…·è°ƒç”¨\")\n    print(\"=\" * 60)\n    \n    # æµ‹è¯• text_search\n    print(\"\\n1. æµ‹è¯• text_search\")\n    try:\n        result = await registry.execute_tool(\n            \"text_search\",\n            query=\"class BaseAgent\",\n            directory=\".\",\n            file_pattern=\"**/*.py\",\n            max_results=5\n        )\n        if result.success:\n            print(\"   âœ… text_search è°ƒç”¨æˆåŠŸ\")\n            lines = result.content.split('\\n')[:3]\n            for line in lines:\n                print(f\"   {line}\")\n        else:\n            print(f\"   âŒ text_search è°ƒç”¨å¤±è´¥: {result.error}\")\n    except Exception as e:\n        print(f\"   âŒ text_search å¼‚å¸¸: {e}\")\n    \n    # æµ‹è¯• list_files\n    print(\"\\n2. æµ‹è¯• list_files\")\n    try:\n        result = await registry.execute_tool(\n            \"list_files\",\n            directory=\"skills/chat-assistant/prompts\",\n            pattern=\"*.md\",\n            recursive=False\n        )\n        if result.success:\n            print(\"   âœ… list_files è°ƒç”¨æˆåŠŸ\")\n            print(f\"   æ‰¾åˆ° {len(result.content)} ä¸ªæ–‡ä»¶\")\n            for file in result.content[:3]:\n                print(f\"   - {file['name']}\")\n        else:\n            print(f\"   âŒ list_files è°ƒç”¨å¤±è´¥: {result.error}\")\n    except Exception as e:\n        print(f\"   âŒ list_files å¼‚å¸¸: {e}\")\n    \n    # æµ‹è¯• read_file\n    print(\"\\n3. æµ‹è¯• read_file\")\n    try:\n        result = await registry.execute_tool(\n            \"read_file\",\n            file_path=\"skills/chat-assistant/skill.yaml\",\n            encoding=\"utf-8\"\n        )\n        if result.success:\n            print(\"   âœ… read_file è°ƒç”¨æˆåŠŸ\")\n            lines = result.content.split('\\n')[:5]\n            for line in lines:\n                print(f\"   {line}\")\n        else:\n            print(f\"   âŒ read_file è°ƒç”¨å¤±è´¥: {result.error}\")\n    except Exception as e:\n        print(f\"   âŒ read_file å¼‚å¸¸: {e}\")\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•å®Œæˆ\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(test_tool_names())"
},
{
"path": "tests/test_tool_registry.py",
"start": 1,
"end": 31,
"text": "\"\"\"æµ‹è¯•å·¥å…·æ³¨å†Œ\"\"\"\nimport sys\nfrom pathlib import Path\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom daoyoucode.agents.tools import get_tool_registry\n\nprint(\"=\"*60)\nprint(\"æµ‹è¯•å·¥å…·æ³¨å†Œ\")\nprint(\"=\"*60)\n\n# è·å–å·¥å…·æ³¨å†Œè¡¨\ntool_registry = get_tool_registry()\n\n# åˆ—å‡ºæ‰€æœ‰å·¥å…·\ntools = tool_registry.list_tools()\nprint(f\"\\nâœ“ å·²æ³¨å†Œ {len(tools)} ä¸ªå·¥å…·:\")\nfor tool in sorted(tools):\n    print(f\"  â€¢ {tool}\")\n\n# æ£€æŸ¥repo_map\nprint(f\"\\næ£€æŸ¥repo_mapå·¥å…·:\")\ntool = tool_registry.get_tool(\"repo_map\")\nif tool:\n    print(f\"  âœ“ repo_mapå·²æ³¨å†Œ\")\n    schema = tool.get_function_schema()\n    print(f\"  â€¢ æè¿°: {schema['description']}\")\nelse:\n    print(f\"  âœ— repo_mapæœªæ‰¾åˆ°\")\n\nprint(\"\\n\" + \"=\"*60)"
},
{
"path": "tests/test_tool_result_fix.py",
"start": 1,
"end": 52,
"text": "\"\"\"\næµ‹è¯•å·¥å…·ç»“æœä¿®å¤\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport asyncio\n\nsys.path.insert(0, str(Path(__file__).parent))\n\nasync def test():\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•å·¥å…·ç»“æœå¤„ç†\")\n    print(\"=\"*60)\n    \n    from daoyoucode.agents.init import initialize_agent_system\n    from daoyoucode.agents.llm.client_manager import get_client_manager\n    from daoyoucode.agents.llm.config_loader import auto_configure\n    \n    # åˆå§‹åŒ–\n    initialize_agent_system()\n    \n    # é…ç½®LLM\n    client_manager = get_client_manager()\n    auto_configure(client_manager)\n    \n    # æ‰§è¡ŒSkill\n    from daoyoucode.agents.executor import execute_skill\n    \n    print(\"\\næµ‹è¯•é—®é¢˜: åˆ—å‡ºbackendç›®å½•çš„æ–‡ä»¶\")\n    \n    result = await execute_skill(\n        skill_name=\"chat_assistant\",\n        user_input=\"åˆ—å‡ºbackendç›®å½•ä¸‹æœ‰å“ªäº›ä¸»è¦çš„å­ç›®å½•ï¼Ÿ\",\n        session_id=\"test\",\n        context={}\n    )\n    \n    print(f\"\\næˆåŠŸ: {result.get('success')}\")\n    if result.get('success'):\n        print(f\"\\nå“åº”:\")\n        print(\"-\"*60)\n        print(result.get('content', '')[:500])\n        print(\"-\"*60)\n        print(f\"\\nä½¿ç”¨çš„å·¥å…·: {result.get('tools_used', [])}\")\n    else:\n        print(f\"é”™è¯¯: {result.get('error')}\")\n    \n    print(\"\\n\" + \"=\"*60)\n\nif __name__ == '__main__':\n    asyncio.run(test())"
},
{
"path": "tests/test_tool_truncation.py",
"start": 1,
"end": 111,
"text": "\"\"\"\næµ‹è¯•å·¥å…·è¾“å‡ºæˆªæ–­åŠŸèƒ½\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport asyncio\n\nsys.path.insert(0, str(Path(__file__).parent))\n\n\nasync def test_truncation():\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•å·¥å…·è¾“å‡ºæˆªæ–­åŠŸèƒ½\")\n    print(\"=\"*60)\n    \n    from daoyoucode.agents.tools import get_tool_registry\n    \n    # è·å–å·¥å…·æ³¨å†Œè¡¨\n    registry = get_tool_registry()\n    \n    # æµ‹è¯•1: è¯»å–ä¸€ä¸ªé•¿æ–‡ä»¶\n    print(\"\\n1. æµ‹è¯•ReadFileToolæˆªæ–­\")\n    print(\"-\"*60)\n    \n    # åˆ›å»ºä¸€ä¸ªæµ‹è¯•æ–‡ä»¶ï¼ˆå¾ˆé•¿ï¼‰\n    test_file = Path(\"test_long_file.txt\")\n    long_content = \"\\n\".join([f\"Line {i}: \" + \"x\" * 100 for i in range(500)])\n    test_file.write_text(long_content, encoding=\"utf-8\")\n    \n    print(f\"åŸå§‹æ–‡ä»¶: {len(long_content)} å­—ç¬¦, {long_content.count(chr(10)) + 1} è¡Œ\")\n    \n    result = await registry.execute_tool(\"read_file\", file_path=str(test_file))\n    \n    if result.success:\n        print(f\"æˆªæ–­å: {len(result.content)} å­—ç¬¦\")\n        print(f\"æˆªæ–­æ ‡è®°: {result.metadata.get('truncated', False)}\")\n        if result.metadata.get('truncated'):\n            print(f\"åŸå§‹é•¿åº¦: {result.metadata.get('original_length')}\")\n            print(f\"æˆªæ–­é•¿åº¦: {result.metadata.get('truncated_length')}\")\n        \n        # æ˜¾ç¤ºå‰100å’Œå100å­—ç¬¦\n        print(f\"\\nå‰100å­—ç¬¦:\\n{result.content[:100]}\")\n        print(f\"\\nå100å­—ç¬¦:\\n{result.content[-100:]}\")\n    else:\n        print(f\"å¤±è´¥: {result.error}\")\n    \n    # æ¸…ç†æµ‹è¯•æ–‡ä»¶\n    test_file.unlink()\n    \n    # æµ‹è¯•2: æµ‹è¯•repo_map\n    print(\"\\n\\n2. æµ‹è¯•RepoMapToolæˆªæ–­\")\n    print(\"-\"*60)\n    \n    result = await registry.execute_tool(\n        \"repo_map\",\n        repo_path=\".\",  # å½“å‰ç›®å½•ï¼ˆbackendï¼‰\n        chat_files=[],\n        mentioned_idents=[],\n        max_tokens=5000  # è®¾ç½®ä¸€ä¸ªè¾ƒå¤§çš„å€¼ï¼Œçœ‹çœ‹æ˜¯å¦ä¼šè¢«æˆªæ–­\n    )\n    \n    if result.success:\n        print(f\"ç»“æœé•¿åº¦: {len(result.content)} å­—ç¬¦\")\n        print(f\"æˆªæ–­æ ‡è®°: {result.metadata.get('truncated', False)}\")\n        if result.metadata.get('truncated'):\n            print(f\"åŸå§‹é•¿åº¦: {result.metadata.get('original_length')}\")\n            print(f\"æˆªæ–­é•¿åº¦: {result.metadata.get('truncated_length')}\")\n        \n        # æ˜¾ç¤ºå‰200å­—ç¬¦\n        print(f\"\\nå‰200å­—ç¬¦:\\n{result.content[:200]}\")\n    else:\n        print(f\"å¤±è´¥: {result.error}\")\n    \n    # æµ‹è¯•3: æµ‹è¯•get_repo_structure\n    print(\"\\n\\n3. æµ‹è¯•GetRepoStructureToolæˆªæ–­\")\n    print(\"-\"*60)\n    \n    result = await registry.execute_tool(\n        \"get_repo_structure\",\n        repo_path=\".\",  # å½“å‰ç›®å½•ï¼ˆbackendï¼‰\n        max_depth=5,  # æ·±åº¦å¾ˆå¤§ï¼Œå¯èƒ½äº§ç”Ÿå¾ˆé•¿çš„è¾“å‡º\n        show_files=True\n    )\n    \n    if result.success:\n        lines = result.content.splitlines()\n        print(f\"ç»“æœ: {len(result.content)} å­—ç¬¦, {len(lines)} è¡Œ\")\n        print(f\"æˆªæ–­æ ‡è®°: {result.metadata.get('truncated', False)}\")\n        if result.metadata.get('truncated'):\n            print(f\"åŸå§‹é•¿åº¦: {result.metadata.get('original_length')}\")\n            print(f\"æˆªæ–­é•¿åº¦: {result.metadata.get('truncated_length')}\")\n        \n        # æ˜¾ç¤ºå‰10è¡Œå’Œå10è¡Œ\n        print(f\"\\nå‰10è¡Œ:\")\n        for line in lines[:10]:\n            print(line)\n        \n        if len(lines) > 20:\n            print(f\"\\nå10è¡Œ:\")\n            for line in lines[-10:]:\n                print(line)\n    else:\n        print(f\"å¤±è´¥: {result.error}\")\n    \n    # æµ‹è¯•4: æµ‹è¯•æˆªæ–­ç­–ç•¥\n    print(\"\\n\\n4. æµ‹è¯•ä¸åŒçš„æˆªæ–­ç­–ç•¥\")\n    print(\"-\"*60)\n    \n    from daoyoucode.agents.tools.base import BaseTool, ToolResult\n    "
},
{
"path": "tests/test_tool_truncation.py",
"start": 112,
"end": 115,
"text": "    class TestTool(BaseTool):\n        \"\"\"æµ‹è¯•å·¥å…·\"\"\"\n        MAX_OUTPUT_CHARS = 100\n        "
},
{
"path": "tests/test_tool_truncation.py",
"start": 116,
"end": 148,
"text": "        def __init__(self, strategy=\"head_tail\"):\n            super().__init__(\"test_tool\", \"æµ‹è¯•å·¥å…·\")\n            self.TRUNCATION_STRATEGY = strategy\n        \n        async def execute(self, **kwargs):\n            return ToolResult(success=True, content=\"x\" * 200)\n    \n    # head_tailç­–ç•¥\n    tool1 = TestTool(\"head_tail\")\n    content = \"0123456789\" * 20  # 200å­—ç¬¦\n    truncated = tool1.truncate_output(content)\n    print(f\"head_tailç­–ç•¥: {len(content)} -> {len(truncated)} å­—ç¬¦\")\n    print(f\"å†…å®¹: {truncated[:50]}...{truncated[-50:]}\")\n    \n    # head_onlyç­–ç•¥\n    tool2 = TestTool(\"head_only\")\n    truncated = tool2.truncate_output(content)\n    print(f\"\\nhead_onlyç­–ç•¥: {len(content)} -> {len(truncated)} å­—ç¬¦\")\n    print(f\"å†…å®¹: {truncated}\")\n    \n    # noneç­–ç•¥\n    tool3 = TestTool(\"none\")\n    truncated = tool3.truncate_output(content)\n    print(f\"\\nnoneç­–ç•¥: {len(content)} -> {len(truncated)} å­—ç¬¦\")\n    print(f\"æœªæˆªæ–­: {len(truncated) == len(content)}\")\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•å®Œæˆï¼\")\n    print(\"=\"*60)\n\n\nif __name__ == '__main__':\n    asyncio.run(test_truncation())"
},
{
"path": "tests/test_tree_visualization.py",
"start": 1,
"end": 12,
"text": "\"\"\"\næµ‹è¯•å¯¹è¯æ ‘å¯è§†åŒ–åŠŸèƒ½\n\néªŒè¯å„ç§å¯è§†åŒ–æ ¼å¼çš„ç”Ÿæˆ\n\"\"\"\n\nimport tempfile\nfrom pathlib import Path\nfrom daoyoucode.agents.memory.conversation_tree import ConversationTree\nfrom daoyoucode.agents.memory.tree_visualizer import TreeVisualizer, visualize_tree\n\n"
},
{
"path": "tests/test_tree_visualization.py",
"start": 13,
"end": 51,
"text": "def create_sample_tree():\n    \"\"\"åˆ›å»ºç¤ºä¾‹å¯¹è¯æ ‘\"\"\"\n    tree = ConversationTree(enabled=True)\n    \n    # åˆ†æ”¯1ï¼šçŒ«çš„å¥åº·é—®é¢˜\n    tree.add_conversation(\n        user_message=\"æˆ‘çš„çŒ«æœ€è¿‘ä¸åƒé¥­ï¼Œæ€ä¹ˆåŠï¼Ÿ\",\n        ai_response=\"çŒ«ä¸åƒé¥­å¯èƒ½æœ‰å¤šç§åŸå› ï¼ŒåŒ…æ‹¬è‚ èƒƒé—®é¢˜ã€å‹åŠ›ã€ç¯å¢ƒå˜åŒ–ç­‰ã€‚å»ºè®®å…ˆè§‚å¯Ÿæ˜¯å¦æœ‰å…¶ä»–ç—‡çŠ¶ã€‚\",\n        detect_topic_switch=True\n    )\n    \n    tree.add_conversation(\n        user_message=\"å®ƒè¿˜æœ‰å‘•åçš„ç—‡çŠ¶\",\n        ai_response=\"å‘•ååŠ ä¸Šé£Ÿæ¬²ä¸æŒ¯ï¼Œå¯èƒ½æ˜¯è‚ èƒƒç‚ã€‚å»ºè®®å°½å¿«å¸¦å»å® ç‰©åŒ»é™¢æ£€æŸ¥ï¼ŒåŒæ—¶æš‚æ—¶ç¦é£Ÿ12å°æ—¶ã€‚\",\n        detect_topic_switch=True\n    )\n    \n    tree.add_conversation(\n        user_message=\"éœ€è¦åšä»€ä¹ˆæ£€æŸ¥å—ï¼Ÿ\",\n        ai_response=\"åŒ»ç”Ÿå¯èƒ½ä¼šåšè¡€æ¶²æ£€æŸ¥ã€Xå…‰æˆ–è¶…å£°æ³¢æ£€æŸ¥ï¼Œä»¥ç¡®å®šå…·ä½“åŸå› ã€‚\",\n        detect_topic_switch=True\n    )\n    \n    # åˆ†æ”¯2ï¼šç‹—çš„çš®è‚¤é—®é¢˜ï¼ˆè¯é¢˜åˆ‡æ¢ï¼‰\n    tree.add_conversation(\n        user_message=\"é‚£ç‹—çš„çš®è‚¤æœ‰çº¢ç‚¹æ˜¯æ€ä¹ˆå›äº‹ï¼Ÿ\",\n        ai_response=\"ç‹—çš®è‚¤å‡ºç°çº¢ç‚¹å¯èƒ½æ˜¯è¿‡æ•ã€å¯„ç”Ÿè™«æˆ–çš®è‚¤æ„ŸæŸ“ã€‚éœ€è¦æ£€æŸ¥çº¢ç‚¹çš„åˆ†å¸ƒå’Œç‹—ç‹—æ˜¯å¦æœ‰ç˜™ç—’ç—‡çŠ¶ã€‚\",\n        detect_topic_switch=True\n    )\n    \n    tree.add_conversation(\n        user_message=\"å®ƒä¸€ç›´åœ¨æŒ \",\n        ai_response=\"æŒç»­ç˜™ç—’å¯èƒ½æ˜¯è·³èš¤ã€è¨è™«æˆ–è¿‡æ•å¼•èµ·çš„ã€‚å»ºè®®ä½¿ç”¨é©±è™«è¯ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦æœ‰é£Ÿç‰©è¿‡æ•ã€‚\",\n        detect_topic_switch=True\n    )\n    \n    return tree\n\n"
},
{
"path": "tests/test_tree_visualization.py",
"start": 52,
"end": 73,
"text": "def test_ascii_visualization():\n    \"\"\"æµ‹è¯•ASCIIå¯è§†åŒ–\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šASCIIå¯è§†åŒ–\")\n    print(\"=\"*60)\n    \n    tree = create_sample_tree()\n    \n    # ç”ŸæˆASCIIæ ‘\n    ascii_tree = tree.visualize(format='ascii', show_content=False)\n    print(\"\\n\" + ascii_tree)\n    \n    # å¸¦å†…å®¹çš„ç‰ˆæœ¬\n    print(\"\\n\" + \"=\"*60)\n    print(\"å¸¦å†…å®¹çš„ASCIIæ ‘ï¼š\")\n    print(\"=\"*60)\n    ascii_tree_full = tree.visualize(format='ascii', show_content=True)\n    print(\"\\n\" + ascii_tree_full)\n    \n    print(\"\\nâœ… ASCIIå¯è§†åŒ–æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_tree_visualization.py",
"start": 74,
"end": 89,
"text": "def test_mermaid_visualization():\n    \"\"\"æµ‹è¯•Mermaidå¯è§†åŒ–\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šMermaidå¯è§†åŒ–\")\n    print(\"=\"*60)\n    \n    tree = create_sample_tree()\n    \n    # ç”ŸæˆMermaidå›¾\n    mermaid = tree.visualize(format='mermaid')\n    print(\"\\n\" + mermaid)\n    \n    print(\"\\nâœ… Mermaidå¯è§†åŒ–æµ‹è¯•é€šè¿‡\")\n    print(\"   æç¤ºï¼šå¯ä»¥å¤åˆ¶ä¸Šé¢çš„ä»£ç åˆ° https://mermaid.live æŸ¥çœ‹å›¾å½¢\")\n\n"
},
{
"path": "tests/test_tree_visualization.py",
"start": 90,
"end": 104,
"text": "def test_json_visualization():\n    \"\"\"æµ‹è¯•JSONå¯è§†åŒ–\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šJSONå¯è§†åŒ–\")\n    print(\"=\"*60)\n    \n    tree = create_sample_tree()\n    \n    # ç”ŸæˆJSON\n    json_tree = tree.visualize(format='json', pretty=True)\n    print(\"\\n\" + json_tree)\n    \n    print(\"\\nâœ… JSONå¯è§†åŒ–æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_tree_visualization.py",
"start": 105,
"end": 132,
"text": "def test_html_visualization():\n    \"\"\"æµ‹è¯•HTMLå¯è§†åŒ–\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šHTMLå¯è§†åŒ–\")\n    print(\"=\"*60)\n    \n    tree = create_sample_tree()\n    \n    # ç”ŸæˆHTML\n    html = tree.visualize(format='html', title=\"å® ç‰©å¥åº·å’¨è¯¢å¯¹è¯æ ‘\")\n    \n    # ä¿å­˜åˆ°ä¸´æ—¶æ–‡ä»¶\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False, encoding='utf-8') as f:\n        f.write(html)\n        temp_path = f.name\n    \n    print(f\"\\nâœ“ HTMLå·²ç”Ÿæˆ: {temp_path}\")\n    print(f\"   å¯ä»¥åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€æŸ¥çœ‹\")\n    \n    # æ˜¾ç¤ºéƒ¨åˆ†HTML\n    print(\"\\nHTMLé¢„è§ˆï¼ˆå‰500å­—ç¬¦ï¼‰:\")\n    print(html[:500] + \"...\")\n    \n    print(\"\\nâœ… HTMLå¯è§†åŒ–æµ‹è¯•é€šè¿‡\")\n    \n    return temp_path\n\n"
},
{
"path": "tests/test_tree_visualization.py",
"start": 133,
"end": 162,
"text": "def test_export_to_file():\n    \"\"\"æµ‹è¯•å¯¼å‡ºåˆ°æ–‡ä»¶\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šå¯¼å‡ºåˆ°æ–‡ä»¶\")\n    print(\"=\"*60)\n    \n    tree = create_sample_tree()\n    \n    # åˆ›å»ºä¸´æ—¶ç›®å½•\n    temp_dir = Path(tempfile.mkdtemp())\n    \n    # å¯¼å‡ºå„ç§æ ¼å¼\n    formats = {\n        'ascii': temp_dir / 'tree.txt',\n        'mermaid': temp_dir / 'tree.md',\n        'json': temp_dir / 'tree.json',\n        'html': temp_dir / 'tree.html'\n    }\n    \n    for format_name, filepath in formats.items():\n        tree.export_visualization(str(filepath), format=format_name)\n        assert filepath.exists(), f\"æ–‡ä»¶æœªåˆ›å»º: {filepath}\"\n        print(f\"âœ“ å¯¼å‡ºæˆåŠŸ: {filepath} ({format_name})\")\n    \n    print(f\"\\næ‰€æœ‰æ–‡ä»¶å·²å¯¼å‡ºåˆ°: {temp_dir}\")\n    print(\"\\nâœ… å¯¼å‡ºæµ‹è¯•é€šè¿‡\")\n    \n    return temp_dir\n\n"
},
{
"path": "tests/test_tree_visualization.py",
"start": 163,
"end": 183,
"text": "def test_empty_tree():\n    \"\"\"æµ‹è¯•ç©ºæ ‘\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šç©ºæ ‘å¯è§†åŒ–\")\n    print(\"=\"*60)\n    \n    tree = ConversationTree(enabled=True)\n    \n    # ASCII\n    ascii_tree = tree.visualize(format='ascii')\n    print(\"\\nASCII:\")\n    print(ascii_tree)\n    \n    # Mermaid\n    mermaid = tree.visualize(format='mermaid')\n    print(\"\\nMermaid:\")\n    print(mermaid)\n    \n    print(\"\\nâœ… ç©ºæ ‘æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_tree_visualization.py",
"start": 184,
"end": 216,
"text": "def test_visualizer_class():\n    \"\"\"æµ‹è¯•TreeVisualizerç±»\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šTreeVisualizerç±»\")\n    print(\"=\"*60)\n    \n    tree = create_sample_tree()\n    visualizer = TreeVisualizer(tree)\n    \n    # æµ‹è¯•å„ç§æ–¹æ³•\n    print(\"\\n1. to_ascii():\")\n    ascii_result = visualizer.to_ascii()\n    assert len(ascii_result) > 0, \"ASCIIç»“æœä¸ºç©º\"\n    print(\"âœ“ ASCIIç”ŸæˆæˆåŠŸ\")\n    \n    print(\"\\n2. to_mermaid():\")\n    mermaid_result = visualizer.to_mermaid()\n    assert \"graph TD\" in mermaid_result, \"Mermaidæ ¼å¼é”™è¯¯\"\n    print(\"âœ“ Mermaidç”ŸæˆæˆåŠŸ\")\n    \n    print(\"\\n3. to_json():\")\n    json_result = visualizer.to_json()\n    assert \"tree\" in json_result, \"JSONæ ¼å¼é”™è¯¯\"\n    print(\"âœ“ JSONç”ŸæˆæˆåŠŸ\")\n    \n    print(\"\\n4. to_html():\")\n    html_result = visualizer.to_html()\n    assert \"<!DOCTYPE html>\" in html_result, \"HTMLæ ¼å¼é”™è¯¯\"\n    print(\"âœ“ HTMLç”ŸæˆæˆåŠŸ\")\n    \n    print(\"\\nâœ… TreeVisualizerç±»æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_tree_visualization.py",
"start": 217,
"end": 258,
"text": "def test_max_depth():\n    \"\"\"æµ‹è¯•æ·±åº¦é™åˆ¶\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•ï¼šæ·±åº¦é™åˆ¶\")\n    print(\"=\"*60)\n    \n    tree = create_sample_tree()\n    \n    # é™åˆ¶æ·±åº¦ä¸º1\n    ascii_tree = tree.visualize(format='ascii', max_depth=1)\n    print(\"\\næ·±åº¦é™åˆ¶ä¸º1:\")\n    print(ascii_tree)\n    \n    # é™åˆ¶æ·±åº¦ä¸º2\n    mermaid = tree.visualize(format='mermaid', max_depth=2)\n    print(\"\\næ·±åº¦é™åˆ¶ä¸º2 (Mermaid):\")\n    print(mermaid)\n    \n    print(\"\\nâœ… æ·±åº¦é™åˆ¶æµ‹è¯•é€šè¿‡\")\n\n\nif __name__ == \"__main__\":\n    print(\"=\"*60)\n    print(\"å¯¹è¯æ ‘å¯è§†åŒ–æµ‹è¯•å¥—ä»¶\")\n    print(\"=\"*60)\n    \n    test_ascii_visualization()\n    test_mermaid_visualization()\n    test_json_visualization()\n    html_path = test_html_visualization()\n    export_dir = test_export_to_file()\n    test_empty_tree()\n    test_visualizer_class()\n    test_max_depth()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"âœ… æ‰€æœ‰æµ‹è¯•å®Œæˆ\")\n    print(\"=\"*60)\n    print(f\"\\nç”Ÿæˆçš„æ–‡ä»¶:\")\n    print(f\"  HTML: {html_path}\")\n    print(f\"  å¯¼å‡ºç›®å½•: {export_dir}\")\n    print(\"\\næç¤ºï¼šå¯ä»¥åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€HTMLæ–‡ä»¶æŸ¥çœ‹å¯è§†åŒ–æ•ˆæœ\")"
},
{
"path": "tests/test_truncate_description.py",
"start": 1,
"end": 14,
"text": "\"\"\"\næµ‹è¯•æ™ºèƒ½æˆªæ–­æè¿°åŠŸèƒ½\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nbackend_dir = Path(__file__).parent\nsys.path.insert(0, str(backend_dir))\n\nfrom daoyoucode.agents.executor import _truncate_description\n\n"
},
{
"path": "tests/test_truncate_description.py",
"start": 15,
"end": 22,
"text": "def test_short_text():\n    \"\"\"æµ‹è¯•çŸ­æ–‡æœ¬ï¼ˆä¸éœ€è¦æˆªæ–­ï¼‰\"\"\"\n    text = \"è¿™æ˜¯ä¸€ä¸ªçŸ­æ–‡æœ¬\"\n    result = _truncate_description(text, max_length=500)\n    assert result == text\n    print(f\"âœ“ çŸ­æ–‡æœ¬æµ‹è¯•é€šè¿‡: {result}\")\n\n"
},
{
"path": "tests/test_truncate_description.py",
"start": 23,
"end": 38,
"text": "def test_long_text():\n    \"\"\"æµ‹è¯•é•¿æ–‡æœ¬ï¼ˆéœ€è¦æˆªæ–­ï¼‰\"\"\"\n    text = \"è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„æ–‡æœ¬\" * 100  # 1000ä¸ªå­—ç¬¦\n    result = _truncate_description(text, max_length=100)\n    \n    print(f\"\\nåŸå§‹æ–‡æœ¬é•¿åº¦: {len(text)}\")\n    print(f\"æˆªæ–­åé•¿åº¦: {len(result)}\")\n    print(f\"æˆªæ–­åå†…å®¹: {result}\")\n    \n    assert len(result) <= 100\n    assert \"...\" in result\n    assert result.startswith(\"è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„æ–‡æœ¬\")\n    assert result.endswith(\"å¾ˆé•¿çš„æ–‡æœ¬\")\n    print(\"âœ“ é•¿æ–‡æœ¬æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_truncate_description.py",
"start": 39,
"end": 46,
"text": "def test_exact_length():\n    \"\"\"æµ‹è¯•åˆšå¥½ç­‰äºæœ€å¤§é•¿åº¦\"\"\"\n    text = \"a\" * 100\n    result = _truncate_description(text, max_length=100)\n    assert result == text\n    print(f\"âœ“ ç²¾ç¡®é•¿åº¦æµ‹è¯•é€šè¿‡: é•¿åº¦={len(result)}\")\n\n"
},
{
"path": "tests/test_truncate_description.py",
"start": 47,
"end": 60,
"text": "def test_slightly_over():\n    \"\"\"æµ‹è¯•ç¨å¾®è¶…è¿‡æœ€å¤§é•¿åº¦\"\"\"\n    text = \"a\" * 101\n    result = _truncate_description(text, max_length=100)\n    \n    print(f\"\\nåŸå§‹é•¿åº¦: {len(text)}\")\n    print(f\"æˆªæ–­åé•¿åº¦: {len(result)}\")\n    print(f\"æˆªæ–­åå†…å®¹: {result[:20]}...{result[-20:]}\")\n    \n    assert len(result) <= 100\n    assert \"...\" in result\n    print(\"âœ“ ç¨å¾®è¶…é•¿æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_truncate_description.py",
"start": 61,
"end": 75,
"text": "def test_very_long_text():\n    \"\"\"æµ‹è¯•éå¸¸é•¿çš„æ–‡æœ¬\"\"\"\n    text = \"ç”¨æˆ·é—®é¢˜ï¼š\" + \"è¿™æ˜¯ä¸€ä¸ªéå¸¸è¯¦ç»†çš„é—®é¢˜æè¿°ï¼ŒåŒ…å«äº†å¾ˆå¤šèƒŒæ™¯ä¿¡æ¯å’Œä¸Šä¸‹æ–‡ã€‚\" * 50\n    result = _truncate_description(text, max_length=500)\n    \n    print(f\"\\nåŸå§‹é•¿åº¦: {len(text)}\")\n    print(f\"æˆªæ–­åé•¿åº¦: {len(result)}\")\n    print(f\"æˆªæ–­åå†…å®¹:\\n{result}\")\n    \n    assert len(result) <= 500\n    assert \"...\" in result\n    assert result.startswith(\"ç”¨æˆ·é—®é¢˜ï¼š\")\n    print(\"âœ“ è¶…é•¿æ–‡æœ¬æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_truncate_description.py",
"start": 76,
"end": 102,
"text": "def test_multiline_text():\n    \"\"\"æµ‹è¯•å¤šè¡Œæ–‡æœ¬\"\"\"\n    text = \"\"\"ç”¨æˆ·é—®é¢˜ï¼š\n    \næˆ‘æƒ³äº†è§£è¿™ä¸ªé¡¹ç›®çš„æ¶æ„è®¾è®¡ã€‚\n\nå…·ä½“æ¥è¯´ï¼Œæˆ‘æƒ³çŸ¥é“ï¼š\n1. é¡¹ç›®çš„æ•´ä½“ç»“æ„æ˜¯ä»€ä¹ˆæ ·çš„ï¼Ÿ\n2. å„ä¸ªæ¨¡å—ä¹‹é—´æ˜¯å¦‚ä½•äº¤äº’çš„ï¼Ÿ\n3. æœ‰å“ªäº›æ ¸å¿ƒç»„ä»¶ï¼Ÿ\n4. ä½¿ç”¨äº†å“ªäº›è®¾è®¡æ¨¡å¼ï¼Ÿ\n5. å¦‚ä½•æ‰©å±•æ–°åŠŸèƒ½ï¼Ÿ\n\nè¯·è¯¦ç»†è¯´æ˜ã€‚\n\"\"\" * 10  # é‡å¤10æ¬¡ï¼Œåˆ¶é€ é•¿æ–‡æœ¬\n    \n    result = _truncate_description(text, max_length=500)\n    \n    print(f\"\\nåŸå§‹é•¿åº¦: {len(text)}\")\n    print(f\"æˆªæ–­åé•¿åº¦: {len(result)}\")\n    print(f\"æˆªæ–­åå†…å®¹:\\n{result}\")\n    \n    assert len(result) <= 500\n    assert \"...\" in result\n    print(\"âœ“ å¤šè¡Œæ–‡æœ¬æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_truncate_description.py",
"start": 103,
"end": 116,
"text": "def test_chinese_text():\n    \"\"\"æµ‹è¯•ä¸­æ–‡æ–‡æœ¬\"\"\"\n    text = \"è¿™æ˜¯ä¸€æ®µä¸­æ–‡æ–‡æœ¬ï¼Œç”¨äºæµ‹è¯•æ™ºèƒ½æˆªæ–­åŠŸèƒ½æ˜¯å¦èƒ½æ­£ç¡®å¤„ç†ä¸­æ–‡å­—ç¬¦ã€‚\" * 20\n    result = _truncate_description(text, max_length=200)\n    \n    print(f\"\\nåŸå§‹é•¿åº¦: {len(text)}\")\n    print(f\"æˆªæ–­åé•¿åº¦: {len(result)}\")\n    print(f\"æˆªæ–­åå†…å®¹: {result}\")\n    \n    assert len(result) <= 200\n    assert \"...\" in result\n    print(\"âœ“ ä¸­æ–‡æ–‡æœ¬æµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_truncate_description.py",
"start": 117,
"end": 130,
"text": "def test_mixed_text():\n    \"\"\"æµ‹è¯•ä¸­è‹±æ–‡æ··åˆæ–‡æœ¬\"\"\"\n    text = \"User question: è¯·å¸®æˆ‘åˆ†æä¸€ä¸‹è¿™ä¸ªé¡¹ç›®çš„ä»£ç ç»“æ„ã€‚I want to understand the architecture. \" * 20\n    result = _truncate_description(text, max_length=300)\n    \n    print(f\"\\nåŸå§‹é•¿åº¦: {len(text)}\")\n    print(f\"æˆªæ–­åé•¿åº¦: {len(result)}\")\n    print(f\"æˆªæ–­åå†…å®¹: {result}\")\n    \n    assert len(result) <= 300\n    assert \"...\" in result\n    print(\"âœ“ ä¸­è‹±æ–‡æ··åˆæµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_truncate_description.py",
"start": 131,
"end": 135,
"text": "def test_code_snippet():\n    \"\"\"æµ‹è¯•åŒ…å«ä»£ç ç‰‡æ®µçš„æ–‡æœ¬\"\"\"\n    text = \"\"\"ç”¨æˆ·é—®é¢˜ï¼šè¯·å¸®æˆ‘ä¼˜åŒ–è¿™æ®µä»£ç \n\n```python"
},
{
"path": "tests/test_truncate_description.py",
"start": 136,
"end": 157,
"text": "def process_data(data):\n    result = []\n    for item in data:\n        if item > 0:\n            result.append(item * 2)\n    return result\n```\n\nè¿™æ®µä»£ç æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿå¦‚ä½•ä¼˜åŒ–ï¼Ÿ\n\"\"\" * 5\n    \n    result = _truncate_description(text, max_length=400)\n    \n    print(f\"\\nåŸå§‹é•¿åº¦: {len(text)}\")\n    print(f\"æˆªæ–­åé•¿åº¦: {len(result)}\")\n    print(f\"æˆªæ–­åå†…å®¹:\\n{result}\")\n    \n    assert len(result) <= 400\n    assert \"...\" in result\n    print(\"âœ“ ä»£ç ç‰‡æ®µæµ‹è¯•é€šè¿‡\")\n\n"
},
{
"path": "tests/test_truncate_description.py",
"start": 158,
"end": 201,
"text": "def test_comparison():\n    \"\"\"å¯¹æ¯”æ—§æ–¹æ³•å’Œæ–°æ–¹æ³•\"\"\"\n    text = \"ç”¨æˆ·é—®é¢˜ï¼š\" + \"è¿™æ˜¯ä¸€ä¸ªè¯¦ç»†çš„é—®é¢˜æè¿°ã€‚\" * 50\n    \n    # æ—§æ–¹æ³•ï¼šç®€å•æˆªæ–­\n    old_result = text[:200]\n    \n    # æ–°æ–¹æ³•ï¼šæ™ºèƒ½æˆªæ–­\n    new_result = _truncate_description(text, max_length=200)\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"å¯¹æ¯”æ—§æ–¹æ³•å’Œæ–°æ–¹æ³•\")\n    print(\"=\"*60)\n    print(f\"\\nåŸå§‹æ–‡æœ¬é•¿åº¦: {len(text)}\")\n    print(f\"\\næ—§æ–¹æ³•ï¼ˆç®€å•æˆªæ–­å‰200å­—ç¬¦ï¼‰:\")\n    print(f\"é•¿åº¦: {len(old_result)}\")\n    print(f\"å†…å®¹: {old_result}\")\n    print(f\"\\næ–°æ–¹æ³•ï¼ˆæ™ºèƒ½æˆªæ–­ï¼Œä¿ç•™å¼€å¤´å’Œç»“å°¾ï¼‰:\")\n    print(f\"é•¿åº¦: {len(new_result)}\")\n    print(f\"å†…å®¹: {new_result}\")\n    print(\"\\n\" + \"=\"*60)\n    print(\"âœ“ å¯¹æ¯”æµ‹è¯•å®Œæˆ\")\n\n\nif __name__ == \"__main__\":\n    print(\"=\"*60)\n    print(\"æµ‹è¯•æ™ºèƒ½æˆªæ–­æè¿°åŠŸèƒ½\")\n    print(\"=\"*60)\n    \n    test_short_text()\n    test_long_text()\n    test_exact_length()\n    test_slightly_over()\n    test_very_long_text()\n    test_multiline_text()\n    test_chinese_text()\n    test_mixed_text()\n    test_code_snippet()\n    test_comparison()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"âœ“ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼\")\n    print(\"=\"*60)\n"
},
{
"path": "tests/test_user_manager.py",
"start": 1,
"end": 14,
"text": "\"\"\"\næµ‹è¯•ç”¨æˆ·ç®¡ç†å™¨\n\néªŒè¯ç”¨æˆ·IDçš„ç”Ÿæˆã€æŒä¹…åŒ–å’Œä½¿ç”¨\n\"\"\"\n\nimport logging\nfrom pathlib import Path\nfrom daoyoucode.agents.memory import get_user_manager, get_current_user_id\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n"
},
{
"path": "tests/test_user_manager.py",
"start": 15,
"end": 164,
"text": "def test_user_manager():\n    \"\"\"æµ‹è¯•ç”¨æˆ·ç®¡ç†å™¨\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"ç”¨æˆ·ç®¡ç†å™¨æµ‹è¯•\")\n    print(\"=\"*60)\n    \n    # ç¬¬ä¸€æ­¥ï¼šè·å–ç”¨æˆ·ç®¡ç†å™¨\n    print(\"\\nç¬¬ä¸€æ­¥ï¼šè·å–ç”¨æˆ·ç®¡ç†å™¨...\")\n    user_manager = get_user_manager()\n    \n    user_id = user_manager.get_user_id()\n    print(f\"âœ… ç”¨æˆ·ID: {user_id}\")\n    \n    # æ£€æŸ¥ç”¨æˆ·æ–‡ä»¶\n    user_file = user_manager.user_file\n    print(f\"âœ… ç”¨æˆ·æ–‡ä»¶: {user_file}\")\n    \n    if user_file.exists():\n        print(f\"âœ… ç”¨æˆ·æ–‡ä»¶å·²åˆ›å»º\")\n        \n        # è¯»å–æ–‡ä»¶å†…å®¹\n        import json\n        with open(user_file, 'r', encoding='utf-8') as f:\n            user_info = json.load(f)\n        \n        print(f\"\\nç”¨æˆ·ä¿¡æ¯:\")\n        print(f\"  user_id: {user_info['user_id']}\")\n        print(f\"  created_at: {user_info['created_at']}\")\n        print(f\"  config: {user_info.get('config', {})}\")\n    else:\n        print(f\"âŒ ç”¨æˆ·æ–‡ä»¶ä¸å­˜åœ¨\")\n        return False\n    \n    # ç¬¬äºŒæ­¥ï¼šæµ‹è¯•ä¾¿æ·å‡½æ•°\n    print(\"\\nç¬¬äºŒæ­¥ï¼šæµ‹è¯•ä¾¿æ·å‡½æ•°...\")\n    user_id_2 = get_current_user_id()\n    print(f\"âœ… get_current_user_id(): {user_id_2}\")\n    \n    if user_id == user_id_2:\n        print(\"âœ… ç”¨æˆ·IDä¸€è‡´\")\n    else:\n        print(f\"âŒ ç”¨æˆ·IDä¸ä¸€è‡´: {user_id} != {user_id_2}\")\n        return False\n    \n    # ç¬¬ä¸‰æ­¥ï¼šæµ‹è¯•ç”¨æˆ·é…ç½®\n    print(\"\\nç¬¬ä¸‰æ­¥ï¼šæµ‹è¯•ç”¨æˆ·é…ç½®...\")\n    \n    # è®¾ç½®é…ç½®\n    user_manager.set_user_config('preferred_language', 'python')\n    user_manager.set_user_config('theme', 'dark')\n    print(\"âœ… è®¾ç½®äº†ç”¨æˆ·é…ç½®\")\n    \n    # è·å–é…ç½®\n    language = user_manager.get_user_config('preferred_language')\n    theme = user_manager.get_user_config('theme')\n    \n    print(f\"  preferred_language: {language}\")\n    print(f\"  theme: {theme}\")\n    \n    if language == 'python' and theme == 'dark':\n        print(\"âœ… ç”¨æˆ·é…ç½®æ­£ç¡®\")\n    else:\n        print(\"âŒ ç”¨æˆ·é…ç½®é”™è¯¯\")\n        return False\n    \n    # ç¬¬å››æ­¥ï¼šæ¨¡æ‹Ÿç¨‹åºé‡å¯\n    print(\"\\nç¬¬å››æ­¥ï¼šæ¨¡æ‹Ÿç¨‹åºé‡å¯...\")\n    \n    # æ¸…é™¤å•ä¾‹\n    import daoyoucode.agents.memory.user_manager as user_manager_module\n    user_manager_module._user_manager_instance = None\n    print(\"âœ… æ¸…é™¤äº†å•ä¾‹\")\n    \n    # é‡æ–°è·å–\n    user_manager_2 = get_user_manager()\n    user_id_3 = user_manager_2.get_user_id()\n    \n    print(f\"âœ… é‡æ–°è·å–ç”¨æˆ·ID: {user_id_3}\")\n    \n    if user_id == user_id_3:\n        print(\"âœ… ç”¨æˆ·IDæŒä¹…åŒ–æˆåŠŸï¼ˆç¨‹åºé‡å¯åä¿æŒä¸å˜ï¼‰\")\n    else:\n        print(f\"âŒ ç”¨æˆ·IDæŒä¹…åŒ–å¤±è´¥: {user_id} != {user_id_3}\")\n        return False\n    \n    # éªŒè¯é…ç½®ä¹Ÿæ¢å¤äº†\n    language_2 = user_manager_2.get_user_config('preferred_language')\n    theme_2 = user_manager_2.get_user_config('theme')\n    \n    print(f\"\\né‡å¯åçš„é…ç½®:\")\n    print(f\"  preferred_language: {language_2}\")\n    print(f\"  theme: {theme_2}\")\n    \n    if language_2 == 'python' and theme_2 == 'dark':\n        print(\"âœ… ç”¨æˆ·é…ç½®æŒä¹…åŒ–æˆåŠŸ\")\n    else:\n        print(\"âŒ ç”¨æˆ·é…ç½®æŒä¹…åŒ–å¤±è´¥\")\n        return False\n    \n    # ç¬¬äº”æ­¥ï¼šæµ‹è¯•åœ¨Agentä¸­çš„ä½¿ç”¨\n    print(\"\\nç¬¬äº”æ­¥ï¼šæµ‹è¯•åœ¨Agentä¸­çš„ä½¿ç”¨...\")\n    \n    from daoyoucode.agents.core.agent import BaseAgent, AgentConfig\n    \n    config = AgentConfig(\n        name=\"TestAgent\",\n        description=\"æµ‹è¯•Agent\",\n        model=\"qwen-plus\",\n        system_prompt=\"ä½ æ˜¯ä¸€ä¸ªæµ‹è¯•Agent\"\n    )\n    \n    agent = BaseAgent(config)\n    \n    # æ¨¡æ‹Ÿæ‰§è¡Œï¼ˆä¸å®é™…è°ƒç”¨LLMï¼‰\n    context = {\n        'session_id': 'test-session'\n        # æ³¨æ„ï¼šæ²¡æœ‰è®¾ç½®user_id\n    }\n    \n    # åœ¨agent.executeä¸­ä¼šè‡ªåŠ¨è·å–user_id\n    # è¿™é‡Œæˆ‘ä»¬ç›´æ¥æµ‹è¯•é€»è¾‘\n    auto_user_id = get_current_user_id()\n    \n    print(f\"âœ… Agentè‡ªåŠ¨è·å–çš„user_id: {auto_user_id}\")\n    \n    if auto_user_id == user_id:\n        print(\"âœ… Agentèƒ½æ­£ç¡®è·å–ç”¨æˆ·ID\")\n    else:\n        print(f\"âŒ Agentè·å–çš„ç”¨æˆ·IDä¸æ­£ç¡®: {auto_user_id} != {user_id}\")\n        return False\n    \n    # æ€»ç»“\n    print(\"\\n\" + \"=\"*60)\n    print(\"æµ‹è¯•æ€»ç»“\")\n    print(\"=\"*60)\n    \n    print(\"ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼\")\n    print(f\"\\nç”¨æˆ·ID: {user_id}\")\n    print(f\"å­˜å‚¨ä½ç½®: {user_file}\")\n    print(\"\\nç‰¹æ€§:\")\n    print(\"  âœ… è‡ªåŠ¨ç”Ÿæˆç”¨æˆ·IDï¼ˆåŸºäºæœºå™¨æ ‡è¯†ï¼‰\")\n    print(\"  âœ… æŒä¹…åŒ–å­˜å‚¨ï¼ˆç¨‹åºé‡å¯åä¿æŒä¸å˜ï¼‰\")\n    print(\"  âœ… ç”¨æˆ·é…ç½®ç®¡ç†\")\n    print(\"  âœ… Agentè‡ªåŠ¨è·å–\")\n    \n    return True\n\n\nif __name__ == \"__main__\":\n    test_user_manager()"
},
{
"path": "tests/test_user_sessions.py",
"start": 1,
"end": 181,
"text": "\"\"\"\næµ‹è¯•ç”¨æˆ·ä¼šè¯æ˜ å°„åŠŸèƒ½\n\néªŒè¯user_idåˆ°session_idçš„æ˜ å°„æ˜¯å¦æ­£å¸¸å·¥ä½œ\n\"\"\"\n\nimport asyncio\nimport logging\nfrom daoyoucode.agents.memory import get_memory_manager\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nasync def test_user_sessions():\n    \"\"\"æµ‹è¯•ç”¨æˆ·ä¼šè¯æ˜ å°„\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"ç”¨æˆ·ä¼šè¯æ˜ å°„æµ‹è¯•\")\n    print(\"=\"*60)\n    \n    memory = get_memory_manager()\n    \n    # æ¨¡æ‹Ÿå¤šä¸ªç”¨æˆ·çš„å¤šä¸ªä¼šè¯\n    test_data = [\n        ('user-alice', 'session-alice-1', 'ä½ å¥½', 'ä½ å¥½ï¼'),\n        ('user-alice', 'session-alice-1', 'è¿™ä¸ªé¡¹ç›®æ˜¯åšä»€ä¹ˆçš„ï¼Ÿ', 'è¿™æ˜¯ä¸€ä¸ªAIåŠ©æ‰‹...'),\n        ('user-alice', 'session-alice-2', 'å¦‚ä½•å†™Pythonå‡½æ•°ï¼Ÿ', 'å¯ä»¥è¿™æ ·å†™...'),\n        ('user-bob', 'session-bob-1', 'JavaScriptæ€ä¹ˆå­¦ï¼Ÿ', 'å»ºè®®ä»åŸºç¡€å¼€å§‹...'),\n        ('user-bob', 'session-bob-2', 'Reactæœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Ÿ', 'Reactæ˜¯ä¸€ä¸ª...'),\n        ('user-alice', 'session-alice-3', 'æµ‹è¯•ä¸€ä¸‹', 'å¥½çš„'),\n    ]\n    \n    print(\"\\nç¬¬ä¸€æ­¥ï¼šæ·»åŠ å¯¹è¯å¹¶å»ºç«‹æ˜ å°„...\")\n    for user_id, session_id, user_msg, ai_msg in test_data:\n        memory.add_conversation(\n            session_id=session_id,\n            user_message=user_msg,\n            ai_response=ai_msg,\n            user_id=user_id\n        )\n        print(f\"  âœ… {user_id} -> {session_id}: {user_msg[:20]}...\")\n    \n    # éªŒè¯æ˜ å°„\n    print(\"\\nç¬¬äºŒæ­¥ï¼šéªŒè¯ç”¨æˆ·ä¼šè¯æ˜ å°„...\")\n    \n    # Aliceçš„ä¼šè¯\n    alice_sessions = memory.get_user_sessions('user-alice')\n    print(f\"\\nAliceçš„ä¼šè¯:\")\n    print(f\"  ä¼šè¯æ•°: {len(alice_sessions)}\")\n    print(f\"  ä¼šè¯ID: {alice_sessions}\")\n    \n    expected_alice = ['session-alice-1', 'session-alice-2', 'session-alice-3']\n    if set(alice_sessions) == set(expected_alice):\n        print(\"  âœ… Aliceçš„ä¼šè¯æ˜ å°„æ­£ç¡®\")\n    else:\n        print(f\"  âŒ Aliceçš„ä¼šè¯æ˜ å°„é”™è¯¯ï¼ŒæœŸæœ›: {expected_alice}\")\n    \n    # Bobçš„ä¼šè¯\n    bob_sessions = memory.get_user_sessions('user-bob')\n    print(f\"\\nBobçš„ä¼šè¯:\")\n    print(f\"  ä¼šè¯æ•°: {len(bob_sessions)}\")\n    print(f\"  ä¼šè¯ID: {bob_sessions}\")\n    \n    expected_bob = ['session-bob-1', 'session-bob-2']\n    if set(bob_sessions) == set(expected_bob):\n        print(\"  âœ… Bobçš„ä¼šè¯æ˜ å°„æ­£ç¡®\")\n    else:\n        print(f\"  âŒ Bobçš„ä¼šè¯æ˜ å°„é”™è¯¯ï¼ŒæœŸæœ›: {expected_bob}\")\n    \n    # åå‘æŸ¥è¯¢\n    print(\"\\nç¬¬ä¸‰æ­¥ï¼šéªŒè¯åå‘æŸ¥è¯¢ï¼ˆsession -> userï¼‰...\")\n    \n    test_sessions = [\n        ('session-alice-1', 'user-alice'),\n        ('session-bob-1', 'user-bob'),\n        ('session-alice-3', 'user-alice'),\n    ]\n    \n    for session_id, expected_user in test_sessions:\n        actual_user = memory.get_session_user(session_id)\n        if actual_user == expected_user:\n            print(f\"  âœ… {session_id} -> {actual_user}\")\n        else:\n            print(f\"  âŒ {session_id} -> {actual_user} (æœŸæœ›: {expected_user})\")\n    \n    # éªŒè¯æŒä¹…åŒ–\n    print(\"\\nç¬¬å››æ­¥ï¼šéªŒè¯æŒä¹…åŒ–...\")\n    \n    # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨\n    storage_dir = memory.storage.storage_dir\n    user_sessions_file = storage_dir / 'user_sessions.json'\n    \n    if user_sessions_file.exists():\n        print(f\"  âœ… æ˜ å°„æ–‡ä»¶å·²åˆ›å»º: {user_sessions_file}\")\n        \n        # è¯»å–æ–‡ä»¶å†…å®¹\n        import json\n        with open(user_sessions_file, 'r', encoding='utf-8') as f:\n            data = json.load(f)\n        \n        print(f\"  ç”¨æˆ·æ•°: {len(data.get('user_sessions', {}))}\")\n        print(f\"  ä¼šè¯æ•°: {len(data.get('session_users', {}))}\")\n    else:\n        print(f\"  âŒ æ˜ å°„æ–‡ä»¶ä¸å­˜åœ¨\")\n    \n    # æ¨¡æ‹Ÿç¨‹åºé‡å¯\n    print(\"\\nç¬¬äº”æ­¥ï¼šæ¨¡æ‹Ÿç¨‹åºé‡å¯...\")\n    \n    # æ¸…é™¤å•ä¾‹\n    import daoyoucode.agents.memory.manager as manager_module\n    manager_module._memory_manager_instance = None\n    print(\"  âœ… æ¸…é™¤äº†å†…å­˜å•ä¾‹\")\n    \n    # é‡æ–°åˆ›å»ºç®¡ç†å™¨\n    memory2 = get_memory_manager()\n    print(\"  âœ… é‡æ–°åˆ›å»ºäº†ç®¡ç†å™¨\")\n    \n    # éªŒè¯æ•°æ®æ˜¯å¦æ¢å¤\n    alice_sessions_2 = memory2.get_user_sessions('user-alice')\n    bob_sessions_2 = memory2.get_user_sessions('user-bob')\n    \n    print(f\"\\né‡å¯åçš„æ•°æ®:\")\n    print(f\"  Aliceä¼šè¯æ•°: {len(alice_sessions_2)}\")\n    print(f\"  Bobä¼šè¯æ•°: {len(bob_sessions_2)}\")\n    \n    if set(alice_sessions_2) == set(expected_alice):\n        print(\"  âœ… Aliceçš„ä¼šè¯æ˜ å°„å·²æ¢å¤\")\n    else:\n        print(f\"  âŒ Aliceçš„ä¼šè¯æ˜ å°„æœªæ¢å¤\")\n    \n    if set(bob_sessions_2) == set(expected_bob):\n        print(\"  âœ… Bobçš„ä¼šè¯æ˜ å°„å·²æ¢å¤\")\n    else:\n        print(f\"  âŒ Bobçš„ä¼šè¯æ˜ å°„æœªæ¢å¤\")\n    \n    # æµ‹è¯•ç”¨æˆ·ç”»åƒç”Ÿæˆ\n    print(\"\\nç¬¬å…­æ­¥ï¼šæµ‹è¯•ç”¨æˆ·ç”»åƒç”Ÿæˆ...\")\n    \n    # ä¸ºAliceç”Ÿæˆç”»åƒ\n    t"
},
{
"path": "tests/test_verification_permission.py",
"start": 1,
"end": 21,
"text": "\"\"\"\næµ‹è¯•éªŒè¯æœºåˆ¶å’Œå¢å¼ºçš„æƒé™ç³»ç»Ÿ\n\"\"\"\n\nimport pytest\nimport asyncio\nfrom pathlib import Path\nfrom daoyoucode.agents.core.verification import (\n    VerificationManager,\n    VerificationLevel,\n    get_verification_manager,\n)\nfrom daoyoucode.agents.core.permission import (\n    PermissionManager,\n    get_permission_manager,\n    check_permission,\n)\n\n\n# ==================== éªŒè¯æœºåˆ¶æµ‹è¯• ====================\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 22,
"end": 28,
"text": "def test_verification_manager_singleton():\n    \"\"\"æµ‹è¯•éªŒè¯ç®¡ç†å™¨å•ä¾‹\"\"\"\n    manager1 = VerificationManager()\n    manager2 = get_verification_manager()\n    assert manager1 is manager2\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 29,
"end": 91,
"text": "def test_verification_manager_configure():\n    \"\"\"æµ‹è¯•éªŒè¯ç®¡ç†å™¨é…ç½®\"\"\"\n    manager = get_verification_manager()\n    manager.configure(\n        project_root=Path(\".\"),\n        build_command=\"echo 'build'\",\n        test_command=\"echo 'test'\",\n        timeout=60\n    )\n    \n    assert manager.project_root == Path(\".\")\n    assert manager.build_command == \"echo 'build'\"\n    assert manager.test_command == \"echo 'test'\"\n    assert manager.timeout == 60\n\n\n@pytest.mark.asyncio\nasync def test_verification_none_level():\n    \"\"\"æµ‹è¯•NONEçº§åˆ«éªŒè¯\"\"\"\n    manager = get_verification_manager()\n    \n    result = await manager.verify(\n        result={'success': True},\n        level=VerificationLevel.NONE\n    )\n    \n    assert result.passed is True\n    assert result.level == VerificationLevel.NONE\n\n\n@pytest.mark.asyncio\nasync def test_verification_basic_level():\n    \"\"\"æµ‹è¯•BASICçº§åˆ«éªŒè¯\"\"\"\n    manager = get_verification_manager()\n    manager.configure(project_root=Path(\".\"))\n    \n    result = await manager.verify(\n        result={'success': True},\n        level=VerificationLevel.BASIC\n    )\n    \n    assert result.level == VerificationLevel.BASIC\n    assert 'diagnostics' in result.details\n\n\n@pytest.mark.asyncio\nasync def test_verification_with_files():\n    \"\"\"æµ‹è¯•æ–‡ä»¶æ£€æŸ¥\"\"\"\n    manager = get_verification_manager()\n    manager.configure(project_root=Path(\".\"))\n    \n    # æµ‹è¯•å­˜åœ¨çš„æ–‡ä»¶\n    result = await manager.verify(\n        result={'success': True},\n        level=VerificationLevel.BASIC,\n        modified_files=[Path(__file__)]  # æµ‹è¯•æ–‡ä»¶æœ¬èº«\n    )\n    \n    assert result.file_check_passed is True\n\n\n# ==================== æƒé™ç³»ç»Ÿæµ‹è¯• ====================\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 92,
"end": 98,
"text": "def test_permission_manager_singleton():\n    \"\"\"æµ‹è¯•æƒé™ç®¡ç†å™¨å•ä¾‹\"\"\"\n    manager1 = PermissionManager()\n    manager2 = get_permission_manager()\n    assert manager1 is manager2\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 99,
"end": 104,
"text": "def test_permission_read_allow():\n    \"\"\"æµ‹è¯•è¯»å–æƒé™ - å…è®¸\"\"\"\n    action = check_permission(\"read\", \"test.py\")\n    assert action == \"allow\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 105,
"end": 116,
"text": "def test_permission_read_env_ask():\n    \"\"\"æµ‹è¯•è¯»å–æƒé™ - ç¯å¢ƒå˜é‡æ–‡ä»¶éœ€è¦ç¡®è®¤\"\"\"\n    action = check_permission(\"read\", \".env\")\n    assert action == \"ask\"\n    \n    action = check_permission(\"read\", \".env.local\")\n    assert action == \"ask\"\n    \n    action = check_permission(\"read\", \".env.production\")\n    assert action == \"ask\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 117,
"end": 122,
"text": "def test_permission_read_env_example_allow():\n    \"\"\"æµ‹è¯•è¯»å–æƒé™ - ç¤ºä¾‹æ–‡ä»¶å…è®¸\"\"\"\n    action = check_permission(\"read\", \".env.example\")\n    assert action == \"allow\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 123,
"end": 136,
"text": "def test_permission_read_sensitive():\n    \"\"\"æµ‹è¯•è¯»å–æƒé™ - æ•æ„Ÿæ–‡ä»¶\"\"\"\n    # å¯†é’¥æ–‡ä»¶\n    assert check_permission(\"read\", \"private.key\") == \"ask\"\n    assert check_permission(\"read\", \"cert.pem\") == \"ask\"\n    assert check_permission(\"read\", \"cert.crt\") == \"ask\"\n    \n    # åŒ…å«æ•æ„Ÿè¯çš„æ–‡ä»¶\n    assert check_permission(\"read\", \"secret_config.json\") == \"ask\"\n    assert check_permission(\"read\", \"password_list.txt\") == \"ask\"\n    assert check_permission(\"read\", \"api_token.txt\") == \"ask\"\n    assert check_permission(\"read\", \"credentials.json\") == \"ask\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 137,
"end": 149,
"text": "def test_permission_write_code_allow():\n    \"\"\"æµ‹è¯•å†™å…¥æƒé™ - ä»£ç æ–‡ä»¶å…è®¸\"\"\"\n    assert check_permission(\"write\", \"test.py\") == \"allow\"\n    assert check_permission(\"write\", \"app.js\") == \"allow\"\n    assert check_permission(\"write\", \"main.ts\") == \"allow\"\n    assert check_permission(\"write\", \"App.jsx\") == \"allow\"\n    assert check_permission(\"write\", \"Component.tsx\") == \"allow\"\n    assert check_permission(\"write\", \"Main.java\") == \"allow\"\n    assert check_permission(\"write\", \"main.cpp\") == \"allow\"\n    assert check_permission(\"write\", \"main.go\") == \"allow\"\n    assert check_permission(\"write\", \"main.rs\") == \"allow\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 150,
"end": 158,
"text": "def test_permission_write_config_allow():\n    \"\"\"æµ‹è¯•å†™å…¥æƒé™ - é…ç½®æ–‡ä»¶å…è®¸\"\"\"\n    assert check_permission(\"write\", \"config.json\") == \"allow\"\n    assert check_permission(\"write\", \"config.yaml\") == \"allow\"\n    assert check_permission(\"write\", \"config.yml\") == \"allow\"\n    assert check_permission(\"write\", \"config.toml\") == \"allow\"\n    assert check_permission(\"write\", \"README.md\") == \"allow\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 159,
"end": 163,
"text": "def test_permission_write_env_deny():\n    \"\"\"æµ‹è¯•å†™å…¥æƒé™ - ç¯å¢ƒå˜é‡æ–‡ä»¶ç¦æ­¢\"\"\"\n    assert check_permission(\"write\", \".env\") == \"deny\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 164,
"end": 168,
"text": "def test_permission_write_env_example_allow():\n    \"\"\"æµ‹è¯•å†™å…¥æƒé™ - ç¤ºä¾‹æ–‡ä»¶å…è®¸\"\"\"\n    assert check_permission(\"write\", \".env.example\") == \"allow\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 169,
"end": 175,
"text": "def test_permission_write_sensitive_deny():\n    \"\"\"æµ‹è¯•å†™å…¥æƒé™ - æ•æ„Ÿæ–‡ä»¶ç¦æ­¢\"\"\"\n    assert check_permission(\"write\", \"private.key\") == \"deny\"\n    assert check_permission(\"write\", \"cert.pem\") == \"deny\"\n    assert check_permission(\"write\", \"cert.crt\") == \"deny\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 176,
"end": 181,
"text": "def test_permission_write_git_deny():\n    \"\"\"æµ‹è¯•å†™å…¥æƒé™ - Gitç›®å½•ç¦æ­¢\"\"\"\n    assert check_permission(\"write\", \".git/config\") == \"deny\"\n    assert check_permission(\"write\", \".git/HEAD\") == \"deny\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 182,
"end": 186,
"text": "def test_permission_write_gitignore_allow():\n    \"\"\"æµ‹è¯•å†™å…¥æƒé™ - .gitignoreå…è®¸\"\"\"\n    assert check_permission(\"write\", \".gitignore\") == \"allow\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 187,
"end": 194,
"text": "def test_permission_write_lock_ask():\n    \"\"\"æµ‹è¯•å†™å…¥æƒé™ - é”æ–‡ä»¶éœ€è¦ç¡®è®¤\"\"\"\n    assert check_permission(\"write\", \"package-lock.json\") == \"ask\"\n    assert check_permission(\"write\", \"yarn.lock\") == \"ask\"\n    assert check_permission(\"write\", \"Pipfile.lock\") == \"ask\"\n    assert check_permission(\"write\", \"poetry.lock\") == \"ask\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 195,
"end": 204,
"text": "def test_permission_delete_temp_allow():\n    \"\"\"æµ‹è¯•åˆ é™¤æƒé™ - ä¸´æ—¶æ–‡ä»¶å…è®¸\"\"\"\n    assert check_permission(\"delete\", \"test.pyc\") == \"allow\"\n    assert check_permission(\"delete\", \"__pycache__/test.pyc\") == \"allow\"\n    assert check_permission(\"delete\", \"app.log\") == \"allow\"\n    assert check_permission(\"delete\", \"temp.tmp\") == \"allow\"\n    assert check_permission(\"delete\", \".DS_Store\") == \"allow\"\n    assert check_permission(\"delete\", \"dist/bundle.js\") == \"allow\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 205,
"end": 213,
"text": "def test_permission_delete_important_deny():\n    \"\"\"æµ‹è¯•åˆ é™¤æƒé™ - é‡è¦æ–‡ä»¶ç¦æ­¢\"\"\"\n    assert check_permission(\"delete\", \".env\") == \"deny\"\n    assert check_permission(\"delete\", \"private.key\") == \"deny\"\n    assert check_permission(\"delete\", \".git/config\") == \"deny\"\n    assert check_permission(\"delete\", \"package.json\") == \"deny\"\n    assert check_permission(\"delete\", \"requirements.txt\") == \"deny\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 214,
"end": 222,
"text": "def test_permission_execute_safe_allow():\n    \"\"\"æµ‹è¯•æ‰§è¡Œæƒé™ - å®‰å…¨å‘½ä»¤å…è®¸\"\"\"\n    assert check_permission(\"execute\", \"git status\") == \"allow\"\n    assert check_permission(\"execute\", \"python test.py\") == \"allow\"\n    assert check_permission(\"execute\", \"npm install\") == \"allow\"\n    assert check_permission(\"execute\", \"ls -la\") == \"allow\"\n    assert check_permission(\"execute\", \"cat file.txt\") == \"allow\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 223,
"end": 232,
"text": "def test_permission_execute_dangerous_deny():\n    \"\"\"æµ‹è¯•æ‰§è¡Œæƒé™ - å±é™©å‘½ä»¤ç¦æ­¢\"\"\"\n    assert check_permission(\"execute\", \"rm -rf /\") == \"deny\"\n    assert check_permission(\"execute\", \"rm -rf *\") == \"deny\"\n    assert check_permission(\"execute\", \"dd if=/dev/zero of=/dev/sda\") == \"deny\"\n    assert check_permission(\"execute\", \"mkfs.ext4 /dev/sda\") == \"deny\"\n    assert check_permission(\"execute\", \"while true; do echo 'loop'; done\") == \"deny\"\n    assert check_permission(\"execute\", \":(){ :|:& };:\") == \"deny\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 233,
"end": 241,
"text": "def test_permission_execute_need_confirm():\n    \"\"\"æµ‹è¯•æ‰§è¡Œæƒé™ - éœ€è¦ç¡®è®¤çš„å‘½ä»¤\"\"\"\n    assert check_permission(\"execute\", \"rm file.txt\") == \"ask\"\n    assert check_permission(\"execute\", \"sudo apt install\") == \"ask\"\n    assert check_permission(\"execute\", \"chmod 777 file.txt\") == \"ask\"\n    assert check_permission(\"execute\", \"curl https://example.com\") == \"ask\"\n    assert check_permission(\"execute\", \"ssh user@host\") == \"ask\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 242,
"end": 248,
"text": "def test_permission_external_directory():\n    \"\"\"æµ‹è¯•å¤–éƒ¨ç›®å½•æƒé™\"\"\"\n    assert check_permission(\"external_directory\", \"/tmp/test\") == \"allow\"\n    assert check_permission(\"external_directory\", \"/root/test\") == \"deny\"\n    assert check_permission(\"external_directory\", \"C:\\\\Windows\\\\System32\") == \"deny\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 249,
"end": 256,
"text": "def test_permission_network():\n    \"\"\"æµ‹è¯•ç½‘ç»œæƒé™\"\"\"\n    assert check_permission(\"network\", \"https://api.example.com\") == \"allow\"\n    assert check_permission(\"network\", \"http://localhost:3000\") == \"allow\"\n    assert check_permission(\"network\", \"http://127.0.0.1:8000\") == \"allow\"\n    assert check_permission(\"network\", \"http://example.com\") == \"ask\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 257,
"end": 268,
"text": "def test_permission_add_custom_rule():\n    \"\"\"æµ‹è¯•æ·»åŠ è‡ªå®šä¹‰è§„åˆ™\"\"\"\n    manager = get_permission_manager()\n    \n    # æ·»åŠ è‡ªå®šä¹‰è§„åˆ™\n    manager.add_rule(\"read\", \"*.secret\", \"deny\", priority=5, reason=\"ç»å¯†æ–‡ä»¶\")\n    \n    # éªŒè¯è§„åˆ™ç”Ÿæ•ˆ\n    action = check_permission(\"read\", \"data.secret\")\n    assert action == \"deny\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 269,
"end": 287,
"text": "def test_permission_load_config():\n    \"\"\"æµ‹è¯•ä»é…ç½®åŠ è½½è§„åˆ™\"\"\"\n    manager = get_permission_manager()\n    \n    config = {\n        \"read\": {\n            \"*.custom\": \"deny\"\n        },\n        \"write\": {\n            \"*.readonly\": \"deny\"\n        }\n    }\n    \n    manager.load_config(config)\n    \n    assert check_permission(\"read\", \"file.custom\") == \"deny\"\n    assert check_permission(\"write\", \"file.readonly\") == \"deny\"\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 288,
"end": 300,
"text": "def test_permission_list_categories():\n    \"\"\"æµ‹è¯•åˆ—å‡ºæƒé™ç±»åˆ«\"\"\"\n    manager = get_permission_manager()\n    categories = manager.list_categories()\n    \n    assert \"read\" in categories\n    assert \"write\" in categories\n    assert \"delete\" in categories\n    assert \"execute\" in categories\n    assert \"external_directory\" in categories\n    assert \"network\" in categories\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 301,
"end": 315,
"text": "def test_permission_list_rules():\n    \"\"\"æµ‹è¯•åˆ—å‡ºæƒé™è§„åˆ™\"\"\"\n    manager = get_permission_manager()\n    \n    # åˆ—å‡ºæ‰€æœ‰è§„åˆ™\n    all_rules = manager.list_rules()\n    assert \"read\" in all_rules\n    assert len(all_rules[\"read\"]) > 0\n    \n    # åˆ—å‡ºç‰¹å®šç±»åˆ«çš„è§„åˆ™\n    read_rules = manager.list_rules(\"read\")\n    assert \"read\" in read_rules\n    assert len(read_rules[\"read\"]) > 0\n\n"
},
{
"path": "tests/test_verification_permission.py",
"start": 316,
"end": 329,
"text": "def test_permission_priority():\n    \"\"\"æµ‹è¯•æƒé™ä¼˜å…ˆçº§\"\"\"\n    manager = get_permission_manager()\n    \n    # .env.example çš„ä¼˜å…ˆçº§(5)é«˜äº *.env.*(10)\n    # æ‰€ä»¥ .env.example åº”è¯¥æ˜¯ allow\n    assert check_permission(\"read\", \".env.example\") == \"allow\"\n    \n    # .env.local åŒ¹é… *.env.*(10)ï¼Œåº”è¯¥æ˜¯ ask\n    assert check_permission(\"read\", \".env.local\") == \"ask\"\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\"])"
},
{
"path": "tests/test_workflow_parallel_explore.py",
"start": 1,
"end": 15,
"text": "\"\"\"\næµ‹è¯•WorkflowOrchestratorå’ŒParallelExploreOrchestratorçš„å¢å¼ºåŠŸèƒ½\n\"\"\"\n\nimport asyncio\nimport pytest\nfrom unittest.mock import Mock, AsyncMock, patch\nfrom daoyoucode.agents.orchestrators.workflow import WorkflowOrchestrator\nfrom daoyoucode.agents.orchestrators.parallel_explore import ParallelExploreOrchestrator\n\n\n# ============================================================================\n# WorkflowOrchestrator æµ‹è¯•\n# ============================================================================\n"
},
{
"path": "tests/test_workflow_parallel_explore.py",
"start": 16,
"end": 163,
"text": "class TestWorkflowOrchestrator:\n    \"\"\"æµ‹è¯•WorkflowOrchestratorçš„å¢å¼ºåŠŸèƒ½\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_step_retry_success(self):\n        \"\"\"æµ‹è¯•æ­¥éª¤é‡è¯•æœºåˆ¶ - æˆåŠŸåœºæ™¯\"\"\"\n        orchestrator = WorkflowOrchestrator()\n        \n        # Mock Agentï¼ˆç¬¬ä¸€æ¬¡å¤±è´¥ï¼Œç¬¬äºŒæ¬¡æˆåŠŸï¼‰\n        mock_agent = Mock()\n        attempt = 0\n        \n        async def execute_with_retry(*args, **kwargs):\n            nonlocal attempt\n            attempt += 1\n            if attempt == 1:\n                return {'success': False, 'content': '', 'error': 'ä¸´æ—¶å¤±è´¥'}\n            else:\n                return {'success': True, 'content': 'æˆåŠŸç»“æœ', 'metadata': {}}\n        \n        mock_agent.execute = AsyncMock(side_effect=execute_with_retry)\n        \n        # Mock Skill\n        mock_skill = Mock()\n        mock_skill.workflow = [\n            {\n                'name': 'test_step',\n                'agent': 'test_agent',\n                'max_retries': 3,\n                'timeout': 10.0\n            }\n        ]\n        mock_skill.middleware = None\n        mock_skill.tools = None\n        \n        with patch.object(orchestrator, '_get_agent', return_value=mock_agent):\n            result = await orchestrator.execute(\n                skill=mock_skill,\n                user_input='æµ‹è¯•è¾“å…¥',\n                context={}\n            )\n        \n        assert result['success'] is True\n        assert 'æˆåŠŸç»“æœ' in result['content']\n        assert attempt == 2  # ç¬¬ä¸€æ¬¡å¤±è´¥ï¼Œç¬¬äºŒæ¬¡æˆåŠŸ\n        print(\"âœ… æ­¥éª¤é‡è¯•æœºåˆ¶æµ‹è¯•é€šè¿‡\")\n    \n    @pytest.mark.asyncio\n    async def test_step_dependency(self):\n        \"\"\"æµ‹è¯•æ­¥éª¤ä¾èµ–æ£€æŸ¥\"\"\"\n        orchestrator = WorkflowOrchestrator()\n        \n        # Mock Agent\n        mock_agent = Mock()\n        mock_agent.execute = AsyncMock(return_value={\n            'success': True,\n            'content': 'æ­¥éª¤ç»“æœ',\n            'metadata': {}\n        })\n        \n        # Mock Skillï¼ˆå¸¦ä¾èµ–ï¼‰\n        mock_skill = Mock()\n        mock_skill.workflow = [\n            {\n                'name': 'step1',\n                'agent': 'agent1'\n                # outputé»˜è®¤ä½¿ç”¨æ­¥éª¤åç§°'step1'\n            },\n            {\n                'name': 'step2',\n                'agent': 'agent2',\n                'depends_on': ['step1'],  # ä¾èµ–step1\n                'input': '${step1}'  # ä½¿ç”¨step1çš„ç»“æœ\n            }\n        ]\n        mock_skill.middleware = None\n        mock_skill.tools = None\n        \n        with patch.object(orchestrator, '_get_agent', return_value=mock_agent):\n            result = await orchestrator.execute(\n                skill=mock_skill,\n                user_input='æµ‹è¯•è¾“å…¥',\n                context={}\n            )\n        \n        assert result['success'] is True\n        assert 'step1' in result['workflow_results']\n        assert 'step2' in result['workflow_results']\n        print(\"âœ… æ­¥éª¤ä¾èµ–æ£€æŸ¥æµ‹è¯•é€šè¿‡\")\n    \n    @pytest.mark.asyncio\n    async def test_circular_dependency_detection(self):\n        \"\"\"æµ‹è¯•å¾ªç¯ä¾èµ–æ£€æµ‹\"\"\"\n        orchestrator = WorkflowOrchestrator()\n        \n        # Mock Skillï¼ˆå¾ªç¯ä¾èµ–ï¼‰\n        mock_skill = Mock()\n        mock_skill.workflow = [\n            {\n                'name': 'step1',\n                'agent': 'agent1',\n                'depends_on': ['step2']  # ä¾èµ–step2\n            },\n            {\n                'name': 'step2',\n                'agent': 'agent2',\n                'depends_on': ['step1']  # ä¾èµ–step1 -> å¾ªç¯ï¼\n            }\n        ]\n        mock_skill.middleware = None\n        \n        result = await orchestrator.execute(\n            skill=mock_skill,\n            user_input='æµ‹è¯•è¾“å…¥',\n            context={}\n        )\n        \n        assert result['success'] is False\n        assert 'å¾ªç¯ä¾èµ–' in result['error']\n        print(\"âœ… å¾ªç¯ä¾èµ–æ£€æµ‹æµ‹è¯•é€šè¿‡\")\n    \n    @pytest.mark.asyncio\n    async def test_rollback_on_failure(self):\n        \"\"\"æµ‹è¯•å¤±è´¥å›æ»š\"\"\"\n        orchestrator = WorkflowOrchestrator()\n        \n        # Mock Agents\n        mock_agent1 = Mock()\n        mock_agent1.execute = AsyncMock(return_value={\n            'success': True,\n            'content': 'æ­¥éª¤1æˆåŠŸ',\n            'metadata': {}\n        })\n        \n        moc"
},
{
"path": "tests/test_workflow_parallel_explore.py",
"start": 164,
"end": 242,
"text": "        def get_agent(name):\n            if name == 'agent1':\n                return mock_agent1\n            elif name == 'agent2':\n                return mock_agent2\n            elif name == 'rollback_agent':\n                return mock_rollback_agent\n        \n        # Mock Skillï¼ˆå¸¦å›æ»šï¼‰\n        mock_skill = Mock()\n        mock_skill.workflow = [\n            {\n                'name': 'step1',\n                'agent': 'agent1',\n                'rollback': 'rollback_agent'  # é…ç½®å›æ»šAgent\n            },\n            {\n                'name': 'step2',\n                'agent': 'agent2'\n            }\n        ]\n        mock_skill.middleware = None\n        mock_skill.tools = None\n        \n        with patch.object(orchestrator, '_get_agent', side_effect=get_agent):\n            result = await orchestrator.execute(\n                skill=mock_skill,\n                user_input='æµ‹è¯•è¾“å…¥',\n                context={}\n            )\n        \n        assert result['success'] is False\n        assert result['rollback_executed'] is True\n        assert mock_rollback_agent.execute.called  # å›æ»šAgentè¢«è°ƒç”¨\n        print(\"âœ… å¤±è´¥å›æ»šæµ‹è¯•é€šè¿‡\")\n    \n    @pytest.mark.asyncio\n    async def test_step_timeout(self):\n        \"\"\"æµ‹è¯•æ­¥éª¤è¶…æ—¶\"\"\"\n        orchestrator = WorkflowOrchestrator()\n        \n        # Mock Agentï¼ˆæ¨¡æ‹Ÿæ…¢æ“ä½œï¼‰\n        mock_agent = Mock()\n        \n        async def slow_execute(*args, **kwargs):\n            await asyncio.sleep(2.0)  # ç¡çœ 2ç§’\n            return {'success': True, 'content': 'ç»“æœ', 'metadata': {}}\n        \n        mock_agent.execute = AsyncMock(side_effect=slow_execute)\n        \n        # Mock Skillï¼ˆè¶…æ—¶1ç§’ï¼‰\n        mock_skill = Mock()\n        mock_skill.workflow = [\n            {\n                'name': 'slow_step',\n                'agent': 'test_agent',\n                'timeout': 0.5,  # è¶…æ—¶0.5ç§’\n                'max_retries': 1  # ä¸é‡è¯•\n            }\n        ]\n        mock_skill.middleware = None\n        mock_skill.tools = None\n        \n        with patch.object(orchestrator, '_get_agent', return_value=mock_agent):\n            result = await orchestrator.execute(\n                skill=mock_skill,\n                user_input='æµ‹è¯•è¾“å…¥',\n                context={}\n            )\n        \n        assert result['success'] is False\n        assert 'è¶…æ—¶' in result['error']\n        print(\"âœ… æ­¥éª¤è¶…æ—¶æµ‹è¯•é€šè¿‡\")\n\n\n# ============================================================================\n# ParallelExploreOrchestrator æµ‹è¯•\n# ============================================================================\n"
},
{
"path": "tests/test_workflow_parallel_explore.py",
"start": 243,
"end": 537,
"text": "class TestParallelExploreOrchestrator:\n    \"\"\"æµ‹è¯•ParallelExploreOrchestratorçš„å¢å¼ºåŠŸèƒ½\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_static_background_tasks(self):\n        \"\"\"æµ‹è¯•é™æ€åå°ä»»åŠ¡ï¼ˆç°æœ‰åŠŸèƒ½ï¼‰\"\"\"\n        orchestrator = ParallelExploreOrchestrator()\n        \n        # Mock BackgroundManager\n        mock_bg_manager = Mock()\n        mock_bg_manager.submit = AsyncMock(return_value='task_1')\n        mock_bg_manager.get_result = AsyncMock(return_value={\n            'success': True,\n            'content': 'åå°ç»“æœ'\n        })\n        orchestrator.bg_manager = mock_bg_manager\n        \n        # Mock Agent\n        mock_agent = Mock()\n        mock_agent.execute = AsyncMock(return_value={\n            'success': True,\n            'content': 'ä¸»ä»»åŠ¡ç»“æœ',\n            'metadata': {}\n        })\n        \n        # Mock Skillï¼ˆé™æ€é…ç½®ï¼‰\n        mock_skill = Mock()\n        mock_skill.agent = 'main_agent'\n        mock_skill.prompt = {'use_agent_default': True}\n        mock_skill.tools = None\n        mock_skill.middleware = None\n        mock_skill.use_dynamic_tasks = False\n        mock_skill.use_llm_aggregate = False\n        mock_skill.background_tasks = [\n            {\n                'agent': 'explore',\n                'prompt': 'æœç´¢: {{user_input}}',\n                'timeout': 5.0,\n                'priority': 8\n            }\n        ]\n        \n        with patch.object(orchestrator, '_get_agent', return_value=mock_agent):\n            result = await orchestrator.execute(\n                skill=mock_skill,\n                user_input='æµ‹è¯•æŸ¥è¯¢',\n                context={}\n            )\n        \n        assert result['success'] is True\n        assert 'ä¸»ä»»åŠ¡ç»“æœ' in result['content']\n        assert len(result['background_results']) == 1\n        assert mock_bg_manager.submit.called\n        print(\"âœ… é™æ€åå°ä»»åŠ¡æµ‹è¯•é€šè¿‡\")\n    \n    @pytest.mark.asyncio\n    async def test_dynamic_task_generation(self):\n        \"\"\"æµ‹è¯•åŠ¨æ€ä»»åŠ¡ç”Ÿæˆï¼ˆLLMé©±åŠ¨ï¼‰- æµ‹è¯•é™çº§æœºåˆ¶\"\"\"\n        orchestrator = ParallelExploreOrchestrator()\n        \n        # Mock BackgroundManager\n        mock_bg_manager = Mock()\n        mock_bg_manager.submit = AsyncMock(side_effect=['task_1', 'task_2'])\n        mock_bg_manager.get_result = AsyncMock(return_value={\n            'success': True,\n            'content': 'æ¢ç´¢ç»“æœ'\n        })\n        orchestrator.bg_manager = mock_bg_manager\n        \n        # Mock Agent\n        mock_agent = Mock()\n        mock_agent.execute = AsyncMock(return_value={\n            'success': True,\n            'content': 'ä¸»ä»»åŠ¡ç»“æœ',\n            'metadata': {}\n        })\n        \n        # Mock Skillï¼ˆåŠ¨æ€ç”Ÿæˆï¼Œä½†LLMä¼šå¤±è´¥ï¼Œæµ‹è¯•é™çº§ï¼‰\n        mock_skill = Mock()\n        mock_skill.agent = 'main_agent'\n        mock_skill.prompt = {'use_agent_default': True}\n        mock_skill.tools = None\n        mock_skill.middleware = None\n        mock_skill.use_dynamic_tasks = True\n        mock_skill.use_llm_aggregate = False\n        mock_skill.llm = {'model': 'qwen-turbo'}\n        mock_skill.available_agents = {\n            'explore': 'ä»£ç æ¢ç´¢',\n            'librarian': 'æ–‡æ¡£æŸ¥æ‰¾'\n        }\n        \n        with patch.object(orchestrator, '_get_agent', return_value=mock_agent):\n            result = await orchestrator.execute(\n                skill=mock_skill,\n                user_input='å¦‚ä½•å®ç°ç™»å½•åŠŸèƒ½',\n                context={}\n            )\n        \n        # éªŒè¯ç»“æœï¼ˆLLMå¤±è´¥ä¼šé™çº§ï¼Œè¿”å›ç©ºä»»åŠ¡åˆ—è¡¨ï¼‰\n        assert result['success'] is True\n        assert result['metadata']['dynamic_tasks'] is True\n        # é™çº§æ¨¡å¼ï¼šæ²¡æœ‰ç”Ÿæˆä»»åŠ¡ï¼ˆå› ä¸ºLLMå¤±è´¥ï¼‰\n        print(\"âœ… åŠ¨æ€ä»»åŠ¡ç”Ÿæˆæµ‹è¯•é€šè¿‡ï¼ˆé™çº§æ¨¡å¼ï¼‰\")\n    \n    @pytest.mark.asyncio\n    async def test_llm_smart_aggregation(self):\n        \"\"\"æµ‹è¯•LLMæ™ºèƒ½èšåˆ - æµ‹è¯•é™çº§æœºåˆ¶\"\"\"\n        orchestrator = ParallelExploreOrchestrator()\n        \n        # Mock BackgroundManager\n        mock_bg_manager = Mock()\n        mock_bg_manager.submit = AsyncMock(return_value='task_1')\n        mock_bg_manager.get_result = AsyncMock(return_value={\n            'success': True,\n            'content': 'åå°æ¢ç´¢å‘ç°äº†ç›¸å…³ä»£ç '\n        })\n        orchestrator.bg_manager = mock_bg_manager\n        \n        # Mock Agent\n        mock"
},
{
"path": "tests/test_working_directory.py",
"start": 1,
"end": 106,
"text": "\"\"\"\næµ‹è¯• working_directory è®¾ç½®\n\"\"\"\n\nimport asyncio\nimport os\nimport sys\n\n# æ·»åŠ backendåˆ°è·¯å¾„\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\n\nasync def test_working_directory():\n    \"\"\"æµ‹è¯•å·¥ä½œç›®å½•è®¾ç½®\"\"\"\n    print(\"=\" * 60)\n    print(\"æµ‹è¯• Working Directory è®¾ç½®\")\n    print(\"=\" * 60)\n    \n    # 1. åˆå§‹åŒ–ç³»ç»Ÿ\n    from daoyoucode.agents.init import initialize_agent_system\n    initialize_agent_system()\n    \n    # 2. è·å–é¡¹ç›®æ ¹ç›®å½•\n    project_root = os.path.dirname(os.path.abspath(__file__))\n    print(f\"\\nå½“å‰è„šæœ¬ç›®å½•: {project_root}\")\n    print(f\"é¡¹ç›®æ ¹ç›®å½•åº”è¯¥æ˜¯: {os.path.dirname(project_root)}\")\n    \n    # 3. è®¾ç½®å·¥ä½œç›®å½•\n    from daoyoucode.agents.tools.registry import get_tool_registry\n    registry = get_tool_registry()\n    \n    # ä½¿ç”¨é¡¹ç›®æ ¹ç›®å½•ï¼ˆbackendçš„ä¸Šä¸€çº§ï¼‰\n    actual_root = os.path.dirname(project_root)\n    registry.set_working_directory(actual_root)\n    print(f\"\\nè®¾ç½®å·¥ä½œç›®å½•ä¸º: {actual_root}\")\n    \n    # 4. æµ‹è¯•å·¥å…·\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•å·¥å…·è°ƒç”¨\")\n    print(\"=\" * 60)\n    \n    # æµ‹è¯• list_files\n    print(\"\\n1. æµ‹è¯• list_files\")\n    try:\n        result = await registry.execute_tool(\n            \"list_files\",\n            directory=\"skills/chat-assistant/prompts\",\n            pattern=\"chat_assistant*.md\"\n        )\n        if result.success:\n            print(\"   âœ… list_files è°ƒç”¨æˆåŠŸ\")\n            print(f\"   æ‰¾åˆ° {len(result.content)} ä¸ªæ–‡ä»¶:\")\n            for file in result.content:\n                print(f\"   - {file['name']} ({file['size']} bytes)\")\n                print(f\"     path: {file['path']}\")\n        else:\n            print(f\"   âŒ list_files è°ƒç”¨å¤±è´¥: {result.error}\")\n    except Exception as e:\n        print(f\"   âŒ list_files å¼‚å¸¸: {e}\")\n    \n    # æµ‹è¯• read_file\n    print(\"\\n2. æµ‹è¯• read_file\")\n    try:\n        result = await registry.execute_tool(\n            \"read_file\",\n            file_path=\"skills/chat-assistant/skill.yaml\",\n            encoding=\"utf-8\"\n        )\n        if result.success:\n            print(\"   âœ… read_file è°ƒç”¨æˆåŠŸ\")\n            lines = result.content.split('\\n')[:5]\n            for line in lines:\n                print(f\"   {line}\")\n        else:\n            print(f\"   âŒ read_file è°ƒç”¨å¤±è´¥: {result.error}\")\n    except Exception as e:\n        print(f\"   âŒ read_file å¼‚å¸¸: {e}\")\n    \n    # 5. æµ‹è¯• execute_skill\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯• execute_skill\")\n    print(\"=\" * 60)\n    \n    from daoyoucode.agents.executor import execute_skill\n    \n    context = {\n        \"session_id\": \"test-session\",\n        \"repo\": actual_root,\n        \"working_directory\": actual_root,\n        \"model\": \"qwen-plus\"\n    }\n    \n    print(f\"\\nContext:\")\n    print(f\"  repo: {context['repo']}\")\n    print(f\"  working_directory: {context['working_directory']}\")\n    \n    # æ³¨æ„ï¼šè¿™é‡Œä¸å®é™…æ‰§è¡Œskillï¼Œåªæ˜¯æµ‹è¯•contextä¼ é€’\n    print(\"\\nâœ… Context å‡†å¤‡å®Œæˆ\")\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"æµ‹è¯•å®Œæˆ\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(test_working_directory())"
},
{
"path": "tests/verify_project_understanding_improvements.py",
"start": 1,
"end": 15,
"text": "#!/usr/bin/env python3\n\"\"\"\néªŒè¯é¡¹ç›®ç†è§£ç­–ç•¥æ”¹è¿›\n\næ£€æŸ¥ç‚¹ï¼š\n1. repo_mapé»˜è®¤max_tokensæ”¹ä¸º5000\n2. schemaä¸­defaultå€¼ä¸º5000\n3. æç¤ºè¯ä¸­åŒ…å«æ–‡æ¡£ä¼˜å…ˆç­–ç•¥\n4. æç¤ºè¯ä¸­æœ‰å®Œæ•´çš„ç¤ºä¾‹\n\"\"\"\n\nimport re\nfrom pathlib import Path\n\n"
},
{
"path": "tests/verify_project_understanding_improvements.py",
"start": 16,
"end": 59,
"text": "def check_repomap_default():\n    \"\"\"æ£€æŸ¥repo_mapé»˜è®¤å€¼\"\"\"\n    print(\"=\" * 60)\n    print(\"æ£€æŸ¥1: repo_mapé»˜è®¤max_tokenså€¼\")\n    print(\"=\" * 60)\n    \n    file_path = Path(\"daoyoucode/agents/tools/repomap_tools.py\")\n    content = file_path.read_text(encoding=\"utf-8\")\n    \n    # æ£€æŸ¥executeæ–¹æ³•çš„é»˜è®¤å€¼\n    match = re.search(r'max_tokens: int = (\\d+)', content)\n    if match:\n        default_value = int(match.group(1))\n        if default_value == 5000:\n            print(\"âœ“ executeæ–¹æ³•é»˜è®¤å€¼: 5000\")\n        else:\n            print(f\"âœ— executeæ–¹æ³•é»˜è®¤å€¼é”™è¯¯: {default_value} (åº”è¯¥æ˜¯5000)\")\n            return False\n    else:\n        print(\"âœ— æœªæ‰¾åˆ°max_tokensé»˜è®¤å€¼\")\n        return False\n    \n    # æ£€æŸ¥schemaä¸­çš„default\n    match = re.search(r'\"max_tokens\".*?\"default\": (\\d+)', content, re.DOTALL)\n    if match:\n        schema_default = int(match.group(1))\n        if schema_default == 5000:\n            print(\"âœ“ schemaé»˜è®¤å€¼: 5000\")\n        else:\n            print(f\"âœ— schemaé»˜è®¤å€¼é”™è¯¯: {schema_default} (åº”è¯¥æ˜¯5000)\")\n            return False\n    else:\n        print(\"âœ— æœªæ‰¾åˆ°schemaä¸­çš„default\")\n        return False\n    \n    # æ£€æŸ¥descriptionæ˜¯å¦ä¸€è‡´\n    if '\"é»˜è®¤5000' in content or '\"default\": 5000' in content:\n        print(\"âœ“ descriptionä¸defaultå€¼ä¸€è‡´\")\n    else:\n        print(\"âš  descriptionå¯èƒ½ä¸defaultå€¼ä¸ä¸€è‡´\")\n    \n    return True\n\n"
},
{
"path": "tests/verify_project_understanding_improvements.py",
"start": 60,
"end": 87,
"text": "def check_prompt_improvements():\n    \"\"\"æ£€æŸ¥æç¤ºè¯æ”¹è¿›\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æ£€æŸ¥2: æç¤ºè¯æ”¹è¿›\")\n    print(\"=\" * 60)\n    \n    file_path = Path(\"../skills/chat-assistant/prompts/chat_assistant.md\")\n    content = file_path.read_text(encoding=\"utf-8\")\n    \n    checks = [\n        (\"æ–‡æ¡£ä¼˜å…ˆåŸåˆ™\", \"æ–‡æ¡£ä¼˜å…ˆ\"),\n        (\"max_tokens=5000ç¤ºä¾‹\", \"max_tokens=5000\"),\n        (\"read_file(README.md)ç¤ºä¾‹\", 'read_file(file_path=\"README.md\")'),\n        (\"ç†è§£é¡¹ç›®ç¤ºä¾‹\", \"äº†è§£ä¸‹å½“å‰é¡¹ç›®\"),\n        (\"repo_mapåªåŒ…å«ä»£ç è¯´æ˜\", \"åªåŒ…å«ä»£ç æ–‡ä»¶\"),\n    ]\n    \n    all_passed = True\n    for name, keyword in checks:\n        if keyword in content:\n            print(f\"âœ“ {name}\")\n        else:\n            print(f\"âœ— ç¼ºå°‘: {name}\")\n            all_passed = False\n    \n    return all_passed\n\n"
},
{
"path": "tests/verify_project_understanding_improvements.py",
"start": 88,
"end": 118,
"text": "def check_documentation():\n    \"\"\"æ£€æŸ¥æ–‡æ¡£æ›´æ–°\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"æ£€æŸ¥3: æ–‡æ¡£å®Œæ•´æ€§\")\n    print(\"=\" * 60)\n    \n    file_path = Path(\"SMART_REPO_MAP.md\")\n    if file_path.exists():\n        content = file_path.read_text(encoding=\"utf-8\")\n        \n        checks = [\n            (\"Tokené¢„ç®—è¯´æ˜\", \"Token é¢„ç®—\"),\n            (\"PageRankè¯´æ˜\", \"PageRank\"),\n            (\"ç¼“å­˜æœºåˆ¶è¯´æ˜\", \"SQLite\"),\n            (\"æ€§èƒ½æ•°æ®\", \"æ€§èƒ½æ•°æ®\"),\n        ]\n        \n        all_passed = True\n        for name, keyword in checks:\n            if keyword in content:\n                print(f\"âœ“ {name}\")\n            else:\n                print(f\"âœ— ç¼ºå°‘: {name}\")\n                all_passed = False\n        \n        return all_passed\n    else:\n        print(\"âœ— SMART_REPO_MAP.mdä¸å­˜åœ¨\")\n        return False\n\n"
},
{
"path": "tests/verify_project_understanding_improvements.py",
"start": 119,
"end": 158,
"text": "def main():\n    print(\"éªŒè¯é¡¹ç›®ç†è§£ç­–ç•¥æ”¹è¿›\\n\")\n    \n    results = []\n    \n    # æ£€æŸ¥1: repo_mapé»˜è®¤å€¼\n    results.append((\"repo_mapé»˜è®¤å€¼\", check_repomap_default()))\n    \n    # æ£€æŸ¥2: æç¤ºè¯æ”¹è¿›\n    results.append((\"æç¤ºè¯æ”¹è¿›\", check_prompt_improvements()))\n    \n    # æ£€æŸ¥3: æ–‡æ¡£\n    results.append((\"æ–‡æ¡£å®Œæ•´æ€§\", check_documentation()))\n    \n    # æ€»ç»“\n    print(\"\\n\" + \"=\" * 60)\n    print(\"éªŒè¯æ€»ç»“\")\n    print(\"=\" * 60)\n    \n    for name, passed in results:\n        status = \"âœ“ é€šè¿‡\" if passed else \"âœ— å¤±è´¥\"\n        print(f\"{status}: {name}\")\n    \n    all_passed = all(r[1] for r in results)\n    \n    if all_passed:\n        print(\"\\nğŸ‰ æ‰€æœ‰æ£€æŸ¥é€šè¿‡ï¼\")\n        print(\"\\næ”¹è¿›å†…å®¹ï¼š\")\n        print(\"1. repo_mapé»˜è®¤max_tokensä»2000æ”¹ä¸º5000\")\n        print(\"2. æç¤ºè¯å¢åŠ æ–‡æ¡£ä¼˜å…ˆç­–ç•¥\")\n        print(\"3. æç¤ºè¯å¢åŠ å®Œæ•´çš„é¡¹ç›®ç†è§£ç¤ºä¾‹\")\n        print(\"4. schemaæè¿°ä¸é»˜è®¤å€¼ä¿æŒä¸€è‡´\")\n        return 0\n    else:\n        print(\"\\nâŒ éƒ¨åˆ†æ£€æŸ¥å¤±è´¥ï¼Œè¯·ä¿®å¤\")\n        return 1\n\n\nif __name__ == \"__main__\":\n    exit(main())"
},
{
"path": "tests/verify_react_docs.py",
"start": 1,
"end": 14,
"text": "\"\"\"\néªŒè¯ReActç¼–æ’å™¨é¢„ç•™æ–¹æ³•çš„æ–‡æ¡£æ”¹è¿›\n\næ£€æŸ¥ï¼š\n1. æ‰€æœ‰é¢„ç•™æ–¹æ³•éƒ½æœ‰ [é¢„ç•™æ–¹æ³•] æ ‡è®°\n2. æ–‡æ¡£åŒ…å«åŠŸèƒ½è¯´æ˜ã€å‚æ•°ã€è¿”å›å€¼\n3. æ–‡æ¡£æåˆ°æµ‹è¯•æ–‡ä»¶æˆ–ä½¿ç”¨åœºæ™¯\n\"\"\"\n\nimport inspect\nimport sys\nfrom daoyoucode.agents.orchestrators.react import ReActOrchestrator\n\n"
},
{
"path": "tests/verify_react_docs.py",
"start": 15,
"end": 93,
"text": "def verify_method_docs():\n    \"\"\"éªŒè¯é¢„ç•™æ–¹æ³•çš„æ–‡æ¡£\"\"\"\n    \n    # é¢„ç•™æ–¹æ³•åˆ—è¡¨\n    reserved_methods = [\n        '_plan',\n        '_approve', \n        '_execute_plan',\n        '_execute_step',\n        '_observe',\n        '_verify',\n        '_reflect'\n    ]\n    \n    orchestrator = ReActOrchestrator()\n    \n    print(\"=\" * 70)\n    print(\"éªŒè¯ReActç¼–æ’å™¨é¢„ç•™æ–¹æ³•çš„æ–‡æ¡£\")\n    print(\"=\" * 70)\n    \n    all_passed = True\n    \n    for method_name in reserved_methods:\n        print(f\"\\næ£€æŸ¥æ–¹æ³•: {method_name}\")\n        print(\"-\" * 70)\n        \n        method = getattr(orchestrator, method_name, None)\n        if not method:\n            print(f\"  âŒ æ–¹æ³•ä¸å­˜åœ¨\")\n            all_passed = False\n            continue\n        \n        doc = inspect.getdoc(method)\n        if not doc:\n            print(f\"  âŒ ç¼ºå°‘æ–‡æ¡£\")\n            all_passed = False\n            continue\n        \n        # æ£€æŸ¥æ˜¯å¦æœ‰ [é¢„ç•™æ–¹æ³•] æ ‡è®°\n        has_reserved_tag = '[é¢„ç•™æ–¹æ³•]' in doc\n        print(f\"  {'âœ…' if has_reserved_tag else 'âŒ'} [é¢„ç•™æ–¹æ³•] æ ‡è®°: {has_reserved_tag}\")\n        \n        # æ£€æŸ¥æ˜¯å¦æœ‰åŠŸèƒ½è¯´æ˜\n        has_functionality = 'åŠŸèƒ½ï¼š' in doc or 'åŠŸèƒ½:' in doc\n        print(f\"  {'âœ…' if has_functionality else 'âŒ'} åŠŸèƒ½è¯´æ˜: {has_functionality}\")\n        \n        # æ£€æŸ¥æ˜¯å¦æœ‰å‚æ•°è¯´æ˜\n        has_args = 'Args:' in doc\n        print(f\"  {'âœ…' if has_args else 'âŒ'} å‚æ•°è¯´æ˜: {has_args}\")\n        \n        # æ£€æŸ¥æ˜¯å¦æœ‰è¿”å›å€¼è¯´æ˜\n        has_returns = 'Returns:' in doc\n        print(f\"  {'âœ…' if has_returns else 'âŒ'} è¿”å›å€¼è¯´æ˜: {has_returns}\")\n        \n        # æ£€æŸ¥æ˜¯å¦æåˆ°æµ‹è¯•æˆ–ä½¿ç”¨åœºæ™¯\n        has_test_ref = 'test_advanced_features' in doc or 'æµ‹è¯•ï¼š' in doc or 'æµ‹è¯•:' in doc\n        has_usage = 'ç”¨äº' in doc or 'ä½¿ç”¨åœºæ™¯' in doc or 'æ³¨æ„ï¼š' in doc or 'æ³¨æ„:' in doc\n        has_context = has_test_ref or has_usage\n        print(f\"  {'âœ…' if has_context else 'âŒ'} æµ‹è¯•/ä½¿ç”¨åœºæ™¯: {has_context}\")\n        \n        # æ˜¾ç¤ºæ–‡æ¡£å‰200å­—ç¬¦\n        print(f\"\\n  æ–‡æ¡£é¢„è§ˆ:\")\n        preview = doc[:200].replace('\\n', '\\n  ')\n        print(f\"  {preview}...\")\n        \n        if not (has_reserved_tag and has_functionality and has_args and has_returns and has_context):\n            all_passed = False\n    \n    print(\"\\n\" + \"=\" * 70)\n    if all_passed:\n        print(\"âœ… æ‰€æœ‰é¢„ç•™æ–¹æ³•çš„æ–‡æ¡£éƒ½ç¬¦åˆè¦æ±‚ï¼\")\n        return 0\n    else:\n        print(\"âŒ éƒ¨åˆ†æ–¹æ³•çš„æ–‡æ¡£éœ€è¦æ”¹è¿›\")\n        return 1\n\n\nif __name__ == '__main__':\n    sys.exit(verify_method_docs())"
},
{
"path": "tests/verify_timeout_config.py",
"start": 1,
"end": 12,
"text": "#!/usr/bin/env python3\n\"\"\"\néªŒè¯è¶…æ—¶é…ç½®æ˜¯å¦æ­£ç¡®\n\næ£€æŸ¥æ‰€æœ‰è¶…æ—¶é…ç½®æ˜¯å¦ç»Ÿä¸€ä¸º 1800 ç§’ï¼ˆ30åˆ†é’Ÿï¼‰\n\"\"\"\n\nimport yaml\nimport sys\nfrom pathlib import Path\n\n"
},
{
"path": "tests/verify_timeout_config.py",
"start": 13,
"end": 29,
"text": "def check_config_file():\n    \"\"\"æ£€æŸ¥é…ç½®æ–‡ä»¶\"\"\"\n    config_path = Path(__file__).parent / \"config\" / \"llm_config.yaml\"\n    \n    with open(config_path, 'r', encoding='utf-8') as f:\n        config = yaml.safe_load(f)\n    \n    timeout = config.get('default', {}).get('timeout')\n    \n    if timeout == 1800:\n        print(f\"âœ… é…ç½®æ–‡ä»¶è¶…æ—¶: {timeout}ç§’ (30åˆ†é’Ÿ)\")\n        return True\n    else:\n        print(f\"âŒ é…ç½®æ–‡ä»¶è¶…æ—¶: {timeout}ç§’ (åº”è¯¥æ˜¯ 1800)\")\n        return False\n\n"
},
{
"path": "tests/verify_timeout_config.py",
"start": 30,
"end": 44,
"text": "def check_client_manager():\n    \"\"\"æ£€æŸ¥ client_manager.py\"\"\"\n    file_path = Path(__file__).parent / \"daoyoucode\" / \"agents\" / \"llm\" / \"client_manager.py\"\n    \n    with open(file_path, 'r', encoding='utf-8') as f:\n        content = f.read()\n    \n    if \"timeout=httpx.Timeout(1800.0)\" in content:\n        print(\"âœ… HTTP å®¢æˆ·ç«¯è¶…æ—¶: 1800ç§’ (30åˆ†é’Ÿ)\")\n        return True\n    else:\n        print(\"âŒ HTTP å®¢æˆ·ç«¯è¶…æ—¶é…ç½®ä¸æ­£ç¡®\")\n        return False\n\n"
},
{
"path": "tests/verify_timeout_config.py",
"start": 45,
"end": 71,
"text": "def check_unified_client():\n    \"\"\"æ£€æŸ¥ unified.py\"\"\"\n    file_path = Path(__file__).parent / \"daoyoucode\" / \"agents\" / \"llm\" / \"clients\" / \"unified.py\"\n    \n    with open(file_path, 'r', encoding='utf-8') as f:\n        content = f.read()\n    \n    # æ£€æŸ¥åŒæ­¥è¯·æ±‚\n    sync_ok = \"timeout=1800.0\" in content\n    \n    # æ£€æŸ¥æµå¼è¯·æ±‚\n    stream_ok = content.count(\"timeout=1800.0\") >= 2\n    \n    if sync_ok and stream_ok:\n        print(\"âœ… å•æ¬¡è¯·æ±‚è¶…æ—¶: 1800ç§’ (30åˆ†é’Ÿ)\")\n        print(\"   - åŒæ­¥è¯·æ±‚: âœ…\")\n        print(\"   - æµå¼è¯·æ±‚: âœ…\")\n        return True\n    else:\n        print(\"âŒ å•æ¬¡è¯·æ±‚è¶…æ—¶é…ç½®ä¸æ­£ç¡®\")\n        if not sync_ok:\n            print(\"   - åŒæ­¥è¯·æ±‚: âŒ\")\n        if not stream_ok:\n            print(\"   - æµå¼è¯·æ±‚: âŒ\")\n        return False\n\n"
},
{
"path": "tests/verify_timeout_config.py",
"start": 72,
"end": 118,
"text": "def main():\n    \"\"\"ä¸»å‡½æ•°\"\"\"\n    print(\"=\" * 60)\n    print(\"éªŒè¯è¶…æ—¶é…ç½®\")\n    print(\"=\" * 60)\n    print()\n    \n    results = []\n    \n    # æ£€æŸ¥é…ç½®æ–‡ä»¶\n    print(\"1. æ£€æŸ¥é…ç½®æ–‡ä»¶ (llm_config.yaml)\")\n    results.append(check_config_file())\n    print()\n    \n    # æ£€æŸ¥ client_manager\n    print(\"2. æ£€æŸ¥ HTTP å®¢æˆ·ç«¯ (client_manager.py)\")\n    results.append(check_client_manager())\n    print()\n    \n    # æ£€æŸ¥ unified client\n    print(\"3. æ£€æŸ¥å•æ¬¡è¯·æ±‚ (unified.py)\")\n    results.append(check_unified_client())\n    print()\n    \n    # æ€»ç»“\n    print(\"=\" * 60)\n    if all(results):\n        print(\"âœ… æ‰€æœ‰è¶…æ—¶é…ç½®æ­£ç¡®ï¼\")\n        print()\n        print(\"è¶…æ—¶æ—¶é—´: 1800ç§’ (30åˆ†é’Ÿ)\")\n        print()\n        print(\"æ”¯æŒçš„åœºæ™¯:\")\n        print(\"  â€¢ ç®€å•æŸ¥è¯¢: 10-30ç§’\")\n        print(\"  â€¢ ä¸­ç­‰å¤æ‚åº¦: 30-90ç§’\")\n        print(\"  â€¢ å¤æ‚æŸ¥è¯¢: 90-180ç§’\")\n        print(\"  â€¢ å¤§è§„æ¨¡æ“ä½œ: 180-1200ç§’ (3-20åˆ†é’Ÿ)\")\n        print(\"  â€¢ æç«¯æƒ…å†µ: 1200-1800ç§’ (20-30åˆ†é’Ÿ)\")\n        print()\n        return 0\n    else:\n        print(\"âŒ éƒ¨åˆ†é…ç½®ä¸æ­£ç¡®ï¼Œè¯·æ£€æŸ¥ï¼\")\n        print()\n        return 1\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())"
}
],
"repo": "D:\\daoyouspace\\daoyoucode\\backend"
}