# 如何将LSP/AST的结构化理解传递给大模型

## 核心问题

大模型只能理解文本，但LSP/AST提供的是结构化信息（类型、引用、AST节点）。如何桥接这个鸿沟？

## 答案：结构化信息 → 富文本 → 大模型

```
┌─────────────┐      ┌──────────────┐      ┌──────────────┐
│  LSP/AST    │      │  富文本格式   │      │   大模型     │
│  结构化信息  │ ───► │  (Markdown)  │ ───► │   理解+生成  │
└─────────────┘      └──────────────┘      └──────────────┘
     │                      │                      │
     │                      │                      │
     ▼                      ▼                      ▼
  类型、引用            格式化文本            生成代码
  AST节点              上下文增强            智能推理
```

## 方法1：增强代码块的上下文

### 当前方式（基础）

```python
# 当前的semantic_code_search返回
result = """
[1] backend/agents/executor.py (L100-150)
```python
async def execute_skill(skill_name: str, user_input: str):
    skill = get_skill(skill_name)
    return await skill.execute(user_input)
```
"""
```

**问题**：大模型只看到代码，不知道类型、引用关系。

### 优化方式（LSP增强）

```python
# LSP增强后的返回
result = """
[1] backend/agents/executor.py (L100-150) ⭐ 高质量代码
📊 代码质量指标:
  - 类型注解: ✅ 完整
  - 文档字符串: ✅ 有
  - 引用次数: 23次 (核心函数)
  - 复杂度: 中等

📝 函数签名:
```python
async def execute_skill(
    skill_name: str,           # 技能名称
    user_input: str,           # 用户输入
    session_id: Optional[str], # 会话ID
    context: Dict[str, Any]    # 上下文
) -> Dict[str, Any]:           # 返回: 执行结果
```

🔗 调用关系:
  被调用于:
    - cli/commands/chat.py:handle_chat() (L520)
    - tests/test_executor.py:test_execute() (L45)
  调用了:
    - core/skill.py:get_skill() (L89)
    - orchestrators/react.py:execute() (L234)

💡 使用示例:
```python
result = await execute_skill(
    skill_name="chat-assistant",
    user_input="你好",
    session_id="abc123",
    context={"repo": "/path/to/repo"}
)
```

📄 完整代码:
```python
async def execute_skill(skill_name: str, user_input: str, ...):
    \"\"\"执行技能
    
    Args:
        skill_name: 技能名称
        user_input: 用户输入
        ...
    
    Returns:
        执行结果字典
    \"\"\"
    skill = get_skill(skill_name)
    return await skill.execute(user_input)
```
"""
```

**效果**：大模型现在知道：
- ✅ 这是一个核心函数（被调用23次）
- ✅ 有完整的类型注解
- ✅ 调用关系清晰
- ✅ 有使用示例

## 方法2：构建结构化Prompt

### 场景：用户问"如何使用execute_skill？"

#### 传统方式

```python
prompt = f"""
用户问题: {user_input}

相关代码:
{search_results}

请回答用户的问题。
"""
```

#### LSP/AST增强方式

```python
prompt = f"""
用户问题: {user_input}

# 代码库理解

## 1. 核心函数分析

### execute_skill() - 技能执行器
**位置**: backend/agents/executor.py:100-150
**类型**: async function
**质量**: ⭐⭐⭐⭐⭐ (5/5)

**函数签名**:
```python
async def execute_skill(
    skill_name: str,           # 必需: 技能名称
    user_input: str,           # 必需: 用户输入
    session_id: Optional[str], # 可选: 会话ID
    context: Dict[str, Any]    # 可选: 上下文
) -> Dict[str, Any]:           # 返回: {success, content, error}
```

**参数说明**:
- `skill_name`: 可用值: "chat-assistant", "sisyphus-orchestrator", "oracle"
- `user_input`: 用户的自然语言输入
- `session_id`: 用于记忆系统，可以为None
- `context`: 包含repo路径、初始文件等

**返回值结构**:
```python
{{
    "success": bool,      # 是否成功
    "content": str,       # AI响应内容
    "error": str,         # 错误信息（如果失败）
    "task_id": str        # 任务ID
}}
```

**调用链**:
```
用户输入
  ↓
cli/commands/chat.py:handle_chat()
  ↓
agents/executor.py:execute_skill()  ← 当前函数
  ↓
core/skill.py:get_skill()
  ↓
orchestrators/react.py:execute()
  ↓
返回结果
```

**使用示例**:
```python
# 示例1: 基础使用
result = await execute_skill(
    skill_name="chat-assistant",
    user_input="你好，介绍一下项目"
)

# 示例2: 带会话ID
result = await execute_skill(
    skill_name="chat-assistant",
    user_input="继续上次的话题",
    session_id="user123_session456"
)

# 示例3: 带上下文
result = await execute_skill(
    skill_name="sisyphus-orchestrator",
    user_input="重构登录模块",
    context={{
        "repo": "/path/to/project",
        "initial_files": ["auth/login.py"]
    }}
)
```

**常见错误**:
1. ❌ `Skill 'xxx' not found` - 技能名称错误
   解决: 使用list_skills()查看可用技能
   
2. ❌ `No working_directory in context` - 缺少repo路径
   解决: 在context中提供repo或working_directory

**相关函数**:
- `list_skills()` - 列出所有可用技能
- `get_skill_info(name)` - 获取技能详细信息

## 2. 类型系统

本项目使用Python类型注解，主要类型:
- `str`: 字符串
- `Dict[str, Any]`: 字典（键为字符串，值为任意类型）
- `Optional[str]`: 可选字符串（可以为None）
- `List[Path]`: 路径列表

## 3. 异步编程

本项目大量使用async/await:
```python
# ✅ 正确: 使用await
result = await execute_skill(...)

# ❌ 错误: 忘记await
result = execute_skill(...)  # 这会返回coroutine对象
```

---

基于以上理解，请回答用户的问题: {user_input}
"""
```

**效果**：
- ✅ 大模型理解了函数的完整上下文
- ✅ 知道参数类型和返回值结构
- ✅ 了解调用链和使用示例
- ✅ 知道常见错误和解决方案

## 方法3：实时类型检查反馈

### 场景：大模型生成代码

#### 传统方式

```python
# 1. 大模型生成代码
generated_code = llm.generate(prompt)

# 2. 直接返回给用户
return generated_code
```

**问题**：生成的代码可能有类型错误。

#### LSP增强方式

```python
# 1. 大模型生成代码
generated_code = llm.generate(prompt)

# 2. 使用LSP检查
diagnostics = await lsp_diagnostics(generated_code)

# 3. 如果有错误，让大模型修复
if diagnostics:
    fix_prompt = f"""
你生成的代码有以下问题:

{format_diagnostics(diagnostics)}

原始代码:
```python
{generated_code}
```

请修复这些问题。注意:
- 确保所有变量都有正确的类型注解
- 导入缺失的模块
- 修复类型不匹配的问题
"""
    
    fixed_code = llm.generate(fix_prompt)
    
    # 4. 再次检查
    diagnostics2 = await lsp_diagnostics(fixed_code)
    
    if not diagnostics2:
        return fixed_code
    else:
        # 最多重试3次
        ...

# 5. 返回正确的代码
return generated_code
```

**效果**：
- ✅ 生成的代码类型正确
- ✅ 自动导入缺失的模块
- ✅ 减少用户手动修复的工作

## 方法4：构建代码知识图谱

### 概念

将代码库转换为知识图谱，然后用自然语言描述给大模型。

```
代码库
  ↓
LSP/AST分析
  ↓
知识图谱
  ↓
自然语言描述
  ↓
大模型理解
```

### 示例

```python
# 1. 构建知识图谱
knowledge_graph = {
    "nodes": [
        {
            "id": "execute_skill",
            "type": "function",
            "file": "executor.py",
            "line": 100,
            "signature": "async def execute_skill(...) -> Dict",
            "quality_score": 0.95
        },
        {
            "id": "get_skill",
            "type": "function",
            "file": "skill.py",
            "line": 89
        }
    ],
    "edges": [
        {
            "from": "execute_skill",
            "to": "get_skill",
            "type": "calls",
            "count": 1
        }
    ]
}

# 2. 转换为自然语言
description = """
代码库架构:

核心模块:
1. executor.py - 技能执行器
   - execute_skill() - 主入口函数 (质量: 95%)
     调用: get_skill(), orchestrator.execute()
     被调用: handle_chat() (23次)

2. skill.py - 技能管理
   - get_skill() - 获取技能实例
     被调用: execute_skill()

调用流程:
用户输入 → handle_chat() → execute_skill() → get_skill() → orchestrator.execute()

关键发现:
- execute_skill() 是核心函数，被调用23次
- 所有技能执行都经过这个函数
- 有完整的类型注解和错误处理
"""

# 3. 传递给大模型
prompt = f"""
{description}

用户问题: {user_input}

基于以上架构理解，请回答...
"""
```

## 方法5：工具调用增强

### 概念

让大模型主动调用LSP/AST工具获取信息。

### 示例

```python
# 大模型可用的工具
tools = [
    {
        "name": "lsp_goto_definition",
        "description": "跳转到符号定义，了解函数/类的实现位置",
        "parameters": {
            "file": "文件路径",
            "line": "行号",
            "character": "列号"
        }
    },
    {
        "name": "lsp_find_references",
        "description": "查找符号的所有引用，了解函数/类在哪里被使用",
        "parameters": {
            "file": "文件路径",
            "line": "行号",
            "character": "列号"
        }
    },
    {
        "name": "ast_grep_search",
        "description": "使用AST模式搜索代码结构",
        "parameters": {
            "pattern": "AST模式",
            "language": "编程语言"
        }
    }
]

# 对话流程
user: "execute_skill函数在哪里被调用？"

llm: 我需要查找execute_skill的引用
     → 调用工具: lsp_find_references("executor.py", 100, 10)

tool_result: [
    {"file": "chat.py", "line": 520, "context": "result = await execute_skill(...)"},
    {"file": "test_executor.py", "line": 45, "context": "await execute_skill(...)"}
]

llm: execute_skill函数在以下位置被调用:
     1. chat.py:520 - 在handle_chat()中调用
     2. test_executor.py:45 - 在测试中调用
     
     这说明它是CLI命令的核心入口。
```

## 实际应用：增强semantic_code_search

### 当前实现

```python
# backend/daoyoucode/agents/tools/codebase_search_tool.py

async def execute(self, query: str, top_k: int = 8):
    results = search_codebase(path, query, top_k)
    
    # 简单格式化
    lines = []
    for r in results:
        lines.append(f"[{i}] {r['path']} (L{r['start']}-{r['end']})")
        lines.append(f"```\n{r['text']}\n```")
    
    return "\n\n".join(lines)
```

### LSP/AST增强实现

```python
async def execute(self, query: str, top_k: int = 8, enable_lsp: bool = True):
    # 1. 使用LSP增强检索
    results = await search_codebase_with_lsp(path, query, top_k, enable_lsp)
    
    # 2. 富文本格式化
    lines = []
    for i, r in enumerate(results, 1):
        # 基础信息
        lines.append(f"[{i}] {r['path']} (L{r['start']}-{r['end']})")
        
        # 质量指标
        if r.get('has_lsp_info'):
            quality_stars = "⭐" * min(5, r.get('symbol_count', 0))
            lines.append(f"质量: {quality_stars}")
            
            if r.get('has_type_annotations'):
                lines.append("✅ 有类型注解")
            
            if r.get('reference_count', 0) > 10:
                lines.append(f"🔥 热点代码 (被引用{r['reference_count']}次)")
        
        # 类型信息
        if r.get('lsp_symbols'):
            lines.append("\n📝 符号信息:")
            for sym in r['lsp_symbols'][:3]:  # 最多3个
                lines.append(f"  - {sym['name']}: {sym.get('detail', 'N/A')}")
        
        # 代码
        lines.append(f"\n```{r.get('language', 'python')}")
        lines.append(r['text'])
        lines.append("```")
        
        # 使用提示
        if r.get('has_type_annotations') and r.get('reference_count', 0) > 10:
            lines.append("\n💡 这是一个核心函数，建议仔细阅读")
    
    return "\n\n".join(lines)
```

### 效果对比

#### 传统输出

```
[1] executor.py (L100-150)
```python
async def execute_skill(skill_name, user_input):
    skill = get_skill(skill_name)
    return await skill.execute(user_input)
```
```

#### LSP增强输出

```
[1] executor.py (L100-150)
质量: ⭐⭐⭐⭐⭐
✅ 有类型注解
🔥 热点代码 (被引用23次)

📝 符号信息:
  - execute_skill: async (skill_name: str, user_input: str) -> Dict[str, Any]
  - skill: Skill
  - result: Dict[str, Any]

```python
async def execute_skill(
    skill_name: str,
    user_input: str,
    session_id: Optional[str] = None,
    context: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """执行技能
    
    Args:
        skill_name: 技能名称
        user_input: 用户输入
        session_id: 会话ID
        context: 上下文
    
    Returns:
        执行结果
    """
    skill = get_skill(skill_name)
    return await skill.execute(user_input, context)
```

💡 这是一个核心函数，建议仔细阅读
```

**大模型现在能理解**：
- ✅ 这是一个高质量的核心函数
- ✅ 有完整的类型注解
- ✅ 被频繁调用（热点代码）
- ✅ 参数和返回值的类型
- ✅ 函数的用途和使用方式

## 总结

### LSP/AST → 大模型的桥梁

1. **富文本格式化** - 将结构化信息转换为易读的文本
2. **结构化Prompt** - 构建包含类型、引用、示例的完整上下文
3. **实时验证** - 使用LSP检查生成的代码
4. **知识图谱** - 将代码关系转换为自然语言描述
5. **工具调用** - 让大模型主动获取LSP/AST信息

### 关键价值

- ✅ 大模型理解更深入（不只是代码文本，还有类型、引用、质量）
- ✅ 生成代码更准确（有类型检查和验证）
- ✅ 回答更专业（基于结构化理解）
- ✅ 用户体验更好（得到更有用的信息）

### 实施优先级

1. **立即实施**：富文本格式化（修改semantic_code_search的输出）
2. **短期实施**：结构化Prompt（在Agent的system prompt中添加）
3. **中期实施**：实时验证（在代码生成后使用LSP检查）
4. **长期实施**：知识图谱（构建完整的代码理解系统）

这就是LSP/AST和大模型的完美结合！🎯
