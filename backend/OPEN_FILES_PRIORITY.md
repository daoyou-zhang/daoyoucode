# 打开文件优先策略

## 问题场景

```
用户: "看看当前项目，针对llm超时报错，有什么优化建议？"

打开的文件：
- timeout_recovery.py
- timeout_handler.py
- executor.py

AI 行为：
🔧 执行工具: text_search
query: timeout
file_pattern: **/*.py

问题：为什么要搜索？文件已经打开了！
```

---

## 根本原因

AI 没有意识到：
1. **"当前项目"通常指打开的文件**
2. **打开的文件名已经暗示了相关性**（timeout_recovery.py 明显与"超时"相关）
3. **应该先检查打开的文件，再考虑搜索**

---

## 解决方案

### 在 Prompt 中强调"打开的文件优先"

#### 1. Step 0 检查清单（调整顺序）

```markdown
检查清单（按顺序）：
1. ⭐ 是否有打开的编辑器文件？（最重要！）
   - 用户说"当前项目"、"看看代码"、"这个项目" → 很可能指打开的文件
   - 检查打开的文件名是否与用户问题相关
   - 如果有相关文件已打开 → 直接读取，不要搜索！

2. 用户是否在继续之前的对话？
   ...

3. 用户的请求是否与最近的工作相关？
   ...
```

**关键变化**：
- 把"打开的文件"从第2条提到第1条
- 强调"最重要"
- 明确"不要搜索"

#### 2. 重要原则（新增第1条）

```markdown
1. **打开的文件优先** ⭐⭐⭐ 最最重要:
   - **用户说"当前项目"、"看看代码" → 99%指打开的文件**
   - **在调用任何搜索工具前，先检查打开的编辑器文件**
   - 如果打开的文件名与问题相关 → 直接读取
   - 只有在打开的文件不相关时，才使用搜索工具
```

#### 3. 添加具体示例

```markdown
**常见错误示例**：
- ❌ 用户说"看看当前项目的超时处理"，打开了 timeout_recovery.py，AI却去 text_search

**正确做法**：
- ✅ 用户说"看看当前项目的超时" + 打开了 timeout_recovery.py → 直接 read_file
```

---

## 预期效果

### 改进前

```
用户: "看看当前项目，针对llm超时报错，有什么优化建议？"

打开的文件: timeout_recovery.py, timeout_handler.py

AI:
→ text_search("timeout") 
→ 找到一堆结果
→ 可能找不到（索引问题）
→ 或者找到了但还要再读取
```

### 改进后

```
用户: "看看当前项目，针对llm超时报错，有什么优化建议？"

打开的文件: timeout_recovery.py, timeout_handler.py

AI:
[检查上下文]
- 打开的文件：timeout_recovery.py, timeout_handler.py
- 文件名包含 "timeout" → 与用户问题相关
- 用户说"当前项目" → 很可能指这些打开的文件

[直接读取]
→ read_file("backend/daoyoucode/agents/core/timeout_recovery.py")
→ read_file("backend/daoyoucode/agents/core/timeout_handler.py")
→ 基于代码给出优化建议
```

---

## 关键信号词

| 用户说 | 含义 | 正确做法 |
|--------|------|----------|
| "当前项目" | 打开的文件 | 检查打开的文件 |
| "看看代码" | 打开的文件 | 检查打开的文件 |
| "这个项目" | 打开的文件 | 检查打开的文件 |
| "这些文件" | 打开的文件 | 检查打开的文件 |
| "目前的实现" | 打开的文件 | 检查打开的文件 |
| "现有代码" | 可能是打开的文件 | 先检查打开的文件 |

---

## 判断逻辑

```
用户问题 + 打开的文件 → 判断相关性

例子1:
- 用户问："超时优化建议"
- 打开文件：timeout_recovery.py, timeout_handler.py
- 判断：文件名包含 "timeout" → 相关 ✅
- 行动：直接读取这些文件

例子2:
- 用户问："超时优化建议"
- 打开文件：agent.py, executor.py
- 判断：文件名不包含 "timeout" → 可能不相关 ⚠️
- 行动：可以先读取（可能有超时相关代码），或者搜索

例子3:
- 用户问："超时优化建议"
- 打开文件：README.md, package.json
- 判断：明显不相关 ❌
- 行动：使用搜索工具

例子4:
- 用户问："了解整个项目"
- 打开文件：任何文件
- 判断：不是问具体文件 ❌
- 行动：使用 discover_project_docs, get_repo_structure
```

---

## 为什么这很重要？

### 1. 用户体验
- 用户打开文件 = 明确的意图信号
- 忽略打开的文件 = 让用户觉得 AI 不理解上下文

### 2. 效率
- 直接读取 vs 搜索 → 节省时间
- 避免搜索失败的风险

### 3. 准确性
- 打开的文件 = 用户已经筛选过的相关文件
- 搜索结果 = 可能不相关或遗漏

---

## 实施位置

**文件**: `skills/chat-assistant/prompts/chat_assistant.md`

**修改内容**:
1. Step 0 检查清单 - 把"打开的文件"提到第1位
2. 重要原则 - 新增"打开的文件优先"作为第1条
3. 添加具体示例 - 展示正确和错误的做法

---

## 测试建议

### 测试场景1: 明确相关
```
打开: timeout_recovery.py
用户: "看看当前项目的超时处理"
期望: 直接 read_file，不要 text_search
```

### 测试场景2: 可能相关
```
打开: agent.py, executor.py
用户: "看看超时处理"
期望: 可以先读取打开的文件，或者搜索
```

### 测试场景3: 明显不相关
```
打开: README.md
用户: "看看超时处理"
期望: 使用 text_search 或 list_files
```

### 测试场景4: 全局问题
```
打开: 任何文件
用户: "了解整个项目"
期望: 使用 discover_project_docs, get_repo_structure
```

---

## 总结

**核心原则**：
- 打开的文件 = 用户的意图信号
- 在搜索之前，先检查打开的文件
- "当前项目" 99% 指打开的文件

**实施方式**：
- 在 Prompt 中强调"打开的文件优先"
- 提供具体示例
- 调整检查清单顺序

**预期效果**：
- 更好的用户体验
- 更高的效率
- 更准确的结果
