# 向量检索快速参考

## 快速开始

### 1. 基本用法

```python
from pathlib import Path
from daoyoucode.agents.memory.codebase_index import CodebaseIndex

# 创建索引
index = CodebaseIndex(Path("."))

# 单层检索（快速）
results = index.search("Agent执行", top_k=10)

# 多层检索（完整）
results = index.search_multilayer("Agent执行", top_k=10)
```

### 2. 查看结果

```python
for result in results:
    print(f"{result['path']}::{result['name']}")
    print(f"  类型: {result['type']}")
    print(f"  分数: {result.get('final_score', 0):.4f}")
    print(f"  相关文件: {result.get('related_files', [])}")
```

## 两种检索方式

### 单层检索 (search)

```python
results = index.search("query", top_k=10)
```

**特点**:
- 快速（~0.1秒）
- 只返回直接匹配
- 适合快速查询

### 多层检索 (search_multilayer)

```python
results = index.search_multilayer("query", top_k=10)
```

**特点**:
- 完整（~0.25秒）
- 返回匹配+相关+调用链
- 适合深度探索

## 配置选项

### 启用/禁用扩展

```python
# 只启用文件扩展
results = index.search_multilayer(
    "query",
    enable_file_expansion=True,
    enable_reference_expansion=False
)

# 只启用引用扩展
results = index.search_multilayer(
    "query",
    enable_file_expansion=False,
    enable_reference_expansion=True
)

# 完全禁用（等同于search）
results = index.search_multilayer(
    "query",
    enable_file_expansion=False,
    enable_reference_expansion=False
)
```

### 控制扩展规模

```python
results = index.search_multilayer(
    "query",
    top_k=5,
    max_expansion=30  # 限制最大扩展数量
)
```

## Chunk结构

### 基础字段（阶段1）

```python
{
    "path": "backend/agents/core/agent.py",
    "start": 100,
    "end": 150,
    "text": "def execute(self, ...):\n    ...",
    "type": "method",
    "name": "execute",
    "pagerank_score": 0.85
}
```

### 增强字段（阶段2）

```python
{
    # ... 基础字段 ...
    
    "parent_class": "BaseAgent",        # 所属类
    "scope": "class",                   # 作用域
    "calls": ["_load_prompt"],          # 调用的函数
    "called_by": ["orchestrator.py"],   # 被谁调用
    "imports": ["from ..llm import"],   # 导入语句
    "related_files": ["llm_client.py"]  # 相关文件
}
```

### 检索结果字段（阶段3）

```python
{
    # ... 所有字段 ...
    
    "score": 0.85,        # 语义相似度
    "final_score": 0.75   # 综合分数
}
```

## 多层检索流程

```
查询: "Agent执行"
    ↓
第1层：语义检索
    → 10个直接匹配的结果
    ↓
第2层：文件关联扩展
    → 扩展到36个结果（包含相关文件）
    ↓
第3层：引用关系扩展
    → 扩展到37个结果（包含调用链）
    ↓
第4层：去重和重排序
    → 去重后37个，按综合分数排序
    ↓
返回: top-10结果
```

## 综合分数公式

```python
final_score = (
    0.5 * similarity +      # 语义相似度 50%
    0.3 * pagerank_score +  # PageRank 30%
    0.2 * position_score    # 位置 20%
)
```

## 性能指标

| 操作 | 时间 | 结果数 |
|------|------|--------|
| 构建索引 | 1.5秒 | 1893 chunks |
| 单层检索 | 0.126秒 | 10个 |
| 多层检索 | 0.249秒 | 10个 |

## 使用场景

### 场景1: 快速查找

```python
# 只想快速找到相关代码
results = index.search("超时处理", top_k=5)
```

### 场景2: 深度探索

```python
# 想了解完整的上下文和调用链
results = index.search_multilayer("超时处理", top_k=5)
```

### 场景3: 发现相关文件

```python
# 找到一个函数后，查看相关文件
result = results[0]
print(f"相关文件: {result['related_files']}")
```

### 场景4: 追踪调用链

```python
# 查看函数的调用关系
result = results[0]
print(f"调用: {result['calls']}")
print(f"被调用: {result['called_by']}")
```

## 常见问题

### Q1: 如何重建索引？

```bash
# 删除旧索引
rm -rf .daoyoucode/codebase_index

# 或在Python中
import shutil
shutil.rmtree('.daoyoucode/codebase_index', ignore_errors=True)

# 重新构建
index = CodebaseIndex(Path("."))
index.build_index(force=True)
```

### Q2: 如何提高检索速度？

1. 使用`search()`而非`search_multilayer()`
2. 减小`max_expansion`参数
3. 复用同一个索引实例

### Q3: 如何提高检索质量？

1. 使用`search_multilayer()`
2. 增大`top_k`参数
3. 启用所有扩展选项

### Q4: 索引多久更新一次？

- 自动检测文件变化
- 首次使用时构建
- 可手动强制重建（`force=True`）

## 调试技巧

### 查看扩展过程

```python
import logging
logging.basicConfig(level=logging.INFO)

# 会输出详细的扩展日志
results = index.search_multilayer("query", top_k=10)
```

### 分析结果质量

```python
for result in results:
    print(f"\n{result['path']}::{result['name']}")
    print(f"  最终分数: {result['final_score']:.4f}")
    print(f"  语义: {result.get('score', 0):.4f}")
    print(f"  PageRank: {result.get('pagerank_score', 0):.4f}")
    
    # 查看为什么被选中
    if result.get('related_files'):
        print(f"  → 通过文件关联发现")
    if result.get('called_by'):
        print(f"  → 通过调用关系发现")
```

### 对比两种检索

```python
query = "超时处理"

# 单层
results_simple = index.search(query, top_k=5)
print(f"单层: {len(results_simple)} 个结果")

# 多层
results_multi = index.search_multilayer(query, top_k=5)
print(f"多层: {len(results_multi)} 个结果")

# 对比
simple_files = {r['path'] for r in results_simple}
multi_files = {r['path'] for r in results_multi}
new_files = multi_files - simple_files
print(f"新增: {len(new_files)} 个文件")
```

## 最佳实践

### 1. 首次使用

```python
# 构建索引（只需一次）
index = CodebaseIndex(Path("."))
index.build_index()

# 后续使用会自动加载缓存
```

### 2. 批量查询

```python
# 复用同一个索引实例
index = CodebaseIndex(Path("."))

queries = ["Agent执行", "超时处理", "配置管理"]
for query in queries:
    results = index.search_multilayer(query, top_k=5)
    # 处理结果...
```

### 3. 性能优化

```python
# 对于大型项目
results = index.search_multilayer(
    "query",
    top_k=5,
    max_expansion=20  # 减小扩展规模
)
```

### 4. 结果过滤

```python
# 只要特定类型的结果
results = index.search_multilayer("query", top_k=20)
functions = [r for r in results if r['type'] == 'function']
classes = [r for r in results if r['type'] == 'class']
```

---

**提示**: 
- 快速查询用`search()`
- 深度探索用`search_multilayer()`
- 性能和质量可以平衡
